/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.dsaproblemsolvingquestions.project.fun;

import java.util.*;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * @author sangeetdas
 */
public class DSA450Questions {

    class GraphEdge {

        int vertex;
        int weight;

        public GraphEdge(int vertex, int weight) {
            this.vertex = vertex;
            this.weight = weight;
        }

    }

    public void reverseArray(int[] a) {

        int len = a.length;

        //.....................O(N)
        for (int i = 0; i < len / 2; i++) {
            int temp = a[i];
            a[i] = a[len - i - 1];
            a[len - i - 1] = temp;
        }

        //output
        for (int x : a) {
            System.out.print(x + " ");
        }
        System.out.println();

    }

    public void arrayElementMoreThan_NDivK(int[] a, int K) {

        int N = a.length;
        int count = N / K;
        Map<Integer, Integer> map = new HashMap<>();
        for (int x : a) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }

        map.entrySet().stream()
                .filter(e -> e.getValue() > count)
                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()))
                .entrySet()
                .stream()
                .forEach(e -> System.out.println(e.getKey()));

    }

    public void minMaxInArray_1(int[] a) {

        //...................T: O(N)
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int i = 0; i < a.length; i++) {
            max = Math.max(max, a[i]);
            min = Math.min(min, a[i]);
        }

        //outpur
        System.out.println("Min and max value in array: " + min + " " + max);
    }

    public void minMaxInArray_2(int[] a) {

        //https://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/
        //...................T: O(N)
        //Min no of comparision
        int min = Integer.MIN_VALUE;
        int max = Integer.MAX_VALUE;

        int n = a.length;
        int itr = 0;
        //check if array is even/odd
        if (n % 2 == 0) {
            max = Math.max(a[0], a[1]);
            min = Math.min(a[0], a[1]);
            //in case of even choose min & max from first two element
            //and set itr to start from 2nd index i.e(3rd element) in pair wise
            itr = 2;
        } else {
            max = a[0];
            min = a[0];
            //in case of odd choose first element as min & max both
            //set itr to 1 i.e, 2nd element
            itr = 1;
        }

        //since we checking itr and itr+1 value in loop 
        //so run loop to n-1 so that itr+1th element corresponds to n-1th element
        while (itr < n - 1) {

            //check current itr and itr+1 element
            if (a[itr] > a[itr + 1]) {
                max = Math.max(max, a[itr]);
                min = Math.min(min, a[itr + 1]);
            } else {
                max = Math.max(max, a[itr + 1]);
                min = Math.min(min, a[itr]);
            }
            itr++;
        }

        //outpur
        System.out.println("Min and max value in array: " + min + " " + max);

    }

    public void kThSmallestElementInArray(int[] arr, int K) {

        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
                (o1, o2) -> o2.compareTo(o1)
        );

        for (int val : arr) {
            maxHeap.add(val);
            if (maxHeap.size() > K) {
                maxHeap.poll();
            }
        }
        //output
        System.out.println(K + " th smallest element: " + maxHeap.peek());
    }

    public void kThLargestElementInArray(int[] arr, int K) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int val : arr) {
            minHeap.add(val);
            if (minHeap.size() > K) {
                minHeap.poll();
            }
        }
        //output
        System.out.println(K + " th largest element: " + minHeap.peek());
    }

    public void kThSmallestTrimmedNumber(String[] nums, int[][] queries) {
        //https://leetcode.com/problems/query-kth-smallest-trimmed-number/
        //based on kThSmallestElementInArray()
        int n = queries.length;
        int numLength = nums[0].length();
        int[] result = new int[n];
        //Pair<String, Integer> = <nums[index], index>
        PriorityQueue<Pair<String, Integer>> maxHeap = new PriorityQueue<>(
                (a, b) -> a.getKey().equals(b.getKey())
                        ? b.getValue() - a.getValue()
                        : b.getKey().compareTo(a.getKey()));

        for (int i = 0; i < n; i++) {
            maxHeap.clear();

            int k = queries[i][0];
            int trim = queries[i][1];

            for (int index = 0; index < nums.length; index++) {
                String num = nums[index];
                //trim-index = numLength - trim ==> num.substring(numLength - trim)
                //substring req is from trim-index till end of num string
                maxHeap.add(new Pair<>(num.substring(numLength - trim), index));
                if (maxHeap.size() > k) {
                    maxHeap.poll();
                }
            }
            //value == index
            result[i] = maxHeap.peek().getValue();
        }
        //output
        System.out.println("KTh smallest trimmed number for given queries: " + Arrays.toString(result));
    }

    public void sortArrayOf012_1(int[] arr) {

        //.............T: O(N)
        //.............S: O(3)
        Map<Integer, Integer> map = new HashMap<>();
        for (int val : arr) {
            map.put(val, map.getOrDefault(val, 0) + 1);
        }

        //creating array
        int k = 0;
        for (int val = 0; val <= 2; val++) {
            int freq = map.get(val);
            while (freq != 0) {
                arr[k++] = val;
                freq--;
            }
        }

        //output
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private void swapIntArray(int[] a, int x, int y) {
        int temp;
        temp = a[x];
        a[x] = a[y];
        a[y] = temp;
    }

    public void sortArrayOf012_2(int[] arr) {

        //.............T: O(N)
        //.............S: O(1)
        //https://leetcode.com/problems/sort-colors/
        //https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/
        //based on Dutch National Flag Algorithm
        int start = 0;
        int mid = 0;
        int end = arr.length - 1;
        while (mid <= end) {
            switch (arr[mid]) {
                case 0: {
                    swapIntArray(arr, start, mid);
                    start++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    swapIntArray(arr, mid, end);
                    end--;
                    break;
                }
            }
        }
        //output
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private void nextPermutation_Print(int[] nums) {
        for (int x : nums) {
            System.out.print(x);
        }
        System.out.println();
    }

    public void nextPermutation(int[] nums) {

        int N = nums.length;

        //length == 1
        if (N == 1) {
            //output:
            nextPermutation_Print(nums);
            return;
        }

        //check if desc sorted
        boolean descSorted = true;
        for (int i = 1; i < N; i++) {
            if (nums[i - 1] < nums[i]) {
                descSorted = false;
                break;
            }
        }

        if (descSorted) {
            for (int i = 0; i < N / 2; i++) {
                swapIntArray(nums, i, N - i - 1);
            }
            nextPermutation_Print(nums);
            return;
        }

        //any other cases
        int firstDecNumIndex = N - 1;
        for (int i = N - 2; i >= 0; i--) {
            if (nums[i] < nums[firstDecNumIndex]) {
                firstDecNumIndex = i;
                break;
            }
            firstDecNumIndex = i;
        }

        int justGreaterNumIndex = firstDecNumIndex + 1;
        int diff = nums[justGreaterNumIndex] - nums[firstDecNumIndex];
        for (int i = justGreaterNumIndex + 1; i < N; i++) {
            int currDiff = nums[i] - nums[firstDecNumIndex];
            if (currDiff > 0 && currDiff < diff) {
                diff = currDiff;
                justGreaterNumIndex = i;
            }
        }

        swapIntArray(nums, firstDecNumIndex, justGreaterNumIndex);
        Arrays.sort(nums, firstDecNumIndex + 1, N);

        //output:
        nextPermutation_Print(nums);
    }

    private int factorialLargeNumber_Multiply(int x, int[] res, int resSize) {

        int carry = 0;
        for (int i = 0; i < resSize; i++) {
            int prod = res[i] * x + carry;
            res[i] = prod % 10;
            carry = prod / 10;
        }

        while (carry != 0) {

            res[resSize] = carry % 10;
            carry = carry / 10;
            resSize++;
        }

        return resSize;
    }

    public void factorialLargeNumber(int N) {
        int[] res = new int[Integer.MAX_VALUE / 200];
        res[0] = 1;

        int resSize = 1;
        for (int x = 2; x <= N; x++) {
            resSize = factorialLargeNumber_Multiply(x, res, resSize);
        }

        //output
        for (int i = resSize - 1; i >= 0; i--) {
            System.out.print(res[i]);
        }
        System.out.println();
    }

    public void rainWaterTrappingUsingStack(int[] height) {

        //https://leetcode.com/problems/trapping-rain-water/solution/
        //..................T: O(N)
        //..................S: O(N)
        int ans = 0;
        int current = 0;
        int N = height.length;
        Stack<Integer> s = new Stack<>();
        while (current < N) {

            while (!s.isEmpty() && height[current] > height[s.peek()]) {

                int top = s.pop();
                if (s.isEmpty()) {
                    break;
                }

                int distance = current - s.peek() - 1;
                int boundedHeight = Math.min(height[current], height[s.peek()]) - height[top];
                ans += distance * boundedHeight;
            }
            s.push(current++);
        }

        //output
        System.out.println("Rain water trapping using stack: " + ans);
    }

    public void rainWaterTrappingUsingTwoPointers(int[] height) {
        //https://leetcode.com/problems/trapping-rain-water
        //OPTIMISED than stack
        //..................T: O(N)
        //..................S: O(1)
        int left = 0;
        int right = height.length - 1;
        int ans = 0;
        int leftMax = 0;
        int rightMax = 0;
        while (right > left) {
            if (height[left] < height[right]) {

                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    ans += (leftMax - height[left]);
                }

                left++;
            } else {

                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    ans += (rightMax - height[right]);
                }

                right--;
            }
        }

        //output
        System.out.println("Rain water trapping using tow pointers: " + ans);
    }

    public void findMaximumProductSubarray(int[] nums) {
        //https://leetcode.com/problems/maximum-product-subarray/
        //Explanation: https://www.youtube.com/watch?j=lXVy6YWFcRM
        //based on KADANES ALGO
        int result = Integer.MIN_VALUE;
        int currMaxProd = 1;
        int currMinProd = 1;
        for (int val : nums) {
            int tempCurrMax = currMaxProd;
            currMaxProd = Math.max(Math.max(val * currMaxProd, val * currMinProd), val);
            currMinProd = Math.min(Math.min(val * tempCurrMax, val * currMinProd), val);
            result = Math.max(currMaxProd, result);
        }

        //output:
        System.out.println("Maximum product subarray: " + result);
    }

    public int kadaneAlgorithm(int[] arr) {
        //https://leetcode.com/problems/maximum-subarray/description/
        //for finding maximum sum subarray

        int maxSubarraySum = Integer.MIN_VALUE;

        int currSubarraySum = 0;

        for (int val : arr) {

            currSubarraySum = Math.max(val, currSubarraySum + val);

            maxSubarraySum = Math.max(maxSubarraySum, currSubarraySum);
        }

        //output
        return maxSubarraySum;
    }

    public void kadaneAlgorithm_PointingIndexes(int[] arr) {

        int maxSum = 0;
        int currMaxSum = 0;
        int maxElement = Integer.MIN_VALUE;
        int maxElementIndex = 0;

        int start = 0;
        int end = 0;
        int index = 0;
        while (index < arr.length) {

            currMaxSum += arr[index];
            //case to handle all negative element
            if (arr[index] > maxElement) {
                maxElement = arr[index];
                maxElementIndex = index;
            }
            if (currMaxSum < 0) {
                currMaxSum = 0;
                start = index + 1;
            }
            if (maxSum < currMaxSum) {
                maxSum = currMaxSum;
                end = index;
            }
            index++;
        }

        //output:
        System.out.println("Max sum subarray with start & end: "
                + (maxSum == 0
                ? maxElement + " Start: " + maxElementIndex + " end: " + maxElementIndex
                : maxSum + " Start: " + start + " end: " + end)
        );
    }

    public void moveNegativeElementsToOneSideOfArray(int[] arr) {

        //Two pointer approach
        //...........................T: O(N)
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();

        int n = arr.length;
        int negativeIndex = 0;
        int positiveIndex = n - 1;

        while (positiveIndex > negativeIndex) {

            //if any element in left side id already a -ve then that element should be taken into consideration
            //move to next element
            while (negativeIndex < positiveIndex && arr[negativeIndex] < 0) {
                negativeIndex++;
            }

            //same way any +ve no on the right side should not be counted and move to next element
            while (negativeIndex < positiveIndex && arr[positiveIndex] > 0) {
                positiveIndex--;
            }

            //as we are planning to shift all the -ve elements to left side of array
            //after above while loops we will be having
            // +ve element (arr[f] > 0) in left side AND any -ve element(arr[h] <0) on right side should be swapped
            swapIntArray(arr, negativeIndex, positiveIndex);
            negativeIndex++;
            positiveIndex--;
        }

        //output:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void findUnionAndIntersectionOfTwoArrays(int[] a, int[] b) {

        int m = a.length;
        int n = b.length;
        int maxLen = Math.max(m, n);
        Set<Integer> unionSet = new HashSet<>();
        for (int i = 0; i < maxLen; i++) {

            if (i < m) {
                unionSet.add(a[i]);
            }

            if (i < n) {
                unionSet.add(b[i]);
            }
        }

        //output
        System.out.println("No of union element: " + unionSet.size() + " elements: " + unionSet);

        //finding intersection of two array
        Set<Integer> aSet = new HashSet<>();
        Set<Integer> bSet = new HashSet<>();
        for (int x : a) {
            aSet.add(x);
        }
        for (int x : b) {
            bSet.add(x);
        }

        Set<Integer> intersectionSet = new HashSet<>();
        for (int i = 0; i < maxLen; i++) {

            if (i < m) {
                if (aSet.contains(a[i]) && bSet.contains(a[i])) {
                    intersectionSet.add(a[i]);
                }
            }

            if (i < n) {
                if (aSet.contains(b[i]) && bSet.contains(b[i])) {
                    intersectionSet.add(b[i]);
                }
            }
        }

        //output
        System.out.println("No of intersection element: " + intersectionSet.size() + " elements: " + intersectionSet);
    }

    public void rotateArrayByK_BruteForce(int[] arr, int k) {
        //.......................T: O(N^2)
        //https://leetcode.com/problems/rotate-array/
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
        int actualK = k; //just for output purpose
        int n = arr.length;

        while (k-- != 0) {
            int last = arr[n - 1];
            for (int i = n - 1; i >= 1; i--) {
                arr[i] = arr[i - 1];
            }

            arr[0] = last;
        }

        //output:
        System.out.println("Rotate array by " + actualK + " steps output brute force: ");
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    private void rotateArrayByK_ReverseArray(int[] arr, int start, int end) {

        while (end > start) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }

    public void rotateArrayByK(int[] arr, int k) {
        //......................T: O(N)
        //https://leetcode.com/problems/rotate-array/
        //explanation: https://youtu.be/BHr381Guz3Y
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();

        int len = arr.length;
        //if k > len, mod it with len so that k always fall under range of len
        k = k % len;
        int start = 0;
        //reverse the array
        rotateArrayByK_ReverseArray(arr, start, len - 1);

        //reverse first [0 to k] elements
        rotateArrayByK_ReverseArray(arr, start, k - 1);

        //reverse remaining [k to len] elements
        rotateArrayByK_ReverseArray(arr, k, len - 1);

        //output:
        System.out.println("Rotate array by " + k + " steps output approach2: ");
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void minimizeDifferenceBetweenHeights(int[] arr, int k) {

        //problem statement: https://practice.geeksforgeeks.org/problems/minimize-the-heights3351/1
        //sol: https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/
        int n = arr.length;

        Arrays.sort(arr);

        int ans = arr[n - 1] - arr[0];

        int big = arr[0] + k;
        int small = arr[n - 1] - k;

        int temp = big;
        big = Math.max(big, small);
        small = Math.min(temp, small);

        //all in between a[0] to a[n-1] i.e, a[1] -> a[n-2]
        for (int i = 1; i < n - 1; i++) {

            int subtract = arr[i] - k;
            int add = arr[i] + k;

            // If both subtraction and addition
            // do not change diff
            if (subtract >= small || add <= big) {
                continue;
            }

            // Either subtraction causes a smaller
            // number or addition causes a greater
            // number. Update small or big using
            // greedy approach (If big - subtract
            // causes smaller diff, update small
            // Else update big)
            if (big - subtract <= add - small) {
                small = subtract;
            } else {
                big = add;
            }
        }
        //output:
        System.out.println("Min height: " + Math.min(ans, big - small));
    }

    public void bestProfitToBuySellStock(int[] prices) {

        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
        int buy = Integer.MAX_VALUE;
        int maxProfit = 0;
        for (int i = 0; i < prices.length; i++) {
            //buy any stock at min price, so find a price < minPrice
            if (prices[i] < buy) {
                buy = prices[i];
            }

            //if any price > minPrice, we can sell that stock to earn profit
            //maxProfit = max(maxProfit, price - minPrice)
            maxProfit = Math.max(maxProfit, prices[i] - buy);
        }

        //output:
        System.out.println("Maximum profit from buying and selling the stocks: " + maxProfit);
    }

    public void countAllPairsInArrayThatSumIsK(int[] arr, int K) {
        /*
         //brute force apprach
         //........................T: O(N^2)
         int pairCount = 0;
         for(int i=0; i<arr.length; i++){
         for(int j=i+1; j<arr.length; j++){
         if(arr[i] + arr[j] == K){
         pairCount++;
         }
         }
         }

         System.out.println("Count of pairs whose sum is equal to K: "+pairCount);
         */

        //Time optimised approach
        //https://www.geeksforgeeks.org/count-pairs-with-given-sum/
        //.......................T: O(N)
        //.......................S: O(N)
        Map<Integer, Integer> map = new HashMap<>();
        for (int val : arr) {
            map.put(val, map.getOrDefault(val, 0) + 1);
        }

        int pairCount = 0;
        for (int val : arr) {
            pairCount += map.getOrDefault(K - val, 0);

            if (K - val == val) {
                pairCount--;
            }
        }

        System.out.println("Count of pairs whose sum is equal to K: " + pairCount / 2);
    }

    public boolean checkIfSubarrayWithSum0(int[] arr) {

        int n = arr.length;
        int sum = 0;
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            sum += arr[i];

            if (arr[i] == 0 || sum == 0 || set.contains(sum)) {
                return true;
            }
            set.add(sum);
        }
        return false;
    }

    public void bestProfitToBuySellStockCanHoldAtmostOneStock(int[] prices) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/2058747/JAVA-or-Single-loop-solution
        int n = prices.length;
        int min = prices[0];
        int max = prices[0];
        int profit = 0;
        for (int price : prices) {
            if (price > max) {
                max = price;
            } else {
                profit += max - min;
                min = price;
                max = price;
            }
        }
        //output:
        System.out.println("Max profit frm buying selling stock atmost twice: " + (profit + max - min));
    }

    public void bestProfitToBuySellStockAtMostTwice(int[] prices) {

        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
        int n = prices.length;
        int[] maxProfits = new int[n];

        int maxSellingPrice = prices[n - 1];
        //looping all prices and checking if currBuyPrice will
        //give max profit from if sold at maxSellingPrice
        for (int i = n - 2; i >= 0; i--) {
            int currBuyPrice = prices[i];
            if (currBuyPrice > maxSellingPrice) {
                maxSellingPrice = currBuyPrice;
            }
            //choosing the max profits, that we already have seen(maxProfit[i + 1])
            //or if we buy at currBuyPrice and sell at maxSellingPrice
            maxProfits[i] = Math.max(maxProfits[i + 1], maxSellingPrice - currBuyPrice);
        }

        int minBuyPrice = prices[0];
        //looping all prices and checking if currSellPrice will
        //give max profit from if previously bought at minBuyPrice
        for (int i = 1; i < n; i++) {
            int currSellPrice = prices[i];
            if (minBuyPrice > currSellPrice) {
                minBuyPrice = currSellPrice;
            }
            //choosing the max profits, that we already have seen(maxProfit[i - 1])
            //or if we sell at currSellPrice that was bought at minBuyPrice
            //in addition with the previous max profit((bought and sold from above loop)maxProfit[i])
            maxProfits[i] = Math.max(maxProfits[i - 1], maxProfits[i] + (currSellPrice - minBuyPrice));
        }

        //output:
        System.out.println("Max profit frm buying selling stock atmost twice: " + maxProfits[n - 1]);
    }

    public void mergeIntervals1(int[][] intervals) {
        //.................................T: O(N.LogN)
        //https://leetcode.com/problems/merge-intervals/
        System.out.println("approach 1");
        List<int[]> result = new ArrayList<>();

        if (intervals == null || intervals.length == 0) {
            //return result.toArray(new int[0][]);
            return;
        }

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        int prevStart = intervals[0][0];
        int prevEnd = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (currStart <= prevEnd) {
                //overlapping situation, choose the max end time out of two that can cover most intervals
                prevEnd = Math.max(prevEnd, currEnd);
            } else if (currStart > prevEnd) {
                //no overlapp situation
                result.add(new int[]{prevStart, prevEnd});
                prevStart = currStart;
                prevEnd = currEnd;
            }
        }

        //final pair
        result.add(new int[]{prevStart, prevEnd});
        //output:
        int[][] output = result.toArray(new int[result.size()][]);
        for (int[] r : output) {
            System.out.print("[");
            for (int c : r) {
                System.out.print(c + " ");
            }
            System.out.println("]");
            System.out.println();
        }
    }

    public void mergeIntervals2(int[][] intervals) {

        //.................................T: O(N.LogN)
        //https://leetcode.com/problems/merge-intervals/
        System.out.println("approach 2");
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        LinkedList<int[]> merged = new LinkedList<>();
        for (int[] interval : intervals) {

            if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {
                merged.add(interval);
            } else {
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);
            }
        }

        //output:
        int[][] output = merged.toArray(new int[merged.size()][]);
        for (int[] r : output) {
            System.out.print("[");
            for (int c : r) {
                System.out.print(c + " ");
            }
            System.out.println("]");
            System.out.println();
        }
    }

    public void nonOverlappingIntervals(int[][] intervals) {
        //.................................T: O(N.LogN)
        //https://leetcode.com/problems/non-overlapping-intervals/
        //based on mergeIntervals1()

        if (intervals == null || intervals.length == 0) {
            return;
        }

        //sort the intervals[][] in incr order of start time but if start times
        //are same then sort in incr order of end times
        Arrays.sort(intervals, (a, b) -> a[0] == b[0]
                ? Integer.compare(a[1], b[1])
                : Integer.compare(a[0], b[0]));

        int prevEnd = intervals[0][1];

        int removeCount = 0;

        for (int i = 1; i < intervals.length; i++) {

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (currStart < prevEnd) {
                removeCount++;
                //overlapping situation, but here choose a min end time such that
                //for next intervals overlapping situation reduces as we need to
                //have min 'removeCount'
                prevEnd = Math.min(prevEnd, currEnd);
            } else if (currStart >= prevEnd) {
                //no overlapp situation
                prevEnd = currEnd;
            }
        }
        //output
        System.out.println("Non overlapping intervals : " + removeCount);
    }

    public void minOperationsToMakeArrayPallindrome(int[] arr) {

        //TWO POINTERS
        int n = arr.length;
        int start = 0;
        int end = n - 1;
        int minOpr = 0;
        while (end >= start) {

            if (arr[start] == arr[end]) {
                start++;
                end--;
            } else if (arr[start] > arr[end]) {
                end--;
                arr[end] += arr[end + 1];
                minOpr++;
            } else {
                start++;
                arr[start] += arr[start - 1];
                minOpr++;
            }
        }

        //output:
        System.out.println("Minimum operation to make array pallindrome: " + minOpr);
    }

    public void productOfArrayExcludingElementItself_BruteForce(int[] arr) {

        //.....................T: O(N)
        int n = arr.length;
        int[] result = new int[n];
        int prod = 1;

        for (int i = 0; i < n; i++) {
            prod *= arr[i];
        }

        for (int i = 0; i < n; i++) {
            result[i] = prod / arr[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void productOfArrayExcludingElementItself_Optimised1(int[] arr) {

        //.....................T: O(N)
        //.....................S: O(N)
        int n = arr.length;
        int[] result = new int[n];
        int[] leftProd = new int[n];
        int[] rightProd = new int[n];

        leftProd[0] = 1;
        rightProd[n - 1] = 1;

        for (int i = 1; i < n; i++) {
            leftProd[i] = leftProd[i - 1] * arr[i - 1];
        }

        for (int i = n - 2; i >= 0; i--) {
            rightProd[i] = rightProd[i + 1] * arr[i + 1];
        }

        for (int i = 0; i < n; i++) {
            result[i] = leftProd[i] * rightProd[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void productOfArrayExcludingElementItself_Optimised2(int[] arr) {

        //.....................T: O(N)
        //.....................S: O(1) //result[] is needed to save output
        int n = arr.length;
        int[] result = new int[n];

        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * arr[i - 1];
        }

        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] = result[i] * right;
            right *= arr[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void maximumOfAllSubArrayOfSizeK(int[] arr, int K) {
        //https://leetcode.com/problems/sliding-window-maximum/
        //https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/
        List<Integer> result = new ArrayList<>();
        int n = arr.length;
        int index;
        Deque<Integer> queue = new LinkedList<>();
        for (index = 0; index < K; index++) {
            //check curr element >= last added element
            while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[index]) {
                queue.removeLast();
            }
            queue.addLast(index);
        }

        for (; index < n; index++) {

            result.add(arr[queue.peekFirst()]);

            //index => endIndex, q.peekFirst() = startIndex
            //endIndex - startIndex >= window(K) then maintain window size
            while (!queue.isEmpty() && index - queue.peekFirst() >= K) {
                queue.removeFirst();
            }

            while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[index]) {
                queue.removeLast();
            }
            queue.addLast(index);
        }
        result.add(arr[queue.peekFirst()]);

        //output:
        System.out.println("Max of all subarrays of size K: " + result);
    }

    public void averageWaitingTime(int[][] customers) {
        //https://leetcode.com/problems/average-waiting-time
        double n = customers.length;
        double timeAtPrevOrderEnd = 0;
        double totalTime = 0;
        for (int[] order : customers) {
            int arrivalTime = order[0];
            int prepTime = order[1];
            timeAtPrevOrderEnd = (timeAtPrevOrderEnd > arrivalTime ? timeAtPrevOrderEnd : arrivalTime)
                    + prepTime;
            totalTime += (timeAtPrevOrderEnd - arrivalTime);
        }
        //output:
        System.out.println("Average waitig time: " + (totalTime / n));
    }

    public int minimumTimeDifference(List<String> timePoints) {

        //problem statement: https://leetcode.com/problems/minimum-time-difference/
        //explanation: https://youtu.be/c5ecNf7JM1Q
        //1 hour = 60 min
        //24 hour = 24 * 60 min == 1440 min
        boolean[] everyMinute = new boolean[24 * 60]; //[1440]

        //convert the string "HH:MM" time format to minute only
        for (String time : timePoints) {
            String[] timeSplit = time.split(":");
            int hour = Integer.parseInt(timeSplit[0]);
            int minute = Integer.parseInt(timeSplit[1]);

            //total minute in an hour = hour * 60 + minute
            //that total minute is minute based index in everyMinute
            int minuteIndex = (hour * 60) + minute;
            //if a minute is already seen and that same timePoint comes again
            //the diff b/w these two timePoints is minimum
            //ex: "10:02", "10:02"
            if (everyMinute[minuteIndex]) {
                return 0;
            }
            everyMinute[minuteIndex] = true;
        }

        int firstTime = -1;
        int prevTime = -1;
        int minDiff = Integer.MAX_VALUE;

        for (int i = 0; i < 1440; i++) {

            if (everyMinute[i]) {

                if (firstTime == -1) {

                    firstTime = i;
                    prevTime = i;
                } else {

                    minDiff = Math.min(minDiff, Math.min(
                            i - prevTime, //clockwise dir
                            1440 - i + prevTime //anti clockwise dir
                    ));

                    prevTime = i;
                }
            }
        }

        minDiff = Math.min(minDiff, Math.min(
                prevTime - firstTime, //clockwise dir
                1440 - prevTime + firstTime //anti clockwise dir
        ));

        return minDiff;
    }

    public void contigousArrayWithEqualZeroAndOne(int[] arr) {

        //https://leetcode.com/problems/contiguous-array/
        Map<Integer, Integer> prefixSumIndexes = new HashMap<>();
        prefixSumIndexes.put(0, -1);
        int prefixSum = 0;
        int maxLen = 0;

        for (int i = 0; i < arr.length; i++) {

            prefixSum += arr[i] == 1 ? 1 : -1;

            if (prefixSumIndexes.containsKey(prefixSum)) {
                maxLen = Math.max(maxLen, i - prefixSumIndexes.get(prefixSum));
            } else {
                prefixSumIndexes.put(prefixSum, i);
            }
        }
        //output:
        System.out.println("Max length: " + maxLen);
    }

    public void maxSumPathInTwoSortedArrays(int[] arr1, int[] arr2) {

        //https://www.geeksforgeeks.org/maximum-sum-path-across-two-arrays/
        int m = arr1.length;
        int n = arr2.length;

        int result = 0;
        int arrSum1 = 0;
        int arrSum2 = 0;

        int i = 0; // for arr1
        int j = 0; // for arr2

        while (i < m && j < n) {

            if (arr1[i] < arr2[j]) {
                arrSum1 += arr1[i++];
            } else if (arr1[i] > arr2[j]) {
                arrSum2 += arr2[j++];
            } else {
                //common point
                result += Math.max(arrSum1, arrSum2);

                arrSum1 = 0;
                arrSum2 = 0;

                int temp = i;
                while (i < m && arr1[i] == arr2[j]) {
                    arrSum1 += arr1[i++];
                }

                while (j < n && arr1[temp] == arr2[j]) {
                    arrSum2 += arr2[j++];
                }

                result += Math.max(arrSum1, arrSum2);

                arrSum1 = 0;
                arrSum2 = 0;
            }
        }

        while (i < m) {
            arrSum1 += arr1[i++];
        }

        while (j < n) {
            arrSum2 += arr2[j++];
        }

        result += Math.max(arrSum1, arrSum2);

        //output:
        System.out.println("Max path sum: " + result);
    }

    public void asteroidCollision(int[] asteroids) {

        //https://leetcode.com/problems/asteroid-collision/
        //explanation: https://youtu.be/6GGTBM7mwfs

        /*
         cond when two collide
         peek = -ve, incoming = -ve = left, left dir no collision //1 if cond in while()
         peek = -ve, incoming = +ve = left, right dir no collision //1 if cond in for()
         peek = +ve, incoming = +ve = right, right dir no collision //1 if cond in for()
         peek = +ve, incoming = -ve = right, left dir will collision
         if(abs(incoming) > peek) all peek will be destroyed and incoming will remain in sack //last else cond
         if(abs(incoming) < peek) incoming will be destroyed and stack remain same //3 else if cond
         if(abs(incoming) == peek) both will be destroyed and stack need to pop out peek value //2 else if cond

         */
        Stack<Integer> stack = new Stack<>();

        for (int stone : asteroids) {
            if (stack.isEmpty() || stone > 0) {
                stack.push(stone);
            } else {
                while (true) {
                    int prevStone = stack.peek();
                    if (prevStone < 0) {
                        //prevStone = -ve, stone = -ve => left, left
                        //prevStone = -ve, stone = +ve => left, right
                        //both cases not collision will happen and we
                        //can add stone to our stack
                        stack.push(stone);
                        break;
                    } else if (prevStone == -stone) {
                        //prevStone = +ve, stone = -ve =>
                        //prevStone == abs(stone) => right, left & size same
                        stack.pop();
                        break;
                    } else if (prevStone > -stone) {
                        //prevStone = +ve, stone = -ve =>
                        //prevStone > abs(stone) => right, left, stone get destroyed
                        break;
                    } else {
                        //prevStone = +ve, stone = -ve => right, left
                        //but abs(stone) > prevStone then all prevStone under this situation will get destroyed
                        stack.pop();
                        if (stack.isEmpty()) {
                            //once all such prevStone get destroyed, add stone
                            stack.push(stone);
                            break;
                        }
                    }
                }
            }
        }

        //output:
        //int[] output = stack.stream().mapToInt(stone -> stone).toArray();
        int[] output = new int[stack.size()];
        int index = stack.size() - 1;
        while (!stack.isEmpty()) {
            output[index--] = stack.pop();
        }

        for (int x : output) {
            System.out.print(x + " ");
        }

        System.out.println();
    }

    public void countCollisionsOnRoad(String directions) {
        //https://leetcode.com/problems/count-collisions-on-a-road/description/
        int n = directions.length();
        int collisions = 0;
        int index = 0;
        int carInRight = 0;

        while (index < n && directions.charAt(index) == 'L') {
            index++;
        }

        for (; index < n; index++) {

            if (directions.charAt(index) == 'R') {
                carInRight++;
            } else {
                collisions += (directions.charAt(index) == 'S') ? carInRight : carInRight + 1;
                carInRight = 0;
            }
        }
        //output
        System.out.println("Count collisions on road : " + collisions);
    }

    public void jumpGame(int[] nums) {
        //https://leetcode.com/problems/jump-game/
        //Explanation: https://youtu.be/muDPTDrpS28

        int reachablePoint = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > reachablePoint) {
                System.out.println("Can we reach the end of nums array from 0th index: NO");
                return;
            }
            reachablePoint = Math.max(reachablePoint, i + nums[i]);
        }

        System.out.println("can we reach the end of nums array from 0th index: YES");
    }

    public void jumpGameTwo(int[] nums) {
        //https://leetcode.com/problems/jump-game-ii/description/
        //https://leetcode.com/problems/jump-game-ii/solutions/3076867/jump-game-ii/
        int n = nums.length;
        int steps = 0;
        int farthestPoint = 0;
        int endPoint = 0;

        for (int i = 0; i < n - 1; i++) {
            farthestPoint = Math.max(farthestPoint, i + nums[i]);
            if (i == endPoint) {
                steps++;
                endPoint = farthestPoint;
            }
        }
        //output
        System.out.println("Steps to reach the end point : " + steps);
    }

    public void jumpGameThree(int[] nums, int startIndex) {
        //https://leetcode.com/problems/jump-game-iii/
        int n = nums.length;

        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();

        visited[startIndex] = true;
        queue.add(startIndex);

        while (!queue.isEmpty()) {

            int currIndex = queue.poll();

            if (nums[currIndex] == 0) {
                System.out.println("Can we reach where nums value is 0 from startIndex index: YES");
                return;
            }

            int leftIndex = currIndex - nums[currIndex];
            int rightIndex = currIndex + nums[currIndex];

            if (leftIndex >= 0 && !visited[leftIndex]) {

                visited[leftIndex] = true;
                queue.add(leftIndex);
            }

            if (rightIndex < n && !visited[rightIndex]) {

                visited[rightIndex] = true;
                queue.add(rightIndex);
            }
        }
        System.out.println("Can we reach where nums value is 0 from startIndex index: NO");
    }

    public int jumpGameFour(int[] nums) {
        //https://leetcode.com/problems/jump-game-iv/
        //exlanation: https://youtu.be/XgP3w7Txvlc
        //based BFS, LEVEL-ORDER TRAVERSAL
        int n = nums.length;

        Map<Integer, List<Integer>> valToIndices = new HashMap<>();

        for (int index = 0; index < n; index++) {
            valToIndices.putIfAbsent(nums[index], new ArrayList<>());
            valToIndices.get(nums[index]).add(index);
        }

        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();

        visited[0] = true;
        queue.add(0);

        int steps = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                int currIndex = queue.poll();

                if (currIndex == n - 1) {
                    return steps;
                }

                //i - 1 where: i - 1 >= 0.
                int leftIndex = currIndex - 1;

                //i + 1 where: i + 1 < arr.length.
                int rightIndex = currIndex + 1;

                if (leftIndex >= 0 && !visited[leftIndex]) {

                    visited[leftIndex] = true;
                    queue.add(leftIndex);
                }

                if (rightIndex < n && !visited[rightIndex]) {

                    visited[rightIndex] = true;
                    queue.add(rightIndex);
                }

                //j where: arr[i] == arr[j] and i != j.
                //as per the third allowed movement, we can move to all the indices 'j'
                //such that nums[currIndex] = nums[j]
                //here we will fetch all the j indices that matches the same value as that
                //of curr value of nums[currIndex]
                List<Integer> sameValIndices = valToIndices.getOrDefault(nums[currIndex], Collections.emptyList());

                //all the valid j indices are going to be added into queue hence we will
                //never require to process the same j indices for same nums[currIndex] again
                //and again, as they will generate the same possible steps again
                valToIndices.remove(nums[currIndex]);

                for (int jIndex : sameValIndices) {

                    if (visited[jIndex]) {
                        continue;
                    }

                    if (currIndex == jIndex) {
                        continue;
                    }

                    visited[jIndex] = true;
                    queue.add(jIndex);
                }
            }

            steps++;
        }

        return 0;
    }

    public boolean jumpGameSeven(String str, int minJump, int maxJump) {
        //https://leetcode.com/problems/jump-game-vii/
        //explanation: https://youtu.be/v1HpZUnQ4Yo
        //BFS approach
        int n = str.length();
        char[] arr = str.toCharArray();

        int src = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(src);

        int farthtestReached = 0;

        while (!queue.isEmpty()) {

            int currIndex = queue.poll();
            int start = Math.max(currIndex + minJump, farthtestReached + 1);
            //range: from currIndex we can move to maxJump + 1 (+1 is to include maxJump also)
            //it can be possible that currIndex + maxJump + 1 is beyond arr[] length
            //so choosing the min of two ranges
            int range = Math.min(currIndex + maxJump + 1, n);
            for (int next = start; next < range; next++) {
                if (arr[next] == '0') {
                    if (next == n - 1) {
                        return true;
                    }
                    queue.add(next);
                }
            }
            farthtestReached = currIndex + maxJump;
        }
        return false;
    }

    public boolean frogJump(int[] stones) {
        //https://leetcode.com/problems/frog-jump/
        class JumpInfo {

            int stone;
            int jump;

            public JumpInfo(int stone, int jump) {
                this.stone = stone;
                this.jump = jump;
            }

        }

        int n = stones.length;
        int lastStone = stones[n - 1];

        Queue<JumpInfo> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();

        Set<Integer> stonesSet = new HashSet<>();
        for (int stone : stones) {
            stonesSet.add(stone);
        }

        //initial position
        int currStone = 0;
        int currJump = 0;

        visited.add(currStone + "," + currJump);
        queue.add(new JumpInfo(currStone, currJump));

        while (!queue.isEmpty()) {

            JumpInfo jumpInfo = queue.poll();

            //if we have reached the last stone
            if (jumpInfo.stone == lastStone) {
                return true;
            }

            //from curr jump we can furtehr move to k - 1, k, k + 1 move
            for (int move = -1; move <= 1; move++) {

                int nextJump = jumpInfo.jump + move;
                int nextStone = jumpInfo.stone + nextJump;

                //if nextStone and nextJump previously visited, continue
                if (visited.contains(nextStone + "," + nextJump)) {
                    continue;
                }

                //if next stone to move to, doesn't exist in the stone list,
                //we can't move there, so continue
                if (!stonesSet.contains(nextStone)) {
                    continue;
                }

                queue.add(new JumpInfo(nextStone, nextJump));
                visited.add(nextStone + "," + nextJump);
            }
        }
        return false;
    }

    public void nextGreaterElement2_CyclicArray(int[] arr) {

        //explanation: https://leetcode.com/problems/next-greater-element-ii/solution/
        //array to be considered as cyclic
        int n = arr.length;
        int[] output = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 2 * n - 1; i >= 0; i--) {

            while (!stack.isEmpty() && arr[stack.peek()] <= arr[i % n]) {
                stack.pop();
            }

            output[i % n] = stack.isEmpty() ? -1 : arr[stack.peek()];

            stack.push(i % n);
        }

        //output:
        System.out.println("Next greater element 2 in cyclic array : " + Arrays.toString(output));
    }

    public void findMedianInDataStream(int[] stream) {

        //explanantion: https://leetcode.com/problems/find-median-from-data-stream/solution/
        //[HEAP BASED]
        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> a.compareTo(b));
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b.compareTo(a));

        for (int num : stream) {

            maxHeap.add(num);
            minHeap.add(maxHeap.poll());

            if (maxHeap.size() < minHeap.size()) {
                maxHeap.add(minHeap.poll());
            }

            double median = maxHeap.size() > minHeap.size()
                    ? maxHeap.peek()
                    : (double) (maxHeap.peek() + minHeap.peek()) * 0.5;

            System.out.println("Median: " + median);
        }
    }

    public void medianOfTwoSortedArrays(int[] arr1, int[] arr2) {
        //.......................T: O(n + m), n & m length of arr1 & arr2
        //.......................S: O(1)
        //https://leetcode.com/problems/median-of-two-sorted-arrays/
        //OPTIMISED
        /*
        brute force
        approach1 is to put both arrays in a list, sort the list,
        then on the basis of total size of list we can find median
        odd length = list[size / 2]
        even length = (list[size / 2] + list[(size / 2) - 1]) / 2.0
        this will take
        T: O((n + m).Log(n + m)), n & m length of arr1 & arr2, for adding
        both arrays in list and then sorting list again
        S: O(n + m), for list we make

        approach2 is to use the fact that our given arrays arr1 & arr2 are
        already sorted, we can use below while() to create our list that will
        reduce our T: O(n + m) but S: O(n + m)

        but below approach is OPTIMIZED because we know that to find the median
        we need to find the median point of both arrays combined, rather than
        creating a list, we can calculate the medianPoint uptil its <= len / 2
         */
        int n = arr1.length;
        int m = arr2.length;

        int totalLength = n + m;
        boolean isLengthEven = totalLength % 2 == 0;
        int medianPoint = 0;

        double midVal = 0;
        double midValPrev = midVal;

        int i = 0;
        int j = 0;

        while (i < n && j < m && medianPoint <= totalLength / 2) {

            if (arr1[i] <= arr2[j]) {

                midValPrev = midVal;
                midVal = arr1[i];
                i++;

            } else {

                midValPrev = midVal;
                midVal = arr2[j];
                j++;
            }

            medianPoint++;
        }

        while (i < n && medianPoint <= totalLength / 2) {

            midValPrev = midVal;
            midVal = arr1[i];
            i++;
            medianPoint++;
        }

        while (j < m && medianPoint <= totalLength / 2) {

            midValPrev = midVal;
            midVal = arr2[j];
            j++;
            medianPoint++;
        }

        double medianOfTwoSortedArrays = isLengthEven
                ? (midVal + midValPrev) / 2.0
                : midVal;
        //output
        System.out.println("Median of two sorted arrays: " + medianOfTwoSortedArrays);
    }

    public void numPairsDivisibleBy60(int[] times) {

        //https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
        int[] seen = new int[60];
        int result = 0;

        for (int time : times) {
            int hashedTime = time % 60;
            int complement = 60 - hashedTime == 60 || 60 - hashedTime < 0
                    ? 0 : 60 - hashedTime;
            result += seen[complement];
            seen[hashedTime]++;
        }

        //output:
        System.out.println("Total pair: " + result);
    }

    private int mergeSort(int[] arr, int start, int mid, int end) {

        int[] left = Arrays.copyOfRange(arr, start, mid + 1); //start to mid
        int[] right = Arrays.copyOfRange(arr, mid + 1, end + 1); //mid + 1 to end
//        IntStream.of(left).boxed().forEach(row -> System.out.println(row));
//        System.out.println();
//        IntStream.of(right).boxed().forEach(row -> System.out.println(row));
        int i = 0;
        int j = 0;
        int k = start;
        int swaps = 0;
        while (i < left.length && j < right.length) {

            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
                swaps += (mid + 1) - (start + i);
            }
        }

        while (i < left.length) {
            arr[k++] = left[i++];
        }

        while (j < right.length) {
            arr[k++] = right[j++];
        }

        return swaps;
    }

    private int divideAndMerge(int[] arr, int start, int end) {
        int count = 0;
        if (end > start) {

            int mid = start + (end - start) / 2;
            count += divideAndMerge(arr, start, mid);
            count += divideAndMerge(arr, mid + 1, end);
            count += mergeSort(arr, start, mid, end);
        }
        return count;
    }

    public void countInversion(int[] arr) {

        //..........................T: O(n log n)
        //..........................S: O(N) temp(left, right arrays)
        //https://www.geeksforgeeks.org/counting-inversions/
        int n = arr.length;
        int countInversion = divideAndMerge(arr, 0, n - 1);
        System.out.println("Count inversion: " + countInversion);
        //array is also got sorted
//        for(int row: arr){
//            System.out.print(row+" ");
//        }
    }

    public void minimumWindowSubarrayForTargetSumK(int[] arr, int K) {

        //SLIDING WINDOW BASIC
        //explanation: https://youtu.be/jKF9AcyBZ6E
        int start = 0;
        int end = 0;
        int sum = 0;
        int win = Integer.MAX_VALUE;
        int index = 0;
        while (end < arr.length) {

            sum += arr[end];

            while (sum >= K) {
                win = Math.min(win, end - start + 1);
                index = start;
                sum -= arr[start];
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Minimum length of subarrays whose sum (>= K): " + (win >= Integer.MAX_VALUE ? 0 : win));
        System.out.println("array element:");
        if (win != Integer.MAX_VALUE) {
            for (int i = 0; i < win; i++) {
                System.out.print(arr[index + i] + " ");
            }
        }
        System.out.println();
    }

    public void flipMZerosFindMaxLengthOfConsecutiveOnes(int[] arr, int M) {
        //https://leetcode.com/problems/max-consecutive-ones-iii/
        int start = 0;
        int end = 0;
        int zeroCount = 0;
        int bestWin = 0;
        int bestStart = 0;

        while (end < arr.length) {

            if (zeroCount <= M) {
                if (arr[end] == 0) {
                    zeroCount++;
                }
                end++;
            }

            if (zeroCount > M) {
                if (arr[start] == 0) {
                    zeroCount--;
                }
                start++;
            }

            if (end - start > bestWin && zeroCount <= M) {
                bestWin = end - start;
                bestStart = start;
            }
        }

        //output
        System.out.println("Length of consecutive ones after flipping M zeros: " + bestWin);
        System.out.println("Indexs of zeros to flip");
        for (int i = 0; i < bestWin; i++) {
            if (arr[bestStart + i] == 0) {
                System.out.print((bestStart + i) + " ");
            }
        }
        System.out.println();
    }

    public void firstNegativeNumberInWindowKFromArray(int[] arr, int K) {
        //SLIDING WINDOW and modification of maximumOfAllSubArrayOfSizeK()
        Deque<Integer> dQueue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        int index = 0;

        for (; index < K; index++) {
            if (arr[index] < 0) {
                dQueue.addLast(index);
            }
        }

        while (index < arr.length) {

            result.add(dQueue.isEmpty() ? 0 : arr[dQueue.peekFirst()]);

            while (!dQueue.isEmpty() && index - dQueue.peekFirst() >= K) {
                dQueue.removeFirst();
            }

            if (arr[index] < 0) {
                dQueue.addLast(index);
            }
            index++;
        }

        result.add(dQueue.isEmpty() ? 0 : arr[dQueue.peekFirst()]);

        //output
        //int[] output = result.stream().mapToInt(val -> val).toArray();
        System.out.println("First negative number in window of K: " + result);
    }

    public boolean handOfStraight(int[] arr, int W) {

        //https://leetcode.com/problems/hand-of-straights/
        //explanation: https://leetcode.com/problems/hand-of-straights/solution/
        int n = arr.length;
        //if we can not make a group of size (W) out of n length arr return false
        if (n % W != 0) {
            return false;
        }

        TreeMap<Integer, Integer> map = new TreeMap<>(); //TreeMap is important
        for (int c : arr) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        while (!map.isEmpty()) {
            //treemap.firstKey() returns first lowest key from the treemap
            int firstLowestKey = map.firstKey();
            for (int c = firstLowestKey; c < firstLowestKey + W; c++) {
                if (!map.containsKey(c)) {
                    return false;
                }

                map.put(c, map.get(c) - 1);
                if (map.get(c) <= 0) {
                    map.remove(c);
                }
            }
        }

        return true;
    }

    public void sortedSquaresOfSortedArray_1(int[] arr) {

        //..........................T: O(N)
        //..........................S: O(N)
        //https://leetcode.com/problems/squares-of-a-sorted-array/
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int x : arr) {
            minHeap.add(x * x);
        }

        int[] result = new int[arr.length];
        int index = 0;
        while (!minHeap.isEmpty()) {
            result[index++] = minHeap.poll();
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void sortedSquaresOfSortedArray_2(int[] arr) {

        //OPTIMISED
        //..........................T: O(N)
        //..........................S: O(1)
        //https://leetcode.com/problems/squares-of-a-sorted-array/
        int n = arr.length;

        int firstPositiveIndex = 0;
        while (firstPositiveIndex < n && arr[firstPositiveIndex] < 0) {
            firstPositiveIndex++;
        }

        int lastNegativeIndex = firstPositiveIndex - 1;

        int[] result = new int[n];
        int index = 0;
        while (lastNegativeIndex >= 0 && firstPositiveIndex < n) {

            int negativeSqr = arr[lastNegativeIndex] * arr[lastNegativeIndex];
            int positiveSqr = arr[firstPositiveIndex] * arr[firstPositiveIndex];

            if (negativeSqr < positiveSqr) {
                result[index++] = negativeSqr;
                lastNegativeIndex--;
            } else {
                result[index++] = positiveSqr;
                firstPositiveIndex++;
            }
        }

        while (lastNegativeIndex >= 0) {

            int negativeSqr = arr[lastNegativeIndex] * arr[lastNegativeIndex];
            result[index++] = negativeSqr;
            lastNegativeIndex--;
        }

        while (firstPositiveIndex < n) {

            int positiveSqr = arr[firstPositiveIndex] * arr[firstPositiveIndex];
            result[index++] = positiveSqr;
            firstPositiveIndex++;
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void moveZeroesToEnd(int[] arr) {

        //https://leetcode.com/problems/move-zeroes/
        int index = 0;
        //move all non-zero elements to index location and update index ptr
        for (int x : arr) {
            if (x != 0) {
                arr[index++] = x;
            }
        }

        //from curr index location fill array with 0
        for (; index < arr.length; index++) {
            arr[index] = 0;
        }

        //output:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void containerWithMostWater(int[] height) {

        //.......................T: O(N)
        //https://leetcode.com/problems/container-with-most-water/
        //explanation: https://youtu.be/6PrIRPpTI9Q
        //maxArea b/w two maxima
        //ex: [1,8,6,2,5,4,8,3,7]
        //min of two maxima(height[]) * dist b/w two maxima(index dist)
        //first 2 maxima = 8(ind 1) & 8(ind 6) area = min(8, 8) * (6 - 1) = 8 * 5 = 40
        //other 2 maxima = 8(ind 1) & 7(ind 8) area = min(8, 7) * (8 - 1) = 7 * 7 = 49 (MAX_AREA)
        int n = height.length;
        int start = 0;
        int end = n - 1;
        int maxArea = 0;
        int area = 0;

        while (end > start) {
            //water can be contained within two heights where one of height is
            //lesser than the other one and max height upto water can be filled without
            //overflowing is min(height[start], height[end])
            if (height[start] < height[end]) {
                //calculations: area = length * breadth
                area = height[start] * (end - start);
                maxArea = Math.max(maxArea, area);
                start++;
            } else {
                area = height[end] * (end - start);
                maxArea = Math.max(maxArea, area);
                end--;
            }
        }

        //output:
        System.out.println("Most water can be contained with area of: " + maxArea);
    }

    public int smallestMissingPositiveNumber(int[] arr) {

        //........................T: O(N)
        //explanation: https://www.youtube.com/watch?j=-lfHWWMmXXM
        if (arr == null || arr.length == 0) {
            return 0;
        }

        int n = arr.length;
        int i = 0;

        for (; i < n; i++) {
            int index = arr[i] - 1;
            while (arr[i] > 0 && arr[i] < n
                    && arr[i] != arr[index]) {

                //swap
                int temp = arr[i];
                arr[i] = arr[index];
                arr[index] = temp;
                index = arr[i] - 1; //update
            }
        }

        for (i = 0; i < n; i++) {
            if (arr[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }

    public void subarraySumEqualsK(int[] arr, int K) {
        //https://leetcode.com/problems/subarray-sum-equals-k/
        //explanation: https://youtu.be/BrWp4gf10fs
        int result = 0;
        int prefixSum = 0;
        Map<Integer, Integer> prefixSumCounter = new HashMap<>();
        prefixSumCounter.put(0, 1); //default sum -> occurence

        for (int element : arr) {
            prefixSum += element;
            result += prefixSumCounter.getOrDefault(prefixSum - K, 0);
            prefixSumCounter.put(prefixSum, prefixSumCounter.getOrDefault(prefixSum, 0) + 1);
        }

        //output:
        System.out.println("Subarrays whose sum equals to K: " + result);
    }

    public void longestSubarrayWithSumEqualsK(int[] arr, int K) {
        //https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/
        //https://leetcode.ca/all/325.html
        //https://www.geeksforgeeks.org/longest-sub-array-sum-k/
        //https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1
        //based on subarraySumEqualsK()
        int n = arr.length;
        int prefixSum = 0;
        int maxLen = 0;
        Map<Integer, Integer> prefixSumIndexes = new HashMap<>();
        //a default prefix sum of 0 exists at index -1
        prefixSumIndexes.put(0, -1);

        for (int i = 0; i < n; i++) {

            prefixSum += arr[i];

            if (!prefixSumIndexes.containsKey(prefixSum)) {
                prefixSumIndexes.put(prefixSum, i);
            }

            if (prefixSumIndexes.containsKey(prefixSum - K)) {
                maxLen = Math.max(maxLen, i - prefixSumIndexes.get(prefixSum - K));
            }
        }

        //output:
        System.out.println("Longest subarrays whose sum equals to K: " + maxLen);
    }

    public boolean continousSubarraySum(int[] nums, int k) {
        //https://leetcode.com/problems/continuous-subarray-sum/
        //explanation: https://youtu.be/M9IaD8oSSoQ
        //based on subarraySumEqualsK()
        /*
        To understand this question, you have to understand how remainders work.
        If k = 5, then 6 % 5 = 1, which also means (6 + 5) % 5 = 1. So you use a
        hash map to check if you have seen that remainder before. If yes, then
        you know between both indexes, it is 5 (i.e. (6 + 5) - 6 = 5).
        This question tests nothing other than knowing how remainders work.
         */
        int n = nums.length;
        Map<Integer, Integer> remainderIndexMap = new HashMap<>();
        remainderIndexMap.put(0, -1); // default remainder 0 with index as -1
        int prefixSum = 0;
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int rem = prefixSum % k;
            if (remainderIndexMap.containsKey(rem)) {
                if (i - remainderIndexMap.get(rem) >= 2) {
                    return true;
                }
            } else {
                remainderIndexMap.put(rem, i);
            }
        }
        return false;
    }

    private int countNicePairsInArray_NumReverse(int num) {
        StringBuilder sb = new StringBuilder(String.valueOf(num)).reverse();
        //remove any preceeding zeroes if any, after the reverse
        //ex: num = 1200, reverse = 0021 remove zeroes = 21
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }
        return Integer.parseInt(sb.toString());
    }

    public void countNicePairsInArray(int[] nums) {
        //https://leetcode.com/problems/count-nice-pairs-in-an-array/
        //https://leetcode.com/problems/count-nice-pairs-in-an-array/discuss/1140804/JAVA-oror-HashMap
        //based on subarraySumEqualsK()
        /*
        A pair of indices (i, j) is nice if it satisfies all of the following
        conditions:
        1. 0 <= i < j < nums.length
        2. nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
         */
        int n = nums.length;
        int mod = 1000000007;
        int pairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int numRev = countNicePairsInArray_NumReverse(nums[i]);
            int diff = nums[i] - numRev;
            pairs = (pairs + freq.getOrDefault(diff, 0)) % mod;
            freq.put(diff, freq.getOrDefault(diff, 0) + 1);
        }
        //output
        System.out.println("Nice pairs count: " + pairs);
    }

    public void countNumberOfBadPairs(int[] nums) {
        //https://leetcode.com/problems/count-number-of-bad-pairs/
        //based on subarraySumEqualsK() & countNicePairsInArray()
        /*
        Count number of bad pairs = TotalPairs - Count number of good pairs
        A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].

        the above cond can be written as
        bad pairs ==> nums[i] - i != nums[j] - j
        then good pairs ==> nums[i] - i == nums[j] - j
         */
        int n = nums.length;
        //this typecasting of 1L and 2L is req otherwise it was giving error
        long totalPairs = n * (n - 1L) / 2L;
        long goodPairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int diff = nums[i] - i;
            goodPairs += freq.getOrDefault(diff, 0);
            freq.put(diff, freq.getOrDefault(diff, 0) + 1);
        }
        //output
        System.out.println("Count number of bad pairs: " + (totalPairs - goodPairs));
    }

    public void numberOfPairsOfInterchangeableRectangles(int[][] rectangles) {
        //https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/
        //based on subarraySumEqualsK()
        int n = rectangles.length;
        long pairs = 0;
        Map<Double, Long> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            double width = rectangles[i][0];
            double height = rectangles[i][1];
            double ratio = width / height;
            pairs += freq.getOrDefault(ratio, 0L);
            freq.put(ratio, freq.getOrDefault(ratio, 0L) + 1L);
        }
        //output
        System.out.println("Number of pairs of interchangeable rectangles: " + pairs);
    }

    public void numberOfSubarraysWithKOddNums(int[] nums, int k) {
        //https://leetcode.com/problems/count-number-of-nice-subarrays/
        //based on subarraySumEqualsK()
        int n = nums.length;
        int countSubarr = 0;

        Map<Integer, Integer> prefixSumCounter = new HashMap<>();
        prefixSumCounter.put(0, 1);

        int oddCount = 0;

        for (int i = 0; i < n; i++) {
            oddCount += nums[i] % 2 == 0 ? 0 : 1;
            countSubarr += prefixSumCounter.getOrDefault(oddCount - k, 0);
            prefixSumCounter.put(oddCount, prefixSumCounter.getOrDefault(oddCount, 0) + 1);
        }
        //output
        System.out.println("Number of subarrays that contains k odd numbers: " + countSubarr);
    }

    public void subarraySumDivisibleByK(int[] arr, int K) {

        //https://leetcode.com/problems/subarray-sums-divisible-by-k/
        //https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/1227888/Java-Map-soln.
        //explanation: https://youtu.be/QM0klnvTQzk
        //APPROACH similar to subarraySumEqualsK()
        /*
         ex: arr = [4,5,0,-2,-3,1], k = 5
         There are 7 subarrays with a sum divisible by k = 5:
         [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
         */
        Map<Integer, Integer> prefixSumRemainderCounter = new HashMap<>();
        prefixSumRemainderCounter.put(0, 1); // Default: remainder = 0, freq = 1
        int prefixSum = 0;
        int count = 0;

        for (int val : arr) {
            prefixSum += val;
            int remainder = prefixSum % K;
            //handle -ve remainder
            remainder = remainder < 0 ? remainder + K : remainder;
            count += prefixSumRemainderCounter.getOrDefault(remainder, 0);
            prefixSumRemainderCounter.put(remainder,
                    prefixSumRemainderCounter.getOrDefault(remainder, 0) + 1);
        }
        //output
        System.out.println("Total subarrays divisible by K: " + count);
    }

    public void longestSubarraySumDivisibleByK(int[] nums, int k) {
        //https://practice.geeksforgeeks.org/problems/longest-subarray-with-sum-divisible-by-k1259/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article
        //based on subarraySumEqualsK() & subarraySumDivisibleByK()
        int n = nums.length;
        int prefixSum = 0;
        int longestSubarr = 0;
        Map<Integer, Integer> remainderIndex = new HashMap<>();
        //a default remainder of 0 exists at index -1
        remainderIndex.put(0, -1);

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int remainder = prefixSum % k;
            remainder = remainder < 0 ? remainder + k : remainder;
            if (remainderIndex.containsKey(remainder)) {
                longestSubarr = Math.max(longestSubarr, i - remainderIndex.get(remainder));
            } else {
                //why this put() in else part?, because,
                //as we need longest subarray, so if we are seeing a particular
                //remainder in map, then that remainder must maintain its first-occurence
                //of index i.e, i. if we always update an existing remainder with new index
                //i then the longest subarray calculation will be incorrect
                remainderIndex.put(remainder, i);
            }
        }
        //output
        System.out.println("Longest subarray with ssum divisble by k : " + longestSubarr);
    }

    public void subarrayProductLessThanK(int[] nums, int K) {
        //https://leetcode.com/problems/subarray-product-less-than-k/
        //explanation: https://youtu.be/SxtxCSfSGlo
        //based on SLIDING WINDOW
        /*

         ex: [10, 5, 2, 6]
         The 8 subarrays that have product less than 100 are:
         [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
         Note that [10, 5, 2] is not included as the product of 100
         is not strictly less than k.

         */
        int n = nums.length;
        int subarr = 0;
        int currProd = 1;
        int start = 0;
        int end = 0;

        while (end < n) {

            currProd *= nums[end];

            while (end > start && currProd >= K) {
                currProd /= nums[start];
                start++;
            }

            if (currProd < K) {
                subarr += (end - start + 1);
            }
            end++;
        }

        //output:
        System.out.println("Total subarrays with product less than K: " + subarr);
    }

    public void makeSumDivisibleByK(int[] nums, int k) {
        //https://leetcode.com/problems/make-sum-divisible-by-p/description/
        //https://leetcode.com/problems/make-sum-divisible-by-p/solutions/854197/java-c-python-prefix-sum/
        //based on subarraySumDivisibleByK()
        int n = nums.length;
        int subarrLength = n;
        int arrSumRemainder = 0;
        int prefixSumRemainder = 0;
        Map<Integer, Integer> lastRemainderIndex = new HashMap<>();
        //default case: remainder 0 exist at index -1
        lastRemainderIndex.put(0, -1);

        //calculating the remainder for the whole arr[], if its already 0 then
        //we dont need to remove any subarray(possible empty) to make arr[] sum
        //divisible by k so then the empty subarray length becomes 0
        //but if the remainder is not 0, then there exist a subarray whose sum's
        //remainder is causing this remainder and we need to find that shortest
        //subarray
        for (int val : nums) {
            arrSumRemainder = (arrSumRemainder + val) % k;
        }

        for (int i = 0; i < n; i++) {
            prefixSumRemainder = (prefixSumRemainder + nums[i]) % k;
            lastRemainderIndex.put(prefixSumRemainder, i);
            int prevRemainder = (prefixSumRemainder - arrSumRemainder + k) % k;
            //default subarrLength is n, so if at any time prevRem is not there
            //in map, we get -n as default from this map then i - -n ==> i + n
            //==> a number always greater than n itself(== N) so here min(n, N)
            //will bound to choose n only but if there exist a prevRem whose value
            //is there in map then i - prevRemIndex < n hence min(n, i - prevRemIndex)
            //==> i - prevRemIndex
            subarrLength = Math.min(subarrLength, i - lastRemainderIndex.getOrDefault(prevRemainder, -n));
        }
        //output
        System.out.println("Shortest subarray removal to make remaining sum divisible by k: "
                + (subarrLength < n ? subarrLength : -1));
    }

    public boolean globalAndLocalInversionCountAreEqual(int[] arr) {

        //THIS QUESTION IS NOT SIMILAR TO COUNT INVERSION, follow link for question desc
        //https://leetcode.com/problems/global-and-local-inversions
        //explanantion: https://youtu.be/vFH3zrUbvD4
        /*

         The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].

         The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].

         ex: arr = 1, 0, 2
         global = 1, 0 as index 0 < 1 and arr[0] > arr[1]
         local = 1, 0 as index 0 < N and arr[0] > arr[0 + 1]
         so total global inversion  == total local inversion

         */
        int n = arr.length;
        int max = -1;
        for (int i = 0; i < n - 2; i++) {
            max = Math.max(max, arr[i]);
            if (max > arr[i + 2]) {
                return false;
            }
        }
        return true;
    }

    public int longestConsecutiveSequence(int[] arr) {
        //https://leetcode.com/problems/longest-consecutive-sequence/
        int N = arr.length;

        if (N == 1) {
            return 1;
        }

        Set<Integer> set = new HashSet<>();
        for (int val : arr) {
            set.add(val);
        }

        int maxLen = 0;
        int currLen;
        for (int val : arr) {
            if (set.contains(val - 1)) {
                continue;
            }
            currLen = 0;
            int nextNum = val;
            while (set.contains(nextNum)) {
                set.remove(nextNum);
                nextNum++;
                currLen++;
            }
            maxLen = Math.max(maxLen, currLen);
        }
        return maxLen;
    }

    public void maxDifferenceOfIndexes(int[] arr) {

        //........................T: O(N)
        //........................S: O(N)
        //OPTIMISED
        //https://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/
        /*
         The task is to find the maximum of j - i subjected to the constraint of A[i] <= A[j].
         */
        int n = arr.length;
        int i;
        int j;
        int maxDiff = -1;
        int[] leftMin = new int[n];
        int[] rightMax = new int[n];

        leftMin[0] = arr[0];
        for (i = 1; i < n; i++) {
            leftMin[i] = Math.min(arr[i], leftMin[i - 1]);
        }

        rightMax[n - 1] = arr[n - 1];
        for (i = n - 2; i >= 0; i--) {
            rightMax[i] = Math.max(arr[i], rightMax[i + 1]);
        }

        i = 0;
        j = 0;

        while (i < n && j < n) {
            if (leftMin[i] <= rightMax[j]) {
                maxDiff = Math.max(maxDiff, j - i);
                j++;
            } else {
                i++;
            }
        }

        //output
        System.out.println("Mmax diff: " + maxDiff);
    }

    public void rearrangeArrayElements(int[] arr) {

        //OPTIMISED
        //.................................T: O(N)
        //.................................S: O(1)
        //https://www.geeksforgeeks.org/rearrange-given-array-place/
        /*
         Given an array arr[] of size N where every element is in the range
         from 0 to n-1.
         Rearrange the given array so that arr[i] becomes arr[arr[i]].
         */
        int n = arr.length;

        for (int i = 0; i < n; i++) {
            arr[i] += (arr[arr[i]] % n) * n;
        }

        for (int i = 0; i < n; i++) {
            arr[i] /= n;
        }

        //output
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void minimumRangeContainingAtleastOneElementFromKSortedList(int[][] kSortedList) {

        ////............................T: O(N*K*LogK)
        //............................S: O(K)
        //https://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/
        //APPROACH SIMILAR TO k sorted list/array
        class Data {

            final int row;
            final int len;
            int col;

            public Data(int row, int col, int len) {
                this.row = row;
                this.len = len;
                this.col = col;
            }
        }

        int K = kSortedList.length;

        int max = Integer.MIN_VALUE;
        int minRange = Integer.MAX_VALUE;
        int minElementRange = -1;
        int maxElementRange = -1;

        PriorityQueue<Data> minHeap = new PriorityQueue<>((a, b) -> {
            return kSortedList[a.row][a.col] - kSortedList[b.row][b.col];
        });

        for (int r = 0; r < K; r++) {
            minHeap.add(new Data(r, 0, kSortedList[r].length));
            max = Math.max(max, kSortedList[r][0]); //max element from all the first element of K sorted list([r][0])
        }

        while (!minHeap.isEmpty()) {

            Data curr = minHeap.poll(); //its minHeap, root is always min

            int min = kSortedList[curr.row][curr.col];

            //find range
            if ((max - min) < minRange) {
                minRange = max - min;
                minElementRange = min;
                maxElementRange = max;
            }

            if (curr.col + 1 < curr.len) {
                curr.col++;
                max = Math.max(max, kSortedList[curr.row][curr.col]); //max(currMax, updated element from the kSortedList)
                minHeap.add(curr);
            } else {
                //if some kTh row reached its max len, break (col == KSortedList[row].length)
                //because we have find range from [0, K]
                break;
            }
        }

        //output
        System.out.println("Min range of elements that is present in all K sorted list: "
                + "[" + minElementRange + ", " + maxElementRange + "]");

    }

    public void tupleWithSameProduct(int[] arr) {

        //https://practice.geeksforgeeks.org/problems/sum-equals-to-sum4006/1 (SAME APPROACH)
        //https://leetcode.com/problems/tuple-with-same-product/
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;

        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                int mul = arr[i] * arr[j];
                if (map.containsKey(mul)) {
                    count += map.get(mul);
                }
                map.put(mul, map.getOrDefault(mul, 0) + 1);
            }
        }

        //output
        //explanation of multiply with 8 = https://www.tutorialspoint.com/tuple-with-the-same-product-in-cplusplus
        System.out.println("Possible tuple counts: " + (count * 8));
    }

    public void kDiffPairsInArray(int[] arr, int k) {
        //https://leetcode.com/problems/k-diff-pairs-in-an-array/
        //https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/
        int pair = 0;
        Map<Integer, Long> map = IntStream.of(arr).boxed()
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        for (int key : map.keySet()) {

            long freq = map.get(key);
            //k > 0 && map.contains(a[row] + k) ex: k = 2 then 1 + k == 3, 3 + k == 5
            //should exists as 2 pairs: (1,3) & (3,5)
            //k == 0 means a[row] - a[col] = k ==> a[row] = a[col] inorder to make a pair, a[row] or a[col] have freq > 1
            //as pair needs 2 element
            if ((k > 0 && map.containsKey(key + k)) || (k == 0 && freq > 1)) {
                pair++;
            }
        }

        //output
        System.out.println("Count of pair of array element with diff equal to k: " + pair);
    }

    public void leastNumberOfUniqueIntegersLeftAfterKRemoval(int[] arr, int K) {

        //https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
        //can't remove K elements if K is more than array's length
        if (K > arr.length) {
            return;
        }
        //get the frequency count of all the array element
        Map<Integer, Long> map = IntStream.of(arr).boxed()
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        //arrange all the array element at top having less frequency
        PriorityQueue<Integer> minFreq = new PriorityQueue<>(
                (a, b) -> (int) (map.get(a) - map.get(b))
        );

        //put all the unique integers in the minFreq queue
        //minFreq.addAll(IntStream.of(arr).boxed().collect(Collectors.toSet()));
        minFreq.addAll(map.keySet());

        while (K > 0 && !minFreq.isEmpty()) {

            int curr = minFreq.poll();
            //reduce the freq of curr array element
            //which is least freq untill K becomes 0
            map.put(curr, map.get(curr) - 1);
            //if freq of curr array element is 0 remove it from map and dont add it in minFreq
            if (map.get(curr) <= 0) {
                map.remove(curr);
            } else {
                //if freq of array element is greater than 0, put it back in minFreq
                minFreq.add(curr);
            }
            K--;
        }

        //output
        System.out.println("Total unique integer after K removals: " + minFreq.size() + " K integers left: " + minFreq);
    }

    private void printAllPermutationOfDistinctIntegerArray_Helper(int[] arr,
                                                                  int index,
                                                                  List<List<Integer>> res) {

        if (index == arr.length) {
            res.add(Arrays.stream(arr).boxed().collect(Collectors.toList()));
        }

        for (int i = index; i < arr.length; i++) {

            //swap
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;

            printAllPermutationOfDistinctIntegerArray_Helper(arr, index + 1, res);

            //swapping back the integers at their orignal places
            temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }

    public void printAllPermutationOfDistinctIntegerArray(int[] arr) {

        //https://leetcode.com/problems/permutations/
        //https://leetcode.com/problems/permutations-ii/
        List<List<Integer>> res = new ArrayList<>();
        printAllPermutationOfDistinctIntegerArray_Helper(arr, 0, res);

        //output
        System.out.println("All permutations of distinct integer: " + res);
    }

    private void combinationSum_1_Helper(
            int[] nums, int target, int index, List<Integer> currCombination, List<List<Integer>> result) {

        //we reach to and end index where we can't pick any value further so here
        //we will check if our target has reached 0, if it has reached 0 add the
        //curr combination into result combinations
        if (index >= nums.length) {
            if (target == 0) {
                result.add(currCombination);
            }
            return;
        }

        //we have 2 choices to make,
        //1.) don't pick the curr val @index and move to next index(==> index + 1) then
        //the target will not be reduced with nums[index] value
        combinationSum_1_Helper(nums, target, index + 1, new ArrayList<>(currCombination), result);

        //2.) pick the curr value @index and reduce target with nums[index] value
        //also make sure that this reduction of target doesn't go negative
        //since we are allowed to pick the same value multiple times hence the index
        //remain as it is
        if (target - nums[index] >= 0) {
            currCombination.add(nums[index]);
            combinationSum_1_Helper(
                    nums, target - nums[index], index, new ArrayList<>(currCombination), result);
        }
    }

    public void combinationSum_1(int[] nums, int target) {
        //..............................T: O(nCtarget) ==> O(n!/ (n - target)! * target!)
        //APPROACH SIMILAR TO SUBSET SUM EQUAL TO TARGET
        //https://leetcode.com/problems/combination-sum
        //https://leetcode.com/problems/combinations/
        List<List<Integer>> result = new ArrayList<>();
        combinationSum_1_Helper(nums, target, 0, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum is equal to target: " + result);
    }

    private void combinationSum_3_Helper(
            int[] nums, int targetSum, int kNums, int index,
            List<Integer> currCombination, List<List<Integer>> result) {

        if (index >= nums.length) {
            if (targetSum == 0 && currCombination.size() == kNums) {
                result.add(currCombination);
            }
            return;
        }

        //2 choices
        //1.) don't pick curr val @index and move to next index(==> index + 1)
        //then targetSum will not be reduced with curr nums[index] value
        combinationSum_3_Helper(
                nums, targetSum, kNums, index + 1, new ArrayList<>(currCombination), result);

        //2.) pick the curr value @index and reduce target with nums[index] value
        //also make sure that this reduction of target doesn't go negative and move
        //to next index (==> index + 1)
        if (targetSum - nums[index] >= 0) {
            currCombination.add(nums[index]);
            combinationSum_3_Helper(
                    nums, targetSum - nums[index], kNums, index + 1,
                    new ArrayList<>(currCombination), result);
        }
    }

    public void combinationSum_3(int kNums, int targetSum) {
        //..............................T: O(2^N)
        //APPROACH SIMILAR TO SUBSET SUM EQUAL TO TARGET
        //https://leetcode.com/problems/combination-sum-iii/
        List<List<Integer>> result = new ArrayList<>();
        //nums can only have [1 to 9] and combinantions will not contain duplication
        //prepare dummy muns[]
        int[] nums = new int[9];
        for (int i = 0; i < 9; i++) {
            nums[i] = i + 1;
        }
        combinationSum_3_Helper(nums, targetSum, kNums, 0, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum is targetSum and have Knums: " + result);
    }

    private void combinationSum_2_Helper(int[] nums, int index, int target,
                                         List<Integer> curr, List<List<Integer>> res) {

        if (target == 0) {
            res.add(new ArrayList<>(curr));
            return;
        }

        for (int i = index; i < nums.length; i++) {
            //skip, if the curr i-th element is same as prev(i - 1)-th element
            //index is starting point for nums[] and i > index checks that we have
            //atleast 2 values to compare i.e, prev and curr
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }

            //break, if reducing target with the curr i-th value from nums[] is
            //making target negative
            //as the nums[] is sorted now so if by picking curr i-th value makes
            //target negative then further next indexes will also do same
            if (target - nums[i] < 0) {
                break;
            }
            //take only those nums[] elements that are smaller or equal to target
            curr.add(nums[i]);
            combinationSum_2_Helper(nums, i + 1, target - nums[i], curr, res);
            curr.remove(curr.size() - 1);
        }
    }

    public void combinationSum_2(int[] nums, int target) {
        //https://leetcode.com/problems/combination-sum-ii
        List<List<Integer>> result = new ArrayList<>();
        //resulting combination is req in sorted order
        //and by sorting we prevent duplicated combinations
        Arrays.sort(nums);
        combinationSum_2_Helper(nums, 0, target, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum equal to target: "
                + result);
    }

    public int shortestUnsortedContigousSubarray(int[] arr) {

        //https://leetcode.com/problems/shortest-unsorted-continuous-subarray
        /*
         arr[] = [2,6,4,8,10,9,15], unsorted contigous subarray = [6,4,8,10,9]
         if [6,4,8,10,9] this subarray is sorted = [4,6,8,9,10]
         then whole arr is sorted = [2,4,6,8,9,10,15]
         find the shortest such kind of this subarray...

         explanation: clone the arr and sort the cloned arr(sortedClone)
         arr[] = [2,6,4,8,10,9,15]
         sortedClone[] = [2,4,6,8,9,10,15]
         start iterating on both at same time,
         if arr[i] != sortedClone[i]
         (index i of (arr = 6 & sortedClone = 4) where subarray should start)
         (index i of (arr = 9 & sortedClone = 10) where subarray should end)
         start is min(i) and end is max(i)
         */
        int n = arr.length;
        int start = Integer.MAX_VALUE;
        int end = Integer.MIN_VALUE;

        int[] sortedClone = arr.clone();
        Arrays.sort(sortedClone);

        for (int i = 0; i < n; i++) {

            if (arr[i] != sortedClone[i]) {
                //min starting index from where sorting should begin
                start = Math.min(start, i);
                //max ending index till there sorting should end
                end = Math.max(end, i);
            }
        }

        if (start == Integer.MAX_VALUE && end == Integer.MIN_VALUE) {
            return 0;
        }
        return end - start + 1;
    }

    public void minimumOperationsToMakeArrayStrictlyIncr(int[] arr) {

        //https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
        /*
         arr[] = [1,1,1]
         start from index i = 1 nextMax possible (prevElement + 1, currElement)
         = (arr[i - 1] + 1, arr[i])
         opr += diff to make currElement increasing = nextMax - currElement
         currElement = nextMax
         i = 1
         nextMax = max(1 + 1, 1)
         opr += 0 + (2 - 1) = 1
         arr[1] = nextMax = 2 => [1,2,1]
         i = 2
         nextMax = max(2 + 1, 1) = 3
         opr += 1 + (3 - 1) = 1 + 2 => 3
         arr[2] = nextMax = 3
         [1,2,3]
         */
        int n = arr.length;
        int opr = 0;
        for (int i = 1; i < n; i++) {
            int nextMax = Math.max(arr[i - 1] + 1, arr[i]);
            opr += nextMax - arr[i];
            arr[i] = nextMax;
        }

        //output
        System.out.println("Minimum operations to make array strictly increasing: " + opr);
    }

    public void longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(int[] arr) {

        //https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
        //APPROACH is similar to longest consecutive one after M zero flips
        //flipMZerosFindMaxLengthOfConsecutiveOnes()
        /*logic is try to flip only 1 zero and get the max len consecutive ones,
         now we have to delete one element so just do maxLen - 1 this will be like
         delete that one element to get rest of consecutive ones.
         edge case: when all the elements are 1 and there are no 0s to flip,
         then maxLen will remain 0 only, if we do maxLen - 1 it will be -ve that
         means all elements were 1 in arr[] so just do n - 1
         */
        int n = arr.length;
        int m = 1;
        int zeroCount = 0;
        int maxLen = 0;
        int start = 0;
        int end = 0;

        while (end < n) {

            if (zeroCount <= m) {
                if (arr[end] == 0) {
                    zeroCount++;
                }
                end++;
            }

            if (zeroCount > m) {
                if (arr[start] == 0) {
                    zeroCount--;
                }
                start++;
            }

            if (end - start > maxLen && zeroCount == m) {
                maxLen = end - start;
            }
        }

        //output
        System.out.println("Longest consecutive ones after deleting one element: "
                + (maxLen - 1 < 0 ? n - 1 : maxLen - 1));
    }

    public void countSubarrayWithOddSum(int[] arr) {

        //https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum
        //explanation: https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/1199776/81-Faster-C%2B%2B-Solution
        /*
         ex: [1,3,5] = [[1],[3],[5],[1,3,5]] == 4 subarray with sum is odd
         */
        int n = arr.length;
        int evenSumPrefix = 1; //default 0 which is even
        int oddSumPrefix = 0;
        int sum = 0;
        int res = 0;
        int mod = 1000000007;

        for (int val : arr) {
            sum += val;
            if (sum % 2 == 0) {
                res = (res + oddSumPrefix) % mod;
                evenSumPrefix++;
            } else {
                res = (res + evenSumPrefix) % mod;
                oddSumPrefix++;
            }
        }
        //output
        System.out.println("Count subarray with odd sum: " + res);
    }

    public void mergeNewInterval(int[][] intervals, int[] newInterval) {

        if (intervals.length == 0) {
//            return new int[][]{newInterval};
            return;
        }

        /*
         1.
         ..........a-----b
         .....................p-----q
         2.
         ................a-----b
         ......p-----q

         3.
         ..........a------b
         ......p------q
         min(p,a) & max(q, b)

         .........a------b
         ............p-------q
         min(p,a) & max(q, b)

         .....a----b
         p--------------q
         min(p,a) & max(q, b)

         a--------------b
         ....p-----q
         min(p,a) & max(q, b)
         */
        List<int[]> left = new ArrayList<>();
        List<int[]> right = new ArrayList<>();

        for (int[] interval : intervals) {

            if (interval[1] < newInterval[0]) {
                left.add(interval);
            } else if (interval[0] > newInterval[1]) {
                right.add(interval);
            } else {
                newInterval[0] = Math.min(interval[0], newInterval[0]);
                newInterval[1] = Math.max(interval[1], newInterval[1]);
            }
        }

        int[][] res = new int[left.size() + 1 + right.size()][2];
        int index = 0;
        for (int[] l : left) {
            res[index++] = l;
        }

        res[index++] = newInterval;

        for (int[] r : right) {
            res[index++] = r;
        }

        //output
        for (int[] e : res) {
            System.out.print(e[0] + "-" + e[1] + "\n");
        }
        System.out.println();
    }

    public void duplicateZeroInArray(int[] arr) {

        //..............T: O(N) if all e in arr[] != 0 AND O(N^2) if some e in arr[] == 0 (AMORTIZED)
        //https://leetcode.com/problems/duplicate-zeros/
        //actual
        System.out.println("Actual");
        for (int e : arr) {
            System.out.print(e + " ");
        }
        System.out.println();

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == 0) {
                for (int j = arr.length - 2; j >= i; j--) {
                    arr[j + 1] = arr[j];
                }
                i++;
            }
        }

        //output
        for (int e : arr) {
            System.out.print(e + " ");
        }
        System.out.println();
    }

    public void arrayNesting(int[] arr) {

        //https://leetcode.com/problems/array-nesting/
        /*
         You are given an integer array nums of length n where nums is a
         permutation of the numbers in the range [0, n - 1].

         You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }
         subjected to the following rule:

         The first element in s[k] starts with the selection of the element nums[k] of index = k.
         The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
         We stop adding right before a duplicate element occurs in s[k].
         Return the longest length of a set s[k].
         */
        int res = 0;
        for (int i = 0; i < arr.length; i++) {

            if (arr[i] != Integer.MAX_VALUE) {
                int start = arr[i];
                int len = 0;
                while (arr[start] != Integer.MAX_VALUE) {
                    int temp = start;
                    start = arr[start];
                    len++;
                    arr[temp] = Integer.MAX_VALUE;
                }
                res = Math.max(res, len);
            }
        }
        //output
        System.out.println("Longest length: " + res);
    }

    public boolean escapingGhost(int[][] ghosts, int[] target) {

        //https://leetcode.com/problems/escape-the-ghosts/
        //user init coord row, col = 0, 0
        //dist b/w user from target = abs(row - tX) + abs(col - tY)
        int userDist = Math.abs(0 - target[0]) + Math.abs(0 - target[1]);
        for (int[] ghost : ghosts) {
            //dist of ghost from target
            int ghostDistFromTarget = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);
            if (ghostDistFromTarget <= userDist) {
                //if the ghost reaches the target before user or at the same time as user reached,
                //ghost will catch you so false
                return false;
            }
        }
        return true;
    }

    public void removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(int[] arr) {

        //https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
        //actual
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        int n = arr.length;
        int start = 0;
        int end = 0;
        int currVal = arr[end];
        int atMostCounter = 0;
        while (end < n) {
            //count the occurences of the consecutive same value as that of currVal
            if (arr[end] == currVal) {
                atMostCounter++;
            } else {
                //if the arr[end] didn't match the currVal
                //we will update the currVal and start counting occurences of this value
                currVal = arr[end];
                //reseting counter back to 1 as atleast this curr arr[end] occuring 1 time
                atMostCounter = 1;
            }

            //we only need atmost 2 occurences of the value (arr[end])
            if (atMostCounter <= 2) {
                //put value at start index if it is less that or equal to 2
                //all greater occurences will not be taken into account
                arr[start] = arr[end];
                start++;
            }
            end++;
        }

        //output
        for (int i = 0; i < start; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    private double nPowerOfX_Helper(double x, int n) {
        if (n == 0) { //pow(row, 0) = 1
            return 1;
        }

        if (n == 1) { // pow(row, 1) = row
            return x;
        }

        if (n % 2 == 0) {
            return nPowerOfX_Helper(x * x, n / 2);
        }
        return x * nPowerOfX_Helper(x * x, n / 2);
    }

    public void nPowerOfX(double x, int n) {

        //..................T: O(N * LogN)
        //https://leetcode.com/problems/powx-n/
        /* n can be +ve or -ve value*/
        double output = n >= 0
                ? nPowerOfX_Helper(x, n)
                : 1.0 / nPowerOfX_Helper(x, Math.abs(n));
        System.out.println("pow(x, n): "
                + output);
    }

    public void gasStationCompleteCircuit(int[] gas, int[] cost) {
        //............................T: O(N) + O(N) + O(N)
        //https://leetcode.com/problems/gas-station/
        //explanation: https://youtu.be/lJwbPZGo05A
        //O(N) + O(N), for summing gas[] & cost[]
        if (IntStream.of(gas).sum() < IntStream.of(cost).sum()) {
            System.out.println("Starting index of gas station to complete the circuit(approach 1): -1");
            return;
        }

        int n = gas.length;
        int moveDiff = 0;
        int resultIndex = 0;
        //O(N)
        for (int i = 0; i < n; i++) {

            moveDiff += (gas[i] - cost[i]);
            if (moveDiff < 0) {
                moveDiff = 0;
                resultIndex = i + 1;
            }
        }

        //output;
        System.out.println("Starting index of gas station to complete the circuit(approach 1): "
                + resultIndex);
    }

    public void gasStationCompleteCircuit2(int[] gas, int[] cost) {
        //..............................T: O(N), little optimized
        //https://leetcode.com/problems/gas-station/
        int n = gas.length;
        int maxVal = Integer.MIN_VALUE;
        int resultIndex = n - 1;
        int moveDiff = 0;

        for (int i = n - 1; i >= 0; i--) {

            moveDiff += (gas[i] - cost[i]);
            if (moveDiff > maxVal) {
                maxVal = moveDiff;
                resultIndex = i;
            }
        }

        //output;
        System.out.println("Starting index of gas station to complete the circuit(approach 2): "
                + (moveDiff < 0 ? -1 : resultIndex));
    }

    private void rangeUpdateAndPointQueries_Update(int[] arr, int left, int right, int val) {
        arr[left] += val;
        if (right + 1 < arr.length) {
            arr[right + 1] -= val;
        }
    }

    private int rangeUpdateAndPointQueries_GetQueries(int[] arr, int i) {
        int prefixSum = 0;
        for (int j = 0; j <= i; j++) {
            prefixSum += arr[j];
        }
        return prefixSum;
    }

    public void rangeUpdateAndPointQueries(int[] arr) {

        //https://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/
        int left = 2;
        int right = 4;
        int val = 2;
        rangeUpdateAndPointQueries_Update(arr, left, right, val);

        //Find the element at Index 4
        int index = 4;
        System.out.println("Element at index " + index + " is " + rangeUpdateAndPointQueries_GetQueries(arr, index));

        left = 0;
        right = 3;
        val = 4;
        rangeUpdateAndPointQueries_Update(arr, left, right, val);

        //Find the element at Index 3
        index = 3;
        System.out.println("Element at index " + index + " is " + rangeUpdateAndPointQueries_GetQueries(arr, index));
    }

    private boolean isOutOfBound(int x, int xLen, int y, int yLen, int z, int zLen) {
        return x >= xLen || y >= yLen || z >= zLen;
    }

    public void allCommonElementIn3SortedArray(int[] a, int[] b, int[] c) {
        //...........................T: O(N), where N = MIN(xLen, yLen, zLen)
        /*
         If arrays was given unsorted, then one way to solve this problem is to sort the arrays first
         using optimised sort(ex merge sort) then time complexity will be
         T: O(xLen.Log(xLen)) + O(yLen.Log(yLen)) + O(zLen.Log(zLen)) + O(N), N = MIN(xLen, yLen, zLen)
         total sorting time will be time taken to sort the longest array = MAX(xLen, yLen, zLen)
         so overall order = T: O(N.LogN) = MAX(xLen, yLen, zLen)
         */
        //https://practice.geeksforgeeks.org/problems/common-elements1132/1
        int x = 0;
        int y = 0;
        int z = 0;
        int xLen = a.length;
        int yLen = b.length;
        int zLen = c.length;
        int prev = Integer.MIN_VALUE;
        List<Integer> result = new ArrayList<>();

        while (!isOutOfBound(x, xLen, y, yLen, z, zLen)) {
            if (a[x] == b[y] && b[y] == c[z]) {
                //If duplicate values are not required
                if (prev != a[x]) {
                    prev = a[x];
                    result.add(a[x]);
                }
                //if duplicate values are req
                //result.add(a[row]);
                x++;
                y++;
                z++;
            } else if (a[x] < b[y]) {
                x++;
            } else if (b[y] < c[z]) {
                y++;
            } else {
                z++;
            }
        }
        //output
        System.out.println("All common elements in 3 sorted arrays: " + result);
    }

    public void allCommonElementInKUnsortedArray(int[][] kArray) {
        //https://leetcode.com/problems/intersection-of-multiple-arrays/
        //https://www.codingninjas.com/codestudio/problems/common-elements-present-in-all-rows-of-a-matrix_1118111
        int k = kArray.length;
        int COL = kArray[0].length;

        List<Integer> commonElements = new ArrayList<>();
        Map<Integer, Integer> freq = new HashMap<>();

        if (k == 1) {
            for (int col = 0; col < COL; col++) {
                commonElements.add(kArray[0][col]);
            }
        }

        for (int col = 0; col < COL; col++) {
            freq.put(kArray[0][col], 1);
        }

        for (int row = 1; row < k; row++) {
            int freqReqAtKThRow = row;
            for (int col = 0; col < COL; col++) {
                int currCellVal = kArray[row][col];
                if (freq.containsKey(currCellVal) && freq.get(currCellVal) == freqReqAtKThRow) {

                    freq.put(currCellVal, freq.getOrDefault(currCellVal, 0) + 1);

                    //at last row
                    if (row == k - 1) {
                        commonElements.add(currCellVal);
                    }
                }
            }
        }
        //output
        System.out.println("All common elements in K unsorted array: " + commonElements);
    }

    public void randomlyRearrangeElementsOfArray(int[] arr) {
        //https://leetcode.com/problems/shuffle-an-array/
        //.............................T: O(N)
        //.............................S: O(1), in-place
        // random{} generates random num between 0 & 1
        // (i + 1) * Math.random(), (i + 1) is length of arr at ith iteration
        // so if N = 5, ex: 1)iteration: i = N - 1 => 4 => i => 4 => 4
        // (i) * random ranges => 4 * 0 & 4 * 1 => 0 & 4
        // floor will keep the ranges to lower bounds that also matches with array indexes
        int N = arr.length;
        for (int i = N - 1; i > 0; i--) {
            int randomIndex = (int) Math.floor(i * Math.random());
            //swap
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //output
        System.out.println("Array shuffle: " + Arrays.toString(arr));
    }

    public void randomlyRearrangeElementsOfArray2(int[] arr) {
        //https://leetcode.com/problems/shuffle-an-array/
        //.............................T: O(N)
        //.............................S: O(1), in-place
        Random rand = new Random();
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            int randomIndex = rand.nextInt(N - i) + i;
            //swap
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //output
        System.out.println("Array shuffle: " + Arrays.toString(arr));
    }

    public int teemoAttackingAshee(int[] timeSeries, int duration) {
        //..............................T: O(N)
        //..............................S: O(1)
        //https://leetcode.com/problems/teemo-attacking
        //https://leetcode.com/problems/teemo-attacking/solution/
        int n = timeSeries.length;
        if (n == 0) {
            return 0;
        }
        int totalTime = 0;
        for (int i = 0; i < n - 1; i++) {
            totalTime += Math.min(timeSeries[i + 1] - timeSeries[i], duration);
        }
        return totalTime + duration;
    }

    public void minOperationToMakeArrayOfSizeNEqual(int n) {
        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/
        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/discuss/2075557/Java-1-Liner-solution
        int operations = n % 2 == 0 ? (n / 2) * (n / 2) : (n / 2) * (n / 2 + 1);
        System.out.println("Min operation to make array equal: " + operations);
    }

    public int findPivotIndex(int[] nums) {
        //https://leetcode.com/problems/find-pivot-index/
        int arrSum = 0;
        int leftPrefixSum = 0;
        for (int val : nums) {
            arrSum += val;
        }
        //ex: [1,7,3,6,5,6] at index  = 3
        //arrSum = 1 + 7 + 3 + 6 + 5 + 6 = 28
        //leftPrefixSum till this is 1 + 7 + 3 = 11
        //leftPrefixSum == arrSum - leftPrefixSum - arr[i]
        //11 == 28 - 11 - 6 ==> 11 == 11 pivot found
        for (int i = 0; i < nums.length; i++) {
            if (leftPrefixSum == arrSum - leftPrefixSum - nums[i]) {
                return i;
            }
            //prefixSum
            leftPrefixSum += nums[i];
        }
        return -1;
    }

    public void findDistinctDiffArray(int[] nums) {
        //https://leetcode.com/problems/find-the-distinct-difference-array/description/
        int n = nums.length;
        int[] distinctDiff = new int[n];
        Map<Integer, Integer> rightSideUniqueVal = new HashMap<>();
        Set<Integer> leftSideUniqueVal = new HashSet<>();

        //count the freqs of value from nums[], this freq will be considered as
        //whole right side of array and rightSideUniqueVal.size is distinct elements
        //in right side of array that is here, initially is whole nums[]
        for (int val : nums) {
            rightSideUniqueVal.put(val, rightSideUniqueVal.getOrDefault(val, 0) + 1);
        }

        for (int i = 0; i < n; i++) {

            int val = nums[i];

            //decrease the count of val @index i in nums[] from rightSideUniqueVal
            rightSideUniqueVal.put(val, rightSideUniqueVal.getOrDefault(val, 0) - 1);
            //if after decreasing the count this val it becomes '0' or negative
            //remove it from rightSideUniqueVal that would mean that for right
            //side array from [i + 1 to n - 1] this val @index i doesn't exist in
            //right part of array
            if (rightSideUniqueVal.get(val) <= 0) {
                rightSideUniqueVal.remove(val);
            }

            //now that we have removed this val @index i from right side of array
            //that also means this reduced/removed value needs to be added in
            //left side of array
            leftSideUniqueVal.add(val);

            //the sizes of leftSideUniqueVal & rightSideUniqueVal will give the
            //count of unique values in left[0 to i] & right[i + 1 to n - 1] side
            //of array respectively
            distinctDiff[i] = leftSideUniqueVal.size() - rightSideUniqueVal.size();
        }
        //output
        System.out.println("Distinct diff array : " + Arrays.toString(distinctDiff));
    }

    public void maximumSubarraySumWithUniqueElements(int[] arr) {

        //https://leetcode.com/problems/maximum-erasure-value/
        //same as longest substring without repeating character, longestSubstringWithoutRepeatingChar()
        //SLIDING WIINDOW approach
        int n = arr.length;
        Map<Integer, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int maxSum = 0;
        int currSum = 0;
        int maxLenSubarray = 0;
        while (end < n) {
            int val = arr[end];
            freq.putIfAbsent(val, 0);
            //in order to have unique elements, its atmost freq can only be 1
            //if a val is coming more than 1 then we will have to slide the window
            if (freq.get(val) < 1) {
                freq.put(val, freq.get(val) + 1);
                currSum += val;
                maxSum = Math.max(maxSum, currSum);
                maxLenSubarray = Math.max(maxLenSubarray, (end - start + 1));
                end++;
            } else {
                int startVal = arr[start++];
                freq.put(startVal, freq.get(startVal) - 1);
                currSum -= startVal;
            }
        }
        //output
        System.out.println("Maximum subarray sum with unique elements: " + maxSum + " subarray length: " + maxLenSubarray);
    }

    public boolean partitionArrayIntoThreePartsWithEqualSum(int[] arr) {
        //https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/
        //ex arr[a,b,c,l,m,n,p,q,r,s]
        //let say partition be sum1 = [a,b,c], sum2 = [l,m,n], sum3 = [p,q,r,s]
        //we have to prove sum1 == sum2 == sum3
        //total arrSum = sum
        //sum1 + sum2 + sum3 = arrSum
        //if sum1 == sum2 == sum3 then 3 * sum1 = arrSum ==> sum1 = arrSum / 3
        //out total arrSum should be div by 3
        int sumArr = 0;
        for (int val : arr) {
            sumArr += val;
        }

        if (sumArr % 3 != 0) {
            return false;
        }

        int sumPerPartition = sumArr / 3;
        int times = 0;
        int sum = 0;
        for (int val : arr) {
            sum += val;
            if (sum == sumPerPartition * (times + 1)) {
                System.out.println(sum);
                times++;
                if (times == 3) {
                    return true;
                }
            }
        }
        return false;
    }

    public void topKFrequentElements(int[] arr, int k) {
        //https://leetcode.com/problems/top-k-frequent-elements/
        Map<Integer, Long> freq = Arrays.stream(arr).boxed()
                .collect(Collectors.groupingBy(val -> val, Collectors.counting()));
//                or
//                .collect(Collectors.groupingBy(
//                        Function.identity(),
//                        Collectors.counting())
//                );

        PriorityQueue<Integer> minHeap = new PriorityQueue<>(
                (val1, val2) -> (int) (freq.get(val1) - freq.get(val2))
        );

        for (int key : freq.keySet()) {
            minHeap.add(key);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        //output:
        System.out.println("Frequent elements: ");
        //to convert result in minHeap to int[]
        int[] result = minHeap.stream().mapToInt(val -> val).toArray();
        for (int val : result) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    public void maximumSumCircularSubarray(int[] arr) {
        //https://leetcode.com/problems/maximum-sum-circular-subarray
        //explanation: https://youtu.be/uHsPcy3xUT0
        //ex: [-1,5,5,-2] = maxSumSubArr = [5,5] = 10 by kadens algo
        //ex: [5,-1,-2,5] = maxSumSubArr(circular) = 5]..[5 = 10
        //intutions:
        //if sum are to be max in circular array i.e around the ends of array in that
        //case there should exists some min sum in between the max sum end and then
        //totalArrSum - -minSumSubArr = maxSumSubArr(circular)
        //ex: [5,-1,-2,5] = maxSumSubArr(circular) = 5]..[5 = 10
        //totalArrSum = 5 + -1 + -2 + 5 = 7
        //minSumSubArr = ]...minSumSubArr...[ => reverseAllSigns(arr[]) =>
        // [-5,1,2,-5] = 1 + 2 = 3 OR - (1 + 2) = -3
        //maxSumSubArr(circular) = 5]..[5 = 10 => totalArrSum - -minSumSubArr = 7 - -3 = 10
        int totalArrSum = Arrays.stream(arr).sum();
        int maxSumSubArr = kadaneAlgorithm(arr);
        //reverseAllSign(arr)
        int minSumSubArr = kadaneAlgorithm(Arrays.stream(arr).map(val -> -val).toArray());
        int maxSumSubArrCircular = maxSumSubArr > 0
                ? Math.max(maxSumSubArr, (totalArrSum - -minSumSubArr))
                //case where arr[] is all negative then smallest element in arr is maxSumSubArr
                : maxSumSubArr;
        //output
        System.out.println("Max sum circular subarray: " + maxSumSubArrCircular);
    }

    public void maxAbsoluteSumOfAnySubarray(int[] arr) {
        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
        //based on Kaden algo & maximumSumCircularSubarray();
        int maxSumSubArr = kadaneAlgorithm(arr);
        //reverseAllSign(arr)
        //minSum of given arr is maxSum of arr with reverse sign,
        //since on reversing sign it would give a maxSum so to
        //call it a minSum we must reverse the sign on result
        int minSumSubArr = -1 * kadaneAlgorithm(Arrays.stream(arr).map(val -> -val).toArray());
        int maxAbsouluteSumAnySubarray = Math.max(Math.abs(maxSumSubArr), Math.abs(minSumSubArr));
        //output
        System.out.println("Max absolute sum any subarray: " + maxAbsouluteSumAnySubarray);
    }

    public void maxAbsoluteSumOfAnySubarray2(int[] nums) {
        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
        //based on Kaden algo
        /*
        as the logic used in above maxAbsoluteSumOfAnySubarray() method
        we will just calculate curr max sum (typical kaden's algo)
        and also curr min sum in the same kaden's algo logic at the same time

        since we need the max absolute sum subarray
        we can choose max sum from max(maxSum, currMaxSum, abs(currMinSum))

         */
        int currMaxSum = 0;
        int currMinSum = 0;
        int maxAbsouluteSumAnySubarray = nums[0];

        for (int val : nums) {
            currMaxSum = Math.max(currMaxSum + val, val);
            currMinSum = Math.min(currMinSum + val, val);
            maxAbsouluteSumAnySubarray = Math.max(
                    maxAbsouluteSumAnySubarray, Math.max(currMaxSum, Math.abs(currMinSum)));
        }
        //output
        System.out.println("Max absolute sum any subarray: " + maxAbsouluteSumAnySubarray);
    }

    public boolean nonDecreasingArrayWithAtmostOneChange(int[] nums) {
        //https://leetcode.com/problems/non-decreasing-array/
        //explanation: https://youtu.be/RegQckCegDk
        int n = nums.length;
        boolean atMostOneChangeHasDone = false;

        for (int i = 0; i < n - 1; i++) {

            //already increasing ex: 1 2 Or 1 1
            if (nums[i] <= nums[i + 1]) {
                continue;
            }

            //we can modify the array with atmost one element
            //if we have previouly done it, we can't do it second time
            //hence false
            if (atMostOneChangeHasDone) {
                return false;
            }

            //if curr ith value and its next value >= its prev value
            //then convert that ith value to next value nums[i + 1]
            //ex: i == 0 cases like [4, 2], other cond cases like [3,2,5]
            if (i == 0 || nums[i - 1] <= nums[i + 1]) {
                //update nums[i] = 2 with nums[i + 1] = 5
                nums[i] = nums[i + 1];
            } else {
                nums[i + 1] = nums[i];
            }
            atMostOneChangeHasDone = true;
        }
        return true;
    }

    public void twoSum_UnsortedArray(int[] nums, int target) {
        //.........................T: O(N)
        //.........................S: O(N)
        //https://leetcode.com/problems/two-sum/
        Map<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        int[] result = null;
        for (int i = 0; i < n; i++) {

            int diff = target - nums[i];
            if (map.containsKey(diff)) {
                result = new int[]{map.get(diff), i};
                break;
            }
            map.put(nums[i], i);
        }
        //output
        if (result == null) {
            System.out.println("No Two element found that sums equal to target");
        } else {
            System.out.println("Indexes(0-based index) of two element that sums equal to target: "
                    + result[0] + " " + result[1]);
        }
    }

    public void twoSum2_SortedArray(int[] nums, int target) {
        //.........................T: O(N)
        //.........................S: O(1)
        //https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
        //explanation: https://youtu.be/cQ1Oz4ckceM
        //this problem can also be solved with above twoSum_UnsortedArray()
        int n = nums.length;
        int[] result = null;

        int start = 0;
        int end = n - 1;

        while (end > start) {

            int sum = nums[start] + nums[end];
            if (sum == target) {
                result = new int[]{start + 1, end + 1};
                break;
            } else if (sum > target) {
                //curr sum > target because nums[end] > nums[start] as
                //array is sorted so try to reduce larger num from end
                end--;
            } else {
                //curr sum < target because nums[end] > nums[start] as
                //array is sorted so try to increase larger num from start
                start++;
            }
        }

        //output
        if (result == null) {
            System.out.println("No Two element found that sums equal to target");
        } else {
            System.out.println("Indexes(1-based index) of two element that sums equal to target: "
                    + result[0] + " " + result[1]);
        }
    }

    public void threeSum(int[] nums) {
        //https://leetcode.com/problems/3sum/
        //https://www.geeksforgeeks.org/java-program-to-find-all-triplets-with-zero-sum/
        //explanation: https://youtu.be/qJSPYnS35SE
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            //either its the first array element(i == 0)
            //OR current arr element(arr[i]) is not same as prev(arr[i - 1])
            if (i == 0 || nums[i - 1] != nums[i]) {

                int start = i + 1;
                int end = n - 1;
                int target = 0 - nums[i];

                while (end > start) {

                    int sum = nums[start] + nums[end];

                    if (target == sum) {
                        result.add(Arrays.asList(nums[i], nums[start], nums[end]));

                        start++;
                        end--;

                        //move start ptr until we find a next distict num[start]
                        while (end > start && nums[start - 1] == nums[start]) {
                            start++;
                        }

                        //move end ptr until we find a next distict num[end]
                        while (end > start && nums[end + 1] == nums[end]) {
                            end--;
                        }

                    } else if (sum < target) {
                        start++;
                    } else {
                        end--;
                    }
                }
            }
        }

        //output:
        System.out.println("All the triplets that sum to 0: " + result);
    }

    public int threeSumClosest(int[] nums, int target) {
        //https://leetcode.com/problems/3sum-closest/
        //based on threeSum()
        int n = nums.length;
        Arrays.sort(nums);
        int closestDiff = Integer.MAX_VALUE;
        int resultSum = 0;

        for (int i = 0; i < n - 2; i++) {
            int start = i + 1;
            int end = n - 1;

            while (end > start) {

                int sumABC = nums[i] + nums[start] + nums[end];

                int currDiff = Math.abs(target - sumABC);

                if (currDiff == 0) {
                    return sumABC;
                }

                if (currDiff < closestDiff) {
                    closestDiff = currDiff;
                    resultSum = sumABC;
                }

                if (sumABC > target) {
                    end--;
                } else {
                    start++;
                }
            }
        }
        return resultSum;
    }

    private void fourSum_twoSumSortedApproach(
            int[] nums, long target, int index, List<Integer> currList, List<List<Integer>> result) {

        int n = nums.length;
        int start = index;
        int end = n - 1;
        while (end > start) {
            long currSum = nums[start] + nums[end];
            if (currSum == target) {
                List<Integer> kSumList = new ArrayList<>(currList);
                kSumList.add(nums[start]);
                kSumList.add(nums[end]);
                result.add(kSumList);
                start++;
                while (start < end && nums[start] == nums[start - 1]) {
                    start++;
                }
            } else if (currSum > target) {
                end--;
            } else {
                start++;
            }
        }
    }

    private void fourSum_CombinationSum2Approach(
            int[] nums, int target, int index, int kSum, List<Integer> currList, List<List<Integer>> result) {
        if (kSum == 2) {
            fourSum_twoSumSortedApproach(nums, target, index, currList, result);
            return;
        }

        for (int i = index; i < nums.length; i++) {
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }
            currList.add(nums[i]);
            fourSum_CombinationSum2Approach(
                    nums, target - nums[i], i + 1, kSum - 1, new ArrayList<>(currList), result);
            currList.remove(currList.size() - 1);
        }
    }

    public void fourSum(int[] nums, int target) {
        //https://leetcode.com/problems/4sum/
        //explanation: https://youtu.be/EYeR-_1NRlQ
        //This approach is generic approach for K-sum (4Sum, 5sum...)
        //based on combination_2 & twoSum-Sorted
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int kSum = 4;
        fourSum_CombinationSum2Approach(nums, target, 0, kSum, new ArrayList<>(), result);
        //output
        System.out.println("Four sum/ Generic KSum: " + result);
    }

    public void fourSum_WithThreeSumApproach(int[] nums, int target) {
        //.....................T: O(N^3)
        //https://leetcode.com/problems/4sum/
        //explanation: https://youtu.be/eD95WRfh81c
        //This approach is similar to 3 sum
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int n = nums.length;
        for (int i = 0; i < n; i++) {

            //skip, if the curr val at i-th is same as val at (i - 1)-th index
            //to avoid generating same quad nums for target
            if (i > 0 && nums[i - 1] == nums[i]) {
                continue;
            }

            //nums[j] will be considered after the i-th index nums
            for (int j = i + 1; j < n; j++) {

                //skip, if the curr val at j-th is same as val at (j - 1)-th index
                //to avoid generating same quad nums for target
                if (j > i + 1 && nums[j - 1] == nums[j]) {
                    continue;
                }

                long newTarget = (long) target - (long) (nums[i] + nums[j]);

                int start = j + 1;
                int end = n - 1;

                while (end > start) {

                    long sum = nums[start] + nums[end];

                    if (sum == newTarget) {

                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));

                        start++;
                        end--;

                        //move start ptr until we find a next distict num[start]
                        while (end > start && nums[start - 1] == nums[start]) {
                            start++;
                        }

                        //move end ptr until we find a next distict num[end]
                        while (end > start && nums[end + 1] == nums[end]) {
                            end--;
                        }
                    } else if (sum < newTarget) {
                        start++;
                    } else {
                        end--;
                    }
                }
            }
        }
        //output
        System.out.println("Four sum (with 3sum approach): " + result);
    }

    public void fourSumTwo(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        //..................T: O(N^2), N is length of given arrays
        //..................S: O(N^2), N is length of given arrays, since we are
        //making sumsMap which we are filling with curr sum of n * n elements from
        //nums3 and nums4, in worst case each of the n * n curr sums will be unique
        //https://leetcode.com/problems/4sum-ii/description/
        /*
        given: nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
        alter this equation as,
        nums1[i] + nums2[j] == -(nums3[k] + nums4[l])

        using k & l nested loop, put the sums of nums3 and nums4 into sums map
        in its negative form as per the alter equation

        using i & j nested loop, check if currSum = nums1[i] + nums2[j] is present
        in sums map and count the freq of these sums as tuples

         */
        //all the given arrays are of same length 'n'
        int n = nums1.length;
        Map<Integer, Integer> sumsMap = new HashMap<>();

        for (int k = 0; k < n; k++) {
            for (int l = 0; l < n; l++) {
                int currSum = -(nums3[k] + nums4[l]);
                sumsMap.put(currSum, sumsMap.getOrDefault(currSum, 0) + 1);
            }
        }

        int tuples = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int currSum = (nums1[i] + nums2[j]);
                tuples += sumsMap.getOrDefault(currSum, 0);
            }
        }

        //output
        System.out.println("Four sum two : " + tuples);
    }

    public void maximumLengthOfSubarrayWithPositiveProduct(int[] nums) {
        //https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/
        int n = nums.length;
        int positiveCount = 0;
        int negativeCount = 0;
        int temp;
        int length = 0;

        for (int val : nums) {

            int anyCase = val == 0 ? 0 : val < 0 ? -1 : 1;
            switch (anyCase) {
                case 0:
                    //reset
                    positiveCount = 0;
                    negativeCount = 0;
                    break;
                case 1:
                    positiveCount++;
                    if (negativeCount != 0) {
                        negativeCount++;
                    }
                    break;
                case -1:
                    temp = positiveCount;
                    positiveCount = negativeCount > 0 ? negativeCount + 1 : 0;
                    negativeCount = temp + 1;
                    break;
            }
            length = Math.max(length, positiveCount);
        }
        //output
        System.out.println("max length of subarray with positive product: " + length);
    }

    public void minimumIntervalToIncludeEachQuery(int[][] intervals, int[] queries) {
        //https://leetcode.com/problems/minimum-interval-to-include-each-query/
        //explanation: https://youtu.be/5hQ5WWW5awQ
        class Node {

            int dist;
            int rightEnd;

            public Node(int dist, int rightEnd) {
                this.dist = dist;
                this.rightEnd = rightEnd;
            }
        }

        //indexes
        int LEFT = 0;
        int RIGHT = 1;

        int intervalLen = intervals.length;
        int queriesLen = queries.length;

        int[] result = new int[queriesLen];

        //<queries[i], List(i)>
        Map<Integer, List<Integer>> queryIndexMap = new HashMap<>();

        for (int i = 0; i < queriesLen; i++) {
            queryIndexMap.putIfAbsent(queries[i], new ArrayList<>());
            queryIndexMap.get(queries[i]).add(i);
        }

        Arrays.sort(queries);
        Arrays.sort(intervals, (a, b) -> a[LEFT] - b[LEFT]);

        PriorityQueue<Node> minHeapDist = new PriorityQueue<>((n1, n2) -> n1.dist - n2.dist);
        int intervalIndex = 0;

        for (int query : queries) {

            //put in all those intervals whose left value is less than equal to query
            //i.e, left <= queries[j]
            while (intervalIndex < intervalLen && intervals[intervalIndex][LEFT] <= query) {
                int left = intervals[intervalIndex][LEFT];
                int right = intervals[intervalIndex][RIGHT];

                int dist = right - left + 1;
                minHeapDist.add(new Node(dist, right));
                intervalIndex++;
            }

            //here in the below loop we will remove all those intervals from heap where
            //query is greater than right part, because we want query to fall under
            //left <= query <= right
            //i.e, queries[j] <= right
            while (!minHeapDist.isEmpty() && minHeapDist.peek().rightEnd < query) {
                minHeapDist.poll();
            }

            //get the first occurring index(i.e, 0) of curr query
            int queryIndex = queryIndexMap.get(query).remove(0);
            if (queryIndexMap.get(query).isEmpty()) {
                queryIndexMap.remove(query);
            }
            result[queryIndex] = minHeapDist.isEmpty() ? -1 : minHeapDist.peek().dist;
        }
        //output
        for (int i = 0; i < queriesLen; i++) {
            System.out.println("For query : " + queries[i] + " dist : " + result[i]);
        }
    }

    public void candyDistributionToNStudent(int[] ratings) {
        //.........................T: O(N)
        //.........................S: O(N + N), left & right neighbour
        //https://leetcode.com/problems/candy/
        //explanation: https://youtu.be/h6_lIwZYHQw
        /*
         rule:
         You are giving candies to these children subjected to the following requirements:
         1. Each child must have at least one candy.
         2. Children with a higher rating get more candies than their neighbors.
         */
        int n = ratings.length;
        int[] leftNeighbour = new int[n];
        int[] rightNeighbour = new int[n];
        int candiesNeeded = 0;
        //atleast 1 candy is given to each student
        leftNeighbour[0] = 1;
        for (int i = 1; i < n; i++) {
            //if rating of curr ith student is greater than its prev left student
            //that curr student should have 1 candy extra than its prev left student
            //otherwise atleast 1 candy should be given
            leftNeighbour[i] = ratings[i] > ratings[i - 1]
                    ? leftNeighbour[i - 1] + 1
                    : 1;
        }
        //atleast 1 candy is given to each student
        rightNeighbour[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            //if rating of curr ith student is greater than its next right student
            //that curr student should have 1 candy extra than its next right student
            //otherwise atleast 1 candy should be given
            rightNeighbour[i] = ratings[i] > ratings[i + 1]
                    ? rightNeighbour[i + 1] + 1
                    : 1;
        }

        for (int i = 0; i < n; i++) {
            //add all the max candies req by each ith student
            candiesNeeded += Math.max(leftNeighbour[i], rightNeighbour[i]);
        }
        //output
        System.out.println("Candies required to be distributed: " + candiesNeeded);
    }

    public void candyDistributionToNStudent2(int[] ratings) {
        //.........................T: O(N)
        //.........................S: O(N), candies
        //OPTIMISED
        //https://leetcode.com/problems/candy/
        //https://leetcode.com/problems/candy/solution/
        //explanation: https://youtu.be/h6_lIwZYHQw
        /*
         rule:
         You are giving candies to these children subjected to the following requirements:
         1. Each child must have at least one candy.
         2. Children with a higher rating get more candies than their neighbors.
         */
        int n = ratings.length;
        int[] candies = new int[n];
        //atleast candy is given to each student
        Arrays.fill(candies, 1);

        for (int i = 1; i < n; i++) {
            //if rating of curr ith student is greater than its prev left student
            //that curr student should have 1 candy extra than its prev left student
            //otherwise atleast 1 candy should be given
            candies[i] = ratings[i] > ratings[i - 1]
                    ? candies[i - 1] + 1
                    : 1;
        }

        int candiesNeeded = candies[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            //if rating of curr ith student is greater than its next right student
            //that curr student should have 1 candy extra than its next right student
            //otherwise atleast 1 candy should be given
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
            candiesNeeded += candies[i];
        }
        //output
        System.out.println("Candies required to be distributed: " + candiesNeeded);
    }

    public void findTriangularSumOfArray(int[] nums) {
        //https://leetcode.com/problems/find-triangular-sum-of-an-array/
        int n = nums.length;
        int index = 1;
        while (n > 1) {
            while (index < n) {
                int sum = nums[index - 1] + nums[index];
                nums[index - 1] = sum % 10;
                index++;
            }
            index = 1;
            n--;
        }
        //output
        System.out.println("Triangular sum of array: " + nums[0]);
    }

    public boolean has132Pattern(int[] nums) {
        //https://leetcode.com/problems/132-pattern/
        //explanation: https://youtu.be/q5ANAl8Z458
        /*
         a 132 pattern is a subsequence of three integers
         nums[i], nums[j] and nums[k]
         such that i < j < k and nums[i] < nums[k] < nums[j].
         */
        class Pair {

            int numJ;
            int numI;

            public Pair(int numJ, int numI) {
                this.numJ = numJ;
                this.numI = numI;
            }

        }

        int n = nums.length;
        //as per the question the 132 pattern should be like
        //nums[i] < nums[k] < nums[j]
        //where the num[i] is always smaller than both nums[k] & nums[j]
        //initially currMin = nums[i] = numI
        int currMin = nums[0];
        Stack<Pair> stack = new Stack();

        for (int k = 1; k < n; k++) {

            int numK = nums[k];
            //this loop will remove all the numJ that is smaller or equal to
            //curr numK as we need a pattern where numK < numJ so when
            //numJ becomes strictly greater than numK it will break
            while (!stack.isEmpty() && stack.peek().numJ <= numK) {
                stack.pop();
            }
            //now we have figured out numsK < numsJ from above loop
            //now, we need to check that numK should be greater than numI
            //if that is true we can return true as we have the "132" pattern
            if (!stack.isEmpty() && stack.peek().numI < numK) {
                return true;
            }
            //push the curr numK which will be the numJ for further k-th iteration
            //and currMin will be the numI
            stack.push(new Pair(numK, currMin));
            currMin = Math.min(currMin, numK);
        }
        return false;
    }

    public void amountToPaintTheArea(int[][] areaPoints) {
        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
        //https://algo.monster/liteproblems/2158
        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
        //explanation: https://www.youtube.com/watch?j=cHYjuMPTHt4
        //<start, end>
        Map<Integer, Integer> paintMap = new HashMap<>();
        List<Integer> result = new ArrayList<>();
        for (int[] point : areaPoints) {

            int start = point[0];
            int end = point[1];

            int cost = 0;
            //for each start to end value, paint each unit sequentially
            //and calculate the cost per unit
            //ex: [4, 10] = seq unit cost = start = 4, cost = 1
            //seq unit cost = start = 5, cost = 2
            //seq unit cost = start = 6, cost = 3 until seq unit = start = 9
            //at the same time add these seq unit and given end in map
            //because in future any other point[] comes that tries to paint the same area
            //we can easily find that and map.value will give the end value which is previous
            //area painted
            while (start < end) {
                if (paintMap.containsKey(start)) {
                    //if curr start is already pained previously
                    //it value = end will tell us upto which point it was covered that time
                    //ex: [4, 10] in between seq unit 7 was also covered map[7 = 10]
                    //now when another point[7, 13] will come it will first check 7 is already painted or not
                    //here it was painted when point[4, 10] so will get the end value
                    //it painted which was map[7] = 10 that means from this 10 we might need to paint
                    start = paintMap.get(start);
                    continue;
                }
                //cost of painting per unit area (start to seq)
                cost++;
                paintMap.put(start, end);
                start++;
            }
            result.add(cost);
        }
        //output
        System.out.println("Total cost to paint the given area points effectively : " + result);
    }

    public void amountToPaintTheArea2(int[][] areaPoints) {
        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
        //https://algo.monster/liteproblems/2158
        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
        //explanation: https://www.youtube.com/watch?j=cHYjuMPTHt4

        List<Integer> result = new ArrayList<>();

        int FENCE_CONSTRAINT = 50000;

        TreeSet<Integer> unpaintedFences = new TreeSet<>();
        //add all the intial fences that are unpainted
        for (int fence = 0; fence <= FENCE_CONSTRAINT; fence++) {
            unpaintedFences.add(fence);
        }

        //iterate through all the areaPoints[][]
        for (int[] point : areaPoints) {

            int start = point[0];
            int end = point[1];
            int cost = 0;

            //for all the unpainted fence from [start to end - 1] will try to paint
            //it and remove it from unpainted fences store
            while (true) {

                //treeset.ceiling(val) will give the next closest-greater or equal
                //value than the given 'val', if not present then null
                int nextUnpaintedFence = unpaintedFences.ceiling(start);

                //if we have reached the end fence then break
                if (nextUnpaintedFence >= end) {
                    break;
                }

                //add cost to paint the curr unpainted fence
                cost++;

                //we got an unpainted fence and painted it will cost += 1 and
                //we will remove it from unpainted fences
                unpaintedFences.remove(nextUnpaintedFence);
            }
            result.add(cost);
        }
        //output
        System.out.println("Total cost to paint the given area points effectively (TreeSet) : " + result);
    }

    public void mThElementAfterKArrayRotation(int[] arr, int k, int m) {
        //https://www.geeksforgeeks.org/cpp-program-to-find-the-mth-element-of-the-array-after-k-left-rotations/
        int n = arr.length;
        k %= n;
        int mthIndex = (k + m - 1) % n;
        //output
        System.out.println("Mth element after k Array rtation : " + arr[mthIndex]);
    }

    public void maximizeSumAfterRemovingValleys(int[] mountains) {
        //https://www.geeksforgeeks.org/maximize-sum-of-given-array-after-removing-valleys/
        int n = mountains.length;
        int[] smallerInLeft = new int[n];
        int[] smallerInRight = new int[n];

        Stack<Integer> stack = new Stack<>();

        //smller to left
        for (int i = 0; i < n; i++) {
            int val = mountains[i];
            while (!stack.isEmpty()
                    && mountains[stack.peek()] >= val) {
                stack.pop();
            }

            if (stack.isEmpty()) {
                //i + 1 == len upto ith element
                //like if arr supposed to [1,1,1] len = 3 and val = 1 then len * val = 3
                smallerInLeft[i] = (i + 1) * val;
            } else {
                int smallIndex = stack.peek();
                smallerInLeft[i] = smallerInLeft[smallIndex] + (i - smallIndex) * val;
            }
            stack.push(i);
        }

        stack.clear();

        //smller in right
        for (int i = n - 1; i >= 0; i--) {
            int val = mountains[i];
            while (!stack.isEmpty()
                    && mountains[stack.peek()] >= val) {
                stack.pop();
            }

            if (stack.isEmpty()) {
                //n - i is same as len upto ith element
                smallerInRight[i] = (n - i) * val;
            } else {
                int smallIndex = stack.peek();
                smallerInRight[i] = smallerInRight[smallIndex] + (smallIndex - i) * val;
            }
            stack.push(i);
        }
        int maxSum = 0;
        for (int i = 0; i < n; i++) {
            int currSum = smallerInLeft[i] + smallerInRight[i] - mountains[i];
            maxSum = Math.max(maxSum, currSum);
        }
        //output:
        System.out.println("Max sum after removing valleys: " + maxSum);
    }

    public void numberOfVisiblePeopleInQueue(int[] heights) {
        //https://leetcode.com/problems/number-of-visible-people-in-a-queue/
        //based on nextGreaterElementInRight
        /*
        heights[] = [10,6,8,5,11,9]
        n = 6
        stack = {}
        visible[]

        ##1
        i = 5, height[i] = 9
        while(!stack.isEmpty) FAIL

        if(!stack.isEmpty) FAIL

        if(stack.isEmpty) YES
        ==> stack.push(9) ==> PEEK -> {9}

        visible[5] = 0

        ##2
        i = 4, height[i] = 11
        while(!stack.isEmpty && stack.peek <= 11) YES
        ==> PEEK = 9 <= 11
        ==> visible[i]++ ==> person(11) can see person(9) hence visible[i]++
        ==> stack.pop ==> {}
        ==> visible[4] = 1

        if(!stack.isEmpty) FAIL

        if(stack.isEmpty) YES
        ==> stack.push(11) ==> PEEK -> {11}

        visible[4] = 1

        ##3
        i = 3, height[i] = 5
        while(!stack.isEmpty && stack.peek <= 5) FAIL
        ==> PEEK = 11 <= 5, person(5) can't see beyond person(11)

        if(!stack.isEmpty) TRUE
        ==> person(5) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++
        ==> visible[3] = 1

        if(stack.isEmpty || stack.peek != 5) YES
        ==> 11 != 5
        ==> stack.push(5) ==> PEEK -> {5, 11}

        visible[3] = 1

        ##4
        i = 2, height[i] = 8
        while(!stack.isEmpty && stack.peek <= 8) YES
        ==> PEEK = 5 <= 8
        ==> visible[i]++ ==> person(8) can see persom(5) hence visible[i]++
        ==> stack.pop ==> {11}
        ==> visible[2] = 1

        ==> PEEK = 11 <= 8
        ==> visible[i]++ ==> person(8) can't see beyond person(11)

        if(!stack.isEmpty) TRUE
        ==> person(8) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++
        ==> visible[2] = 2

        if(stack.isEmpty || stack.peek != 8) YES
        ==> 11 != 8
        ==> stack.push(5) ==> PEEK -> {8, 11}

        visible[2] = 2

        ##5
        i = 1, height[i] = 6
        while(!stack.isEmpty && stack.peek <= 6) FAIL
        ==> PEEK = 8 <= 6, person(6) can't see beyond person(8)

        if(!stack.isEmpty) TRUE
        ==> person(6) can't see beyond person(8) BUT can see person(8)
        ==> visible[i]++
        ==> visible[1] = 1

        if(stack.isEmpty || stack.peek != 6) YES
        ==> 8 != 6
        ==> stack.push(5) ==> PEEK -> {6, 8, 11}

        visible[1] = 1

        ##6
        i = 0, height[i] = 10
        while(!stack.isEmpty && stack.peek <= 10) FAIL
        ==> PEEK = 6 <= 10
        ==> visible[i]++ ==> person(10) can see persom(6) hence visible[i]++
        ==> stack.pop ==> {8, 11}
        ==> visible[0] = 1

        ==> PEEK = 8 <= 10
        ==> visible[i]++ ==> person(10) can see persom(8) hence visible[i]++
        ==> stack.pop ==> {11}
        ==> visible[0] = 2

        ==> PEEK = 11 <= 10, person(10) can't see beyond person(11)

        if(!stack.isEmpty) TRUE
        ==> person(10) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++
        ==> visible[0] = 3

        if(stack.isEmpty || stack.peek != 10) YES
        ==> 11 != 10
        ==> stack.push(10) ==> PEEK -> {10, 11}

        visible[0] = 3

         */
        int n = heights.length;
        Stack<Integer> stack = new Stack<>();
        int[] personVisible = new int[n];

        for (int i = n - 1; i >= 0; i--) {
            //this while cond allow heights[i] person to check all those
            //person who are smaller to itself and count them
            while (!stack.isEmpty() && stack.peek() < heights[i]) {
                personVisible[i]++;
                stack.pop();
            }

            //this cond is for the case where height[i] < height[j] where  i < j
            //greater height[j] person is still visible to height[i] person
            if (!stack.isEmpty()) {
                personVisible[i]++;
            }
            if (stack.isEmpty() || heights[i] != stack.peek()) {
                stack.push(heights[i]);
            }
        }
        //output
        for (int val : personVisible) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private boolean splitArrayInLargestSum_CanSplit(int[] nums, int possibleSubarraySum, int m) {

        int subarrays = 1;
        int currSubarraySum = 0;

        for (int val : nums) {

            currSubarraySum += val;

            if (currSubarraySum > possibleSubarraySum) {

                currSubarraySum = val;
                subarrays++;
            }
        }

        return subarrays <= m;
    }

    public void splitArrayInLargestSum(int[] nums, int m) {
        //https://leetcode.com/problems/split-array-largest-sum/
        //explanation: https://youtu.be/YUF3_eBdzsk | https://youtu.be/bcAwHkL7A3A
        //based on BINARY SEARCH
        /*
         intution:
         1. if m = 1 that means, a single subarray which means the whole array
         is that subarray where the largest sum possible would be sum of arr

         2. if m = arr.length that means, each element of arr is itself a subarray
         (and no subarray is possible m > arr.length) in this case the largest
         sum of sub array would be the max num of arr
         Now if we need to split the arr in m subarrays with largest sum
         that could be formed within range of m >= 1 && m <= n where largest sum would
         lie in range of [maxNum, arrSum]

         ex: arr [7,2,5,10,8] m = 2, maxNum = 10, arrSum = 32

         1. partition (m = 2 subarrays)= [7] | [2,5,10,8] sum = 7 | 25 largest = 25
         2. partition (m = 2 subarrays)= [7,2] | [5,10,8] sum = 9 | 23 largest = 23
         3. partition (m = 2 subarrays)= [7,2,5] | [10,8] sum = 14 | 18 largest = 18
         3. partition (m = 2 subarrays)= [7,2,5,10] | [8] sum = 24 | 8 largest = 24

         these are the possible largest sums we will get if we divide the arr
         into m (non-empty subarrays). From these we need the min largest sum which is 18
         see all these largest sums are in the range of [maxNum, arrSum]
         */
        int maxNum = nums[0];
        int arrSum = 0;
        for (int val : nums) {
            maxNum = Math.max(maxNum, val);
            arrSum += val;
        }

        //minimizing the largest sum would lie between [maxNum, arrSum]
        //lower bound = max num in nums[] in case each element is a subarray
        //when m = nums.length then the largest possible subarray sum is the
        //max num among all values
        int start = maxNum;

        //upper bound = sum of values in nums[] in case there is one partition
        //that is the nums[] array itself when m = 1 then the largest possible
        //subarray sum is sum of values in nums[]
        int end = arrSum;

        int minimizedLargestSubarraySum = 0;

        while (end >= start) {

            //'mid' represent a possible subarray sum, meaning, we should be able
            //to generate subarrays whose value sum should be 'atmost mid'
            int mid = start + (end - start) / 2;

            //canSplit() validate the 'mid' as a valid subarray sum, such that
            //the number of subarrays generated with sum 'atmost mid', should not
            //be more than given partition 'm' as we need to divide the nums[]
            //into 'm' subarray partitions only not more than that
            if (splitArrayInLargestSum_CanSplit(nums, mid, m)) {

                minimizedLargestSubarraySum = mid;
                //if canSplit() return true that means subarray sum 'mid' will
                //generate 'atmost m' subarray partitions but we still need to
                //minimize the subarray sum so we need to move search space to
                //left-side to have lower 'mid' as subarray sum
                end = mid - 1;
            } else {
                //if canSplit() return false subarray sum 'mid' is not valid,
                //it is generating more subarrays that given 'm', so move to
                //right-side to have higher 'mid' as subarray sum
                start = mid + 1;
            }
        }

        //output
        System.out.println("Minimized the largest sum among m subarrays: " + minimizedLargestSubarraySum);
    }

    private boolean shipWeightsWithinGivenDays_CheckDays(int[] weights, int possibleWeightCapacity, int days) {

        int daysTakenToTransposrtAllItems = 1;

        int currAddedItemsWeightSum = 0;

        for (int weight : weights) {

            currAddedItemsWeightSum += weight;

            //another item of 'weight' added to ship, has incr more weight than
            //the assumed ship's weight capacity so ship needs to transport this
            //item & next items on day after
            if (currAddedItemsWeightSum > possibleWeightCapacity) {
                //require another day to transport item & next items
                daysTakenToTransposrtAllItems++;
                //item of 'weight' to be picked first on next day
                currAddedItemsWeightSum = weight;
            }
        }

        //days taken to transport all the given weights[] are within 'days'
        //means 'possibleWeightCapacity' is valid weight
        return daysTakenToTransposrtAllItems <= days;
    }

    public void shipWeightsWithinGivenDays(int[] weights, int days) {
        //https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
        //explanation: https://youtu.be/YUF3_eBdzsk | https://youtu.be/bcAwHkL7A3A
        //based on BINARY SEARCH, splitArrayInLargestSum()
        int totalWeight = 0;
        int maxShipmentWeight = 0;

        for (int weight : weights) {
            totalWeight += weight;
            maxShipmentWeight = Math.max(maxShipmentWeight, weight);
        }

        //lower bound = max weight, in case if we are given days == weight.length
        //meaning we can transport each shipment on every single day that means the
        //least weight capacity of the ship should be the max weight of items in weights[]
        //ex: weights = [1,2,3,4,5,6,7,8,9,10], assume days = weights.length = 10
        //on each day transport each item sequentially,
        //day1: 1, day2: 2, day3: 3 .... so on day10: 10
        //if we say least weight capacity of ship should be weight(1) then from
        //day2 to day10 the same ship will not able to transport any other weight
        //using this intuition, lower bound is max weight from weight[]
        int start = maxShipmentWeight;

        //upper bound = totalWeight, in case if we were given day = 1 meaning
        //within just 1 day we have to transport all the weights, then in that
        //situation the least weight capacity of ship should be able to handle
        //all these given weights that is sum of all the weights given
        int end = totalWeight;

        int leastWeightCapacityOfShip = -1;

        while (end >= start) {

            //'mid', represent the possible weight capacity of ship where we are
            //assuming that ship should transport items of total weight of 'atmost
            //mid', in that case all these weights can be transported within 'days'
            int mid = start + (end - start) / 2;

            //here, we will validate that if weight capacity of ship as 'mid' then
            //all the weights transported within 'days'
            if (shipWeightsWithinGivenDays_CheckDays(weights, mid, days)) {

                leastWeightCapacityOfShip = mid;
                //here, 'mid' is valid weight capacity of ship with which we are
                //able to transport all the weights within 'days', but we still
                //need to find the least possible weight capacity of ship, so
                //we move search space to left-side to have lower 'mid' weight
                //capacity
                end = mid - 1;
            } else {
                //here, 'mid' is not valid weight capacity of ship meaning if
                //this were to be ship's weight capacity then the days required
                //to transport all the weights are more than 'days', so we need
                //find a higher weight capacity, move search space to right-side
                //to have 'mid' as higher weigh capacity
                start = mid + 1;
            }
        }

        //output:
        System.out.println("Capacity of ship required to ship all weights in given days: " + leastWeightCapacityOfShip);
    }

    private boolean minimizePageAllocationsToStudents_CanAllocate(
            int[] pages, int maxPageAllocation, int students) {

        int studentsReq = 1;
        int currPagesSum = 0;
        for (int page : pages) {
            currPagesSum += page;
            if (currPagesSum > maxPageAllocation) {
                currPagesSum = page;
                studentsReq++;
            }
        }
        return studentsReq <= students;
    }

    public void minimizePageAllocationsToStudents(int[] pages, int students) {
        //............................T: O(N + N.Log(RANGE)), N = length of pages array
        //RANGE is [min(pages[i]) to sum(pages[i])]
        //https://www.interviewbit.com/problems/allocate-books/
        //explanation: https://youtu.be/gYmWHvRHu-s
        //based on splitArrayInLargestSum()
        int minPage = pages[0];
        int totalPages = 0;
        for (int page : pages) {
            minPage = Math.min(minPage, page);
            totalPages += page;
        }

        //minimize the page allocations to student will lie in range
        //[minPage to totalPages]
        //overall T: O(N * Log(RANGE))
        //Binary search: T; O(Log(RANGE))
        int startPage = minPage;
        int endPage = totalPages;
        int minimizesPageAllocation = totalPages;
        while (endPage > startPage) {
            int midPage = startPage + (endPage - startPage) / 2;
            //T: O(N), at worst the below method will check for N pages in pages[]
            //whether we can allocate all of the pages to given student or not
            if (minimizePageAllocationsToStudents_CanAllocate(pages, midPage, students)) {
                minimizesPageAllocation = midPage;
                endPage = midPage - 1;
            } else {
                startPage = midPage + 1;
            }
        }
        //output
        System.out.println("Minimized pages allocation to students: " + minimizesPageAllocation);
    }

    private boolean kokoEatingBananas_CanEat(
            int[] piles, long currBananaPerHour, long maxHoursAllowed) {

        long hourTaken = 0;

        for (int pile : piles) {

            //given the number of bananas curr pile have i.e, pile
            //and the speed (banana-per-hour) meaning koko can eat 'currBananaPerHour'
            //bananas in an hour.
            //so here, we check how many hours are required to finish 'pile' of bananas
            //ex: pile = 6, currBananaPerHour = 4
            //in 1 hour = 4 banana can be consumed out of 6 and left over are (6 - 4 = 2)
            //now we need another hour to consume the left over bananas(==> 2) and after
            //that the curr pile will be completely finished hourTaken = 1 + 1 = 2
            //here, 6 / 4 ==> 1 this is the minimum hour required
            //and remainder/left-over is 2 which requires another hour
            hourTaken += pile / currBananaPerHour;

            //here, with % oprn we check if there are any remainders/left-over
            //basically 6 % 4 == 2 != 0 which means same as above that we need
            //an extra hour
            if (pile % currBananaPerHour != 0) {
                hourTaken += 1;
            }
        }

        //if the hours taken to finish all the bananas in the piles[] is still
        //within the given 'maxHoursAllowed' limit that means 'currBananaPerHour'
        //is a valid banana-per-hour consumption speed
        return hourTaken <= maxHoursAllowed;
    }

    public void kokoEatingBananas(int[] piles, int hour) {
        //https://leetcode.com/problems/koko-eating-bananas/
        //https://leetcode.com/problems/koko-eating-bananas/discuss/1691271/similar-to-allocate-pages-of-books

        //if the 'hour' is given 1 meaning koko has to finish all the bananas in
        //the piles[] within this 1 hour then koko must have banana-per-hour equal
        //to the total bananas in the piles ==> totalBananas
        long totalBananas = 0;
        for (int pile : piles) {
            totalBananas += pile;
        }

        //lower bound = 1, meaning koko can have least banana-per-hour equal to 1
        long start = 1;
        //upper bound = totalBananas, meaning koko can have max banana-per-hour
        //equal to totalBananas
        long end = totalBananas;

        long bananaPerHour = 0;

        while (end >= start) {

            //'mid' represent tha banana-per-hour consumption by koko, means eating
            //'mid' amount of banana/hour from the each piles[index]
            long mid = start + (end - start) / 2;

            //validate 'mid' as banana-per-hour consumption, means with this 'mid'
            //speed koko can finish all the bananas in piles[] within 'hour'
            if (kokoEatingBananas_CanEat(piles, mid, hour)) {

                bananaPerHour = mid;
                //here, 'mid' is a valid speed but as per requirement we need to
                //minimize this number so move to left-side of banana-per-hour
                //to have lower 'mid' as speed value
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        //output
        System.out.println("Minimized speed in koko can eat all the bananas within given hours: " + bananaPerHour);
    }

    public void minTimeToCompleteTrips(int[] time, int totalTrips) {
        //https://leetcode.com/problems/minimum-time-to-complete-trips/description/
        //based BINARY SEARCH
        //assumming all buses can complete atleast totalTrips in just 1 unit of
        //time hence the lower bound is 1
        long start = 1;
        //max time when all buses can complete atleast totalTrips in just 1 unit
        //of time hence the upper bound is 100000000000000L
        long end = 100000000000000L;

        long minTimeToCompleteTotalTrips = 0;

        //perform binary search between the lower & upper bound
        //to find a time where it is possible for all the buses to complete atleast
        //'totalTrips'
        while (end >= start) {

            //mid represents a unit of time, where it is assumed that within 'mid'
            //time all the buses can complete 'totalTrips'
            long mid = start + (end - start) / 2;

            long tripsCompleted = 0;

            //here we will calculate trips completed by each bus and add up
            //'tripsCompleted' as total trips completed by all the buses within
            //'mid' time
            //calculation here is simple math,
            //if one bus takes 'oneTripCompletionTime' time to complete 1 trip
            //then how many trips will it complete in given 'mid' time?
            //==> total_alloted_time / time_to_complete_one_trip
            for (int oneTripCompletionTime : time) {
                //within 'mid' time each bus will complete certain number of trips
                //that will be added up as 'tripsCompleted'
                tripsCompleted += mid / oneTripCompletionTime;
            }

            //now, we were assuming that within 'mid' time, all the buses will
            //complete 'atleast totalTrips'
            //if(tripsCompleted >= totalTrips) means yes, within 'mid' time
            //tripsComplete is more or equal than given 'totalTrips' meaning
            //'mid' is a valid time
            if (tripsCompleted >= totalTrips) {

                //hence 'mid' is a valid time, so we will save it
                minTimeToCompleteTotalTrips = mid;

                //but questions asks to minimize the time, so it is sure that
                //within 'mid' time all trips can be completed meaning for higher
                //mid values also trip will be completed, so to minimize 'mid'
                //time, move the search space to left-side
                end = mid - 1;

            } else {
                //above 'mid' time was not a valid time within which all the trips
                //can be completed, so we need to find a little higher 'mid' time
                //so move search space to right-side
                start = mid + 1;
            }
        }
        //output
        System.out.println("Min time to compelete trips: " + minTimeToCompleteTotalTrips);
    }

    private boolean minSpeedToArriveOnTime_IsValid(int[] dist, double speed, double hour) {

        int n = dist.length;
        double totalTime = 0.0;

        for (int i = 0; i < n; i++) {

            double currTrainTime = (double) dist[i] / speed;
            //as per questions, 'Each train can only depart at an integer hour,
            //so you may need to wait in between each train ride.'
            //if the curr train time is float value, it should be rounded to next
            //interger except for the last train(==> i == n - 1) bcause we don't
            //have any train after this i-th train and there is not wait time to
            //consider hence we can consider the float value
            totalTime += (i == n - 1) ? currTrainTime : Math.ceil(currTrainTime);

            if (totalTime > hour) {
                return false;
            }

        }
        return totalTime <= hour;
    }

    public void minSpeedToArriveOnTime(int[] dist, double hour) {
        //https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/
        //based on BINARY SEARCH
        /*

        intuition behind using binary search:

        naively or with brute force approach, we can try all possible speed in
        linear way and try to check the validity of the 'speed' such that time
        taken for all n trains is within 'hour', BUT this linear search is costly
        we first try on all possible speeds then internally we also check if that
        speed is valid or not

        speed range consider: 1, 2, 3, 4 ......10^7

        now, as we can see here the search for speed is based on sorted integers
        that repesents speed, hence we can get the intuition that we can apply
        BINARY SEARCH here

         */
        //lower bounds for speed of trains
        int start = 1;
        //upper bound for spped of trains
        int end = 10000000;

        int minSpeed = -1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //dist[] represents the dist[i] each i-th train will travel,
            //mid represents a curr possible speed on which all n trains should
            //run(==> n = dist.length) such that total time taken to travel via
            //all the trains sequentially can be covered within given 'hour'
            //if this curr 'mid' speed for the trains is valid speed, meaning
            //total time taken by all n trains to cover dist[i] with speed 'mid'
            //(==> dist[i] / speed) is within 'hour', then we can say 'mid' is
            //the possible minSpeed, but also we will try to find a lesser
            //minSpeed, if possible, for that we will reduce the search space to
            //lower bound speed(==> end = mid - 1)
            if (minSpeedToArriveOnTime_IsValid(dist, mid, hour)) {
                minSpeed = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        //output
        System.out.println("Min speed for trains to arrive within 'hour' : " + minSpeed);
    }

    public void maxRunningTimeOfNComputers(int n, int[] batteries) {
        //https://leetcode.com/problems/maximum-running-time-of-n-computers/description/
        //explanation: https://youtu.be/CdqZNsvVSS4
        //based on BINARY SEARCH
        /*

        given that there n computers and batteries[] and i-th battery i.e, batteries[i]
        can run a computer for batteries[i] minutes, so once any battery reduced to 0
        it can't be charged and will not be able to run any computer

        totalBatteryTime represents the total run time all the batteries combined can
        provide, then on an average how much time can support a single computer
        i.e,

        timeUtilizedPerComputer = (totalBatteryTime / n) this represents that, at max
        a single computer can run 'timeUtilizedPerComputer' minutes

        the lowest time a single computer can run is 1 minute, why?
        BECAUSE it is also mentioned in constraints ==> 1 <= batteries[i] <= 10^9
        so if a computer is assinged a battery with batteries[i] = 1 then that
        computer can only run for this 1 minute only
        AND also remember that this question requires
        'ALL 'n' COMPUTER TO RUN SIMULTANEOUSLY' means if a single computer's
        battery is emptied then all other will also not be considered

        so the lower bound for single computer is 1 and also we figured that on
        average a single computer will require time 'timeUtilizedPerComputer' so
        the upper bound for single computer is 'timeUtilizedPerComputer'

        start = 1
        end = timeUtilizedPerComputer

        now we have range and with this we can apply binary search

        in the binary search below, we will get 'mid' that represents a run time
        where we are assuming a single computer will need 'mid' minutes of run
        time from batteries

        now if a single computer requies 'mid' minutes then in order to run all
        'n' computer simulatenously we will require at max (mid * n) minutes

        also, for single computer to utilise atmost 'mid' minutes from batteries[]
        we will calculate the min time utilized by this single computer as 'minTimeUtilized'

        now if time utilized by a single computer 'minTimeUtilized' is sufficient
        enough for all 'n' computers to run simultaneously

        ==> (minTimeUtilized >= (long) (mid * n))

        then we can try for a higher 'mid' value as we need to have max run time
        so we can move the search space to higher side i.e, start = mid + 1
        otherwise end = mid - 1;

         */

        long totalBatteryTime = 0;

        for (int time : batteries) {
            totalBatteryTime += time;
        }

        long timeUtilizedPerComputer = totalBatteryTime / n;

        long start = 1;
        long end = timeUtilizedPerComputer;

        long maxRunTime = 0;

        while (end >= start) {

            long mid = start + (end - start) / 2;

            long minTimeUtilized = 0;

            for (int time : batteries) {
                minTimeUtilized += Math.min(time, mid);
            }

            if (minTimeUtilized >= (long) (mid * n)) {
                maxRunTime = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        //output
        System.out.println("Max runtime of n computer : " + maxRunTime);
    }

    private boolean minimizeMaxDiffOfPairs_CanFormRequiredPairsWithGivenDiff(
            int[] nums, int pairs, int diff) {

        int n = nums.length;

        //countPairs = number of pairs we can from with having a given 'diff'
        //and we should atleast make 'pairs' number of pairs
        int countPairs = 0;

        //as the nums[] is sorted now, two closest/ adjacent nums[] values
        //can have the least diff meaning diffOf(nums[i], nums[i + 1]) is less
        //as compared to any value from (i + 2 or higher)
        //also we need to find |nums[i] - nums[j]| ==> nums[i + 1] - nums[i]
        int index = 0;

        while (index <= n - 2) {

            //as we need to find the diff between two adjacent pairs and if their
            //diff is less or equal to given 'diff' means this pair(nums[i], nums[i + 1])
            //is a valid pair hence do countPairs += 1
            //also we checked & formed pair(nums[i], nums[i + 1]) means we need
            //to now check pairs after (i + 1) i.e from i + 2 hence index += 2
            if (nums[index + 1] - nums[index] <= diff) {
                index += 2;
                countPairs++;
                continue;
            }

            //otherwise if the above pairs(nums[i], nums[i + 1]) is not valid
            //then we have to the next pair with (i + 1) & (i + 2) in that case
            //we move to next index ==> index += 1
            index++;
        }

        //with the given 'diff' if we can make atleast 'pairs' (countPairs more
        //or equal to given pairs) means the given 'diff' is a valid max diff
        //which also need to be minimized further
        return countPairs >= pairs;
    }

    public void minimizeMaxDiffOfPairs(int[] nums, int pairs) {
        //https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/
        //based on BINARY SEARCH
        int n = nums.length;

        Arrays.sort(nums);

        //min diff any pair can have is pair(a, b) ==> a - b = 0 when a == b
        int start = 0;
        //max diff any pair can have is pair(max(nums[]), min(nums[]))
        //in the sorted nums[] the max diff is between a pair i.e the first and
        //last val of the nums
        int end = nums[n - 1] - nums[0];

        int minimizeDiff = end;

        while (end >= start) {

            //here mid, is the 'diff' we are expecting that any pair in nums[]
            //should have means |nums[i] - nums[j]| == |diff| should be less or
            //equal to mid, hence 'mid' behaves as the potential max diff any
            //pair can have
            int mid = start + (end - start) / 2;

            //now that 'mid' is the potential diff any pairs should atleast have
            //now with this diff ==> 'mid' we need to check that if we can form
            //required number of 'pairs' or not
            //if we can form 'countPairs' that will be more or equal to 'pairs'
            //that would mean 'mid' is a valid max diff
            if (minimizeMaxDiffOfPairs_CanFormRequiredPairsWithGivenDiff(nums, pairs, mid)) {
                minimizeDiff = mid;
                //now that it is proven, 'mid' is a diff with which we can form
                //'pairs' number of pairs from nums[] now question req to minimize
                //this max diff, so we need to move the search space to left-side
                //as there we will have the lesser 'mid' value as diff
                end = mid - 1;
            } else {
                //if the above 'mid' is not valid max diff, then we still need to
                //find a max diff with which we can form atleat 'pairs' so to find
                //max diff 'mid' value, move the search space to right-side
                start = mid + 1;
            }
        }

        //output
        System.out.println("Minimize the maximum diff of pairs : " + minimizeDiff);
    }

    public void cuttingRibbons(int[] ribbons, int k) {
        //https://leetcode.com/problems/cutting-ribbons/description/
        //based on BINARY SEARCH
        int n = ribbons.length;
        //lower bound = min length of segment that we can cut from all of the
        //given ribbons to try to obtain 'k' segments
        int start = 1;

        //upper bound = max length of segment that we can cut(in case if we need
        //to obtain 'k' segments i.e, k = 1), we possibly can use the max length
        int end = 0;

        for (int ribbon : ribbons) {
            end = Math.max(end, ribbon);
        }

        //ribbon cut segment length that we need to maximize such that we can
        //obtain atleast 'k' segments of this max length
        int ribbonSegmentCutMaxLength = 0;

        while (end >= start) {

            //'mid' represent a possible cut length, that if we cut each ribbon
            //in ribbons[] of size 'mid' then we should be able to obtain 'k'
            //cut segments of length 'mid'
            int mid = start + (end - start) / 2;

            //initialy, number of cut segments obtained is 0
            int ribbonSegmentCut = 0;

            //here, each ribbon will be cut into segments of length 'mid' then
            //how many segments can be formed from curr ribbon that will be
            //number of segments obtained from curr ribbon
            //= length of curr ribbon / req length of segment 'mid'
            for (int ribbon : ribbons) {
                ribbonSegmentCut += (ribbon / mid);
            }

            //if on cutting all the ribbons into segments of length 'mid' we are
            //able to obtain 'atleast k' segments(of length 'mid') then it means
            //'mid' is a valid length for a segment
            if (ribbonSegmentCut >= k) {
                ribbonSegmentCutMaxLength = mid;
                //as 'mid' is valid length for cut segment to obtain 'atleast k'
                //segments, we still need to maximize this length such that higher
                //'mid' length should also geenrate atleat k segments, so for that
                //we move search space to right-side for higher 'mid' length
                start = mid + 1;
            } else {
                //here, 'mid' is not valid length for cut segment to obtain
                //'atleast k' segments, so any 'mid' length higher than this
                //'mid' will also not generate req 'k' segments, so we need to
                //reduce search space to left-side to have lower 'mid' length
                end = mid - 1;
            }
        }

        //output
        System.out.println("Cutting ribbons : " + ribbonSegmentCutMaxLength);
    }

    private boolean cakeDistributionMaxSweetnessAmongKFriends_isMaxSweetnessPossible(
            int[] sweetness, int reqSweetness, int reqFriends) {

        int friends = 0;
        int currSweetness = 0;
        for (int sweet : sweetness) {
            currSweetness += sweet;
            if (currSweetness >= reqSweetness) {
                friends++;
                currSweetness = 0;
            }
        }
        return friends >= reqFriends + 1;
    }

    public void cakeDistributionMaxSweetnessAmongKFriends(int[] sweetness, int k) {
        //https://practice.geeksforgeeks.org/problems/0a7c7f1089932257071f9fa076f25d353f91e0fd/1
        //based on BINARY SEARCH & splitArrayInLargestSum()
        int minSweetness = Integer.MAX_VALUE;
        int maxSweetness = 0;
        for (int sweet : sweetness) {
            maxSweetness += sweet;
            minSweetness = Math.min(minSweetness, sweet);
        }

        int start = minSweetness;
        int end = maxSweetness;

        int maxSweetnessProvided = 0;

        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (cakeDistributionMaxSweetnessAmongKFriends_isMaxSweetnessPossible(sweetness, mid, k)) {
                maxSweetnessProvided = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        //output
        System.out.println("Cake distribution with max swetness amon K friends : " + maxSweetnessProvided);
    }

    public void subseqOfLengthKWithLargestSum(int[] nums, int k) {
        //......................T: O(N.LogK) + O(K.LogK), minHeap + List<Pair> sorting
        //https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/
        class Pair {

            int val;
            int index;

            public Pair(int val, int index) {
                this.val = val;
                this.index = index;
            }
        }

        //first find the K largest elements, so sort by value
        //by finding K largest elements, we will have largest sum
        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);

        //K largest elements
        for (int i = 0; i < nums.length; i++) {
            minHeap.add(new Pair(nums[i], i));
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }

        //after above loop, we will left with K largest elements in the heap
        //now sort the values by min index to maintain subseq order
        List<Pair> values = new ArrayList<>(minHeap);
        Collections.sort(values, (a, b) -> a.index - b.index);

        int[] subseq = new int[k]; // values.size == k
        for (int i = 0; i < values.size(); i++) {
            subseq[i] = values.get(i).val;
        }
        //output
        System.out.println("Subsequence of length k having largest sum : " + Arrays.toString(subseq));
    }

    public void rangeSumQueries_BruteForce(int[] nums, int[][] queries) {
        //.........................T: O(M*N), for processing M queries it will
        //take in worst case O(N) time (if for mth query left = 0 and right = N - 1)
        //https://leetcode.com/problems/range-sum-query-immutable/
        List<Integer> sumsInQueryRange = new ArrayList<>();
        //T: O(M)
        for (int[] query : queries) {

            int left = query[0];
            int right = query[1];
            int sum = 0;
            //T: O(N) in worst case
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
            sumsInQueryRange.add(sum);
        }
        //output
        System.out.println("Sums from all the queries (Brute Force): " + sumsInQueryRange);
    }

    public void rangeSumQueries(int[] nums, int[][] queries) {
        //.........................T: O(N + M), for finding prefix sum,
        //for processing M queries it will take O(1)
        //https://leetcode.com/problems/range-sum-query-immutable/
        //explanation: https://youtu.be/k5Im14rNUFA
        //OPTIMISED
        //based on PREFIX SUM
        //convert nums array to its prefix sum array
        int prefix = nums[0];
        int n = nums.length;
        for (int i = 1; i < n; i++) {
            prefix += nums[i];
            nums[i] = prefix;
        }
        List<Integer> sumsInQueryRange = new ArrayList<>();
        for (int[] query : queries) {

            int left = query[0];
            int right = query[1];

            int sum = left - 1 < 0
                    ? nums[right]
                    : nums[right] - nums[left - 1];

            sumsInQueryRange.add(sum);
        }
        //output
        System.out.println("Sums from all the queries: " + sumsInQueryRange);
    }

    public void partitionArrayOnGivenPivot(int[] nums, int pivot) {
        //https://leetcode.com/problems/partition-array-according-to-given-pivot/
        int n = nums.length;
        int[] result = new int[n];
        int index = 0;

        //val strictly smaller than pivot in relative order of their position in
        //nums[]
        for (int val : nums) {
            if (val < pivot) {
                result[index++] = val;
            }
        }

        //val equals to pivot in relative order of their position in nums[]
        for (int val : nums) {
            if (val == pivot) {
                result[index++] = val;
            }
        }

        //val strictly greater than pivot in relative order of theri position in
        //nums[]
        for (int val : nums) {
            if (val > pivot) {
                result[index++] = val;
            }
        }

        //output
        System.out.println("Partition array on given pivot with relative order maintained: " + Arrays.toString(result));
    }

    public void rearrangeArrayElementsBySign(int[] nums) {
        //https://leetcode.com/problems/rearrange-array-elements-by-sign
        int n = nums.length;

        List<Integer> result = new ArrayList<>();
        List<Integer> positives = new ArrayList<>();
        List<Integer> negatives = new ArrayList<>();

        for (int val : nums) {
            if (val >= 0) {
                positives.add(val);
            } else {
                negatives.add(val);
            }
        }

        int posIndex = 0;
        int negIndex = 0;

        for (int i = 0; i < n; i++) {
            result.add(i % 2 == 0
                    ? positives.get(posIndex++)
                    : negatives.get(negIndex++));
        }

        //output
        //int[] output = result.stream().mapToInt(val -> val).toArray();
        System.out.println("Rearrange array elements by sign: " + result);
    }

    public void distinctBarcodes(int[] barcodes) {
        //https://leetcode.com/problems/distant-barcodes/
        //based on reorganizeString()
        //Acc to quest, rearrange barcodes so that no two adjacent barcodes are equal.
        int n = barcodes.length;
        int[] result = new int[n];
        int index = 0;

        Map<Integer, Integer> freq = new HashMap<>();
        for (int val : barcodes) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        PriorityQueue<Integer> maxHeapFreq = new PriorityQueue<>(
                (a, b) -> freq.get(b) - freq.get(a));

        for (int val : freq.keySet()) {
            maxHeapFreq.add(val);
        }

        //until there are 2 or more elements to pick
        //pick firstMostFreqNum and secondMostFreqNum
        while (maxHeapFreq.size() > 1) {

            int firstMostCommonNum = maxHeapFreq.poll();
            int secondMostCommonNum = maxHeapFreq.poll();

            result[index++] = firstMostCommonNum;
            result[index++] = secondMostCommonNum;

            //since we have taken 1 unit of firstMostCommonNum we must reduce its freq
            freq.put(firstMostCommonNum, freq.getOrDefault(firstMostCommonNum, 0) - 1);
            //if there are still some freq for curr firstMostCommonNum is left
            //we will add it back to maxHeap
            if (freq.get(firstMostCommonNum) > 0) {
                maxHeapFreq.add(firstMostCommonNum);
            }

            //since we have taken 1 unit of secondMostCommonNum we must reduce its freq
            freq.put(secondMostCommonNum, freq.getOrDefault(secondMostCommonNum, 0) - 1);
            //if there are still some freq for curr secondMostCommonNum is left
            //we will add it back to maxHeap
            if (freq.get(secondMostCommonNum) > 0) {
                maxHeapFreq.add(secondMostCommonNum);
            }
        }

        //there are chances, that there will remain 1 element in the maxHeap
        //we simply add it to our result
        if (!maxHeapFreq.isEmpty()) {
            result[index] = maxHeapFreq.poll();
        }
        //output
        System.out.println(Arrays.toString(result));
    }

    public void kRadiusSubarrayAverages(int[] nums, int k) {
        //https://leetcode.com/problems/k-radius-subarray-averages/
        //https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-effort/
        //based on SLIDING WINDOW
        int n = nums.length;
        int[] result = new int[n];
        //default avg at each index
        Arrays.fill(result, -1);

        int start = 0;
        int end = 0;
        //long to handle large numbers
        long winLen = 2 * k + 1;
        long currSum = 0;

        while (end < n) {
            currSum += nums[end];

            if (end - start + 1 == winLen) {
                long avg = currSum / winLen;
                int avgAtIndex = end - k;
                result[avgAtIndex] = (int) avg;
                //minimizing window
                currSum -= nums[start++];
            }
            end++;
        }
        //output
        System.out.println("K radius subarray averages: " + Arrays.toString(result));
    }

    public void stepsToMakeArrayNonDecreasing(int[] nums) {
        //https://leetcode.com/problems/steps-to-make-array-non-decreasing/
        //based on nextGreaterElementToRightInArray
        /*
        ex: [5,3,4,4,7,3,6,11,8,5,11]
        at currVal = 11, stack was empty[]
        stack[{11,0}]
        at currVal = 5, it can't remove 11 as 5 ! greater than prevVal 11
        stack[{11,0}, {5, 0}]
        at currVal = 8, it can remove only 5 thus the count = 1
        stack[{11,0}, {8, 1}]
        at currVal = 11, it can remove only 8 thus the count = 1
        stack[{11,0}, {11, 1}], , steps = 1
        at currVal = 6, it can't remove 11 as 6 ! greater than prevVal 11
        stack[{11,0}, {11, 1}, {6, 0}]
        at currVal = 3, it can't remove 6 as 3 ! greater than prevVal 6
        stack[{11,0}, {11, 1}, {6, 0}, {3, 0}]
        at currVal = 7, it can remove 3, 6 thus count = 2
        stack[{11,0}, {11, 1}, {7, 2}], steps = 2
        at currVal = 4, it can't remove 7 as 4 ! greater than prevVal 7
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}]
        at currVal = 4, it can't remove 4 as 4 ! greater than prevVal 4
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}, {4, 0}]
        at currVal = 4, it can't remove 3 as 3 ! greater than prevVal 4
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}, {4, 0}, {3, 0}]
        at currVal = 5, it can remove 3, 4, 4 thus count = 3
        stack[{11,0}, {11, 1}, {7, 2}, {5, 3}], steps = 3

        this 3 is the max removal we need to make between element [5 to 7]
        to make it non-decreasing, so that much removal will take min of 3 steps
        as each removal will happen in 1 unit steps
         */
        class ValCount {

            int val;
            int count;

            public ValCount(int val, int count) {
                this.val = val;
                this.count = count;
            }

        }

        int n = nums.length;
        int steps = 0;
        Stack<ValCount> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {

            //the count will be calculated for curr val such that
            //we will check like how many elements before this it can remove
            //if this curr val is greater that is previous elements (stack.peek().val < val)
            int removalCount = 0;

            while (!stack.isEmpty() && stack.peek().val < nums[i]) {
                removalCount = Math.max(removalCount + 1, stack.peek().count);
                stack.pop();
            }

            //checking the max with removalCount because
            //as per question, in one step we can remove nums[i]
            //if nums[i - 1] > nums[i] so we are comparing the removal counts
            //at any particular time this count will tell
            //"to remove this much(== removalCount) count we will
            //require atmost (removalCount) steps as each removal
            //will be treated as 1 unit step"
            steps = Math.max(steps, removalCount);

            stack.push(new ValCount(nums[i], removalCount));
        }

        //output
        System.out.println("Total steps to make array non-decreasing: " + steps);
    }

    public void onlineStockSpan(int[] prices) {
        //https://leetcode.com/problems/online-stock-span/
        //based on nextSmallerElementToLeftInArray()
        int n = prices.length;
        Stack<Integer> stack = new Stack<>();
        int[] spans = new int[n];
        for (int i = 0; i < n; i++) {
            int price = prices[i];
            while (!stack.isEmpty() && prices[stack.peek()] <= price) {
                stack.pop();
            }
            spans[i] = stack.isEmpty() ? i + 1 : i - stack.peek();
            stack.push(i);
        }
        //output
        System.out.println("Online stock span for every i-th price: " + Arrays.toString(spans));
    }

    public void maxPointsObtainFromCards(int[] points, int k) {
        //https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/
        //based on SLIDING WINDOW
        /*
        Question asks to choose the num in one step, from either starting or ending
        of points[] that should be of length k and this k-length array should give the
        max points.
        intution behind this, rather than doing a simple sliding window of window size k
        find the totalsPointSum (i.e, points[] sum) and do a sliding window on (n - k)
        size and we can find the maxPoint with totalPointSum - currPointSum(in curr window)

        ex: points: [1,2,3,4,5,6,1], k = 3
        totalPointSum = sum(points[]) = 22
        winSize = n - k => 7 - 3 = 4
        win1: [1,2,3,4],5,6,1 | currWindowSum = [1,2,3,4] = 10 | totalPointSum - currWindowSum = 22 - 10 = 12
        win2: 1,[2,3,4,5],6,1 | currWindowSum = [2,3,4,5] = 14 | totalPointSum - currWindowSum = 22 - 14 = 8
        win3: 1,2,[3,4,5,6],1 | currWindowSum = [3,4,5,6] = 18 | totalPointSum - currWindowSum = 22 - 18 = 4
        win4: 1,2,3,[4,5,6,1] | currWindowSum = [4,5,6,1] = 16 | totalPointSum - currWindowSum = 22 - 16 = 6

        maxPoints = 12
         */
        int n = points.length;
        //as per the question we can either choose values from start or end
        //we can choose 'k' value from these positions. so think it the other ways
        //each time we consider a window of size 'window' we will leave k elements
        //on either start or end or both (see above intuition)
        int window = n - k;

        int maxPoints = 0;

        int totalPointSum = 0;
        for (int point : points) {
            totalPointSum += point;
        }

        int currWindowSum = 0;
        int index = 0;
        //calculate the sum of first 'window' length subarray
        //i.e, win1: [1,2,3,4],5,6,1
        for (; index < window; index++) {
            currWindowSum += points[index];
        }

        //initial max points from first 'window' length subarray sum
        maxPoints = totalPointSum - currWindowSum;

        int start = 0;
        //end ptr should start from the window-th index(i.e, after the first 'window')
        int end = index;

        while (end < n) {

            //maintain the subarray sum having length 'window' by adding a new
            //points[end] value and reducing points[start] value
            //ex:
            //win1: [1,2,3,4],5,6,1
            //win2: 1,[2,3,4,5],6,1
            //win3: 1,2,[3,4,5,6],1
            currWindowSum += points[end];
            currWindowSum -= points[start];

            start++;
            end++;

            maxPoints = Math.max(maxPoints, totalPointSum - currWindowSum);

        }
        //output
        System.out.println("Max point sum: " + maxPoints);
    }

    public void minStepsToRemoveMaxAndMinValueFromFrontOrBack(int[] nums) {
        //https://leetcode.com/problems/removing-minimum-and-maximum-from-array/
        /*
        ex: nums: [2,10,7,5,4,1,8,6] maxVal = 10 & minVal = 1 | maxIndex = 1, minIndex = 5

        1. removing max or min val from front
        <---
        [2,10,7,5,4,1,8,6] (2 steps to remove maxVal == 10, i.e, maxIndex + 1)
        <-----------
        [2,10,7,5,4,1,8,6] (6 steps to remove minVal == 1, i.e, minIndex + 1)
        stepsForRemovingBothFromFront = max(2, 6)

        2. removing max or min val from back
            ------------>
        [2,10,7,5,4,1,8,6] (7 steps to remove maxVal == 10, i.e, n - maxIndex)
                    ---->
        [2,10,7,5,4,1,8,6] (3 steps to remove minVal == 1, i.e, n - minIndex)
        stepsForRemovingBothFromBack = max(7, 3)

        3. removing each of the value from front and back
        <---
        [2,10,7,5,4,1,8,6] (for removing maxVal == 10, from either front or back will take 2 or 7 steps)
            ------------>
        stepsForRemovingMaxVal = min(2, 7);

        <-----------
        [2,10,7,5,4,1,8,6] (for removing minVal == 1, from either front or back will take 6 or 3 steps)
                    ---->
        stepsForRemovingMinVal = min(6, 3);

        stepsForRemovingMaxMinSeparately = stepsForRemovingMaxVal + stepsForRemovingMinVal;

        now choose which possible scenario will give min no of steps
        minSteps = Math.min(stepsForRemovingMaxMinSeparately,
                Math.min(stepsForRemovingBothFromFront, stepsForRemovingBothFromBack));
         */
        int n = nums.length;
        int maxVal = Integer.MIN_VALUE;
        int minVal = Integer.MAX_VALUE;

        int maxIndex = 0;
        int minIndex = 0;

        //simply finding the maxVal and its index and minVal and its index from array
        for (int i = 0; i < n; i++) {
            int val = nums[i];
            if (val > maxVal) {
                maxVal = val;
                maxIndex = i;
            }
            if (val < minVal) {
                minVal = val;
                minIndex = i;
            }
        }

        int stepsForRemovingBothFromFront = Math.max(maxIndex + 1, minIndex + 1);
        int stepsForRemovingBothFromBack = Math.max(n - maxIndex, n - minIndex);

        //steps for removing each element from either front or back,
        //depending which one is giving lesser steps
        //min steps for removing just the max val either from front or back
        int stepsForRemovingMaxVal = Math.min(maxIndex + 1, n - maxIndex);
        //min steps for removing just the min val either from front or back
        int stepsForRemovingMinVal = Math.min(minIndex + 1, n - minIndex);

        int stepsForRemovingMaxMinSeparately = stepsForRemovingMaxVal + stepsForRemovingMinVal;

        int minSteps = Math.min(stepsForRemovingMaxMinSeparately,
                Math.min(stepsForRemovingBothFromFront, stepsForRemovingBothFromBack));
        //output
        System.out.println("Min steps for removing max & min value from array: " + minSteps);
    }

    public void makeArrayEmpty(int[] nums) {
        //https://leetcode.com/problems/make-array-empty/description/
        int n = nums.length;
        Map<Integer, Integer> valIndex = new HashMap<>();
        for (int i = 0; i < n; i++) {
            valIndex.put(nums[i], i);
        }

        Arrays.sort(nums);

        //initially oprns = n because even if the given nums[] was already sorted where
        //starting value is smaller, it would still take 'n' operations to empty the array
        long oprns = n;
        for (int i = 1; i < n; i++) {
            if (valIndex.get(nums[i - 1]) > valIndex.get(nums[i])) {
                oprns += (n - i);
            }
        }
        //output
        System.out.println("Operations to make array empty : " + oprns);
    }

    public void maxConsecutiveFloorsWithoutIncludingSpecialFloors(int bottom, int top, int[] special) {
        //https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
        /*
        floors: [2    3   sorted([4, 6])  7   8   9]
        4 - 2 = 2 consecutive-non-special floors(2, 3)
        6 - 4 - 1 = 1 consecutive-non-special floors(5)
        9 - 6 = 3 consecutive-non-special floors(7, 8, 9)
        maxConsecutiveFloors = max(2, 1, 3) = 3
         */
        int n = special.length;
        Arrays.sort(special);
        //first consecutive floors will be between
        //first(bottom) floor and the first special floor(after sorting)
        int maxConsecutiveFloors = special[0] - bottom;

        //there can be some consecutive-non-special floors between
        //two special floors in sorted special[] that will be (special[i] - special[i - 1] - 1)
        //choose where we are tracking most num of consecutive floors
        for (int i = 1; i < n; i++) {
            maxConsecutiveFloors = Math.max(maxConsecutiveFloors,
                    special[i] - special[i - 1] - 1);
        }

        //and finally the consecutive floors can be between
        //last special floor(after sorting) and the top floor given
        maxConsecutiveFloors = Math.max(maxConsecutiveFloors,
                top - special[n - 1]);

        System.out.println("Max consecutive floors in given bottom to top floors without some special floors: "
                + maxConsecutiveFloors);
    }

    public void findGoodDayToRobBank(int[] security, int time) {
        //https://leetcode.com/problems/find-good-days-to-rob-the-bank/
        int n = security.length;
        List<Integer> days = new ArrayList<>();
        List<Integer> incrDaysBeforeIThDay = new ArrayList<>();
        List<Integer> nonIncrDaysBeforeIThDay = new ArrayList<>();

        //calculating days that are greater than the curr i-th day
        incrDaysBeforeIThDay.add(0);
        for (int i = 1; i < n; i++) {
            if (security[i - 1] >= security[i]) {
                incrDaysBeforeIThDay.add(
                        incrDaysBeforeIThDay.get(incrDaysBeforeIThDay.size() - 1) + 1
                );
            } else {
                incrDaysBeforeIThDay.add(0);
            }
        }

        //calculating days where curr i-th day is greater than its previous
        nonIncrDaysBeforeIThDay.add(0);
        for (int i = 1; i < n; i++) {
            if (security[i - 1] <= security[i]) {
                nonIncrDaysBeforeIThDay.add(
                        nonIncrDaysBeforeIThDay.get(nonIncrDaysBeforeIThDay.size() - 1) + 1
                );
            } else {
                nonIncrDaysBeforeIThDay.add(0);
            }
        }

        //starting day = time because in order to rob the bank there is a
        //'time' range before and after from our curr day, so any day starting from < time
        //will not give that before-range, same is the reason for running it till n - time
        //so that we can have after-range form our curr day
        for (int day = time; day < n - time; day++) {
            if (incrDaysBeforeIThDay.get(day) < time || nonIncrDaysBeforeIThDay.get(day + time) < time) {
                continue;
            }
            days.add(day);
        }
        //output
        System.out.println("Good days to rob the bank: " + days);
    }

    public boolean validateMountainArray(int[] arr) {
        //https://leetcode.com/problems/valid-mountain-array/description/
        /*
        arr is a mountain array if and only if:

        1. arr.length >= 3
        2. There exists some i with 0 < i < arr.length - 1 such that:
        arr[0] < arr[1] < ... < arr[i - 1] < arr[i]
        arr[i] > arr[i + 1] > ... > arr[arr.length - 1]

         */
        int n = arr.length;

        //base case
        if (n < 3) {
            return false;
        }

        int startIndex = 0;
        int endIndex = startIndex;

        //find the peek of the mountain by moving 'uphill' to the peek index
        while (endIndex + 1 < n && arr[endIndex] < arr[endIndex + 1]) {

            //if curr element @endIndex is same as next element @endIndex + 1
            //then this can't be mountain array as all elements should be strictly
            //increasing in the 'uphill' till the peek
            if (arr[endIndex] == arr[endIndex + 1]) {
                return false;
            }

            //move to next 'uphill' element
            endIndex++;
        }

        //after finding the peek above if we notice that peek exist @endIndex = 0
        //or @endIndex = n - 1 that means there are no smaller uphills or downhills
        //to left or right side of this peek, respectively
        if (endIndex == 0 || endIndex == n - 1) {
            return false;
        }

        //from curr peek @endIndex find the 'downhill' end of this mountain
        //so all the elements after this peek should be smaller
        while (endIndex + 1 < n && arr[endIndex] > arr[endIndex + 1]) {

            //if curr element @endIndex is same as next element @endIndex + 1
            //then this can't be mountain array as all elements should be strictly
            //decreasing in the 'downhill' after the peek
            if (arr[endIndex] == arr[endIndex + 1]) {
                return false;
            }

            //move to next 'downhill' element
            endIndex++;
        }

        //as there can be only 1 mountain peek so starting and ending of this
        //mountain should have a length same as given arr[] meaning that whole
        //arr is a valid mountain array
        return (endIndex - startIndex + 1) == n;
    }

    public void longestMountainInArray(int[] arr) {
        //https://leetcode.com/problems/longest-mountain-in-array/
        int n = arr.length;
        int maxMountainSize = 0;
        int mountainStart = 0;

        while (mountainStart < n) {
            int mountainEnd = mountainStart;

            if (mountainEnd + 1 < n && arr[mountainEnd] < arr[mountainEnd + 1]) {
                //after this loop our mountainEnd will be at the mountain-peek index
                //strictly incr to mountain-peek
                while (mountainEnd + 1 < n && arr[mountainEnd] < arr[mountainEnd + 1]) {
                    mountainEnd++;
                }

                //validate if this is the actually the mountain-peek
                if (mountainEnd + 1 < n && arr[mountainEnd] > arr[mountainEnd + 1]) {
                    //strictly decr from mountain-peek
                    while (mountainEnd + 1 < n && arr[mountainEnd] > arr[mountainEnd + 1]) {
                        mountainEnd++;
                    }

                    maxMountainSize = Math.max(maxMountainSize, mountainEnd - mountainStart + 1);
                }
            }
            mountainStart = Math.max(mountainEnd, mountainStart + 1);
        }
        //output
        System.out.println("Longest mountain size: " + maxMountainSize);
    }

    public boolean increasingTripletSubseq(int[] nums) {
        //https://leetcode.com/problems/increasing-triplet-subsequence/
        int n = nums.length;
        int firstMin = Integer.MAX_VALUE;
        int secondMin = Integer.MAX_VALUE;

        for (int val : nums) {
            if (val <= firstMin) {
                firstMin = val;
            } else if (val <= secondMin) {
                secondMin = val;
            } else {
                return true;
            }
        }
        return false;
    }

    public void deckRevealedIncreasing(int[] deck) {
        //https://leetcode.com/problems/reveal-cards-in-increasing-order/
        //https://leetcode.com/problems/reveal-cards-in-increasing-order/solution/
        //question statement not cleared right now, need explanation & update comment is future
        int n = deck.length;
        int[] result = new int[n];
        //saving the indexes from [0 to n-1]
        Queue<Integer> indexes = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            indexes.add(i);
        }

        //sorting the cards in the deck in increasing order
        Arrays.sort(deck);

        for (int card : deck) {
            //here polling an index from indexes queue will get you first
            //even-index(0,2,4...). Because all the odd-index
            //will be moved back in the queue by below if-block
            result[indexes.poll()] = card;
            if (!indexes.isEmpty()) {
                //all the odd-index move back in the queue, until
                //even index are set increasingly
                indexes.add(indexes.poll());
            }
        }
        //output
        System.out.println("Deck revealed increasing: " + Arrays.toString(result));
    }

    private int sumOfSubarrayMins_PickElement(int[] arr, int index) {
        return (index == -1 || index == arr.length) ? Integer.MIN_VALUE : arr[index];
    }

    public void sumOfSubarrayMins(int[] arr) {
        //https://leetcode.com/problems/sum-of-subarray-minimums/
        //https://leetcode.com/problems/sum-of-subarray-minimums/discuss/2535363/JavaOne-Pass-Monotonic-Stack-with-Comments
        int n = arr.length;
        long result = 0l;
        int mod = 1000000007;
        Stack<Integer> indexes = new Stack<>();
        for (int i = -1; i <= n; i++) {

            while (!indexes.isEmpty()
                    && sumOfSubarrayMins_PickElement(arr, indexes.peek()) > sumOfSubarrayMins_PickElement(arr, i)) {
                int currIndex = indexes.pop();
                int start = indexes.peek();
                int end = i;
                result = (result + (long) (currIndex - start) * (end - currIndex) * arr[currIndex]) % mod;
            }
            indexes.push(i);
        }
        //output
        System.out.println("Sum of subarray minimums elements: " + result);
    }

    public void maxAreaOfPieceOfCake(int height, int width, int[] horizontalCuts, int[] verticalCuts) {
        //https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
        /*
        height = 5, width = 4, horizontalCuts = [1,2,4], verticalCuts = [1, 3]

        initial cut point
        left-edge \ top-edge
                      verCut[0]         verCut[1]
                    0       1       2       3       4
        horCut[0]   1-------|---------------|---------
        horCut[1]   2-------|---------------|---------
                    3       |  piece area   |
        horCut[2]   4-------|---------------|---------
                    5       |               |

        maxDiffHorizontal is between horCut[3] and horCut[1] (4 - 2) = 2
        maxDiffVertical is between verCut[1] and horCut[0] (3 - 1) = 2

        max cake piece area = maxDiffHorizontal * maxDiffVertical
         */
        int horLen = horizontalCuts.length;
        int vertLen = verticalCuts.length;

        Arrays.sort(horizontalCuts);
        Arrays.sort(verticalCuts);

        //inital diff between the first cut point and starting of cake top edge == 0
        int maxDiffOfHorizontalCuts = horizontalCuts[0] - 0;
        //inital diff between the first cut point and starting of cake left edge == 0
        int maxDiffOfVerticalCuts = verticalCuts[0] - 0;

        //find the max diff between two consecutive cuts after sorting
        for (int row = 1; row < horLen; row++) {
            maxDiffOfHorizontalCuts = Math.max(maxDiffOfHorizontalCuts,
                    horizontalCuts[row] - horizontalCuts[row - 1]);
        }

        //also find the max diff between actual height and last cut point after sorting
        maxDiffOfHorizontalCuts = Math.max(maxDiffOfHorizontalCuts,
                height - horizontalCuts[horLen - 1]);

        //find the max diff between two consecutive cuts after sorting
        for (int col = 1; col < vertLen; col++) {
            maxDiffOfVerticalCuts = Math.max(maxDiffOfVerticalCuts,
                    verticalCuts[col] - verticalCuts[col - 1]);
        }

        //also find the max diff between actual width and last cut point after sorting
        maxDiffOfVerticalCuts = Math.max(maxDiffOfVerticalCuts,
                width - verticalCuts[vertLen - 1]);

        //output
        System.out.println("Max area of piece of cake: " + (maxDiffOfHorizontalCuts * maxDiffOfVerticalCuts));
    }

    public void freqOfMostFrequentElement(int[] nums, int k) {
        //https://leetcode.com/problems/frequency-of-the-most-frequent-element/
        //based on SLIDING WINDOW
        int n = nums.length;
        Arrays.sort(nums);
        int start = 0;
        int end = 0;
        int sum = 0;
        int freq = 0;

        while (end < n) {
            sum += nums[end];
            //since we have sorted the nums[] so each nums[i] will be greater
            //than its prev value
            //this below while cond means,
            //(end - start + 1) * nums[end] means we need num[end] to be most freq
            //element under [start to end]
            //ex nums = [1,2,4] when start = 0, end = 1
            //winLen = end - start + 1 = 2
            //winLen * nums[end] ==> 2 * 4 = 8
            //this means if we make our nums like this nums[[4, 4], 4] it should
            //have a total sum of winLen * nums[end]
            //BUT
            //the actual sum till this [start to end] is 'sum'
            //means we need (winLen * nums[end]) but total at this point is 'sum'
            //if the diff of them is atmost K we can use all the K operations to
            //make our sum == winLen * nums[end] and hence under [start to end] all
            //elements will be equal to nums[end] hence winLen == freq of nums[end]
            //BUT
            //if this diff is greater than K we will never be able to do K operations
            //to cover up that diff then we reduce our window
            while ((end - start + 1) * nums[end] - sum > k) {
                sum -= nums[start];
                start++;
            }
            //end - start + 1 == winLen will tell that under above while cond
            //it is possible to make nums[end] to be most freq element from [start to end]
            //if we do k operations, and if we can do that then this winLen will contain
            //most freq element
            freq = Math.max(freq, (end - start + 1));
            end++;
        }
        //output
        System.out.println("After performing atmost K operations in elements, freq of most frequent element: " + freq);
    }

    public void findAllLonelyNumberInArray(int[] nums) {
        //https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
        List<Integer> lonelyElements = new ArrayList<>();
        int n = nums.length;

        Arrays.sort(nums);

        for (int i = 0; i < n; i++) {

            //skip the given valid (non-lonely) nums[i]
            //if prev nums[i - 1] is consecutive prev num of nums[i]
            //or prev nums[i - 1] is same as nums[i]
            if (i - 1 >= 0 && (nums[i - 1] == nums[i] - 1 || nums[i - 1] == nums[i])) {
                continue;
            }

            //skip the given valid (non-lonely) nums[i]
            //if next nums[i + 1] is consecutive next num of nums[i]
            //or next nums[i + 1] is same as nums[i]
            if (i + 1 < n && (nums[i + 1] == nums[i] + 1 || nums[i + 1] == nums[i])) {
                continue;
            }
            //here we have lonely nums[i]
            lonelyElements.add(nums[i]);
        }
        //output
        System.out.println("All the lonley elements in arrasy: " + lonelyElements);
    }

    public void numberOfSubarraysFilledWithZeros(int[] nums) {
        //https://leetcode.com/problems/number-of-zero-filled-subarrays/
        //based on SLIDING WINDOW
        int n = nums.length;
        long currSum = 0;
        long subarrays = 0;
        int start = 0;
        int end = 0;

        while (end < n) {
            currSum += nums[end];
            //nums[] can have +ve or -ve values so at any point in time
            //where our currSum is either greater than 0 or less than 0
            //we must reduce it to currSum == 0 because
            //ex any subarray[] with zeoes [0,0] the currSum always remain 0 only
            while (currSum > 0 || currSum < 0) {
                currSum -= nums[start];
                start++;
            }
            //if we have shrinked our window to a subarray where currSum == 0
            //we have a subarray where it is zero(s) only
            if (currSum == 0) {
                subarrays += (end - start + 1);
            }
            end++;
        }
        //output
        System.out.println("Number of subarrays filled with zeroes: " + subarrays);
    }

    private void productOfTheLastKNumbersHelper(
            List<String> commandStrings, List<Integer> commandValues) {

        int inputLength = commandStrings.size();

        int ARBITARY_VALUE_FOR_ADD_COMMAND = Integer.MIN_VALUE;

        List<Integer> prefixProdList = new ArrayList<>();
        List<Integer> result = new ArrayList<>();

        for (int i = 0; i < inputLength; i++) {

            String command = commandStrings.get(i);
            int value = commandValues.get(i);

            if (command.equals("add")) {
                if (value == 0) {
                    //if we ever see the the value 0, we will clear out our list
                    //beacuse if we don't do this our prefixProd will go 0 from
                    //that point
                    prefixProdList.clear();
                } else if (prefixProdList.isEmpty()) {
                    //if list was empty that means it the first record, save both
                    //as num & prefixprod
                    prefixProdList.add(value);
                } else {
                    //just like we find a prefixSum in array, here we are also
                    //doing the same thing, curr value will be multiplied with
                    //the last prefixProd
                    int size = prefixProdList.size();
                    int nextPrefixProd = prefixProdList.get(size - 1) * value;
                    prefixProdList.add(nextPrefixProd);
                }
                //for 'add' command a corresponding value(no meaning as such)
                result.add(ARBITARY_VALUE_FOR_ADD_COMMAND);
            } else if (command.equals("getProduct")) {
                int k = value;
                int size = prefixProdList.size();
                //k can be greater than the actual list size only when we have
                //encountered a 0 previously (otherwise acc to question 1 <= k <= list.size())
                //beacuse in 'add' we have a logic to clear list whenever we see 0
                //otherwise our prefixProd will go 0
                if (k > size) {
                    result.add(0);
                } else if (size == k) {
                    //if k is same as the size of the whole list we have so far
                    //means we need to add the totalProd which is the last prefixProd
                    //@size - 1 index
                    result.add(prefixProdList.get(size - 1));
                } else {
                    //using the formula:
                    //prod of last k elemenst = prefixProd[size - 1] / prefixProd[size - k - 1]
                    int lastKElementsProd
                            = (prefixProdList.get(size - 1) / prefixProdList.get(size - k - 1));

                    result.add(lastKElementsProd);
                }
            }
        }
        //output
        System.out.println("Last Kth product in the data stream: " + result);
    }

    public void productOfTheLastKNumbers() {
        //......................T: O(1)
        //......................S: O(N), storing N incoming nums from data stream
        //https://leetcode.com/problems/product-of-the-last-k-numbers/
        /*
        ex: nums[1,2,3,4,5]
        prefixProd [1,2,6,24,120]
        size = 5
        num:            1   2   3   4   5
        prefixProd:     1   2   6   24  120

        totalProd = lastProd @prefixProd == 120

        let say k == 3 then need to find the last k prod i.e, [3 to 5] == [3 * 4 * 5] = 60

        kThIndexfromLast = size - k ==> 5 - 3 = 2
        prefixProd[kThIndexfromLast] = 6

        prefixProd[kThIndexfromLast] = prefixProd[kThIndexfromLast - 1] * num[kThIndexfromLast]
        ==> 2 * 3 = 6

        so inorder to get the prod for last k elements from the data streams
        we just need the

        1. totalProd = prefixProd[size - 1]
        2. prodTillK = prod till (size - k - 1) index = prefixProd[size - k - 1]

        then if we divide totalProd / prodTillK = prod of last k elements

        index           : 0   1   2   3   4
        nums[]          : [1   2   3   4   5]
        prefixProd[]    : [1   2   6   24  120]

        prod of last k elemenst = prefixprod[size - 1] / prefixProd[size - k - 1]
        ==> 120 / 2 = 60 ==> 3 * 4 * 5

         */
        //input
        List<String> commandStrings = new ArrayList<>(
                Arrays.asList("add", "add", "add", "add", "add", "getProduct",
                        "getProduct", "getProduct", "add", "getProduct"));
        List<Integer> commandValues = new ArrayList<>(
                Arrays.asList(3, 0, 2, 5, 4, 2, 3, 4, 8, 2));
        //output
        productOfTheLastKNumbersHelper(commandStrings, commandValues);
    }

    public void findOriginalArrayFromDoubledArray(int[] changed) {
        //https://leetcode.com/problems/find-original-array-from-doubled-array/
        //https://leetcode.com/problems/array-of-doubled-pairs/
        /*
        Given that there was some OriginalArray[] where each of its element get doubled
        and added into the array and we are given this changed[] array. Need to find
        back the originalArrays(if possible)
        originalArray[].length = changed[].length / 2

        Intution:
        Sort the arrays first and create a freq map for the changed[]

        Now iterate over the changed[] and try to remove the val and ist doubledVal
        reduce freq by freq and if there is no more freq left remove the element from
        freq map

        Since the changed[] is double the original array therefore, if we form the
        originalArray that is of reqLen break the loop because thats how the originalArray
        initially was

         */
        int n = changed.length;
        int reqLen = n / 2;

        List<Integer> originalArray = new ArrayList<>();
        Map<Integer, Integer> freq = new HashMap<>();

        for (int val : changed) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        Arrays.sort(changed);

        for (int val : changed) {

            int doubledVal = 2 * val;

            //to handle cases for 0 (ex: [0,0,0,0])
            if (val == 0 && freq.containsKey(val) && freq.get(val) <= 1) {
                continue;
            }

            if (freq.containsKey(val) && freq.containsKey(doubledVal)) {

                originalArray.add(val);

                freq.put(val, freq.getOrDefault(val, 0) - 1);
                if (freq.get(val) <= 0) {
                    freq.remove(val);
                }

                freq.put(doubledVal, freq.getOrDefault(doubledVal, 0) - 1);
                if (freq.get(doubledVal) <= 0) {
                    freq.remove(doubledVal);
                }
            }
            if (originalArray.size() == reqLen) {
                break;
            }
        }
        //output
        System.out.println("Original array from given changed array: " + (originalArray.size() == reqLen
                ? originalArray
                : Arrays.toString(new int[]{})));
    }

    private int kConcatenationMaxSubarraySum_KadenAlgo(int[] arr) {
        //slightly modified version of actual kaden's algo
        int n = arr.length;
        int maxSum = arr[0];
        int currSum = arr[0];
        for (int i = 1; i < n; i++) {
            currSum = Math.max(arr[i], currSum + arr[i]);
            //if currSum goes negative then reset currSum to 0
            currSum = Math.max(currSum, 0);
            maxSum = Math.max(maxSum, currSum);
        }
        return maxSum;
    }

    public int kConcatenationMaxSubarraySum(int[] arr, int k) {
        //https://leetcode.com/problems/k-concatenation-maximum-sum/
        //based on kaden's algo
        int mod = 1000000007;
        int n = arr.length;
        //if arr is concatenated k == 1 times that is same arr as original
        if (k == 1) {
            return kConcatenationMaxSubarraySum_KadenAlgo(arr) % mod;
        }

        int[] twiceTheArr = new int[2 * n];
        for (int i = 0; i < n; i++) {
            //first half same as arr[]
            twiceTheArr[i] = arr[i];
            //other half is also same as arr[]
            twiceTheArr[n + i] = arr[i];
        }

        if (k == 2) {
            return kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
        }

        long totalSum = 0;
        for (int val : arr) {
            totalSum += val;
        }

        if (totalSum >= 0) {
            int twiceTheArrMaxSum = kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
            int remaining = (int) ((totalSum % mod) * (k - 2) % mod);
            return (int) (twiceTheArrMaxSum + remaining) % mod;
        }
        return kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
    }

    public void sumOfEvenNumbersAfterGivenQueries(int[] nums, int[][] queries) {
        //https://leetcode.com/problems/sum-of-even-numbers-after-queries/
        int n = nums.length;
        int m = queries.length;
        int[] result = new int[m];

        int totalEvenSum = 0;

        for (int val : nums) {
            //if val is even number add it to totalEvenSum
            totalEvenSum += val % 2 == 0 ? val : 0;
        }

        int qIndex = 0;
        for (int[] query : queries) {
            int val = query[0];
            int index = query[1];

            int oldNumVal = nums[index];
            //if the old num value at given index was even that means, it was
            //used to form the totalEvenSum now adjust this num by deleting
            //it from totalEvenSum
            totalEvenSum -= oldNumVal % 2 == 0 ? oldNumVal : 0;

            //update the value at index in nums[] by the given value in query
            nums[index] += val;

            //now if the new updated value in nums[] becomes an even number
            //we must consider this number in our totalEvenSum, then again adjust
            //this totalEvenSum
            totalEvenSum += nums[index] % 2 == 0 ? nums[index] : 0;

            //at this point we have proccessed our single query, we must store
            //the totalEvenSum till now in our result[]
            result[qIndex++] = totalEvenSum;
        }
        //output
        System.out.println("Sum of even number after queries: " + Arrays.toString(result));
    }

    public void fruitsIntoBasket(int[] fruits) {
        //https://leetcode.com/problems/fruit-into-baskets/
        //based on SLIDING WINDOW
        //this question is like longest contigous subarray with ATMOST k (here == 2)
        //numbers(repetitions allowed)
        int n = fruits.length;
        Map<Integer, Integer> basket = new HashMap<>();
        int start = 0;
        int end = 0;
        int maxTreeRange = 0;

        while (end < n) {

            int fruitsEnd = fruits[end];
            basket.put(fruitsEnd, basket.getOrDefault(fruitsEnd, 0) + 1);

            //if currently the basket contains fruits <= 2 that can be our tree range
            if (basket.size() <= 2) {
                maxTreeRange = Math.max(maxTreeRange, end - start + 1);
            }

            //basket can contain atmost 2 fruits
            while (basket.size() > 2) {
                int fruitsStart = fruits[start];
                basket.put(fruitsStart, basket.getOrDefault(fruitsStart, 0) - 1);
                if (basket.get(fruitsStart) <= 0) {
                    basket.remove(fruitsStart);
                }
                start++;
            }

            end++;
        }
        //output
        System.out.println("Max tree range where basket can contains atmost fruits: " + maxTreeRange);
    }

    public void maxWidthBetweenGivenPoints(int[][] points) {
        //https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/
        //simple plain sorting, why this one was a Medium question on leetcode,
        //don't know :P
        int n = points.length;
        //sort the points in incr order of row-axis,
        //if row-axis are same then sort in incr order of col-axis else incr order of row-axis
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        int maxWidth = 0;
        for (int i = 1; i < n; i++) {
            int prevX = points[i - 1][0];
            int currX = points[i][0];
            maxWidth = Math.max(maxWidth, currX - prevX);
        }
        //output
        System.out.println("Max width from given points: " + maxWidth);
    }

    public void kThSmallestPairDistance(int[] nums, int k) {
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/solution/
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/196304/Verbosely-commented-Python-Approach-3-with-example-walkthrough
        //based on BINARY SEARCH + SLIDING WINDOW
        /*
        A straight forward Pair generation(using nested for loops) + Heap method
        would also work but that was giving TLE for large inputs
         */
        int n = nums.length;

        Arrays.sort(nums);

        int min = nums[0];
        int max = nums[n - 1];

        //min possible dist from pair
        int low = 0;
        //max possible dist from pair
        int high = max - min;

        //with binary search, we will try to find a potential dist 'mid' such that
        //the pairs formed having dist == 'mid' will tell how close or far we are
        //from our k-smallest dist pair, with binary search we can efficiently
        //locate pairs as close as possible to k hence giving us k-smallest dist
        while (high > low) {

            //mid is the potential dist that we will check as sliding window
            int mid = low + (high - low) / 2;

            //we need to figure out how many pairs can be made having pair dist <= mid
            int pairs = 0;

            //sliding window
            int start = 0;
            int end = 0;

            //since we sort the nums[] that means nums[end] - nums[start] will be
            //an abs diff
            while (end < n) {

                //curr dist from pairs in range [start to end] > mid then adjust
                //the window by moving the start ptr
                while (nums[end] - nums[start] > mid) {
                    start++;
                }

                //here, in this area every nums value pairs in range [start to end]
                //has dist <= mid, so count total pairs formed
                pairs += (end - start);
                end++;
            }

            //if we are generating more pairs than given k (==> k <= pairs) by
            //keeping min as a potential dist for pairs as k-smallest dist that
            //means for any higher value that the curr 'mid' the pairs will always
            //be more than k
            //hence, need to move the search to lower mid side that is in range
            //[start to mid]
            if (k <= pairs) {
                high = mid;
            } else {
                //if, pairs formed are less than k, then in order to generate the
                //k-smallest pair dist, we need more pairs
                //hence, need to move the search to higher mid side that is in
                //range [mid + 1 to end]
                low = mid + 1;
            }
        }
        //output
        System.out.println("KTh smallest pair distance: " + low);
    }

    public void kThSmallestPairSum(int[] nums1, int[] nums2, int k) {
        //https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
        class Pair {

            int val1;
            int val2;
            long smallestSum;

            public Pair(int val1, int val2, long smallestSum) {
                this.val1 = val1;
                this.val2 = val2;
                this.smallestSum = smallestSum;
            }

        }

        int n = nums1.length;
        int m = nums2.length;

        List<List<Integer>> kSmallestSumPairs = new ArrayList<>();

        PriorityQueue<Pair> maxHeapSum = new PriorityQueue<>(
                (a, b) -> Long.compare(b.smallestSum, a.smallestSum));

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < m; j++) {

                //as we progress in i & j iterations, our curr 'smallestSum' tends
                //to have greater sum as both nums1[] & nums2[] is given sorted, so
                //lower values on the start side of both these arrays will will have
                //lesser pairs sum and higher values on end side of both these arrays
                //will have greater pair sum
                int smallestSum = nums1[i] + nums2[j];

                //if the curr maxHeap size is less than k we can pick this pair
                //as we need min k smallest pair sum
                if (maxHeapSum.size() < k) {

                    maxHeapSum.add(new Pair(nums1[i], nums2[j], smallestSum));

                } else if (smallestSum < maxHeapSum.peek().smallestSum) {
                    //as we reached maxHeap size == k we will check this cond
                    //smallestSum < maxHeapSum.peek().smallestSum, why?
                    //because we need k smallest pair and in this else block
                    //we have atleast k pairs in maxHeap, now we need to decide
                    //if the curr 'smallestSum' is pickable or not!
                    //as this is a maxHeap then root is already a max value and
                    //we need k smallest pair sum so curr 'smallestSum' should be
                    //less than the maxHeap.peek().smallestSum value to be called in
                    //k-smallest pair sum

                    //remove the maxHeap.peek() sum which is greater than curr
                    //'smallestSum'
                    maxHeapSum.poll();
                    //put the curr pair with the 'smallestSum'
                    maxHeapSum.add(new Pair(nums1[i], nums2[j], smallestSum));
                } else {
                    //why break?
                    //because in question it is given that both nums1 & nums2 are
                    //sorted so if the curr 'smallestSum' is greater than maxHeap.peek().smallestSum
                    //then it will always be greater sum in next i & j after this
                    //and as it will always remain greater so no need to waste time
                    //on checking further pair sum, break here which also prevent TLE
                    break;
                }
            }
        }

        while (!maxHeapSum.isEmpty()) {
            Pair pair = maxHeapSum.poll();
            kSmallestSumPairs.add(Arrays.asList(pair.val1, pair.val2));
        }
        //output
        System.out.println("K smallest pair sum: " + kSmallestSumPairs);
    }

    public void kThSmallestPairSum2(int[] nums1, int[] nums2, int k) {
        //https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
        //explanation: https://youtu.be/PiGYS7BbV_Q
        /*

        nums1[] = [1,7,11]
        nums2[] = [2,4,6]

        we know that both nums1 and nums2 is already sorted in asc order, so it
        is very clear that their 0-th index (i, j) = (0, 0) will always have a
        smallest pair sum out of any other pairs
        so we will start with
        i = 0
        j = 0

        later on we have 2 options to find smallest pair sum but keep check of
        index limit under m & n respec
        1. (i + 1, j)
        2. (i, j + 1)

        ex: with above example
        (0, 0) = 1 + 2 = 3
        (0 + 1, 0) or (0, 0 + 1)
        ==> (1, 0) or (0, 1)
        ==> (7 + 2) or (1 + 4)
        ==> 9 or 5
        ==> next time min heap will pick pair with sum 5

        why do we need to check these 2 options (i + 1, j) or (i, j + 1)?
        as seen above
        we have pair sum as: (7 + 2) or (1 + 4)

        but if we have this example
        nums1[] = [1,2,11]
        nums2[] = [2,4,6]

        then pairs sum would have been
        (2 + 2) or (1 + 4) ==> 4 or 5
        where 4 is smallest sum now
        that's why both options needs to be checked

         */
        class Pair {

            //represents nums1 index
            int i;
            //represents nums2 index
            int j;
            //represents nums1[i] + nums2[j] sum
            long smallestSum;

            public Pair(int i, int j, long smallestSum) {
                this.i = i;
                this.j = j;
                this.smallestSum = smallestSum;
            }

        }

        int m = nums1.length;
        int n = nums2.length;

        List<List<Integer>> kSmallestSumPairs = new ArrayList<>();

        Set<String> visited = new HashSet<>();

        //min heap
        PriorityQueue<Pair> minHeapSum = new PriorityQueue<>(
                (a, b) -> Long.compare(a.smallestSum, b.smallestSum));

        //represents nums1 index
        int i = 0;
        //represents nums2 index
        int j = 0;

        visited.add(i + "," + j);
        minHeapSum.add(new Pair(i, j, nums1[i] + nums2[j]));

        //since we are using min heap upto k value, we will pick peek value
        while (!minHeapSum.isEmpty() && k > 0) {

            k--;

            //since we have a min heap now, we will have smalles sum at the peek
            //we can poll that smallest sum and create pair
            Pair currPair = minHeapSum.poll();

            kSmallestSumPairs.add(Arrays.asList(nums1[currPair.i], nums2[currPair.j]));

            //now we have two options from where we can have min sum pairs
            //that is 1. (i + 1, j) or 2. (i, j + 1) but both nums1 and nums2
            //may have different lengths so we need to check if (i + 1) is pickable
            //under nums1[] and (j + 1) is pickable under nums2[]
            //there are also chances that we may add up new (i, j) pairs which is
            //already there in minHeap or already processed before, so keep check
            //the visited
            if (currPair.i + 1 < m && !visited.contains((currPair.i + 1) + "," + currPair.j)) {

                visited.add((currPair.i + 1) + "," + currPair.j);

                minHeapSum.add(new Pair(
                        currPair.i + 1,
                        currPair.j,
                        nums1[currPair.i + 1] + nums2[currPair.j]));
            }

            if (currPair.j + 1 < n && !visited.contains(currPair.i + "," + (currPair.j + 1))) {

                visited.add(currPair.i + "," + (currPair.j + 1));

                minHeapSum.add(new Pair(
                        currPair.i,
                        currPair.j + 1,
                        nums1[currPair.i] + nums2[currPair.j + 1]));
            }
        }

        //output
        System.out.println("K smallest pair sum (Approach 2): " + kSmallestSumPairs);
    }

    private boolean minDeletionsToMakeArrayDivisble_IsDivisible(
            int val, Set<Integer> numsToDivideSet) {
        for (int num : numsToDivideSet) {
            if (num % val != 0) {
                return false;
            }
        }
        return true;
    }

    public int minDeletionsToMakeArrayDivisble(int[] nums, int[] numsToDivide) {
        //https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/
        //based on BRUTE FORCE
        Set<Integer> numsToDivideSet = new HashSet<>(IntStream.of(numsToDivide)
                .boxed().collect(Collectors.toSet()));

        Map<Integer, Integer> numsFreq = new HashMap<>();
        for (int val : nums) {
            numsFreq.put(val, numsFreq.getOrDefault(val, 0) + 1);
        }

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.addAll(numsFreq.keySet());

        int deletes = 0;
        while (!minHeap.isEmpty()) {

            int minNumVal = minHeap.poll();
            //if the curr smallest num value from minHeap is able to divide all
            //the num in numsToDivideSet then the result would be how many deletes
            //we made to get to this smallest value
            if (minDeletionsToMakeArrayDivisble_IsDivisible(minNumVal, numsToDivideSet)) {
                return deletes;
            }

            //since in above if() the curr smallest value from nums[] (==> 'minNumVal')
            //was not able to delete all the values in numsToDivide[] that means
            //we must delete this 'minNumVal' and to delete all its occurences
            //we will use freq of 'minNumVal' from freq map
            deletes += numsFreq.get(minNumVal);
            //perform the actual delete
            numsFreq.remove(minNumVal);
        }
        return -1;
    }

    public boolean checkIfArrayPairsAreDivisibleByK(int[] nums, int k) {
        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/
        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/discuss/709691/Java-7ms-Simple-Solution
        /*
        we need a pair(a, b) whose sum is divisible by k
        means (a + b) % k == 0
        let say remainder be x if a % k ==> x
        then remainder be k - x if b % k ==> k - x

        ex: k = 5, pair(1, 9)
        ==> (1 + 9) % k == 0
        ==> 10 % 5 == 0

        proof:
        1 % 5 ==> x ==> 1
        9 % 5 ==> k - x ==> 4 (==> 5 - 1)

        with this approach, we will calculate each val's remainder freq then
        how will we check if pairs possible?

        since with above explanation

        if freq[x] == freq[k - x]
        means number of remainders x is same as numbers of remainder (k - x)
        then we will be able to make pairs with each val contributing to these
        remainders(x, k - x) otherwise if freq[x] != freq[k - x] means pairs can't
        be formed

         */
        int[] remainderFreq = new int[k];
        for (int val : nums) {

            int remainder = val % k;

            //offset the negative remainders with +k otherwise keep as it is
            remainder = (remainder < 0) ? remainder + k : remainder;

            remainderFreq[remainder]++;
        }

        int remainder = 0;
        //ex: nums[] = [5,5,5,1,1,1], k = 5
        //then remainderFreq[0] = 3 as 5 % 5 = 0 and we three 5 in nums[]
        //so remainderFreq[5 % k] = 3
        if (remainderFreq[remainder] % 2 != 0) {
            return false;
        }

        remainder = 1;
        for (; remainder <= k / 2; remainder++) {

            if (remainderFreq[remainder] != remainderFreq[k - remainder]) {
                return false;
            }
        }

        return true;
    }

    public int shortestSubarrayRemovedToMakeArrayNonDecreasing(int[] arr) {
        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830480/C%2B%2B-O(N)-Sliding-window-Explanation-with-Illustrations
        /*

        ex: arr[] = [1,2,3,10,4,2,3,5]
            index = [0,1,2,3,4,5,6,7]

        PEEK index = left = 3
        means from arr[0 to left] it is non-dec
        ==> arr[0 to left] = [1,2,3,10]

        VALLEY index = right = 5
        means from arr[right to n - 1] it is non-dec
        ==> arr[right to n - 1] = [2,3,5]

        first option is either to

        1. keep PEEK side non-dec arr but then we have to delete the subarray
        after this PEEK ==> (n - left - 1)
        ==> keep[1,2,3,10], delete[4,2,3,5]

        2. keep VALLEY side non-dec arr but then we have to delete the subarray
        before this VALLEY ==> (right)
        ==> delete[1,2,3,10,4], keep[2,3,5]

        thats why we have initial min deletions as
        ==> minLength = min(n - left - 1, right)
        ==> minLength = min(8 - 3 - 1, 5)
        ==> minLength = min(4, 5) ==> 4

        till now the non-dec array can made by choosing the option 1. as
        length of subarray deleted is less

        BUT we still can minimize the deleted subarray size from 4 to 3
        by deleting a subarray from arr[2 to 4]
        ==> delete[3,10,4]
        ==> keep[1,2,2,3,5]

         */
        int n = arr.length;
        int left = 0;
        int right = n - 1;

        //move left index to the peek element in arr from start
        //ex: arr[0] <= arr[1] <= ... <= arr[left] <-- PEEK
        //such that arr[left + 1] is a downhill after this PEEK
        while (left + 1 < n && arr[left] <= arr[left + 1]) {
            left++;
        }

        //means the given arr was already non-decreasing, so no subarray to be
        //removed to make it non-decreasing hence removed subarray's length is 0
        if (left == n - 1) {
            return 0;
        }

        //move the right index to deepest valley in the arr from end
        //ex: VALLEY --> a[right] <= ... <= a[n - 2] <= a[n - 1]
        //such that arr[right - 1] is an uphill after this VALLEY
        while (right > left && arr[right - 1] <= arr[right]) {
            right--;
        }

        //currently, two possibility to make arr non-decreasing is
        //1. arr[0 to left] is already non-dec so remove the subarray after the
        //left index which is right-side of arr[] = (n - left - 1)
        //2. arr[right to n - 1] is already non-dec so remove the subarray before
        //the right index which is left-side of arr[] = (right)
        int minLength = Math.min(n - left - 1, right);

        //there is another possibility to remove the subarray to make arr non-decreasing
        //that is to find the shortest subarray between left and right indexes
        int start = 0;
        int end = right;

        //here we are checking if the window between start & end gives us the
        //shortest subarray to be removed, by comparing arr[end] >= arr[start]
        //hence the removable subarray length becomes end - start - 1
        while (left >= start && end < n) {

            if (arr[end] >= arr[start]) {
                minLength = Math.min(minLength, end - start - 1);
                start++;
            } else {
                end++;
            }
        }
        return minLength;
    }

    public void partitionsArrayIntoDisjointIntervals(int[] nums) {
        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/
        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/solution/
        /*
        partition it into two (contiguous) subarrays left and right so that:

        1. Every element in left is less than or equal to every element in right.
        2. left and right are non-empty.
        3. left has the smallest possible size.
         */
        int n = nums.length;
        int currMax = nums[0];
        int possibleMax = nums[0];
        int length = 1;
        for (int i = 1; i < n; i++) {
            if (currMax > nums[i]) {
                length = i + 1;
                currMax = possibleMax;
            } else {
                possibleMax = Math.max(possibleMax, nums[i]);
            }
        }
        //output
        System.out.println("Partition length: " + length);
    }

    public boolean containsDuplicateThree(int[] nums, int indexDiff, int valueDiff) {
        //https://leetcode.com/problems/contains-duplicate-iii/
        //https://leetcode.com/problems/contains-duplicate-iii/discuss/2728206/Java-Solution-using-TreeMap-and-sliding-window-oror-O(nLog(indexDiff))
        //based on SLIDING WINDOW
        /*
        Find a pair of indices (i, j) such that:
        1. i != j,
        2. abs(i - j) <= indexDiff.
        3. abs(nums[i] - nums[j]) <= valueDiff, and
         */
        int n = nums.length;
        int start = 0;
        int end = 0;

        TreeSet<Integer> sortedVals = new TreeSet<>();

        while (end < n) {

            while (end - start > indexDiff) {
                sortedVals.remove(nums[start++]);
            }

            Integer minVal = sortedVals.floor(nums[end]);
            Integer maxVal = sortedVals.ceiling(nums[end]);

            if (minVal != null && Math.abs(nums[end] - minVal) <= valueDiff) {
                return true;
            }

            if (maxVal != null && Math.abs(nums[end] - maxVal) <= valueDiff) {
                return true;
            }

            sortedVals.add(nums[end]);

            end++;
        }
        return false;
    }

    public void minOperationsToMakeArrayContinous(int[] nums) {
        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/
        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/2725833/Java-Sliding-Windows
        //based on SLIDING WINDOW
        /*
        nums[] is considered continuous if both of the following conditions are fulfilled:
        1. All elements in nums are unique.
        2. The difference between the maximum element and the minimum element in
        nums equals nums.length - 1.
         */
        int len = nums.length;
        nums = Arrays.stream(nums).sorted().distinct().toArray();
        int newLen = nums.length;
        int start = 0;
        int end = 0;
        int oprn = len;

        while (end < newLen) {

            while (nums[end] - nums[start] >= len) {
                start++;
            }

            oprn = Math.min(oprn, len - (end - start + 1));

            end++;
        }
        //output
        System.out.println("Min number of operation to make array continous: " + oprn);
    }

    public void groupPeopleInTheirGroupSizes(int[] groupSizes) {
        //https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
        int n = groupSizes.length;
        List<List<Integer>> groupWithPeople = new ArrayList<>();
        Map<Integer, List<Integer>> groups = new HashMap<>();

        for (int people = 0; people < n; people++) {
            int groupSize = groupSizes[people];

            //create a new group in map with size == groupSize, and put all the
            //people into this group until we we reach the max size of curr group
            groups.putIfAbsent(groupSize, new ArrayList<>());
            groups.get(groupSize).add(people);

            //when we reach the maxSize of the curr group == groupSize
            //take that groups and put that in separate list groupWithPeople
            //and since we have reached the maxSize limit for the curr group we
            //can remove this group from map that would mean we have processes
            //one group and later on we can create a new groups in map with the
            //same groupSize
            if (groups.get(groupSize).size() == groupSize) {
                groupWithPeople.add(groups.get(groupSize));
                groups.remove(groupSize);
            }
        }
        //output
        System.out.println("People in groups with fixed group sizes: " + groupWithPeople);
    }

    public void groupPeopleInTheirGroupSizes2(int[] groupSizes) {
        //https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
        //based exactly on groupPeopleInTheirGroupSizes() BUT using List[] arrays
        //as map, why? because using List[] array in the from of Map is more faster
        //otherwise both logic are exactly same
        int n = groupSizes.length;
        List<List<Integer>> groupWithPeople = new ArrayList<>();

        //finding a max group size so that we can create a List[] having group
        //holding capacity of (maxGroupSize + 1) so that it can include 'maxGroupSize'
        //itself
        int maxGroupSize = groupSizes[0];
        for (int size : groupSizes) {
            maxGroupSize = Math.max(maxGroupSize, size);
        }

        //to include this 'maxGroupSize' as well that why create an array of size
        //(maxGroupSize + 1)
        List<Integer>[] groups = new ArrayList[maxGroupSize + 1];

        for (int people = 0; people < n; people++) {

            int size = groupSizes[people];

            //create a new group that maps to curr group 'size' in List[], and put
            //all the people into this group until we we reach the max size of curr group
            if (groups[size] == null) {
                groups[size] = new ArrayList<>();
            }

            groups[size].add(people);

            //when we reach the maxSize of the curr group == 'size'
            //take that groups and put that in separate list groupWithPeople
            //and since we have reached the maxSize limit for the curr group we
            //can remove this group from List[] that would mean we have processed
            //one group and later on we can create a new groups in List[] with the
            //at same groupSize (==> size)
            if (groups[size].size() == size) {

                groupWithPeople.add(groups[size]);
                //reset the curr group that maps to 'size' as null so that next
                //time, if it required to create a new group, groups[size] will
                //initialized again with new ArrayList<>() (see above)
                groups[size] = null;
            }
        }
        //output
        System.out.println("People in groups with fixed group sizes (approach 2): " + groupWithPeople);
    }

    public void maxNumberOfKSumPairs(int[] nums, int k) {
        //https://leetcode.com/problems/max-number-of-k-sum-pairs/
        //based on twoSum()
        /*

        how two sum works?
        in a given nums[] arrays, should exists two numbers a & b such that this
        pair(a, b) in nums[] should sum to given 'k' value that is, a + b = k

        ==> a + b = k
        ==> a = k - b

        so using a Set we can know if ever (k - b) existed means we have both
        b & (k - b) (==> a) then we can say twoSum possible

        here for this question, we need Map for extending the twoSum logic
        nums[] = [2,5,4,4,1,3,4,4,1,4,4,1,2,1,2,2,3,2,4,2], k = 3

        we need to find all pairs (counts) that sums to given 'k'

        as above, we have b = val then we can find its complement value
        a as (k - b) ==> (k - val)

        (k - val) = [1, -2, -1, -1, 2, 0, -1, -1, 2, -1, -1, 2, 1, 2, 1, 1, 0, 1, -1, 1]

        map{ 1 = 5, -2 = 1, -1 = 7, 2 = 4, 0 = 2}

        -2, -1, 0 are the complement value that doesn't exist in given nums[]
        hence they will never form any pair with any other 'val' so we left with

        as compared to twoSum, we only need to tell if a single pair existed
        but here we need to tell the count of pairs can be formed, hence Map
        is required

        as we can see here, each complement value can occur multiple times hence
        can form multiple similar but unique pairs means each pair(a, b) will be
        a different (a, b) and not using any overlapped a or b

        map = {1 = 5, 2 = 4}

        4 pairs possible here is whose sum == k
        (1,2), (1,2), (1,2), (1,2)

         */

        //using map here to count the freq of possible pairs we can form if we
        //see (k - val) multiple times
        Map<Integer, Integer> freq = new HashMap<>();

        int pairs = 0;

        for (int val : nums) {

            int diff = k - val;

            if (!freq.containsKey(diff)) {
                freq.put(val, freq.getOrDefault(val, 0) + 1);
                continue;
            }

            pairs++;

            freq.put(diff, freq.getOrDefault(diff, 0) - 1);

            if (freq.get(diff) <= 0) {
                freq.remove(diff);
            }
        }
        //output
        System.out.println("Max number of k sum pairs: " + pairs);
    }

    public void arrayWithElementsNotEqualToAverageOfNeighbours(int[] nums) {
        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/discuss/2762685/2-Solutions-oror-O(Nlogn)-and-O(N)-oror-Easy
        int n = nums.length;
        for (int i = 1; i < n - 1; i++) {
            if (nums[i - 1] + nums[i + 1] == 2 * nums[i]) {
                swapIntArray(nums, i, i + 1);
            }
        }

        for (int i = n - 2; i >= 1; i--) {
            if (nums[i - 1] + nums[i + 1] == 2 * nums[i]) {
                swapIntArray(nums, i, i - 1);
            }
        }
        //output
        System.out.println("Arrays with elements not equal to average of neighbours: " + Arrays.toString(nums));
    }

    public void minConsecutiveCardsToPickUpBetweenSameCards(int[] cards) {
        //https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
        //based on SLIDING WINDOW
        /*
        cards[] = [3,4,2,3,4,7]
        same cards = 3 at index 0 & 3 cards to pick between them = 3 - 0 + 1 = 4
        same cards = 4 at index 1 & 4 cards to pick between them = 4 - 1 + 1 = 4
        min cards picked is 4
         */
        int n = cards.length;
        int minCardsPickUp = Integer.MAX_VALUE;

        Map<Integer, Integer> cardsStartIndex = new HashMap<>();

        int end = 0;

        while (end < n) {

            int card = cards[end];

            //if a card already seen before and curr card now, is repeated then
            //we need to calculate the min cards to pick between this curr card
            //and starting index of same card that already existed
            if (cardsStartIndex.containsKey(card)) {
                //window of cards picked = end - start + 1
                //end = index of curr card
                //start = index of same card that already existed
                //(==> cardsStartIndex.get(cardValue))

                //minimize the cards picked
                minCardsPickUp = Math.min(minCardsPickUp, end - cardsStartIndex.get(card) + 1);
            }

            //update the card(if already existed) with new start index that is
            //now @end
            //OR this curr card might have been seen first time here so simply
            //put it as first occuerence @end
            cardsStartIndex.put(card, end);

            end++;
        }
        //output
        minCardsPickUp = minCardsPickUp == Integer.MAX_VALUE ? -1 : minCardsPickUp;
        System.out.println("Min consecutive cards to pick between cards with same value: "
                + minCardsPickUp);
    }

    public void destroySequentialTarget(int[] nums, int space) {
        //https://leetcode.com/problems/destroy-sequential-targets/
        //https://leetcode.com/problems/destroy-sequential-targets/discuss/2773080/Counter-or-Python
        /*
        given this equation:

        nums[i] + c * space
        apply % space to above equation
        ==> (nums[i] + c * space) % space
        ==> nums[i] % space + (c * space) % space
        ==> nums[i] % space + 0
        ==> ** (c * space) % space, here c is multiple of space hence whole
        c * space is divisible by space hence its mod with space is 0

         */
        int maxFreq = 0;
        Map<Integer, Integer> destroyFreq = new HashMap<>();
        for (int val : nums) {
            int destroy = val % space;
            destroyFreq.put(destroy, destroyFreq.getOrDefault(destroy, 0) + 1);
            maxFreq = Math.max(maxFreq, destroyFreq.get(destroy));
        }

        int minSeedVal = Integer.MAX_VALUE;
        for (int val : nums) {
            int destroy = val % space;
            if (destroyFreq.get(destroy) == maxFreq) {
                minSeedVal = Math.min(minSeedVal, val);
            }
        }
        //output
        System.out.println("Destroy sequential target: " + minSeedVal);
    }

    public void singleElementInSortedArray(int[] nums) {
        //https://leetcode.com/problems/single-element-in-a-sorted-array/
        //https://leetcode.com/problems/single-element-in-a-sorted-array/discuss/2803159/Single-Element-In-A-Sorted-Array-or-C%2B%2B-or-O(logn)or-Binary-Search
        //based on BINARY SEARCH
        int n = nums.length;
        int start = 0;
        int end = n - 1;
        while (end > start) {
            int mid = start + (end - start) / 2;
            if ((mid % 2 == 0 && nums[mid] == nums[mid + 1])
                    || (mid % 2 == 1 && nums[mid] == nums[mid - 1])) {
                start = mid + 1;
            } else {
                end = mid;
            }
        }
        //output
        System.out.println("Single element in sorted array : " + nums[start]);
    }

    public void maxSumOfDistinctSubarrayOfLengthK(int[] nums, int k) {
        //https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/
        //based on SLIDING WINDOW
        int n = nums.length;

        int start = 0;
        int end = 0;

        Map<Integer, Integer> windowDistinctVals = new HashMap<>();

        long currWindowSum = 0;

        //process the first window of k-length having sum of k-length subarray
        //as 'currWindowSum' and distinct values stored as val-freqs in max
        for (; end < k; end++) {
            currWindowSum += nums[end];
            windowDistinctVals.put(nums[end], windowDistinctVals.getOrDefault(nums[end], 0) + 1);
        }

        //if the first window of k-length subarray has all distinct 'val' then
        //val-freqs max size will be same as k itself and hence first max sum
        //can be assigned with currWindowSum otherwise remain 0
        long maxKDistinctNumsSum = (windowDistinctVals.size() == k)
                ? currWindowSum
                : 0;

        //process further windows
        while (end < n) {

            //maintain the window of k-length subarray by adjusting start and end
            //ptr
            //value @end should be added to curr window and 'currWindowSum' to be
            //updated
            currWindowSum += nums[end];
            //since value @end is add into curr window, it should also be put in
            //val-freqs map
            windowDistinctVals.put(nums[end], windowDistinctVals.getOrDefault(nums[end], 0) + 1);

            //shrink the window @start and 'currWindowSum' should be reduced with
            //value @start
            currWindowSum -= nums[start];
            //since value @start is reduced from curr window, it should also be
            //reduced in val-freqs map
            windowDistinctVals.put(nums[start], windowDistinctVals.getOrDefault(nums[start], 0) - 1);
            //if after reducing a value @start its freqs is 0 means that value has
            //gone out of the window of k-length subarray hence val-freqs should
            //remove those value @start
            if (windowDistinctVals.get(nums[start]) <= 0) {
                windowDistinctVals.remove(nums[start]);
            }

            //maintain the window by moving start & end ptr
            end++;
            start++;

            //if curr window of k-length subarray hold all values distinct, then
            //val-freqs map size will be same as k
            if (windowDistinctVals.size() == k) {
                maxKDistinctNumsSum = Math.max(maxKDistinctNumsSum, currWindowSum);
            }

        }
        //output
        System.out.println("Max sum of distinct subarray of length k: " + maxKDistinctNumsSum);
    }

    public void longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(int[] nums, int limit) {
        //..........................T: O(N*LogN), N is length of nums[]
        //..........................S: O(N), N is length of nums[]
        //worst case can be where nums[] contains the same value
        //https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
        //https://practice.geeksforgeeks.org/problems/close-to-perfection1525/1
        //based on SLIDING WINDOW
        int n = nums.length;
        int start = 0;
        int end = 0;
        //tree map stores the key in sorted order and fetching the min & max value
        //is easily possible
        TreeMap<Integer, Integer> minMax = new TreeMap<>();
        int maxLen = 0;

        while (end < n) {

            minMax.put(nums[end], minMax.getOrDefault(nums[end], 0) + 1);

            //treemap stores the nums[] value as key and keep it in sorted order
            //min is at root and max will be in last
            int min = minMax.firstKey();
            int max = minMax.lastKey();

            //shink the window size when the dif of min & max value is greater than limit
            while (start < end && max - min > limit) {
                minMax.put(nums[start], minMax.getOrDefault(nums[start], 0) - 1);
                if (minMax.get(nums[start]) <= 0) {
                    minMax.remove(nums[start]);
                }
                start++;
                //update the new min & max
                min = minMax.firstKey();
                max = minMax.lastKey();
            }
            maxLen = Math.max(maxLen, end - start + 1);
            end++;
        }
        //output
        System.out.println("Max length of subarray where the diff of its min & max value is atmost 1: " + maxLen);
    }

    public void countSubarraysWithFixedBounds(int[] nums, int minK, int maxK) {
        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/
        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/discuss/2784063/PYTHON-SOLUTION-100-EXPLAINED-LINE-BY-LINE
        //based on SLIDING WINDOW
        int n = nums.length;
        int start = 0;
        int end = 0;
        long count = 0;
        int minValIndex = -1;
        int maxValIndex = -1;

        while (end < n) {
            //run the loop till the nums[end] is in the bounds of [minK..nums[end]..maxK]
            while (end < n && (minK <= nums[end] && nums[end] <= maxK)) {

                if (nums[end] == minK) {
                    minValIndex = end;
                }

                if (nums[end] == maxK) {
                    maxValIndex = end;
                }

                if (minValIndex != -1 && maxValIndex != -1) {
                    count += (Math.min(minValIndex, maxValIndex) - start + 1);
                }

                end++;
            }

            //since the above loop will break when there is a nums[end] not in
            //the [minK, maxK] bound so we also don't need this curr end index
            //that is not in bounds, so move to next end index == end + 1
            end += 1;
            start = end;
            //reset
            minValIndex = maxValIndex = -1;
        }
        //output
        System.out.println("Subarrays that in the fixed bounds: " + count);
    }

    private int circularArrayLoop_nextIndex(int[] nums, int index, boolean isFrontDir) {
        int n = nums.length;

        int nextIndex = (index + nums[index]) % n;

        if (nextIndex < 0) {
            nextIndex = n + nextIndex;
        }

        if (index == nextIndex) {
            return -1;
        }

        boolean nextDir = nums[nextIndex] >= 0;

        if (nextDir != isFrontDir) {
            return -1;
        }

        return nextIndex;
    }

    public boolean circularArrayLoop(int[] nums) {
        //https://leetcode.com/problems/circular-array-loop/
        //https://leetcode.com/problems/circular-array-loop/discuss/2820902/Circular-Array-problem-solved-(Java)
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            boolean isFrontDir = nums[i] >= 0;
            int slow = i;
            int fast = i;
            while (true) {

                slow = circularArrayLoop_nextIndex(nums, slow, isFrontDir);
                if (slow == -1) {
                    break;
                }

                int tempFast = circularArrayLoop_nextIndex(nums, fast, isFrontDir);
                if (tempFast == -1) {
                    break;
                }

                fast = circularArrayLoop_nextIndex(nums, fast, isFrontDir);
                if (fast == -1) {
                    break;
                }

                if (slow == fast) {
                    return true;
                }
            }
        }
        return false;
    }

    public void findPlayerWithZeroOrOneLosses(int[][] matches) {
        //https://leetcode.com/problems/find-players-with-zero-or-one-losses/
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> wonAllMatches = new ArrayList<>();
        List<Integer> lostOnlyOneMatches = new ArrayList<>();

        Map<Integer, Integer> winners = new HashMap<>();
        Map<Integer, Integer> loosers = new HashMap<>();

        int minPlayer = Integer.MAX_VALUE;
        int maxPlayer = Integer.MIN_VALUE;

        for (int[] match : matches) {

            int winner = match[0];
            int looser = match[1];

            //with minPlayer and maxPlayer we figuring out the range of players
            //who played matches
            minPlayer = Math.min(minPlayer, Math.min(winner, looser));
            maxPlayer = Math.max(maxPlayer, Math.max(winner, looser));

            //winners map will have all the players who won
            winners.put(winner, winners.getOrDefault(winner, 0) + 1);
            //loosers map will have all the players who lost
            loosers.put(looser, loosers.getOrDefault(looser, 0) + 1);
        }

        //from the range of players
        for (int player = minPlayer; player <= maxPlayer; player++) {
            //a player who won AND never lost is the one who won all the matches
            if (winners.containsKey(player) && !loosers.containsKey(player)) {
                wonAllMatches.add(player);
            } else if (loosers.containsKey(player) && loosers.get(player) == 1) {
                //a player who never won BUT lost only 1 times is the one who
                //lost only one match
                lostOnlyOneMatches.add(player);
            }
        }

        result.add(wonAllMatches);
        result.add(lostOnlyOneMatches);

        //output
        System.out.println("Players with 1) zero loss & 2) one loss:  " + result);
    }

    public void removeCoveredIntervals(int[][] intervals) {
        //https://leetcode.com/problems/remove-covered-intervals/
        //https://leetcode.com/problems/remove-covered-intervals/discuss/2749987/intuitive-solution-using-python
        /*

        intervals = [[1,2],[1,4],[3,4]]

        sort(interval) = [[1,4],[1,2],[3,4]]

        prevStart = 1, prevEnd = 4

        ranges:

        ..........1.................4
        ..........1.....2
        ......................3.....4

        now with above sorting, we get the initial max interval range as prev
        start & end, here [1,4]

        further we can check, any other intervals coming after this is covered
        into this prev interval or not, if covered, incr count

         */
        int n = intervals.length;
        //sort on incr start time, if start time are same then sort them on decr
        //order of end time other incr order of start time
        Arrays.sort(intervals, (a, b) -> a[0] == b[0]
                ? Integer.compare(b[1], a[1])
                : Integer.compare(a[0], b[0]));

        int intervalCovered = 0;

        int prevStart = intervals[0][0];
        int prevEnd = intervals[0][1];

        //The interval [currStart, currEnd) is covered by the interval [prevStart, prevEnd)
        //if and only if prevStart <= currStart and currEnd <= prevEnd.
        for (int i = 1; i < n; i++) {

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (prevStart <= currStart && currEnd <= prevEnd) {
                intervalCovered++;
                prevEnd = Math.max(prevEnd, currEnd);
            } else {
                prevStart = currStart;
                prevEnd = currEnd;
            }
        }
        //output
        System.out.println("After removing crossovered intervals, remaining intervals: " + (n - intervalCovered));
    }

    public void taskSchedulerTwo(int[] tasks, int space) {
        //https://leetcode.com/problems/task-scheduler-ii/
        //https://leetcode.com/problems/task-scheduler-ii/discuss/2842466/Java-using-HashMap-time-complexity-O(n)
        Map<Integer, Long> taskDays = new HashMap<>();
        long days = 0;
        for (int task : tasks) {

            if (!taskDays.containsKey(task) || (days - taskDays.get(task) > (long) space)) {
                taskDays.put(task, days);
            } else if (taskDays.containsKey(task)) {
                long waitDays = (long) space - days + taskDays.get(task) + 1L;
                days += waitDays;
                taskDays.put(task, days);
            }
            days++;
        }
        //output
        System.out.println("Min days required: " + days);
    }

    public void minAverageDiff(int[] nums) {
        //https://leetcode.com/problems/minimum-average-difference/
        //based on PREFIX SUM
        int n = nums.length;

        long[] prefixSumArr = new long[n];
        long prefixSum = 0;

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            prefixSumArr[i] = prefixSum;
        }

        long totalSum = prefixSum;
        int minIndex = n + 1;
        long minAbsAvgDiff = Long.MAX_VALUE;

        for (int i = 0; i < n; i++) {

            long leftAvg = prefixSumArr[i] / (long) (i + 1);

            //to prevent / 0 when i = n - 1 and (n - i - 1) == 0
            long rightAvg = (i == n - 1)
                    ? 0
                    : (totalSum - prefixSumArr[i]) / (long) (n - i - 1);

            long currAbsAvgDiff = Math.abs(leftAvg - rightAvg);

            if (currAbsAvgDiff < minAbsAvgDiff) {
                minAbsAvgDiff = currAbsAvgDiff;
                minIndex = i;
            }
        }
        //output
        System.out.println("Min absolute average difference: " + minIndex);
    }

    private int maxPairSumWithEqualDigitSum_DigitSum(int val) {
        int digitSum = 0;
        while (val > 0) {
            digitSum += (val % 10);
            val /= 10;
        }
        return digitSum;
    }

    public void maxPairSumWithEqualDigitSum(int[] nums) {
        //https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/
        /*

        nums[] = [18,43,36,13,7]
        digitSum:
        18 == 1 + 8 = 9
        43 == 4 + 3 = 7
        36 == 3 + 6 = 9
        13 == 1 + 3 = 4
        7 == 7 = 7
        digitSumWithVals: {9 = [18, 36], 7 = [43, 7], 4 = [13]}

         */
        //group all the values in nums[] whose val's sum of digit are same
        Map<Integer, PriorityQueue<Integer>> digitsSumToVals = new HashMap<>();

        for (int val : nums) {

            int digitSum = maxPairSumWithEqualDigitSum_DigitSum(val);

            digitsSumToVals.putIfAbsent(digitSum, new PriorityQueue<>());

            //same as maintaining k-largest values in min heap
            digitsSumToVals.get(digitSum).add(val);
            //to have max pair sum, we maintain k = 2 largest vals in min heap
            //for those vals whose digits sum is same
            if (digitsSumToVals.get(digitSum).size() > 2) {
                digitsSumToVals.get(digitSum).poll();
            }
        }

        //default is -1, if no such pair can be formed
        int maxPairSum = -1;
        for (PriorityQueue<Integer> vals : digitsSumToVals.values()) {
            //skip, if we don't have k-largest vals in min heap
            if (vals.size() < 2) {
                continue;
            }

            int currPairSum = vals.poll() + vals.poll();
            maxPairSum = Math.max(maxPairSum, currPairSum);
        }
        //output
        System.out.println("Max pair sum with digit sum: " + maxPairSum);
    }

    public void maxChunkToMakeSorted(int[] arr) {
        //https://leetcode.com/problems/max-chunks-to-make-sorted/description/
        //https://leetcode.com/problems/max-chunks-to-make-sorted/solutions/113528/simple-java-o-n-solution-with-detailed-explanation/
        /*
        given an integer array arr of length n that represents a permutation of
        the integers in the range [0, n - 1]

        this algorithm wants us to do is finding some splitting line so that
        numbers being left of this line are all small than numbers right of this
        line. The idea is very similar to quick sort. What the answer of this
        question is how many lines you can find. So that is why we want the max
        array, or we can only need a number for storing the maximum number up to
        now(because original array is 0 to len-1), as long as the max number
        equals the index, we know that all numbers left to this point are smaller
        than this point and numbers right to this point are larger than this point,
        then we count add one.
         */
        int n = arr.length;
        int chunks = 0;
        int maxVal = 0;
        for (int i = 0; i < n; i++) {
            maxVal = Math.max(maxVal, arr[i]);
            if (maxVal == i) {
                chunks++;
            }
        }
        //output
        System.out.println("Max chunks to make arr sorted: " + chunks);
    }

    public void maxChunkToMakeSortedTwo(int[] arr) {
        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/
        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/solutions/2821654/advance-sorting-technique/
        int n = arr.length;
        int[] minFromRight = new int[n + 1];
        Arrays.fill(minFromRight, Integer.MAX_VALUE);
        for (int i = n - 1; i >= 0; i--) {
            minFromRight[i] = Math.min(minFromRight[i + 1], arr[i]);
        }

        int maxOnLeft = Integer.MIN_VALUE;
        int chunks = 0;

        for (int i = 0; i < n; i++) {
            maxOnLeft = Math.max(maxOnLeft, arr[i]);
            if (maxOnLeft <= minFromRight[i + 1]) {
                chunks++;
            }
        }
        //output
        System.out.println("Max chunks to make arr sorted two: " + chunks);
    }

    public void minIncreamentToMakeArrayUnique(int[] nums) {
        //https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/
        /*
        ex: num = [3,2,1,2,1,7]
        sort(nums) = [1,1,2,2,3,7]
        uniqVal = nums[0] = 1
        #1.
        val = 1, uniqVal = 1
        req increament: incr = max(0, uniqVal - val) ==> max(0, 1 - 1) = 0;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(1 + 1, 1 + 1) = 2

        #2.
        val = 1, uniqVal = 2
        //means for arr to be unique we need a value 2 but curr value is still 1
        req increament: incr = max(0, uniqVal - val) ==> max(0, 2 - 1) = 1;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(2 + 1, 1 + 1) = 3

        #3.
        val = 2, uniqVal = 3
        //means for arr to be unique we need a value 3 but curr value is 2
        req increament: incr = max(0, uniqVal - val) ==> max(0, 3 - 2) = 1;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(3 + 1, 2 + 1) = 4

        #4.
        val = 2, uniqVal = 4
        //means for arr to be unique we need a value 4 but curr value is 2
        req increament: incr = max(0, uniqVal - val) ==> max(0, 4 - 2) = 2;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(4 + 1, 2 + 1) = 5

        #5.
        val = 3, uniqVal = 5
        //means for arr to be unique we need a value 5 but curr value is 3
        req increament: incr = max(0, uniqVal - val) ==> max(0, 5 - 3) = 2;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(5 + 1, 3 + 1) = 6

        #5.
        val = 7, uniqVal = 6
        req increament: incr = max(0, uniqVal - val) ==> max(0, 6 - 7) = 0;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(6 + 1, 7 + 1) = 8

        incr = 0 + 1 + 1 + 2 + 2 + 0 ==> 6
         */
        Arrays.sort(nums);
        int incr = 0;
        //unique value in the array should starts from first smallest value in
        //curr arr[] after sorting
        int uniqueVal = nums[0];
        for (int val : nums) {
            //incr req from curr val to the req unique value
            incr += Math.max(0, uniqueVal - val);
            //next unique value required to be in the array
            uniqueVal = Math.max(uniqueVal + 1, val + 1);
        }
        //output
        System.out.println("Min increament to make array unique: " + incr);
    }

    public void validateStackSequences(int[] pushed, int[] popped) {
        //........................T: O(N)
        //........................T: O(N), for using a stack
        //https://leetcode.com/problems/validate-stack-sequences/description/
        int n = popped.length;

        int j = 0;

        Stack<Integer> stack = new Stack<>();

        for (int val : pushed) {
            stack.push(val);
            //if stack has some data and also if pop seq at j-th index is same as
            //what we have at stack.peek, then actually pop it from stack move j
            //to next popped seq (== j++)
            while (!stack.isEmpty() && stack.peek() == popped[j]) {
                stack.pop();
                j++;
            }
        }

        //output
        System.out.println("Validate stack seq: " + stack.isEmpty());
    }

    public void validateStackSequences2(int[] pushed, int[] popped) {
        //........................T: O(N)
        //........................T: O(1)
        //OPTIMIZED
        //https://leetcode.com/problems/validate-stack-sequences/description/
        //https://leetcode.com/problems/validate-stack-sequences/solutions/1853250/java-c-space-complexity-going-from-o-n-o-1/
        int n = popped.length;

        int i = 0;
        int j = 0;

        for (int val : pushed) {
            //i++ simulates pushing a i-th value in stack and moving to next seq
            //in pushed seq
            pushed[i++] = val;
            //since i moved to next pushed seq but pushed[i - 1] value is stack's
            //peek value, if that peek value is same as what is needed to be popped
            //from popped seq at j-th index pop that and move to next pop value in
            //popped seq
            while (i > 0 && pushed[i - 1] == popped[j]) {
                i--;
                j++;
            }
        }

        //output
        System.out.println("Validate stack seq: " + (i == 0));
    }

    public void minMovesToEqualArrayElements(int[] nums) {
        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
        int n = nums.length;
        int moves = 0;

        int minVal = Integer.MAX_VALUE;
        for (int val : nums) {
            minVal = Math.min(minVal, val);
        }

        for (int i = 0; i < n; i++) {
            moves += nums[i] - minVal;
        }
        //output
        System.out.println("Min moves to equal array elements: " + moves);
    }

    public void minMovesToMakeArrayEqualTwo(int[] nums) {
        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/
        //based on MATHS
        /*
        How?
        nums[] = [1,10,2,9]
        sort(nums) = [1,2,9,10]

        choose val = 1 as convertVal
        ==> move[i] = abs(convertVal - nums[i])

        val = 1 ==> moves[] = [0, 1, 8, 9] ==> total = 18
        val = 2 ==> moves[] = [1, 0, 7, 8] ==> total = 16
        val = 9 ==> moves[] = [8, 7, 0, 1] ==> total = 16
        val = 10 ==> moves[] = [9, 8, 1, 0] ==> total = 18

        we this observations we need to make all the nums[i] same & with min moves
        that will only possible if we choose convertVal as a mindian value of
        sorted nums[]

         */
        int n = nums.length;

        Arrays.sort(nums);

        int medianIndex = n % 2 == 0 ? (n - 1) / 2 : n / 2;

        int medianVal = nums[medianIndex];

        int moves = 0;

        for (int val : nums) {
            moves += Math.abs(medianVal - val);
        }

        //output
        System.out.println("Min moves to make array equal II : " + moves);
    }

    public void intervalsListIntersection(int[][] firstList, int[][] secondList) {
        //.............................T: O(M + N), M & N length of firstList & secondList
        //https://leetcode.com/problems/interval-list-intersections/description/
        //based on TWO POINTER
        /*
        ex:
        firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
        firstList:  0----2   5-----10     13-----23  24---25
        secondList:   1------5   8-----12     15-----24   25---26

        start = max(firstList[start], secondList[start])
        end = min(firstList[end], secondList[end])

        start = max(0, 1) = 1, end = min(2, 5) = 2  ==> intersection = [1,2]
        firstList[end] > secondList[end] ==> 2 > 5 ==> i++ ==> firstList next slot = [5,10]

        start = max(5, 1) = 5, end = min(5, 10) = 5  ==> intersection = [5,5]
        firstList[end] > secondList[end] ==> 10 > 5 ==> j++ ==> secondList next slot = [8,12]
        .
        .
        .
        same....

        intersections: [1, 2],[5,5],[8,10],[15,23],[24,24],[25,25]

         */
        int m = firstList.length;
        int n = secondList.length;

        //start & end time indexes in given list
        int START = 0;
        int END = 1;

        int i = 0;
        int j = 0;

        List<int[]> intervalIntersections = new ArrayList<>();

        while (i < m && j < n) {

            //start & end time of the intersecting time from first & second list
            int start = Math.max(firstList[i][START], secondList[j][START]);
            int end = Math.min(firstList[i][END], secondList[j][END]);

            //take only valid intersections
            if (end >= start) {
                intervalIntersections.add(new int[]{start, end});
            }

            //if firstList end time is greater than secondList end time
            //move next time slot in secondList(== j++) to compare with firstList
            //else move next time slot in firstList(== i++) to compare with secondList
            if (firstList[i][END] > secondList[j][END]) {
                j++;
            } else {
                i++;
            }
        }
        //output
        //return intervalIntersections.toArray(new int[intervalIntersections.size()][2]);
        if (intervalIntersections.isEmpty()) {
            System.out.println("No intersections possible");
            return;
        }

        for (int[] intersection : intervalIntersections) {
            System.out.print(Arrays.toString(intersection) + " ");
        }
        System.out.println();
    }

    public void countPairsWithAbsoluteDiffDivisibleByK(int[] nums, int k) {
        //https://practice.geeksforgeeks.org/problems/e0059183c88ab680b2f73f7d809fb8056fe9dc43/1
        //https://www.geeksforgeeks.org/count-pairs-in-an-array-whose-absolute-difference-is-divisible-by-k/
        /*
        1. Convert each elements (A[i]) of the array to ((A[i]+K)%K)
        2. Use hashing technique to store the number of times (A[i]%K) occurs in the array
        3. Now, if an element A[i] occurs row times in the array then add row*(row-1)/2
        (choosing any 2 elements out of row elements ) in the count pair where 1<=i<=n.
        This is because value of each elements of the array lies between 0 to K-1
        so the absolute difference is divisible only if value of both the elements
        of a pair are equal
         */
        int n = nums.length;
        long pairs = 0;
        int[] hash = new int[k];

        for (int i = 0; i < n; i++) {
            nums[i] = (nums[i] + k) % k;
        }

        for (int rem : nums) {
            hash[rem]++;
        }

        for (int i = 0; i < k; i++) {
            pairs += (hash[i] * (hash[i] - 1)) / 2;
        }

        //output
        System.out.println("Pairs with absolute diff divisible by k: " + pairs);
    }

    private boolean removeOneElementMakeArrayStrictlyIncr_IsStrictlyIncr(int[] nums, int skipIndex) {
        int n = nums.length;
        int prevVal = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (i == skipIndex) {
                continue;
            }
            if (prevVal >= nums[i]) {
                return false;
            }
            prevVal = nums[i];
        }
        return true;
    }

    public boolean removeOneElementMakeArrayStrictlyIncr(int[] nums) {
        //https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/description/
        int n = nums.length;
        //starting from -1 will basically consider all nums[] to be checked
        //rest other indexes 0 to n - 1 will be skipped iteratively
        //if removing the skip-index make it strictly incr then true
        for (int skipIndex = -1; skipIndex < n; skipIndex++) {
            //if skipping this skipIndex will make the nums[] strictly incr
            //checking if nums[] is strictly incr if val at skipIndex is assumed
            //to be removed
            if (removeOneElementMakeArrayStrictlyIncr_IsStrictlyIncr(nums, skipIndex)) {
                System.out.println("Remove " + nums[skipIndex]
                        + " to make " + Arrays.toString(nums) + " stictly incr");
                return true;
            }

        }
        return false;
    }

    public void dataStreamAsDisjointIntervals(List<String> commands, List<Integer> values) {
        //https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/
        class Helper {

            Set<Integer> values;

            public Helper() {
                this.values = new TreeSet<>();
            }

            //keep all the incoming interval value in sorted order
            //because we will need to calculate all those intervals which are
            //forming disjoint intervals
            public void addNum(int num) {
                values.add(num);
            }

            public int[][] getIntervals() {

                if (values.isEmpty()) {
                    return new int[][]{};
                }

                //initial start & end of curr interval
                int start = -1;
                int end = -1;
                List<int[]> intervals = new ArrayList<>();

                for (int value : values) {

                    //a default case when we start, for the first interval in
                    //values list, this first interval becomes start & end of
                    //curr interval, for later comming value from values we need
                    //to check if that comming next value is joining with curr end
                    if (start < 0) {
                        start = end = value;
                    } else if (value == end + 1) {
                        //if the curr value is same as prev end + 1 then this value
                        //gets consumed in the curr interval of [start, end] hence
                        //end = value
                        end = value;
                    } else {
                        //if curr value != prev end + 1, means this curr value is
                        //forming a disjoint because it can't be included in the
                        //curr ongoing interval [start, end]
                        //so we add curr interval in list
                        intervals.add(new int[]{start, end});
                        //start the next disjoint interval with curr value
                        start = end = value;
                    }
                }

                intervals.add(new int[]{start, end});
                return intervals.toArray(new int[0][]);
            }

        }

        Helper helper = new Helper();
        for (int i = 0; i < commands.size(); i++) {

            String command = commands.get(i);
            int value = values.get(i);

            if (command.equals("addNum")) {
                helper.addNum(value);
            } else {
                int[][] intervals = helper.getIntervals();
                for (int[] interval : intervals) {
                    System.out.print(Arrays.toString(interval));
                }
                System.out.println();
            }
        }
    }

    public long dividePlayersIntoTeamsOfEqualSkill(int[] skill) {
        //https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/description/
        //based on TWO POINTER
        int n = skill.length;
        if (n == 2) {
            return skill[0] * skill[1];
        }

        long totalSum = 0;
        for (int val : skill) {
            totalSum += val;
        }

        //as length of skill(== n) is even so teams is number of pairs
        long teams = n / 2;

        //if the whole array sum can't be divided among the number of teams we have
        //means sum of each pair of our teams == totalSum
        if (totalSum % teams != 0) {
            return -1;
        }

        long eachTeamSum = totalSum / teams;

        Arrays.sort(skill);

        int start = 0;
        int end = n - 1;
        long chemistry = 0;

        while (end > start) {
            if (skill[start] + skill[end] == eachTeamSum) {
                chemistry += (skill[start] * skill[end]);
                start++;
                end--;
            } else {
                return -1;
            }
        }
        return chemistry;
    }

    public void countOddNumbersInIntervalRange(int low, int high) {
        //https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/
        //https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/solutions/2957338/count-odd-numbers-in-an-interval-range/
        //based on MATH concept, and test for code optimization using this concept
        /*
        brute force approach seems simple
        run loop from [low to high] and check for each value, if its odd then
        update oddCount

        but here we will optimize code using some MATH concepts

        Intuition:

        let X be odd number
        next even number after X is X + 1 and next odd after this X + 1 + 1

        odd1, even1, odd2, even2, odd3
        X, X + 1, X + 2, X + 3, X + 4....

        so firstly, if the low value is even (==> low % 2 == 0) move to next odd
        low value ==> low++

        and as seen above odd & even are alternating and consider this ex
        low = 1, high = 5

        numbers = 1, 2, 3, 4, 5
        in this range total odd numbers are ((high - low) / 2) + 1
        ==> ((5 - 1) / 2) + 1

         */
        //if low is even then incr by 1
        if (low % 2 == 0) {
            low++;
        }
        int oddCount = low > high ? 0 : ((high - low) / 2) + 1;
        //output
        System.out.println("Odd count in interval range : " + oddCount);
    }

    public void maxSubarraySumWithAtmostOneDeletion(int[] arr) {
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/solutions/377397/intuitive-java-solution-with-explanation/
        //based on KADEN'S Algo
        int n = arr.length;
        int oneDelete = 0;
        int noDelete = arr[0];
        int maxSum = arr[0];

        for (int i = 1; i < n; i++) {
            oneDelete = Math.max(oneDelete + arr[i], noDelete);
            noDelete = Math.max(noDelete + arr[i], arr[i]);
            maxSum = Math.max(maxSum, Math.max(oneDelete, noDelete));
        }
        //output
        System.out.println("Max subarray sum with atmost one deletion: " + maxSum);
    }

    private int successfulPairsOfSpellsAndPotions_BinarySearch(int[] potions, long spell, long success) {

        int m = potions.length;
        int start = 0;
        int end = m - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //with curr 'mid' value of potions[] we assume that potions[mid] * spell
            //is 'atleast success' means (potions[mid] * spell greater or equal to success)
            //if this case is TRUE then it would also means the spell with a previous
            //potion from curr 'mid' should be strictly less than 'success'
            //(potions[mid - 1] * spell < success) BUT there if mid exist at index 0
            //then this previous mid (==> mid - 1) is not valid hence check (mid == 0)
            if ((mid == 0 || potions[mid - 1] * spell < success) && success <= potions[mid] * spell) {
                return mid;
            } else if (potions[mid] * spell < success) {
                //if curr potion[mid] with spell is smaller than the given 'success'
                //we need to get close to that 'success' as (potions[mid] * spell)
                //is 'atleast success' so for that move search space to right-side
                //for 'mid' value and get larger potions[mid] value
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        //no successful pair found
        return -1;
    }

    public void successfulPairsOfSpellsAndPotions(int[] spells, int[] potions, long success) {
        //https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/
        //based on BINARY SEARCH
        int n = spells.length;
        int m = potions.length;

        int[] countPairs = new int[n];

        Arrays.sort(potions);

        for (int i = 0; i < n; i++) {

            int foundIndex = successfulPairsOfSpellsAndPotions_BinarySearch(potions, spells[i], success);
            //foundIndex == -1 means there is no successful pair found for curr
            //spell[i] with potions[]
            countPairs[i] = foundIndex == -1 ? 0 : m - foundIndex;
        }

        //output
        System.out.println("Successful pairs of spells and potions: " + Arrays.toString(countPairs));
    }

    private int smallerSumThanEachValueInArray_BinarySearch(int[] nums, int find) {
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //the can be duplicated values in nums[] so we need to find the first
            //occuerence of 'find'
            if ((mid == 0 || nums[mid - 1] < find) && nums[mid] == find) {
                return mid;
            } else if (nums[mid] < find) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }

    public void smallerSumThanEachValueInArray(int[] nums) {
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        //based on BINARY SEARCH, findFirstOccurenceKInSortedArray()
        int n = nums.length;
        int[] originalNums = nums.clone();
        long[] result = new long[n];
        long[] prefixSumArr = new long[n];
        int prefixSum = 0;

        //we will sort the nums[] and precompute its prefix sum array, this
        //prefix sum array will help us find the sum of inetgers smaller than
        //the each value in originalNums[i] easily
        Arrays.sort(nums);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            prefixSumArr[i] = prefixSum;
        }

        for (int i = 0; i < n; i++) {
            //now originalNums[] & nums[] are both the same array having same values
            //the diff is that nums[] is now sorted only to compute prefix sum array
            //since, both array are same then any value of originalNums[i] will also
            //be present in nums[] in sorted manner, we can exactly find the first
            //occuerence of the originalNum[i] == find value in sorted nums[], that
            //way, to the left this 'index' (means [0 to index - 1]) are the elements
            //which are smaller than 'find' value and (index - 1) on prefixSumArr will
            //give the sum of integers. Except for index = 0 because there are no elements
            //before this index hence sum of integers is always 0 for first index
            int find = originalNums[i];
            int index = smallerSumThanEachValueInArray_BinarySearch(nums, find);
            //also to note, as its clear that both originalNums[] & nums[] are same arr
            //so finding a value from originalNums[i] in nums[] will always get us a valid
            //index hence index == -1 is not possible in this case
            //And, results[] should be based on values present in originalNums[]
            result[i] = (index == 0) ? 0 : prefixSumArr[index - 1];
        }
        //output
        System.out.println("Sum of integers for each value smaller than nums[i] : "
                + Arrays.toString(result));
    }

    public void smallerSumThanEachValueInArray_HashMapBased(int[] nums) {
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        //based on HASHMAP, O(1) for search the first-occuerence of elements in
        //original nums[]
        int n = nums.length;
        int[] originalNums = nums.clone();
        Map<Integer, Integer> sortedElementIndex = new HashMap<>();
        long[] result = new long[n];
        long[] prefixSumArr = new long[n];
        int prefixSum = 0;

        //we will sort the nums[] and precompute its prefix sum array, this
        //prefix sum array will help us find the sum of inetgers smaller than
        //each value in originalNums[i] easily
        //also store the unique array element in hashmap and only first-occuerence
        //index of that element will be stored (similar to what we doing with
        //binary search)
        Arrays.sort(nums);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            prefixSumArr[i] = prefixSum;
            //store first-occuerence index of nums[i], if we have duplicates their
            //first-occuerence index will only be stored
            sortedElementIndex.putIfAbsent(nums[i], i);
        }

        for (int i = 0; i < n; i++) {
            //first-occuerence of originalNums[i] from the sorted element map
            int index = sortedElementIndex.get(originalNums[i]);
            result[i] = (index == 0) ? 0 : prefixSumArr[index - 1];
        }
        //output
        System.out.println("Sum of integers for each value smaller than nums[i] (HashMap Based): "
                + Arrays.toString(result));
    }

    public void nearestSmallerTower(int[] heights) {
        //https://practice.geeksforgeeks.org/problems/a520c08a8ea9b617be25c38b0fc2fe057e889253/1
        //based on nearest smaller value in left and in right
        int n = heights.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];

        //nearest smaller value in left
        //this will fill a smaller tower present in left of the curr heights[i]
        //and fill that smaller tower's index in result[i]
        for (int i = 0; i < n; i++) {

            int height = heights[i];

            while (!stack.isEmpty() && heights[stack.peek()] >= height) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }

        stack.clear();

        //nearest smaller value in right
        //this will fill a smaller tower present in right of the curr heights[i]
        //and fill that smaller tower's index in result[i] but here's a catch
        //we have already calculated smaller in left side now we have to choose
        //which one to pick from, left or right smaller towers
        for (int i = n - 1; i >= 0; i--) {

            int height = heights[i];

            while (!stack.isEmpty() && heights[stack.peek()] >= height) {
                stack.pop();
            }

            //if the stack is empty, means for curr heights[i] there is no smaller
            //tower in right but we might have a smaller tower to curr heights[i]
            //in its left side, so keep that only
            //else if stack is not empty
            if (!stack.isEmpty()) {
                //if for curr heights[i] there was no smaller tower in left side
                //because currently result[i] == -1 calculated for left side but
                //here we do have a smaller tower in its right so update result[i]
                if (result[i] == -1) {
                    result[i] = stack.peek();
                } else {
                    //1. If two smaller towers are at the same distance, pick the smallest tower.
                    //2. If two towers have the same height then we choose the one with a smaller index.
                    if (Math.abs(result[i] - i) == Math.abs(i - stack.peek())) {
                        //if from curr heights[i] the dist to smaller tower in its
                        //left and in its right is same then we check if the
                        //height of the right side tower(heights[stack.peek()]) is
                        //smaller than left side tower(heights[result[i]]) then only
                        //update result[i] otherwise result[i] is already
                        //holding the smaller tower index from its left side
                        if (heights[result[i]] > heights[stack.peek()]) {
                            result[i] = stack.peek();
                        }
                    } else if (Math.abs(result[i] - i) > Math.abs(i - stack.peek())) {
                        //if the dist of smaller tower in curr heights[i] right side
                        //is smaller than the dist of smaller tower in its left then
                        //update the index of right side tower in result[i] that is
                        //also closer to curr heights[i]
                        result[i] = stack.peek();
                    }
                }
            }
            stack.push(i);
        }
        //output
        System.out.println("Nearest smallest tower : " + Arrays.toString(result));
    }

    public void nearestGreaterElementFour(int[] nums) {
        //https://leetcode.com/problems/next-greater-element-iv/description/
        //https://leetcode.com/problems/next-greater-element-iv/solutions/2756668/java-c-python-one-pass-stack-solution-o-n/
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> stack = new Stack<>();
        Stack<Integer> secondGreater = new Stack<>();
        Stack<Integer> temp = new Stack<>();
        for (int i = 0; i < n; i++) {

            int val = nums[i];

            while (!secondGreater.isEmpty() && nums[secondGreater.peek()] < val) {
                result[secondGreater.pop()] = val;
            }

            while (!stack.isEmpty() && nums[stack.peek()] < val) {
                temp.push(stack.pop());
            }

            while (!temp.isEmpty()) {
                secondGreater.push(temp.pop());
            }

            stack.push(i);
        }
        //output
        System.out.println("Nearest Greater Element Four : " + Arrays.toString(result));
    }

    public void minOperationToReduceXToZero(int[] nums, int X) {
        //https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description/
        //based on SLIDING WINDOW
        /*
        We need to find values from nums[] from its left or right side whose
        values if reduced from X should make it 0.

        ex: nums[] = [1,1,4,2,3], x = 5

        sum from left or right we can choose

        1. left = 1, 1 & right = 3 ==> 1 + 1 + 3 ==> 5 ==> x
        oprns taken ==> 3 ==> pick {1, 1, 3}

        2. left = none & right = 2, 3 ==> 2 + 3 ==> 5 ==> x
        oprns taken ==> 2 ==> pick {2, 3}

        min oprn = 2

        in either of the above choice, we are able to make pick sum == x

        nums[] = [1,1,4,2,3]
        pickSum = 1 + 1 + 3 ==> 5 ==> x
        remaining = 4 + 2 = 6

        pickSum = 2 + 3 ==> 5 ==> x
        remaining = 1 + 1 + 4 = 6

        intuition:
        rather than finding a window of subarray whose sum is X, find a window
        of subarray whose sum is (arrSum - X) == remainingSubarraySum meaning
        leaving out sum of elements at left or right positions == X

        again see both the choices

        arrSum = 11

        nums[] = [1,1,4,2,3], x = 5
        remainingSubarraySum = arrSum - x ==> 11 - 5 ==> 6

        subarray window having sum == remainingSubarraySum

        1. [4,2] than means we leave the number left = [1, 1] & right [3] whose
        sum == x

        2. [1,1,4] that means we leave the number [2, 3] in the right whose
        sum == x

        subarray in choice 2. contains 3 elements
        [1, 1, 4] ==> (end - start + 1)

        now this is oprns to pick elements for remainingSubarraySum then oprns
        to pick element from left or right

        ==> n - oprns to pick elements for remainingSubarraySum
        ==> n - (end - start + 1)

        and, if we need to minimize the oprn to pick elements from left or right
        whose sum would reduce x to 0 we must find subarray window whose sum is
        remainingSubarraySum == (arrSum - x) and maximize the length of this subarray

         */
        int n = nums.length;

        int arrSum = 0;

        for (int val : nums) {
            arrSum += val;
        }

        int start = 0;
        int end = 0;

        int minOprn = n + 1;

        int currSubarraySum = 0;

        int remainingSubarraySum = arrSum - X;

        while (end < n) {

            currSubarraySum += nums[end];

            while (end >= start && currSubarraySum > arrSum - X) {
                currSubarraySum -= nums[start++];
            }

            if (currSubarraySum == remainingSubarraySum) {
                minOprn = Math.min(minOprn, n - (end - start + 1));
            }

            end++;
        }
        //output
        minOprn = minOprn == n + 1 ? -1 : minOprn;
        System.out.println("Min  operation to reduce X to zero : " + minOprn);
    }

    public void prefixCommonArrayOfTwoArrays(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/
        //explanation: https://youtu.be/m6s9dBCBocQ
        /*
        It is guaranteed that nums1 and nums2 are both a permutation of n integers.

        intution:
        nums1 = [1,3,2,4], nums2 = [3,1,2,4]

        #1. i = 0
        freq[nums1[i]]++ ==> freq[1]++ = {1 = 1}
        if(freq[1] == 2) //BUT freq[1] = 1 means 1 exists only in one array at this time

        freq[nums2[i]]++ ==> freq[3]++ = {3 = 1}
        if(freq[1] == 2) //BUT freq[3] = 1 means 3 exists only in one array at this time

        #2. i = 1
        freq[nums1[i]]++ ==> freq[3]++ = {1 = 1, 3 = 2}
        //at this point 3 exists in both the array
        if(freq[1] == 2) ==> (freq[3] == 2) count++ ==> 1

        freq[nums2[i]]++ ==> freq[1]++ = {1 = 2, 3 = 2}
        //at this point 1 exists in both the array
        if(freq[1] == 2) ==> (freq[1] == 2) count++ ==> 2

        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;

        #3. i = 2
        freq[nums1[i]]++ ==> freq[2]++ = {1 = 1, 3 = 2, 2 = 1}
        if(freq[2] == 2) //2 exists only in nums1[]

        freq[nums2[i]]++ ==> freq[2]++ = {1 = 2, 3 = 2, 2 = 2}
        //at this point 2 exists in both the array
        if(freq[2] == 2) ==> (freq[2] == 2) count++ ==> 3

        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;

        #4. i = 3
        freq[nums1[i]]++ ==> freq[4]++ = {1 = 1, 3 = 2, 2 = 2, 4 = 1}
        if(freq[4] == 2) //4 exists only in nums1[]

        freq[nums2[i]]++ ==> freq[4]++ = {1 = 2, 3 = 2, 2 = 2, 4 = 2}
        //at this point 4 exists in both the array
        if(freq[4] == 2) ==> (freq[4] == 2) count++ ==> 4

        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;

         */
        int n = nums1.length;
        int[] commonPrefixCount = new int[n];
        int[] freq = new int[n + 1];
        int count = 0;
        for (int i = 0; i < n; i++) {
            freq[nums1[i]]++;
            if (freq[nums1[i]] == 2) {
                count++;
            }

            freq[nums2[i]]++;
            if (freq[nums2[i]] == 2) {
                count++;
            }

            commonPrefixCount[i] = count;
        }
        //output
        System.out.println("Prefix common arrays : " + Arrays.toString(commonPrefixCount));
    }

    private int subseqSatisfyGivenSumCond_BinarySearch(int[] nums, int find) {
        int n = nums.length;
        int start = 0;
        int end = n - 1;
        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (nums[mid] <= find) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return start;
    }

    public void subseqSatisfyGivenSumCond_1(int[] nums, int target) {
        //.........................T: O(N * LogN), where N is nums[] length,
        ////here O(N * LogN) comes from the sorting of nums[]
        //also, O(N) comes from for(start) loop and inside it we performing binary
        //search that takes O(LogN) in searching the value hence O(N * LogN)
        //makes it like O(SORTING + LOOPINP) ==> O(N * LogN + N * LogN) ==> O(N * LogN)
        //.........................S: O(N), for power[]
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/editorial/
        //based on BINARY SEARCH
        int n = nums.length;
        int mod = 1000000007;
        int subseq = 0;

        Arrays.sort(nums);

        //to generate possible subsequneces of n values in arr[], it would take
        //2^n time complexity, how?
        //for a given values in nums[], if you try to form subseq of them, you have
        //2 choices to make, either to pick or don't pick the value
        //also Math.pow() will also give TLE, so here we
        //have to pre compute the power of 2 as power[i] = power[i - 1] * 2 where
        //i represents the power
        int[] preComputePowerOf2 = new int[n];

        //here i = 0, means 2 ^ i ==> 2 ^ 0 ==> 1
        //in loop below,
        //for i == 1, 2 ^ 1 ==> 2 but this can written as (2 ^ 0) * 2 ==> 2
        //also, for i == 2, 2 ^ 2 ==> 4 but this can be written as (2 ^ 1) * 2 ==> 4
        //also, for i == 3, 2 ^ 3 ==> 8 but this can be written as (2 ^ 2) * 2 ==> 8
        //also, for i == 4, 2 ^ 4 ==> 16 but this can be written as (2 ^ 3) * 2 ==> 16
        //to conclude this observation, here to calculate a power of 2 ^ i we need only
        //power of (2 ^ (i - 1)) * 2 ==> preComputePowerOf2[i] = preComputePowerOf2[i - 1] * 2
        preComputePowerOf2[0] = 1;
        for (int i = 1; i < n; i++) {
            preComputePowerOf2[i] = (preComputePowerOf2[i - 1] * 2) % mod;
        }

        for (int start = 0; start < n; start++) {
            int end = subseqSatisfyGivenSumCond_BinarySearch(nums, target - nums[start]) - 1;
            if (end < start) {
                break;
            }
            subseq = (subseq + preComputePowerOf2[end - start]) % mod;
        }
        //output
        System.out.println("Subsequence that staify the given sum condition : " + subseq);
    }

    public void subseqSatisfyGivenSumCond_2(int[] nums, int target) {
        //.........................T: O(N * LogN), where N is nums[] length,
        //here O(N * LogN) directly comes from the sorting of nums[]
        //.........................S: O(N), for power[]
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/editorial/
        //explanation: https://youtu.be/eGqs55VTP3I
        //based on TWO POINTER, easy to understand & faster as compared to above
        //binary search approach
        int n = nums.length;
        int mod = 1000000007;
        int subseq = 0;
        int start = 0;
        int end = n - 1;

        Arrays.sort(nums);

        //to generate possible subsequneces of n values in arr[], it would take
        //2^n time complexity, how?
        //for a given values in nums[], if you try to form subseq of them, you have
        //2 choices to make, either to pick or don't pick the value
        //also Math.pow() will also give TLE, so here we
        //have to pre compute the power of 2 as power[i] = power[i - 1] * 2 where
        //i represents the power
        int[] preComputePowerOf2 = new int[n];

        //here i = 0, means 2 ^ i ==> 2 ^ 0 ==> 1
        //in loop below,
        //for i == 1, 2 ^ 1 ==> 2 but this can written as (2 ^ 0) * 2 ==> 2
        //also, for i == 2, 2 ^ 2 ==> 4 but this can be written as (2 ^ 1) * 2 ==> 4
        //also, for i == 3, 2 ^ 3 ==> 8 but this can be written as (2 ^ 2) * 2 ==> 8
        //also, for i == 4, 2 ^ 4 ==> 16 but this can be written as (2 ^ 3) * 2 ==> 16
        //to conclude this observation, to calculate a power of 2 ^ i we need only
        //power of (2 ^ (i - 1)) * 2 ==> preComputePowerOf2[i] = preComputePowerOf2[i - 1] * 2
        preComputePowerOf2[0] = 1;
        for (int i = 1; i < n; i++) {
            preComputePowerOf2[i] = (preComputePowerOf2[i - 1] * 2) % mod;
        }

        //this loop in linear (O(N)) as compared to above approach with binary search
        //which was (O(LogN)) for all the N values in nums[] makes it to (O(N * LogN))
        while (end >= start) {
            //as required in question, we need our min & max values from a subseq
            //to have a sum less than or equal to target, since we sorted our array
            //we know that our min is at start ptr and max is at end ptr.
            //Here we will pick these two min & max values, if it matches the cond
            //we will calculate our subseqs that lies in range of (start to end]
            //start non-inclusive as this min ==> nums[start] is always a fixed value
            //so the remaining values from the ranges becomes (end - start)
            //this (end - start) represents the range of nums we can pick & don't pick
            //in our subseq hence form 2 ^ (end - start) subsequences
            //We could have used Math.pow(2, end - start) but that will give errors
            //because this power can be very large to compute so use pre computed power[]
            if (nums[start] + nums[end] <= target) {
                subseq = (subseq + preComputePowerOf2[end - start]) % mod;
                start++;
            } else {
                //if(nums[start] + nums[end] > target), then needs adjust the end ptr
                //as it holds the max value
                end--;
            }
        }

        //output
        System.out.println("Subsequence that staify the given sum condition : " + subseq);
    }

    public boolean checkIfArrayIsSortedAndRotated(int[] nums) {
        //https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/
        /*
        nums[] = [3,4,5,1,2]
        here the intution is count the dips/valleys
        ..............5.....2
        ............./.\.../
        ............4....1
        .........../
        ..........3

        see 3 -> 4 -> 5 is an increasing trend
        then 5 -> 1 is decrease/ dip
        then 1 -> 2 again increase

        also, to note here,
        ex: nums[] = [1,2,3,4]
        ideally, this array is sorted AND looks not rotated BUT note here, a
        simple sorted array like above ex will be considered as rotated where
        rotations made on array is 0
        thats why, we also need to check that nums[n - 1] > nums[0]
        that is covered as nums[i] > nums[(i + 1) % n]
        when last index, i == n - 1,  (i + 1) % n will be wrapped to index 0
        hence we are checking nums[n - 1] > nums[0]

        now in a sorted and single time roatated array this dip should be <= 1
        so if countDip > 1 return false as there are more than 1 rotation

         */
        int n = nums.length;
        int countDip = 0;
        for (int i = 0; i < n; i++) {

            if (nums[i] > nums[(i + 1) % n]) {
                countDip++;
            }

            if (countDip > 1) {
                return false;
            }
        }
        return true;
    }

    private int longestValidObstacleCourseAtEachPosition_BinarySearch(int[] memoLIS, int find) {

        int n = memoLIS.length;

        int start = 0;
        int end = n - 1;

        int smallerPrevSeqIndex = -1;

        while (end >= start) {

            //'mid' represents a possible smaller-prev-value index that could be
            //strictly lesser or equal to 'find'
            int mid = start + (end - start) / 2;

            //here, the value at 'mid' is actually smaller-prev-val than the find
            //means 'mid' is a valid index that represents a LIS whose last-value
            //is memoLIS[index] and curr 'find' will come after this as
            //memoLIS[index] <= 'find'
            if (memoLIS[mid] <= find) {

                smallerPrevSeqIndex = mid;
                //we know that curr 'mid' is a valid LIS index meaning value 'find'
                //can be the next incr seq to memoLIS[mid] and hence a new longest
                //incr seq will form as mid == smallerPrevSeqIndex +1
                //but as our motive is to find a longest incr subseq for that we
                //would try to check if any higher 'mid' index also holds smaller
                //prev value that is lesser or equal to 'find', if yes, that higher
                //'mid' index will given even higher LIS
                //to find higher 'mid' index, move search space to right-side
                start = mid + 1;
            } else {
                //here, 'mid' index holds a memoLIS[mid] value which is greater
                //than the 'find' and hence not form any incr seq, so reduce the
                //search space to left-side
                end = mid - 1;
            }
        }

        return smallerPrevSeqIndex;
    }

    public void longestValidObstacleCourseAtEachPosition(int[] obstacles) {
        //https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description/
        //explanation: https://youtu.be/sUtUgMW2kMY | https://youtu.be/Xq9VT7p0lic
        //based on BINARY SEARCH, LONGEST INCREASING SUBSEQUENCE
        /*
        Exact logic of longestIncreasingSubsequence_DP_Memoization() will solve this
        question, but this question requires optimization on LIS hence for larger
        input value LIS will throw TLE, so we are using
        longestIncreasingSubsequence2_DP_Memoization() approach of LIS

        in actual LIS algo, what memoLIS will means
        index:      0      1     2     3
        memoLIS[] = [Len1, Len2, Len3, Len4]

        for a particular 'index' there exist a subseq as long as 'Len'
        means memoLIS[index] == memoLIS[3] == Len4

        ex: nums[] = [1,3,2,4]
        memoLIS[] = [1, 2, 2, 3]
        memoLIS[0] == 1 ==> subseq ==> {1}
        memoLIS[1] == 2 ==> subseq ==> {1 < 3}
        memoLIS[2] == 2 ==> subseq ==> {1 < 2}
        memoLIS[3] == 3 ==> subseq ==> {1 < 3 < 4} OR {1 < 2 < 4}

        for this question we have to modify the LIS logic a little bit
        index:      0                 1                2                3                4
        memoLIS[] = [prevSmallerNum1, prevSmallerNum2, prevSmallerNum3, prevSmallerNum4, prevSmallerNum5]

        here the 'index' of memoLIS[] represent the length of the longest subseq
        means index ==> 0 ==> (0 + 1) = 1 ==> any subseq of length 1
        means index ==> 1 ==> (1 + 1) = 2 ==> any subseq of length 2
        means index ==> 2 ==> (2 + 1) = 3 ==> any subseq of length 3
        means index ==> 3 ==> (3 + 1) = 4 ==> any subseq of length 4
        means index ==> 4 ==> (4 + 1) = 5 ==> any subseq of length 5

        each value in memoLIS[index] will have prev smaller num of the subseq
         */
        int n = obstacles.length;

        int[] result = new int[n];

        int[] memoLIS = new int[n + 1];

        Arrays.fill(memoLIS, Integer.MAX_VALUE);

        memoLIS[0] = Integer.MIN_VALUE;

        for (int i = 0; i < n; i++) {

            int val = obstacles[i];

            int smallerPrevSeqIndex = longestValidObstacleCourseAtEachPosition_BinarySearch(memoLIS, val);

            if (smallerPrevSeqIndex == -1) {
                continue;
            }

            result[i] = smallerPrevSeqIndex + 1;

            memoLIS[smallerPrevSeqIndex + 1] = val;
        }
        //output
        System.out.println("Longest valid obstacles course at each position : " + Arrays.toString(result));
    }

    public void parsingBooleanExpression(String expression) {
        //https://leetcode.com/problems/parsing-a-boolean-expression/description/
        //based on STACK
        Stack<Character> operatorsStack = new Stack<>();
        Stack<Character> expressionsStack = new Stack<>();

        for (char ch : expression.toCharArray()) {
            if (ch == ',') {
                continue;
            } else if (ch == '&' || ch == '|' || ch == '!') {
                //put curr operator as 'chr' in operators stack
                operatorsStack.push(ch);
            } else if (ch == ')') {
                //here we will process the expression block from the expression
                //string
                //pick the operator need to apply
                char operator = operatorsStack.pop();
                //to start our expressions calculations we need to first initialize
                //our currExpression with the curr peek() value from expressionsStack
                //and also remove it from the stack
                boolean currExpression = expressionsStack.pop() == 't';
                //if the below while() loop ever run then isLooped will become true
                boolean isLooped = false;
                //process the remaining 't', 'f' values in the expressionsStack
                //(if any, as there can be only single 't' or 'f' in a expression block)
                //loop on expressionsStack until we find an opening bracket '('
                //process all the expressions in between
                while (!expressionsStack.isEmpty() && expressionsStack.peek() != '(') {
                    isLooped = true;
                    switch (operator) {
                        case '&':
                            currExpression &= (expressionsStack.pop() == 't');
                            break;
                        case '|':
                            currExpression |= (expressionsStack.pop() == 't');
                            break;
                        case '!':
                            currExpression = !(expressionsStack.pop() == 't');
                            break;
                    }
                }

                //pop the opening bracket '(' in the expressions stack
                expressionsStack.pop();

                //edge case like : !(subExpr) ==> ex: !(t) ==> f
                //since inside bracket (t) there is single value 't' that will
                //already be popped before the while() in 'currExpression' hence
                //after popping, that while() will not work as expressionStack.peek()
                //will have only '(' and loop will break so 'isLooped' will remain
                //false but due to this the operator == '!' will not be processed
                //so need to handle this edge case
                if (!isLooped && operator == '!') {
                    currExpression = !currExpression;
                }

                //add the processed expression 'currExpression' back into expression stack
                expressionsStack.push(currExpression ? 't' : 'f');

            } else {
                //here we put all other things, '(', 't', 'f'
                expressionsStack.push(ch);
            }
        }
        //output
        boolean expressionResult = expressionsStack.peek() == 't';
        System.out.println("Parsing boolean expression : " + expressionResult);
    }

    public void binarySubarraySumEqualToGoal(int[] binary, int goal) {
        //https://leetcode.com/problems/binary-subarrays-with-sum/description/
        int n = binary.length;
        int[] prefixSumArr = new int[n + 1];
        int prefixSum = 0;
        for (int i = 0; i < n; i++) {
            prefixSum += binary[i];
            prefixSumArr[i + 1] = prefixSum;
        }

        Map<Integer, Integer> freq = new HashMap<>();
        int subarr = 0;
        for (int sum : prefixSumArr) {
            subarr += freq.getOrDefault(sum, 0);
            freq.put(sum + goal, freq.getOrDefault(sum + goal, 0) + 1);
        }
        //output
        System.out.println("Binary subarray sum equal to goal : " + subarr);
    }

    public void longestTurbulentSubarray(int[] nums) {
        //https://leetcode.com/problems/longest-turbulent-subarray/description/
        //explanation: https://youtu.be/V_iHUhR8Dek
        //based on SLIDING WINDOW
        int n = nums.length;
        //any single element in nums[] will be considered as turbulent subarr of
        //length 1
        int longestTurbulentSubarr = 1;
        int start = 0;
        int end = 1;
        //default prev turbulent sign
        char prev = '.';

        while (end < n) {
            //if prev turbulent sign was either default or '<' then curr must be
            //followed with '>'
            if ((prev == '.' || prev == '<') && nums[end - 1] > nums[end]) {
                longestTurbulentSubarr = Math.max(longestTurbulentSubarr, (end - start + 1));
                end++;
                //as currently we checking a turbulent sign of '>' in
                //nums[end - 1] > nums[end] so for next time prev turbulent sign
                //should be this sign '>'
                prev = '>';
            } //if prev turbulent sign was either default or '>' then curr must be
            //followed with '<'
            else if ((prev == '.' || prev == '>') && nums[end - 1] < nums[end]) {
                longestTurbulentSubarr = Math.max(longestTurbulentSubarr, (end - start + 1));
                end++;
                //as currently we checking a turbulent sign of '<' in
                //nums[end - 1] < nums[end] so for next time prev turbulent sign
                //should be this sign '<'
                prev = '<';
            } else {
                //case where nums[end - 1] == nums[end]
                end = nums[end - 1] == nums[end] ? end + 1 : end;
                start = end - 1;
                prev = '.';
            }
        }
        //output
        System.out.println("Longest turbulent subarray : " + longestTurbulentSubarr);
    }

    public void mostProfitAssigningWork(int[] difficulties, int[] profits, int[] workers) {
        //https://leetcode.com/problems/most-profit-assigning-work/description/
        int n = workers.length;
        int m = profits.length;

        int[][] difficultyWithProfit = new int[m][2];
        for (int i = 0; i < m; i++) {
            difficultyWithProfit[i] = new int[]{difficulties[i], profits[i]};
        }

        //sort in increasing order of difficulty in the difficultyWithProfit[i][0]
        Arrays.sort(difficultyWithProfit, (a, b) -> a[0] - b[0]);
        //sort in increasing order of worker ability
        Arrays.sort(workers);

        int maxProfit = 0;
        int currMaxProfit = 0;
        int index = 0;

        for (int ability : workers) {
            while (index < n && difficultyWithProfit[index][0] <= ability) {
                currMaxProfit = Math.max(currMaxProfit, difficultyWithProfit[index][1]);
                index++;
            }
            maxProfit += currMaxProfit;
        }
        //output
        System.out.println("Most profit assiging work : " + maxProfit);
    }

    public boolean subarraysHavingEqualSum(int[] nums) {
        //https://leetcode.com/problems/find-subarrays-with-equal-sum/description/
        //based on SLIDING WINDOW
        /*
        determine whether there exist two subarrays of length 2 with equal sum.
        Note that the two subarrays must begin at different indices
         */
        int n = nums.length;
        Set<Integer> subarrSumsSeen = new HashSet<>();
        //as given subarray/ window length is required 2 hence window = 2
        int window = 2;

        int start = 0;
        int end = 0;

        //take the initial sum of subarray of size 'window' from nums[0 to window - 1]
        int currWindowSum = 0;
        for (; end < window; end++) {
            currWindowSum += nums[end];
        }

        //the first subarray sum of length 'window' is calculated as 'currWindowSum'
        //put that in set which behaves as 'seen' set
        subarrSumsSeen.add(currWindowSum);

        while (end < n) {

            //maintain curr sum as 'currWindowSum' for subarray of size 'window'
            //by adjusting the window(moving start and end ptrs)
            currWindowSum += nums[end];
            currWindowSum -= nums[start];

            start++;
            end++;

            //if the curr curr of size 'window' subarray sum as 'currWindowSum'
            //is already seen then that means there exist two subarrays having same sum
            if (subarrSumsSeen.contains(currWindowSum)) {
                return true;
            }
            //put the curr k len window subarray sum
            subarrSumsSeen.add(currWindowSum);
        }
        return false;
    }

    public void countGoodMeals(int[] nums) {
        //https://leetcode.com/problems/count-good-meals/description/
        //https://leetcode.com/problems/count-good-meals/solutions/999119/java-hashmap-two-sum-o-n/
        //based on twoSum()
        int n = nums.length;
        int mod = 1000000007;
        int pairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();

        for (int val : nums) {

            int powerOfTwo = 1;
            for (int power = 0; power < 22; power++) {

                pairs += freq.getOrDefault(powerOfTwo - val, 0);
                pairs %= mod;

                powerOfTwo *= 2;
            }
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }
        //output
        System.out.println("Count good meals : " + pairs);
    }

    public void oddEvenJumps(int[] nums) {
        //https://leetcode.com/problems/odd-even-jump/description/
        //https://leetcode.com/problems/odd-even-jump/solutions/217981/java-c-python-dp-using-map-or-stack/
        int n = nums.length;
        boolean[] higher = new boolean[n];
        boolean[] lower = new boolean[n];

        higher[n - 1] = lower[n - 1] = true;

        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(nums[n - 1], n - 1);

        //1 because if we pick index ==> n - 1 that is also good starting index
        //to reach end
        int goodStartingIndexCount = 1;

        for (int i = n - 2; i >= 0; i--) {

            Map.Entry<Integer, Integer> high = map.ceilingEntry(nums[i]);
            Map.Entry<Integer, Integer> low = map.floorEntry(nums[i]);

            if (high != null) {
                higher[i] = lower[high.getValue()];
            }

            if (low != null) {
                lower[i] = higher[low.getValue()];
            }

            if (higher[i]) {
                goodStartingIndexCount++;
            }

            map.put(nums[i], i);
        }
        //output
        System.out.println("Odd even jumps : " + goodStartingIndexCount);
    }

    public void minAreaRectangle(int[][] points) {
        //...............T: O(N ^ 2), N is length of points[][]
        //https://leetcode.com/problems/minimum-area-rectangle/description/
        //<x, List<y>>
        Map<Integer, Set<Integer>> pointsMap = new HashMap<>();
        for (int[] point : points) {
            int x = point[0];
            int y = point[1];

            pointsMap.putIfAbsent(x, new HashSet<>());
            pointsMap.get(x).add(y);
        }

        int minArea = Integer.MAX_VALUE;

        for (int[] point1 : points) {

            int x1 = point1[0];
            int y1 = point1[1];

            for (int[] point2 : points) {

                int x2 = point2[0];
                int y2 = point2[1];

                /*

                skip, if both the point1 & point2 lie either on same x-axis or
                y-axis
                we will not consider such points because we are looking of those
                points as p1 & p2 that are currently diagonal to each other,
                from those points we can make two other points 'A' & 'B' as
                explained below

                1.
                ......p1(x1, y1)------------------p2(x2, y2) here y1 == y2

                2.
                ................p1(x1, y1)
                ................|
                ................|
                ................|
                ................p2(x2, y2) here x1 == x2

                 */
                if (x2 == x1 || y2 == y1) {
                    continue;
                }

                /*

                assume that p1 and p2 are two diagonal points of a rectangle
                then there must exist two points 'A'(x1, y2) and 'B'(x2, y1)
                from points p1 & p2 hence these 4 points together will from
                a rectangle and then we can calculate its length * breadth
                for area

                ...A = (p1.x, p2.y) ==> (x1, y2)
                .......D----------p2 = (x2, y2)
                .......|          |
                .......|          |
                .......|          |
                ......p1----------B = (p2.x, p1.y) ==> (x2, y1)
                ...p1 = (x1, y1)

                area = length * breadth
                ==>
                length = abs(p2.x - p1.x) ==> abs(x2 - x1)
                breadth = abs(p2.y - p1.y) ==> abs(y2 - y1)

                 */
                if (pointsMap.get(x1).contains(y2) && pointsMap.get(x2).contains(y1)) {
                    minArea = Math.min(minArea, Math.abs(x2 - x1) * Math.abs(y2 - y1));
                }
            }
        }
        //output
        minArea = minArea == Integer.MAX_VALUE ? 0 : minArea;
        System.out.println("Min area of rectangle : " + minArea);
    }

    public void maxValueOfEquation(int[][] points, int k) {
        //https://leetcode.com/problems/max-value-of-equation/description/
        //based on SLIDING WINDOW
        /*

        Given:
        sorted by the x-values, where points[i] = [xi, yi] such that xi < xj
        for all 1 <= i < j <= points.length. You are also given an integer k.

        Return the maximum value of the equation yi + yj + |xi - xj|
        where |xi - xj| <= k and 1 <= i < j <= points.length.

        intuition:

        maximize this equation yi + yj + |xi - xj|
        ==> |xi - xj| is always positive
        ==> also given that xi < xj for all 1 <= i < j <= points.length
        so to make |xi - xj| <= k without abs() we can simply rephrase this as
        |xi - xj| = xj - xi <= k as given xi < xj (bigger(xj) - smaller(xi) > 0)

        ==> yi + yj + |xi - xj|
        ==> yi + yj + xj - xi
        ==> (yi - xi) + (xj + yj)

        in our Queue we will store 2 things as Pair class
        1. diff = (yi - xi)
        2. xI = xi

        from our j-loop we will have (xj + yj) but inorder to max the result
        we also need to maximize this diff (yi - xi)

        so using Deque we check 2 things:
        1. xj - xi > k, poll if first xi(s) from queue, are out of range ( > k)
        2. (yi - xi) keep this diff as we increament our j-th index but inorder
        to maximize this diff part we might have to poll the min diff(s) already
        in the queue

         */
        class Pair {

            //(yi - xi)
            int diff;
            //xi
            int xI;

            public Pair(int diff, int xI) {
                this.diff = diff;
                this.xI = xI;
            }

        }

        int n = points.length;
        Deque<Pair> queue = new LinkedList<>();
        int maxValue = Integer.MIN_VALUE;

        for (int j = 0; j < n; j++) {

            int xJ = points[j][0];
            int yJ = points[j][1];

            //poll first xi(s), if xj - xi > k
            while (!queue.isEmpty() && xJ - queue.peekFirst().xI > k) {
                queue.pollFirst();
            }

            //check for max equation value
            if (!queue.isEmpty()) {
                //queue.peekFirst().diff + (xJ + yJ) ==> (yi - xi) + (xj + yj)
                maxValue = Math.max(maxValue, queue.peekFirst().diff + (xJ + yJ));
            }

            //(yJ - xJ) > queue.peekLast().diff ==> curr diff(yj - xj) > prev diff(yi - xi)
            //then inorder to maximize the sum of equation we will poll the smaller
            //prev diff(s)(==> yi - xi) from queue
            while (!queue.isEmpty() && (yJ - xJ) > queue.peekLast().diff) {
                queue.pollLast();
            }

            //saving curr {(yj - xj), xj} in pair so for next j-th index this curr
            //pair will act as i-th index as i < j as per question
            queue.add(new Pair((yJ - xJ), xJ));
        }
        //output
        System.out.println("Max value of equation : " + maxValue);
    }

    public void minOperationsToMakeASubseq(int[] target, int[] nums) {
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/description/
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/solutions/999153/java-c-python-lcs-to-lis/
        /*
        this question is classic case for longest common subeq between two arrays
        but the same lcs() logic will give TLE. We will have to apply modified
        version of longest increasing subseq logic here
        this logic will not check the longest increasing element sequence BUT
        we will check longest increasing index order

        logic:
        given that target[] will always have distinct elements(==> no duplicates)

        target = [6,4,8,1,3,2], nums = [4,7,6,2,3,8,6,1]

        targetIndexMap = {6 = 0, 4 = 1, 8 = 2, 1 = 3, 3 = 4, 2 = 5}

        longestIncrIndex = {} ==> TreeSet will contain indexes in sorted order

        for(val : nums[]):

        ##1.....................
        val = 4

        if(!targetIndexMap[4]) FAIL

        if(longestIncrIndex.isEmpty) YES
        ==> index of targetIndexMap[4] = 1 to be added in longest-incr-index

        longestIncrIndex.add(targetIndexMap[4]) ==> longestIncrIndex.add(1) ==> {1}

        continue

        ##2.....................
        val = 7

        if(!targetIndexMap[7]) YES
        ==> continue

        ##3.....................
        val = 6

        if(!targetIndexMap[6]) FAIL

        if(longestIncrIndex.last < targetIndexMap[6]) FAIL
        ==> **treeset.last() gives last (highest) value in the treeset
        ==> 1 < 0 ==> we already have index 1, ideally we should have a higher
        ==> index value than 1 but we got index of targetIndexMap[6] = 0 hence
        ==> with index = 0 we can't make longest incr index

        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[6]) ==> 1
        ==> **treeset.ceiling(val) gives a value greater or equal to given 'val',
        ==> **if present otherwise null

        longestIncrIndex.remove(higherTargetIndex) ==> {}

        longestIncrIndex.add(targetIndexMap[6]) ==> longestIncrIndex.add(0) ==> {0}

        ##4.....................
        val = 2

        if(!targetIndexMap[2]) FAIL

        if(longestIncrIndex.last < targetIndexMap[6]) ==> (0 < 5)
        ==> 0 < 5 ==> we already have index 0 and current index of targetIndexMap[2]
        ==> is 5 which is making it longest incr index, hence we will add this index

        longestIncrIndex.add(targetIndexMa[2]) ==> longestIncrIndex.add(5) ==> {0, 5}

        continue

        ##5.....................
        val = 3

        if(!targetIndexMap[3]) FAIL

        if(longestIncrIndex.last < targetIndexMap[3]) FAIL
        ==> 5 < 4 ==> we already have index 5, ideally we should have a higher
        ==> index value than 5 but we got index of targetIndexMap[3] = 4 hence
        ==> with index = 4 we can't make longest incr index

        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[3]) ==> 5

        longestIncrIndex.remove(higherTargetIndex) ==> {0}

        longestIncrIndex.add(targetIndexMap[3]) ==> longestIncrIndex.add(4) ==> {0, 4}

        ##6.....................
        val = 8

        if(!targetIndexMap[8]) FAIL

        if(longestIncrIndex.last < targetIndexMap[8]) FAIL
        ==> 4 < 2 ==> we already have index 4, ideally we should have a higher
        ==> index value than 4 but we got index of targetIndexMap[8] = 2 hence
        ==> with index = 4 we can't make longest incr index

        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[8]) ==> 4

        longestIncrIndex.remove(higherTargetIndex) ==> {0}

        longestIncrIndex.add(targetIndexMap[8]) ==> longestIncrIndex.add(4) ==> {0, 2}

        ##7.....................
        val = 6

        if(!targetIndexMap[6]) FAIL

        if(longestIncrIndex.last < targetIndexMap[6]) FAIL
        ==> 2 < 0 ==> we already have index 2, ideally we should have a higher
        ==> index value than 2 but we got index of targetIndexMap[6] = 0 hence
        ==> with index = 2 we can't make longest incr index

        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[6]) ==> 0
        ==> **treeset.ceiling(val) gives a value greater or equal to given 'val',
        ==> **if present otherwise null
        ==> here 'val' = targetIndexMap[6] = 0 so treeset.ceiling(0) ==> 0

        longestIncrIndex.remove(higherTargetIndex) ==> {2}

        longestIncrIndex.add(targetIndexMap[6]) ==> longestIncrIndex.add(0) ==> {0, 2}

        ##8.....................
        val = 1

        if(!targetIndexMap[1]) FAIL

        if(longestIncrIndex.last < targetIndexMap[6]) ==> (2 < 3)
        ==> 2 < 3 ==> we already have index 2 and current index of targetIndexMap[1]
        ==> is 3 which is making it longest incr index, hence we will add this index

        longestIncrIndex.add(targetIndexMa[1]) ==> longestIncrIndex.add(3) ==> {0, 2, 3}

        continue

        ....END....

        longestIncrIndex = {0, 2, 3} ==> size() => 3

        result = targetLen - longestIncrIndex.size

         */

        int targetLen = target.length;

        Map<Integer, Integer> targetIndexMap = new HashMap<>();
        for (int i = 0; i < targetLen; i++) {
            targetIndexMap.put(target[i], i);
        }

        TreeSet<Integer> longestIncrIndex = new TreeSet<>();

        for (int val : nums) {

            if (!targetIndexMap.containsKey(val)) {
                continue;
            }

            //last() = last/highest index in set < curr index of 'val' in target[]
            if (longestIncrIndex.isEmpty() || longestIncrIndex.last() < targetIndexMap.get(val)) {
                longestIncrIndex.add(targetIndexMap.get(val));
                continue;
            }

            int higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap.get(val));
            longestIncrIndex.remove(higherTargetIndex);
            longestIncrIndex.add(targetIndexMap.get(val));
        }
        //output
        int minOperation = targetLen - longestIncrIndex.size();
        System.out.println("Min operations to make subseq : " + minOperation);
    }

    private int countNegativesInSortedMatrix_BinarySearch(int[] nums, int n) {

        //find the index of first negative value in non-increasing nums[]
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //if curr mid index to be the first negative value then its prev
            //value (mid - 1) should be a positive or 0 value OR there is a chance
            //where first negative value occur at index 0 itself then in that case
            //(mid - 1) will never occur hence we will check (mid == 0) case
            if ((mid == 0 || nums[mid - 1] >= 0) && nums[mid] < 0) {
                return mid;

            } else if (nums[mid] >= 0) {
                //if the curr mid value is positive or 0, then it is sure that
                //the negtive value will occur on its right side of nums[], hence
                //start ptr to move into right side array (start = mid + 1) because
                //its a non-increasing array, negatives will on right side of array
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        //if no negative value is found in array
        return -1;
    }

    public void countNegativesInSortedMatrix(int[][] grid) {
        //https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/
        //https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/
        //based on BINARY SEARCH
        int ROW = grid.length;
        int COL = grid[0].length;

        int countNegatives = 0;

        for (int row = 0; row < ROW; row++) {

            int index = countNegativesInSortedMatrix_BinarySearch(grid[row], COL);

            //if no negative value is found in curr row-th grid[row] array
            //(==> index == -1) means 0 count to add but if we found a valid first
            //index of a negative value then we can calculate the amount of negative
            //values present from this 'index' till end of grid[row](==> COL)
            countNegatives += (index == -1) ? 0 : COL - index;
        }
        //output
        System.out.println("Count negatives in non-increasing sorted matrix : " + countNegatives);
    }

    public void buildArrayWithStackOperations(int[] targetStack, int n) {
        //https://leetcode.com/problems/build-an-array-with-stack-operations/description/
        //based on STACK, SIMULATION
        //given that targetStack[] will always be STRICTLY-INCREASING
        //and nums to be in stack will be in range [1 to n]
        List<String> stackOprns = new ArrayList<>();
        int len = targetStack.length;
        int stackLastVal = targetStack[len - 1];
        int index = 0;

        //we only want to run this loop to min(n, stackLastVal)
        //because that many push and pop operation would only be considered
        for (int num = 1; num <= Math.min(n, stackLastVal); num++) {
            //if we have traversed our targetStack[] completely
            if (index >= len) {
                break;
            } else if (targetStack[index] == num) {
                //if the curr int stream value 'num' is same as what we have in
                //our target stack that means we only have pushed it into the
                //stack
                stackOprns.add("Push");
                //and move to next value in our targetStack to check
                index++;
            } else {
                //if the curr int stream value 'num' is not same as what we have
                //in our target stack that means previously we must have pushed
                //this 'num' and later poped this 'num' as well
                stackOprns.add("Push");
                stackOprns.add("Pop");
            }
        }
        //output
        System.out.println("Build array with stack operations : " + stackOprns);
    }

    private boolean maxValueAtGivenIndexInBoundedArray_IsPossible(
            int n, int index, int maxSum, int value) {

        int leftValue = Math.max(value - index, 0);
        int rightValue = Math.max(value - ((n - 1) - index), 0);

        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;
        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;

        return sumBefore + sumAfter - value <= maxSum;
    }

    public void maxValueAtGivenIndexInBoundedArray(int n, int index, int maxSum) {
        //https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/
        //https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/solutions/3619947/easy-solution-of-java-beginner-friendly/
        //explanation: https://youtu.be/d50vvNSrqfk
        //based on BINARY SEARCH, GREEDY
        int left = 0;
        int right = maxSum - n;

        while (right > left) {

            int middle = (left + right + 1) / 2;

            if (maxValueAtGivenIndexInBoundedArray_IsPossible(n, index, maxSum - n, middle)) {
                left = middle;
            } else {
                right = middle - 1;
            }
        }
        //output
        int maxValAtIndex = left + 1;
        System.out.println("Max value at given index in bounded array : " + maxValAtIndex);
    }

    public void summaryRanges(int[] nums) {
        //https://leetcode.com/problems/summary-ranges/description/
        //based on TWO POINTERS, similar to positionsOfLargeGroups2()
        int n = nums.length;
        List<String> ranges = new ArrayList<>();

        if (n == 0) {
            System.out.println("Summary ranges : " + ranges);
            return;
        }

        int start = 0;
        int end = 0;

        while (end < n) {

            if (end + 1 < n && Math.abs(nums[end + 1] - nums[end]) == 1) {
                end++;
                continue;
            }

            ranges.add((start != end) ? nums[start] + "->" + nums[end] : String.valueOf(nums[start]));

            start = end + 1;
            end++;
        }

        System.out.println("Summary ranges : " + ranges);
    }

    private int countNumberOfUniqueNumbers_Helper(int digit) {
        int total = 1;
        int possibility = 9;
        for (int i = 1; i <= digit; i++) {
            if (i > 1) {
                possibility--;
            }
            total *= possibility;
        }
        return total;
    }

    public int countNumberOfUniqueNumbers(int n) {
        //https://leetcode.com/problems/count-numbers-with-unique-digits/description/
        //https://leetcode.com/problems/count-numbers-with-unique-digits/solutions/3591981/pure-math-o-1-detail-explanation/
        //based on MATHS, PERMUTATION & COMBINATION
        if (n == 0) {
            return 1;
        }
        if (n == 1) {
            return 10;
        }

        //starting from first digit of 'n' lengthed number where if n is 1
        int totalUniqueNumbers = 10;
        for (int digit = 2; digit <= n; digit++) {
            totalUniqueNumbers += countNumberOfUniqueNumbers_Helper(digit);
        }
        //output
        return totalUniqueNumbers;
    }

    public int findAStrictlyGreaterValueThanPivot_BinarySearch(int[] nums, int pivot) {
        /*
        given nums[] = [1,3,2,4], pivot = 1
        output = 2 (as value)
         */
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //aim is to find a mid index here, whose value in sorted nums[mid]
            //has a value STRICTLY GREATER than given pivot
            //a case where a value STRICTLY GREATER than pivot exist @index = 0 hence mid
            //should be 0 then in that case nums[mid - 1] is not possible so keep
            //a check ((mid == 0) && pivot < nums[mid])
            //other cases where our mid points to a value STRICTLY GREATER than
            //pivot then in that case its prev value (nums[mid - 1]) should be
            //less or equal to given pivot so keep a check
            //(nums[mid - 1] <= pivot && pivot < nums[mid])
            if ((mid == 0 || nums[mid - 1] <= pivot) && pivot < nums[mid]) {
                return mid;
            } else if (nums[mid] <= pivot) {
                //as we are trying to find a mid value whose value is STRICTLY GREATER
                //than pivot value but here nums[mid] <= pivot that means a
                //STRICTLY GREATER value than pivot must exists on right side of
                //the nums[] hence mid + 1
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        //this case when pivot is greater or equal to all of the values in sorted num[]
        //simply means nums[n - 1] <= pivot in that case a STRICTLY GREATER value
        //than pivot is not possible
        return n + 1;
    }

    public void findAStrictlyGreaterValueThanPivot(int[] nums, int pivot) {
        //based on BINARY SEARCH
        /*
        given nums[] = [1,3,2,4], pivot = 1
        output = 2 (as value)
         */
        int n = nums.length;
        Arrays.sort(nums);
        int index = findAStrictlyGreaterValueThanPivot_BinarySearch(nums, pivot);
        if (index < n) {
            System.out.println("Strictly greater value than " + pivot + " : " + nums[index]);
            return;
        }
        System.out.println("Strictly greater value than " + pivot + " : NA");
    }

    private long minCostToMakeArrayEqual_TotalCostForConvertVal(int[] nums, int[] cost, int convertVal) {

        //here in this helper methods we will determine the total cost if we were
        //to convert all the nums[i] value to match with 'convertVal'
        //cost can be calculated as:
        //steps taken to make nums[i] to convertVal ==> abs(convertVal - nums[i])
        //cost[i] is cost associated to the nums[i] if we make any change to nums[i]
        //cost = steps * cost[i] ==> abs(convertVal - nums[i]) * cost[i]
        // * 1L just to make the curr cost as long type
        int n = nums.length;
        long totalCost = 0l;

        for (int i = 0; i < n; i++) {
            totalCost += (1L * Math.abs(convertVal - nums[i]) * cost[i]);
        }
        return totalCost;
    }

    public void minCostToMakeArrayEqual(int[] nums, int[] cost) {
        //https://leetcode.com/problems/minimum-cost-to-make-array-equal/description/
        //explanation: https://youtu.be/lGo6E8jiDB8
        //BINARY SEARCH approach is OPTIMIZED than its GREEDY approach

        //in order for us to calculate min cost of converting all nums[i] to a
        //value 'convertVal', we must find the range we can pick these 'convertVal'
        //that range lie between [min(nums[i]) to max(nums[i])] ==> [minVal, maxVal]
        int minVal = nums[0];
        int maxVal = nums[0];

        for (int val : nums) {
            minVal = Math.min(minVal, val);
            maxVal = Math.max(maxVal, val);
        }

        //do a binary search from range determined
        int start = minVal;
        int end = maxVal;

        long minCost = 0l;

        while (end >= start) {

            //mid represent the 'convertVal', a possible value within the range
            //[minVal, maxVal], so that we can convert all the nums[i] to mid
            int mid = start + (end - start) / 2;

            //now from here calculate the cost of converting all nums[i] to this
            //mid that would result as cost1
            long cost1 = minCostToMakeArrayEqual_TotalCostForConvertVal(nums, cost, mid);
            //also here calculate the cost of converting all nums[i] to the mid + 1
            //value that would result as cost2
            long cost2 = minCostToMakeArrayEqual_TotalCostForConvertVal(nums, cost, mid + 1);

            //why we are considering cost of two values mid & (mid + 1)?
            //because these two costs, cost1 & cost2 helps in deciding where to
            //move our start and end ptr
            //ex: if we pick 'mid' as convertVal and gets cost1
            //and if we pick 'mid + 1' as convertVal and gets cost2
            //[start..................mid.|.(mid + 1)...................end]
            //if cost1 is lesser and we need 'minCost' then its good if we reduce
            //our search space to [start to mid] because mid is giving smaller cost
            //then we might get lesser cost in that range
            //if cost2 is lesser and we need 'minCost' then its good if we reduce
            //our search space to [mid + 1 to end] because mid + 1 is giving smaller
            //cost then we might get lesser cost in that range
            if (cost1 < cost2) {

                minCost = cost1;
                end = mid - 1;
            } else {
                minCost = cost2;
                start = mid + 1;
            }
        }
        //output
        System.out.println("Min cost to make array equal (Binary search approach): " + minCost);
    }

    public void longestArithemticSubsequence(int[] nums) {
        //https://leetcode.com/problems/longest-arithmetic-subsequence/description/
        //based on Longest Increasing Subsequence
        /*
        nums[] = [9,4,7,2,10]

        as diff between arithemetic seq can be negative, its good to use map
        instead of arrays

        ##1.
        i = 0
        seq[i] = {} ==> seq[0] = {}
        j = 0; j < i
        FAIL

        seq[0] = {}

        ##2.
        i = 1
        seq[i] = {}
        j = 0; j < i
        ==> j = 0
        ==> diff = 9 - 4 = 5
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[1] = {5 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(0, 2) ==> 2;

        ==> j = 1
        FAIL

        seq[0] = {}
        seq[1] = {5 = 2}

        ##3.
        i = 2
        seq[i] = {} ==> seq[2] = {}
        j = 0; j < i ==> 2
        ==> j = 0
        ==> diff = 9 - 7 = 2
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[2] = {2 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 1
        ==> diff = 4 - 7 = -3
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[2] = {-3 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 2
        FAIL

        seq[0] = {}
        seq[1] = {5 = 2}
        seq[2] = {-3 = 2}

        ##4.
        i = 3
        seq[i] = {} ==> seq[3] = {}
        j = 0; j < i ==> 3
        ==> j = 0
        ==> diff = 9 - 2 = 7
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[3] = {7 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 1
        ==> diff = 4 - 2 = 2
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[3] = {2 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 2
        ==> diff = 7 - 2 = 5
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[3] = {2 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 3
        FAIL

        seq[0] = {}
        seq[1] = {5 = 2}
        seq[2] = {-3 = 2}
        seq[3] = {2 = 2}

        ##5.
        i = 4
        seq[i] = {} ==> seq[4] = {}
        j = 0; j < i ==> 4
        ==> j = 0
        ==> diff = 9 - 10 = 1
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[4] = {-1 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 1
        ==> diff = 4 - 10 = -6
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[3] = {-6 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 2) ==> 2;

        ==> j = 2
        ==> diff = 7 - 10 = -3
        **==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> {-3 = seq[2].(-3, 1) + 1} ==> seq[3] = {-3 = 3}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 3) ==> 3;

        ==> j = 3
        ==> diff = 2 - 10 = -8
        ==> seq[i] = {diff = seq[j].(diff, 1) + 1} ==> seq[3] = {-8 = 2}
        ==> maxLen = max(maxLen, seq[i].(diff)) ==> max(2, 3) ==> 3;

        ----END----

        maxLen = 3

         */
        int n = nums.length;
        int maxLength = 0;
        Map<Integer, Integer>[] incrSeq = new HashMap[n];

        for (int i = 0; i < n; i++) {
            incrSeq[i] = new HashMap<>();

            for (int j = 0; j < i; j++) {

                int diff = nums[j] - nums[i];

                incrSeq[i].put(diff, incrSeq[j].getOrDefault(diff, 1) + 1);

                maxLength = Math.max(maxLength, incrSeq[i].get(diff));
            }
        }
        //output
        System.out.println("Longest arithemetic subseq : " + maxLength);
    }

    private boolean maxFruitsHarvestedAfterAtMostKSteps_IsValidRange(
            int leftPos, int startPos, int rightPos, int k) {

        /*

        ideally:
        if leftPos < startPos < rightPos then the total dist between leftPos & rightPos
        should be at most 'k'

        but also to note in order to collect harvested fruits we can either
        go left side from startPos at most k steps
        OR
        go right side from startPos at most k steps

        in order for us calculate the exact range at any point we need to check here

         */
        if (rightPos <= startPos) {
            return startPos - leftPos <= k;
        }

        if (leftPos >= startPos) {
            return rightPos - startPos <= k;
        }

        int leftDist = startPos - leftPos;
        int rightDist = rightPos - startPos;

        return leftDist <= rightDist
                ? leftDist * 2 + rightDist <= k
                : rightDist * 2 + leftDist <= k;
    }

    public void maxFruitsHarvestedAfterAtMostKSteps(int[][] fruits, int startPos, int k) {
        //https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description/
        int n = fruits.length;
        int maxFruitsHarvested = 0;
        int start = 0;
        int end = 0;
        int currFruitHarvested = 0;

        while (end < n) {

            currFruitHarvested += fruits[end][1];

            while (end >= start && !maxFruitsHarvestedAfterAtMostKSteps_IsValidRange(
                    fruits[start][0], startPos, fruits[end][0], k)) {

                currFruitHarvested -= fruits[start++][1];
            }

            maxFruitsHarvested = Math.max(maxFruitsHarvested, currFruitHarvested);
            end++;
        }
        //output
        System.out.println("Max fruits harvested after at most k steps : " + maxFruitsHarvested);
    }

    public void totalCostToHireKWorkers(int[] costs, int k, int candidates) {
        //https://leetcode.com/problems/total-cost-to-hire-k-workers/description/
        int n = costs.length;
        //min heaps to store the workers with lowest cost value for both start side
        //and end side of workers
        PriorityQueue<Integer> startMinHeap = new PriorityQueue<>((a, b) -> Integer.compare(a, b));
        PriorityQueue<Integer> endMinHeap = new PriorityQueue<>((a, b) -> Integer.compare(a, b));

        int nextStartWorker = 0;
        int nextEndWorker = n - 1;

        //put all 'candidates' from start side into start min heap
        while (startMinHeap.size() < candidates) {
            startMinHeap.add(costs[nextStartWorker++]);
        }

        //put all 'candidates' from end side into end min heap but while adding
        //from end side the same workers should not be duplicately added into end
        //min heap that we have already added in start min heap thats why this
        //check is placed (nextEndWorker >= nextStartWorker)
        while (nextEndWorker >= nextStartWorker && endMinHeap.size() < candidates) {
            endMinHeap.add(costs[nextEndWorker--]);
        }

        long totalHireCost = 0;

        for (int i = 0; i < k; i++) {

            if (endMinHeap.isEmpty()
                    || (!startMinHeap.isEmpty() && startMinHeap.peek() <= endMinHeap.peek())) {

                totalHireCost += startMinHeap.poll();

                //in choosing 'candidates' from start side of workers from costs[i]
                //there might be chances that we overlap with the 'candidates'
                //from end side of workers from costs[i] in that case we will add
                //up workers in start min heap which are already there in end min heap
                //so to prevent adding duplicate workers we have a check:
                //(nextEndWorker >= nextStartWorker)
                if (nextEndWorker >= nextStartWorker) {
                    //if workers from start side are not overlapping with workers
                    //from end side, we can simply put a 'nextStartWorker' in start min heap
                    startMinHeap.add(costs[nextStartWorker++]);
                }
            } else {

                totalHireCost += endMinHeap.poll();

                //in choosing 'candidates' from end side of workers from costs[i]
                //there might be chances that we overlap with the 'candidates'
                //from start side of workers from costs[i] in that case we will add
                //up workers in end min heap which are already there in start min heap
                //so to prevent adding duplicate workers we have a check:
                //(nextEndWorker >= nextStartWorker)
                if (nextEndWorker >= nextStartWorker) {
                    //if workers from end side are not overlapping with workers
                    //from start side, we can simply put a 'nextEndWorker' in end min heap
                    endMinHeap.add(costs[nextEndWorker--]);
                }
            }
        }
        //output
        System.out.println("Total cost to hire k workers : " + totalHireCost);
    }

    public void countHillsAndValleysInArray(int[] nums) {
        //https://leetcode.com/problems/count-hills-and-valleys-in-an-array/description/
        int n = nums.length;
        List<Integer> distinct = new ArrayList<>();
        distinct.add(nums[0]);
        for (int i = 1; i < n; i++) {
            //skips, if two consecutive nums[i] & nums[i - 1] are same
            if (nums[i - 1] == nums[i]) {
                continue;
            }
            distinct.add(nums[i]);
        }

        n = distinct.size();
        int i = 1;
        int count = 0;

        while (i < n - 1) {

            if (distinct.get(i - 1) < distinct.get(i) && distinct.get(i) > distinct.get(i + 1)) {
                //hills
                count++;
            } else if (distinct.get(i - 1) > distinct.get(i) && distinct.get(i) < distinct.get(i + 1)) {
                //valleys
                count++;
            }
            i++;
        }
        //output
        System.out.println("Count hills and valleys : " + count);
    }

    public void longestEvenOddSubarrayWithThreshold(int[] nums, int threshold) {
        //https://leetcode.com/contest/weekly-contest-352/problems/longest-even-odd-subarray-with-threshold/
        //based on TWO POINTER
        /*

        You are given a 0-indexed integer array nums and an integer threshold.

        Find the length of the longest subarray of nums starting at index l and
        ending at index r (0 <= l <= r < nums.length) that satisfies the following
        conditions:

        1. nums[l] % 2 == 0
        2. For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2
        3. For all indices i in the range [l, r], nums[i] <= threshold

         */
        int n = nums.length;
        int start = 0;
        int end = 0;

        int maxLen = 0;

        while (end < n) {

            //find the first 'even' val in nums[] that will occur @end
            //so this while() will break when nums[end] is 'even'
            while (end < n && nums[end] % 2 != 0) {
                end++;
            }

            //case to handle nums[] with just 1 value
            if (end >= n) {
                break;
            }

            //here, we at index in nums[] where end ptr points to an even value
            //from this two pointer traversal we will try to calclate max len
            //so 'start' ptr = end, which is pointing to first 'even' value as per
            //condition: nums[l] % 2 == 0 where l == start of the subarray
            start = end;
            //in order to compare two adjacent values if they are even odd we move
            //'end' ptr to next index so that we can compare curr end & prev end(end - 1)
            end += 1;

            //case to handle where in complete nums[] we just have 1 even value
            //so that should be counted as of length 1 but only if this even val
            //is under threshold limit
            maxLen = Math.max(maxLen, (nums[start] <= threshold) ? 1 : 0);

            //2. For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2
            //3. For all indices i in the range [l, r], nums[i] <= threshold
            while (end < n
                    && nums[end - 1] <= threshold
                    && nums[end] <= threshold
                    && ((nums[end - 1] % 2) != (nums[end] % 2))) {

                maxLen = Math.max(maxLen, end - start + 1);
                end++;
            }
        }
        //output
        System.out.println("Longest even odd subarray with threshold : " + maxLen);
    }

    public void convertArrayToMatrixWithConditions(int[] nums) {
        //https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/description/
        /*

        For this question, given constraints are important

        Constraints:
        1 <= nums.length <= 200
        1 <= nums[i] <= nums.length
         */

        int n = nums.length;

        List<List<Integer>> matrix = new ArrayList<>();

        //as per constraint, 1 <= nums[i] <= nums.length
        //so max value in the nums[] can be 'n' that must be included in freqs[]
        //so make freqs[] of size (n + 1)
        int[] freqs = new int[n + 1];

        for (int val : nums) {
            freqs[val]++;
        }

        //keep count of vals processed from nums[]
        int picked = 0;

        while (picked < n) {

            List<Integer> row = new ArrayList<>();

            //as per constraint, 1 <= nums[i] <= nums.length
            //looping over all the possible distinct 'val' from nums, we will pick
            //it one by one, as for each row 'val's should be distinct
            for (int val = 1; val <= n; val++) {

                //skip, if the curr 'val' in nums[] don't exist anymore
                if (freqs[val] <= 0) {
                    continue;
                }

                //put the curr 'val' into curr row
                row.add(val);
                //as we have picked one 'val', we must reduce its freq
                freqs[val]--;
                //one value is picked and added into curr row
                picked++;
            }
            matrix.add(row);
        }

        //output
        System.out.println("Convert arrays to 2D matrix with conditions : " + matrix);
    }

    public void distinctNumbersInEachSubarray(int[] nums, int k) {
        //https://leetcode.com/problems/distinct-numbers-in-each-subarray/description/
        //https://leetcode.ca/all/1852.html
        //based on SLIDING WINDOW
        int n = nums.length;
        List<Integer> distinctNumbersCounts = new ArrayList<>();

        Map<Integer, Integer> distinctNumsToFreqs = new HashMap<>();

        int start = 0;
        int end = 0;

        //process first window of k-length subarray, count each value's freqs in
        //freqs map
        for (; end < k; end++) {
            distinctNumsToFreqs.put(nums[end], distinctNumsToFreqs.getOrDefault(nums[end], 0) + 1);
        }

        distinctNumbersCounts.add(distinctNumsToFreqs.size());

        while (end < n) {

            //maintain window of k-length subarray by adjusting start and end ptr
            //values from the window
            //add a new value to window from @end
            distinctNumsToFreqs.put(nums[end], distinctNumsToFreqs.getOrDefault(nums[end], 0) + 1);
            //reduce the freq of value @start ptr
            distinctNumsToFreqs.put(nums[start], distinctNumsToFreqs.getOrDefault(nums[start], 0) - 1);
            //if after reducing the freq of value @start, it becomes 0, remove its
            if (distinctNumsToFreqs.get(nums[start]) <= 0) {
                distinctNumsToFreqs.remove(nums[start]);
            }

            //move to next window of k-length
            end++;
            start++;

            //put count the distinct values present in curr window of k-length
            //subarray which will be taken as freqs.size()
            distinctNumbersCounts.add(distinctNumsToFreqs.size());

        }
        //output
        System.out.println("Distinct numbers in each k subarray : " + distinctNumbersCounts);
    }

    public void buildingWithAnOceanView(int[] heights) {
        //https://leetcode.com/problems/buildings-with-an-ocean-view/description/
        /*

        heights = [4,2,3,1].......OCEAN_VIEW_HERE

        index =     0 1 2 3
        heights =   4 2 3 1

        1 is at extreme right and can easily have ocean view
        result[] = [3]

        3 can pop building(1) and can easily have ocean view
        if(stack.peek < height) ==> (1 < 3) ==> TRUE
        ==>result[] = [3,2]

        2 can't pop building(3) and will not have ocean view
        if(stack.isEmpty || stack.peek < height) ==> (FAIL || FAIL)
        ==> result[] = [3,2]

        4 can pop building(2, 3) and can easily have ocean view
        if(stack.isEmpty) ==> TRUE
        result[] = [3,2,0]

        sort(result) ==> [0,2,3]

         */
        //based on nextGreaterElementToRightInArray()
        int n = heights.length;
        List<Integer> buildingsIndexWithOceanView = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {

            //curr height
            int height = heights[i];

            //pop out all the smaller height from stack that is in front/right of
            //curr 'height'
            while (!stack.isEmpty() && stack.peek() < height) {
                stack.pop();
            }

            //here, if curr 'height' can see the ocean if there is no building
            //at all OR if the curr 'height' is taller than the tallest building
            //in the stack i.e, stack.peek
            //if these cond matches, building with i-th index can see ocean
            if (stack.isEmpty() || stack.peek() < height) {
                buildingsIndexWithOceanView.add(i);
            }

            stack.push(height);
        }

        Collections.sort(buildingsIndexWithOceanView);
        //output
        //int[] result = result.stream().mapToInt(val -> val).toArray();
        System.out.println("Building with ocean view : " + buildingsIndexWithOceanView);
    }

    public void buildingWithAnOceanView2(int[] heights) {
        //https://leetcode.com/problems/buildings-with-an-ocean-view/description/
        //based on nextGreaterElementToRightInArray()
        //OPTIMIZED
        /*

        heights = [4,2,3,1].......OCEAN_VIEW_HERE

        index =     0 1 2 3
        heights =   4 2 3 1

        lastmaxBuildingHeight = MIN

        1 is at extreme right and can easily have ocean view
        if(lastmaxBuildingHeight < height) ==> (MIN < 1)
        ==> lastmaxBuildingHeight = height = 1
        ==> result[] = [3]

        3 can easily have ocean view
        if(lastmaxBuildingHeight < height) ==> (1 < 3)
        ==> lastmaxBuildingHeight = height = 3
        ==> result[] = [3,2]

        2 will not have ocean view
        if(lastmaxBuildingHeight < height) ==> (3 < 2) ==> FAIL
        ==> result[] = [3,2]

        4 can easily have ocean view
        if(lastmaxBuildingHeight < height) ==> (3 < 4)
        ==> lastmaxBuildingHeight = height = 3
        ==> result[] = [3,2,0]

         */
        int n = heights.length;
        List<Integer> buildingsIndexWithOceanView = new ArrayList<>();

        int lastMaxBuildingHeight = Integer.MIN_VALUE;

        for (int i = n - 1; i >= 0; i--) {

            //curr height
            int height = heights[i];

            if (lastMaxBuildingHeight < height) {
                lastMaxBuildingHeight = height;
                buildingsIndexWithOceanView.add(i);
            }
        }

        int[] result = new int[buildingsIndexWithOceanView.size()];
        int index = result.length - 1;

        for (int building : buildingsIndexWithOceanView) {
            result[index--] = building;
        }

        System.out.println("Building with ocean view (approach without stack): " + Arrays.toString(result));
    }

    public void carFleet(int[] positions, int[] speeds, int target) {
        //https://leetcode.com/problems/car-fleet/description/
        //based on nextGreaterElementToRightInArray()
        int n = positions.length;
        double[][] positionsToTime = new double[n][2];

        for (int i = 0; i < n; i++) {

            positionsToTime[i] = new double[]{positions[i], (double) (target - positions[i]) / speeds[i]};
        }

        Arrays.sort(positionsToTime, (a, b) -> Double.compare(a[0], b[0]));

        int fleet = 0;
        double lastTime = 0.0;

        for (int i = n - 1; i >= 0; i--) {

            double currTime = positionsToTime[i][1];

            if (currTime > lastTime) {
                lastTime = currTime;
                fleet++;
            }
        }

        //output
        System.out.println("Car fleet : " + fleet);
    }

    public void shortestDistanceToTargetColor(int[] colors, int[][] queries) {
        //https://leetcode.com/problems/shortest-distance-to-target-color/description/

        List<Integer> distances = new ArrayList<>();

        //as the given colors are only, 1, 2, 3 so we can take size of 4
        //and simply ignore index 0
        TreeSet<Integer>[] colorsToIndexes = new TreeSet[4];

        //create color-index array map, tree set will helpe store the indexes
        //in sorted order and we can apply floor() & ceiling() methods for
        //given index in the queires[][]
        colorsToIndexes[1] = new TreeSet<>();
        colorsToIndexes[2] = new TreeSet<>();
        colorsToIndexes[3] = new TreeSet<>();

        int n = colors.length;

        for (int i = 0; i < n; i++) {
            colorsToIndexes[colors[i]].add(i);
        }

        for (int[] query : queries) {

            int index = query[0];
            int color = query[1];

            //get a prev color-index occurred before 'index', if any
            Integer prevIndex = colorsToIndexes[color].floor(index);

            //get a next color-index occurred after 'index', if any
            Integer nextIndex = colorsToIndexes[color].ceiling(index);

            int minDist = Integer.MAX_VALUE;

            //find the min dist from the given 'index' to the prev occurred index
            if (prevIndex != null) {
                minDist = Math.min(minDist, Math.abs(index - prevIndex));
            }

            //find the min dist from the given 'index' to the next occurred index
            if (nextIndex != null) {
                minDist = Math.min(minDist, Math.abs(index - nextIndex));
            }

            //add the min dist
            distances.add(minDist == Integer.MAX_VALUE ? -1 : minDist);
        }

        //output
        System.out.println("Shortest distance to target color : " + distances);
    }

    public void slidingSubarrayBeauty(int[] nums, int window, int x) {
        //https://leetcode.com/problems/sliding-subarray-beauty/description/
        //based on SLIDING WINDOW
        int n = nums.length;
        int[] result = new int[n - window + 1];
        int index = 0;

        //as per given constraint: -50 <= nums[i] <= 50
        int[] freqs = new int[51];

        int start = 0;
        int end = 0;

        int currX = 0;

        //process the first window of window-lengthed subarray and count the freqs
        //of only negative values
        for (; end < window; end++) {

            //if the curr val @end that is nums[end] is negative
            if (nums[end] < 0) {
                //count the freq of this val @end, negative values can't be indexed
                //in arrays so better take abs(nums[end]) ==> -nums[end] as we already
                //know nums[end] is negative
                freqs[-nums[end]]++;
            }
        }

        //negVal = 50, why? as we are counting freqs for negative values and finding
        //the x-th smallest from the subarray of size 'window', since we can't map
        //negative values to freqs[] index, we made negative values as positive but
        //technically, 50 is not +50 it is representing -50 which is first smallest
        //negative value and reducing down to 1 ==> -1 (i.e, [1 to 50] ==> [-50 to -1])
        //we will find the x-th smallest negative value
        //negVal >= 1 why? because 0 can't be considered as +ve or -ve
        for (int negVal = 50; negVal >= 1; negVal--) {
            //count the freqs of negative values, this count will tell how many
            //times a particular 'negVal' existed in the curr 'window'
            //as we need to find the x-th smallest negative value so when the
            //currX reaches the x-th limit then that 'negVal' will be the x-th
            //smallest negative value
            currX += freqs[negVal];
            //ex: curr window subarray = [-3,-2,-3]
            //==> freqs[-2] = freqs[2] = 1
            //==> freqs[-3] = freqs[3] = 2
            //consider sorted form of the above subarray [-3,-3,-2] and we
            //need to find x = 2nd smallest negative value
            //from above, first samllest negative value = -3
            //then second smallest negative value = -3 ==> x-th smallest
            //loop: negVal = 3 to 1
            //==> currX += freqs[3] ==> 0 + 2 ==> 2
            //==> if: currX >= x hence found x-th smallest negative value
            if (currX >= x) {
                result[index++] = -negVal;
                //break, as soon as we find the first occuring x-th smallest
                //negative value
                break;
            }
        }

        //this case means,
        //in the curr 'window' we don't have enough elements through which we can
        //get the x-th smallest negative value, hence 0
        //also, if the curr 'window' only holds the positive values, then in that
        //case freqs[] for negative values are 0 means currX remained 0 only
        if (currX < x) {
            result[index++] = 0;
        }

        while (end < n) {

            //maintain the window, but moving start & end ptr and also increase
            //and decrease the negative value freqs if any
            //if the curr val @end that is nums[end] is negative
            if (nums[end] < 0) {
                freqs[-nums[end]]++;
            }

            //if the curr val @start that is nums[end] is negative
            if (nums[start] < 0) {
                freqs[-nums[start]]--;
            }

            end++;
            start++;

            currX = 0;

            for (int negVal = 50; negVal >= 1; negVal--) {

                currX += freqs[negVal];

                if (currX >= x) {
                    result[index++] = -negVal;
                    break;
                }
            }

            if (currX < x) {
                result[index++] = 0;
            }
        }

        //output
        System.out.println("Sliding subarray beauty : " + Arrays.toString(result));
    }

    public void scoresOfAllPrefixesOfArray(int[] nums) {
        //https://leetcode.com/problems/find-the-score-of-all-prefixes-of-an-array/description/
        int n = nums.length;

        long[] scores = new long[n];
        int index = 0;

        long maxVal = nums[0];

        long score = 0;

        for (int val : nums) {

            maxVal = Math.max(maxVal, val);

            score += val + maxVal;

            scores[index++] = score;
        }

        //output
        System.out.println("Scores of all prefixes of array : " + Arrays.toString(scores));
    }

    public void shortestSubarrayWithSumAtleastK(int[] nums, int k) {
        //https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/
        //based on PREFIX SUM, SLIDING WINDOW

        int n = nums.length;
        long[] prefixSumArr = new long[n + 1];

        for (int i = 0; i < n; i++) {
            prefixSumArr[i + 1] = prefixSumArr[i] + nums[i];
        }

        Deque<Integer> queue = new LinkedList<>();

        int shortestSubarrayLength = n + 1;

        int end = 0;

        while (end < n + 1) {

            while (!queue.isEmpty() && prefixSumArr[end] - prefixSumArr[queue.peekFirst()] >= k) {
                shortestSubarrayLength = Math.min(shortestSubarrayLength, end - queue.pollFirst());
            }

            while (!queue.isEmpty() && prefixSumArr[queue.peekLast()] >= prefixSumArr[end]) {
                queue.pollLast();
            }

            queue.add(end);

            end++;
        }

        //output
        shortestSubarrayLength = shortestSubarrayLength == n + 1 ? -1 : shortestSubarrayLength;
        System.out.println("Shortest subarray with sum atleast k : " + shortestSubarrayLength);
    }

    public void countSubarraysWithScoreLessThanK(int[] nums, int k) {
        //https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/
        //based on PREFIX SUM, SLIDING WINDOW
        /*

        ex: nums[] = [2,1,4,3,5], k = 10
        prefixSumArr[] = [2, 3, 7, 10, 15]

        iterations:

        n = 5
        start = 0
        end = 0

        #1.
        end < 5 ==> (0 < 5)
        prefixSum += nums[end] ==> 0 + 2 ==> 2

        //curr score sum of subarray * length of subarray(==> prefixSum * currWindowSize)
        //subarray window ==> [2]
        while(prefixSum * (end - start + 1) >= k) ==> (2 * 1 >= 10) ==> FALSE

        //subarray considered [2]
        subarrays += (end - start + 1) ==> 0 + 1 ==> 1

        end++ ==> 1


        #2.
        end < 5 ==> (1 < 5)
        prefixSum += nums[end] ==> 2 + 1 ==> 3

        //curr score sum of subarray * length of subarray(==> prefixSum * currWindowSize)
        //subarray window ==> [2, 1]
        while(prefixSum * (end - start + 1) >= k) ==> (3 * 2 >= 10) ==> FALSE

        //subarray considered [2, 1], [1]
        subarrays += (end - start + 1) ==> 1 + 2 ==> 3

        end++ ==> 2


        #3.
        end < 5 ==> (2 < 5)
        prefixSum += nums[end] ==> 3 + 4 ==> 7

        //curr score sum of subarray * length of subarray(==> prefixSum * currWindowSize)
        //subarray window ==> [2, 1, 4]
        while(prefixSum * (end - start + 1) >= k) ==> (7 * 3 >= 10) ==> TRUE
        ==>1.
        ===> prefixSum -= nums[start++] ==> 7 - 2 ==> 5
        ===> start ==> 1
        //(5 * 2 >= 10) ==> TRUE
        ==>2.
        ===> prefixSum -= nums[start++] ==> 5 - 1 ==> 4
        ===> start ==> 2
        //(4 * 1 >= 10) ==> FALSE
        ...INNER-WHILE-END...

        //subarray considered [4]
        subarrays += (end - start + 1) ==> 3 + 1 ==> 4

        end++ ==> 3


        #4.
        end < 5 ==> (3 < 5)
        prefixSum += nums[end] ==> 4 + 3 ==> 7

        //curr score sum of subarray * length of subarray(==> prefixSum * currWindowSize)
        //subarray window ==> [4,3]
        while(prefixSum * (end - start + 1) >= k) ==> (7 * 2 >= 10) ==> TRUE
        ==>1.
        ===> prefixSum -= nums[start++] ==> 7 - 4 ==> 3
        ===> start ==> 3

        //(3 * 1 >= 10) ==> FALSE
        ...INNER-WHILE-END...

        //subarray considered [3]
        subarrays += (end - start + 1) ==> 4 + 1 ==> 5

        end++ ==> 4


        #5.
        end < 5 ==> (4 < 5)
        prefixSum += nums[end] ==> 3 + 5 ==> 8

        //curr score sum of subarray * length of subarray(==> prefixSum * currWindowSize)
        //subarray window ==> [3,5]
        while(prefixSum * (end - start + 1) >= k) ==> (8 * 2 >= 10) ==> TRUE
        ==>1.
        ===> prefixSum -= nums[start++] ==> 8 - 3 ==> 5
        ===> start ==> 4

        //(5 * 1 >= 10) ==> FALSE
        ...INNER-WHILE-END...

        //subarray considered [5]
        subarrays += (end - start + 1) ==> 5 + 1 ==> 6

        end++ ==> 5
        ...END...

        total subarrays considered
        ==> subarrays = 6 ==> [2], [2,1], [1], [4], [3], [5]


         */
        int n = nums.length;

        long subarrays = 0;
        long prefixSum = 0;

        int start = 0;
        int end = 0;

        while (end < n) {

            prefixSum += nums[end];

            while (prefixSum * (end - start + 1) >= k) {
                prefixSum -= nums[start++];
            }

            subarrays += (end - start + 1);

            end++;
        }

        //output
        System.out.println("Count subarrays with score less than k : " + subarrays);
    }

    public void missingRanges(int[] nums, int lower, int upper) {
        //https://leetcode.com/problems/missing-ranges/description/
        List<List<Integer>> missingRanges = new ArrayList<>();
        int n = nums.length;

        if (n == 0) {
            System.out.println("Missing ranges : " + Arrays.asList(Arrays.asList(lower, upper)));
            return;
        }

        //as the nums[] given is sorted and unique integers
        //we need to find the missing ranges between lower & upper inclusive
        //so if any range is missing in between [lower to nums[0] - 1] we must
        //add that, why nums[0] - 1? because nums[0] is already covered in nums[]
        //we need to just check the previous value
        //ex: lower = -2, nums[] = [0, 1, 2]
        //initail missing range = [-2, -1] ==> [lower to nums[0] - 1]
        if (lower <= nums[0] - 1 && nums[0] - 1 <= upper) {
            missingRanges.add(Arrays.asList(lower, nums[0] - 1));
        }

        for (int i = 0; i < n - 1; i++) {

            //skip, if the curr and next values are consecutive, meaning no
            //missing ranges in between them
            if (nums[i + 1] - nums[i] == 1) {
                continue;
            }

            //missging range between the curr i-th nums[] value and (i+1)-th
            //nums[] value and not including them as they are already there in
            //nums[]
            //ex: nums[] = [5,6,9,10], we see that there are some missing ranges
            //between nums[i] = 6 & nums[i + 1] = 9 i.e, 7, 8
            //start = nums[i] + 1 = 7 & end = nums[i + 1] - 1 = 8
            int start = nums[i] + 1;
            int end = nums[i + 1] - 1;

            //also, these missing ranges should lie in between [lower to upper]
            if (lower <= start && end <= upper) {
                missingRanges.add(Arrays.asList(start, end));
            }
        }

        //sinilary above, there could be some missing ranges after the last value
        //in nums[] and the upper bound [nums[n - 1] + 1 to upper]
        //ex: upper =5, nums[] = [0, 1, 2]
        //last missing range = [3, 5] ==> [nums[n - 1] + 1 to upper]
        if (lower <= nums[n - 1] + 1 && nums[n - 1] + 1 <= upper) {
            missingRanges.add(Arrays.asList(nums[n - 1] + 1, upper));
        }

        //output
        System.out.println("Missing ranges : " + missingRanges);
    }

    private int specialArrayWithXElementsGreaterOrEqualToX_BinarySearch(int[] nums, int x) {

        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            //'mid' represents index where its nums[mid] value is assumed to be
            //greater or equal to given 'x'
            int mid = start + (end - start) / 2;

            //here, if nums[mid] is greater or equal to 'x' (==> x <= nums[mid])
            //then surely, mid's prev value (==> nums[mid - 1]) should be less
            //than 'x' (==> nums[mid - 1] < x) OR 'x' could be found at index 0
            //in that case there will be no (mid - 1) hence check (mid == 0)
            if ((mid == 0 || nums[mid - 1] < x) && x <= nums[mid]) {
                return mid;
            } else if (nums[mid] < x) {
                //here, value at curr 'mid' index is smaller than given 'x' but
                //we need nums[mid] to be greater or equal to 'x' hence we need
                //to move mid to right-side
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        return -1;
    }

    public int specialArrayWithXElementsGreaterOrEqualToX(int[] nums) {
        //https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/description/
        int n = nums.length;

        Arrays.sort(nums);

        //for each value 'x' there should exist 'x' number of elements that are
        //greater or equal to 'x'
        for (int x = n; x > 0; x--) {

            //find index where nums[index] >= x
            int index = specialArrayWithXElementsGreaterOrEqualToX_BinarySearch(nums, x);
            //count number of elements greater or equal to 'x'
            int countElements = index == -1 ? 0 : n - index;

            //if the number of elements greater or equal to 'x' are equal to 'x'
            if (x == countElements) {
                return x;
            }
        }

        return -1;
    }

    private int subarrayWithKDifferentIntegers_SlidingWindowHelper(int[] nums, int k) {

        int n = nums.length;

        Map<Integer, Integer> freqs = new HashMap<>();

        int subarrays = 0;

        int start = 0;
        int end = 0;

        while (end < n) {

            freqs.put(nums[end], freqs.getOrDefault(nums[end], 0) + 1);

            while (freqs.size() > k) {

                freqs.put(nums[start], freqs.getOrDefault(nums[start], 0) - 1);

                if (freqs.get(nums[start]) <= 0) {
                    freqs.remove(nums[start]);
                }

                start++;
            }

            subarrays += (end - start + 1);

            end++;
        }

        return subarrays;
    }

    public void subarrayWithKDifferentIntegers(int[] nums, int k) {
        //https://leetcode.com/problems/subarrays-with-k-different-integers/description/
        //explanation: https://leetcode.com/problems/subarrays-with-k-different-integers/solutions/523136/java-c-python-sliding-window/
        int subarraysWithExactKDistinctInteger
                //here, we count subarrays with 'atmost k' distinct integers
                = subarrayWithKDifferentIntegers_SlidingWindowHelper(nums, k)
                //here, we count subarrays with 'atmost k - 1' distinct integers
                - subarrayWithKDifferentIntegers_SlidingWindowHelper(nums, k - 1);

        //output
        System.out.println("Subarray with exactly k distinct integer : " + subarraysWithExactKDistinctInteger);
    }

    public int integerBreak(int n) {
        //https://leetcode.com/problems/integer-break/editorial/
        //based on MATHS
        if (n <= 3) {
            return n - 1;
        }

        int product = 1;

        while (n > 4) {
            product *= 3;
            n -= 3;
        }

        return product * n;
    }

    public void rotateMatrixClockWise90Deg(int[][] mat) {
        //https://leetcode.com/problems/rotate-image
        int col = mat[0].length;

        int left = 0;
        int right = col - 1;

        while (right > left) {
            //(right - left is amount of element need to take)
            for (int i = 0; i < (right - left); i++) {
                int top = left;
                int bottom = right;

                /*

                 top-[left + i]  ---> [top + i]-right
                 /\                             |
                 |   Clock dir                  |
                 |                             \/
                 [bottom - i]-left <---- bottom-[right - i]

                 */
                //save top-left corner value
                int topLeftCornerValue = mat[top][left + i];
                //in top-left put bottom-left value
                mat[top][left + i] = mat[bottom - i][left];
                //in bottom-left put bottom-right value
                mat[bottom - i][left] = mat[bottom][right - i];
                //in bottom-right put top-right value
                mat[bottom][right - i] = mat[top + i][right];
                //in top-right put top-left value
                mat[top + i][right] = topLeftCornerValue;
            }
            left++;
            right--;
        }

        //output
        System.out.println("N * N matrix 90deg clockwise rotation: ");
        for (int[] r : mat) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    public void rotateMatrixAntiClockWise90Deg(int[][] mat) {

        int row = mat.length;
        int col = mat[0].length;

        int left = 0;
        int right = col - 1;

        while (right > left) {

            for (int i = 0; i < (right - left); i++) {
                int top = left;
                int bottom = right;

                /*

                 [top + i]-left  <--- top-[right - i]
                 |                              /\
                 |   AntiClock dir              |
                 \/                             |
                 bottom-[left + i] ----> [bottom - i]-right

                 */
                //save top-left corner value
                int topLeftCornerValue = mat[top + i][left];
                //in top-right put top-right value
                mat[top + i][left] = mat[top][right - i];
                //in top-right put bottom-right value
                mat[top][right - i] = mat[bottom - i][right];
                //in bottom-right put bottom-left value
                mat[bottom - i][right] = mat[bottom][left + i];
                //in bottom-left put top-left value
                mat[bottom][left + i] = topLeftCornerValue;
            }
            left++;
            right--;
        }

        //output
        System.out.println("N * N matrix 90deg anticlockwise rotation: ");
        for (int[] r : mat) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    private int areaPerRow(int[] hist) {

        //same as laregstAreaHistogram method
        Stack<Integer> stack = new Stack<>();
        int n = hist.length;
        int maxArea = 0;
        int top;
        int areaWithTop;
        int i = 0;
        while (i < n) {

            if (stack.isEmpty() || hist[stack.peek()] <= hist[i]) {
                stack.push(i++);
            } else {
                top = stack.pop();
                areaWithTop = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
                maxArea = Math.max(maxArea, areaWithTop);
            }
        }

        while (!stack.isEmpty()) {
            top = stack.pop();
            areaWithTop = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
            maxArea = Math.max(maxArea, areaWithTop);
        }

        return maxArea;
    }

    public void maxAreaOfRectangleInBinaryMatrix(int[][] mat) {
        //https://leetcode.com/problems/maximal-rectangle
        //problem statment & sol: https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/
        //explanation: https://youtu.be/dAVF2NpC3j4
        //find max area of per row int the matrix
        //each row in the matrix is histogram
        //use max area histogram
        int R = mat.length;
        int C = mat[0].length;

        int maxArea = areaPerRow(mat[0]);

        for (int r = 1; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (mat[r][c] == 1) {
                    mat[r][c] += mat[r - 1][c];
                }
            }
            maxArea = Math.max(maxArea, areaPerRow(mat[r]));
        }

        //output:
        System.out.println("Max area in binary matrix: " + maxArea);
    }

    public void maximumOnesInRowOfABinarySortedMatrix_1(int[][] mat) {

        //.....................................T; O(M*N)
        //problem statement: https://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/
        int maxOnes = 0;
        int index = 0;
        for (int i = 0; i < mat.length; i++) {

            int onePerRow = areaPerRow(mat[i]);
            if (maxOnes < onePerRow) {
                maxOnes = onePerRow;
                index = i;
            }
        }
        //output;
        System.out.println("Max 1(s) found at index: " + (maxOnes == 0 ? -1 : index) + " counts of is are: " + maxOnes);
    }

    public void maximumOnesInRowOfABinarySortedMatrix_2(int[][] mat) {

        //............................T: O(M.LogN)
        //OPTIMISED
        int maxOnes = 0;
        int index = 0;
        for (int r = 0; r < mat.length; r++) {
            int C = mat[r].length;
            int firstIndexOfOne = findFirstOccurenceTargetInSortedArray(mat[r], 1);

            //if no index is found
            if (firstIndexOfOne == -1) {
                continue;
            }

            int onePerRow = C - firstIndexOfOne;
            if (maxOnes < onePerRow) {
                maxOnes = onePerRow;
                index = r;
            }
        }

        //output;
        System.out.println("Max 1(s) found at index: " + (maxOnes == 0 ? -1 : index) + " counts of is are: " + maxOnes);
    }

    public void findAValueInRowWiseSortedMatrix(int[][] mat, int K) {
        //https://leetcode.com/problems/search-a-2d-matrix-ii/
        int M = mat.length;
        int N = mat[0].length;

        int i = 0;
        int j = N - 1;

        //search starts from top right corner
        while (i < M && j >= 0) {

            if (mat[i][j] == K) {
                System.out.println("Found at: " + i + ", " + j);
                return;
            } else if (K < mat[i][j]) {
                j--;
            } else {
                i++;
            }
        }

        //K is not there in the matrix at all
        System.out.println("Not found");
    }

    public void spiralMatrixTraversal(int[][] mat) {
        //https://leetcode.com/problems/spiral-matrix/description/
        //https://leetcode.com/problems/spiral-matrix-ii/description/
        //https://leetcode.com/problems/spiral-matrix-iv/description/
        List<Integer> result = new ArrayList<>();

        int R = mat.length;
        int C = mat[0].length;

        int top = 0; // top row
        int bottom = R - 1; //bottom row
        int left = 0; //left col
        int right = C - 1; //right col
        int totalElement = R * C;

        //with each row and col processing we will shrink the matrix bounds (top++, bottom--, left++, right--)
        //result list is going to hold all the elements in the matrix
        while (result.size() < totalElement) {

            //get the top row from left to right
            for (int i = left; i <= right && result.size() < totalElement; i++) {
                result.add(mat[top][i]); //top row and ith col left to right
            }
            top++; //since we traversed top row now to next row next time.

            //top to bottom but right col
            for (int i = top; i <= bottom && result.size() < totalElement; i++) {
                result.add(mat[i][right]); //top to bottom but right col
            }
            right--; //now till here we have traversed the very right col of mat. for next time right col is prev

            //right to left but bottom row only
            for (int i = right; i >= left && result.size() < totalElement; i--) {
                result.add(mat[bottom][i]); //bottom row from right to left
            }
            bottom--; //completed bottom row also next time bottom to be prev one

            //bottom to top but only left col
            for (int i = bottom; i >= top && result.size() < totalElement; i--) {
                result.add(mat[i][left]); //left col
            }
            left++; //for next itr left will be moved ahead
        }

        //output:
        System.out.println("Spiral matrix: " + result);
    }

    public void spriralMatrixTraversalThree(int ROW, int COL, int rStart, int cStart) {
        //https://leetcode.com/problems/spiral-matrix-iii/description/
        int totalElements = ROW * COL;
        int[][] matrix = new int[totalElements][2];
        int[][] dirs = {
                //move right if dir is 0
                {0, 1},
                //move down if dir is 1
                {1, 0},
                //move left if dir is 2
                {0, -1},
                //move up if dir is 2
                {-1, 0}
        };

        int row = rStart;
        int col = cStart;

        //initially to move right from row & col, thats why dir is initially 0
        int dir = 0;
        int len = 0;
        int index = 0;

        matrix[index++] = new int[]{row, col};

        while (index < totalElements) {

            //for the dir == RIGHT OR dir == LEFT, we need to incr the elements
            //picking up len by 1
            if (dir == 0 || dir == 2) {
                len++;
            }

            //will pick all the elements(upto curr len) in the curr 'dir',
            //once the picking process is complete in curr 'dir', then we will
            //change the 'dir'
            for (int pick = 0; pick < len; pick++) {
                row += dirs[dir][0];
                col += dirs[dir][1];

                //if the new row & col is not 'isOutOfBounds'
                if (!(row < 0 || row >= ROW || col < 0 || col >= COL)) {
                    matrix[index++] = new int[]{row, col};
                }
            }

            //change the dir
            dir = (dir + 1) % 4;
        }
        //output
        System.out.println("Spiral matrix three all the coords : ");
        for (int[] coord : matrix) {
            System.out.println(Arrays.toString(coord));
        }
    }

    public void diagonalMatrixTraversal(int[][] mat) {

        int R = mat.length;
        int C = mat[0].length;
        int x = 0;
        int y = 0;
        boolean isGoingUp = true;
        int totalElements = R * C;
        int element = 0;
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> diagonal = new ArrayList<>();
        while (element < totalElements) {

            if (isGoingUp) {

                while (x >= 0 && y < C) {
                    diagonal.add(mat[x][y]);
                    x--;
                    y++;
                    element++;
                }

                if (x < 0 && y <= C - 1) {
                    x = 0;
                }

                if (y == C) {
                    x += 2;
                    y--;
                }
            } else {

                while (x < R && y >= 0) {
                    diagonal.add(mat[x][y]);
                    x++;
                    y--;
                    element++;
                }

                if (x <= R - 1 && y < 0) {
                    y = 0;
                }

                if (x == R) {
                    y += 2;
                    x--;
                }
            }

            isGoingUp = !isGoingUp;
            result.add(diagonal);
            diagonal = new ArrayList<>();
        }

        //output:
        System.out.println("Diagonal matrix: " + result);
    }

    public void sumOfElementsInMatrixExceptGivenRowAndCol(int[][] matrix, int[][] rowAndCol) {

        //OPTIMISED
        //..........................T: O((R * C) + n) where n = rowAndCol.length
        //..........................S: O(R + C) because rowSum and colSum array of size R & C respec
        //https://www.geeksforgeeks.org/find-sum-of-all-elements-in-a-matrix-except-the-elements-in-given-row-andor-column-2/
        int R = matrix.length;
        int C = matrix[0].length;

        int[] rowSum = new int[R];
        int[] colSum = new int[C];

        int sumOfElements = 0;

        for (int x = 0; x < R; x++) {
            for (int y = 0; y < C; y++) {
                sumOfElements += matrix[x][y]; //total sum of elements of matrix
                rowSum[x] += matrix[x][y]; //all the sum of elements in current row row
                colSum[y] += matrix[x][y]; //all the sum of elements in current col col
            }
        }

        for (int[] except : rowAndCol) {

            int row = except[0];
            int col = except[1];
            int sumWithoutRowAndCol = sumOfElements - rowSum[row] - colSum[col] + matrix[row][col];
            System.out.println("Sum of elements except row: " + row + " & col: " + col + " sum: " + sumWithoutRowAndCol);
        }
    }

    public void sortTheMatrixDiagonally(int[][] mat) {

        //.................................T: O(R * C)
        //DATA STRUCTURE BASED SORTING
        //https://leetcode.com/problems/sort-the-matrix-diagonally/
        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();
        int R = mat.length;
        int C = mat[0].length;

        //actual:
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                System.out.print(mat[r][c] + "\t");
            }
            System.out.println();
        }

        //All the elements in the diagonal lie at same location of r - c
        //map key will have all r - c locations of diagonal and inside a priority queue(minHeap)
        //which will keep elements of that diagonal in sorted order as we add it in.
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {

                map.putIfAbsent(r - c, new PriorityQueue<>());
                map.get(r - c).add(mat[r][c]);
            }
        }
        //generate the matrix from the data structure
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                mat[r][c] = map.get(r - c).poll();
            }
        }

        //output:
        System.out.println("Diagonally sorted matrix");
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                System.out.print(mat[r][c] + "\t");
            }
            System.out.println();
        }
    }

    public void minimumPathSumInGrid(int[][] grid) {
        //https://leetcode.com/problems/minimum-path-sum/
        int R = grid.length;
        int C = grid[0].length;

        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (r == 0 && c == 0) {
                    //skip the top-left corner
                    continue;
                } else if (r == 0) {
                    //curr row,col to be added with same-row, prev-col
                    grid[r][c] += grid[r][c - 1];
                } else if (c == 0) {
                    //curr row,col to be added with prev-row, same-col
                    grid[r][c] += grid[r - 1][c];
                } else {
                    //curr row,col to be added with min((prev-row, same-col) OR (same-row, prev-sol))
                    grid[r][c] += Math.min(grid[r - 1][c], grid[r][c - 1]);
                }
            }
        }
        //output
        System.out.println("Min path sum in grid from top-left to bottom-right: " + grid[R - 1][C - 1]);
    }

    public int triangleMinPathSumTopToBottom(List<List<Integer>> triangle) {
        //https://leetcode.com/problems/triangle/
        //explanation: https://youtu.be/OM1MTokvxs4
        int size = triangle.size();
        if (size == 1) {
            return triangle.get(0).get(0);
        }
        int secondLastRow = size - 2;
        //find the min values from the end rows and proceed from bottom to top
        //add each min value to curr row value
        for (int row = secondLastRow; row >= 0; row--) {

            int rowBelowCurr = row + 1;
            List<Integer> rowBelowCurrList = triangle.get(rowBelowCurr);
            List<Integer> currRowList = triangle.get(row);
            int currRowSize = currRowList.size();

            for (int c = 0; c < currRowSize; c++) {

                int currRowValue = currRowList.get(c);

                int firstChild = rowBelowCurrList.get(c);
                int secondChild = rowBelowCurrList.get(c + 1);

                int minOfTwoChild = Math.min(firstChild, secondChild);
                currRowList.set(c, currRowValue + minOfTwoChild);
            }
        }
        return triangle.get(0).get(0);
    }

    public int maxPathSumInMatrixFromFirstRowToLastRow(int[][] matrix) {
        //https://www.codingninjas.com/codestudio/problems/maximum-path-sum-in-the-matrix_797998?leftPanelTab=0
        //based on triangleMinPathSumTopToBottom
        int ROW = matrix.length;
        int COL = matrix[0].length;
        int maxPathSum = 0;

        if (ROW == 1) {
            for (int c = 0; c < COL; c++) {
                maxPathSum = Math.max(maxPathSum, matrix[0][c]);
            }
            return maxPathSum;
        }

        int secondLastRow = ROW - 2;
        //find the max values from the end rows and proceed from bottom to top
        //add each max values to curr row value
        for (int r = secondLastRow; r >= 0; r--) {
            int[] listBelowCurrRow = matrix[r + 1];
            for (int c = 0; c < COL; c++) {

                //default values
                int firstPos = Integer.MIN_VALUE;
                int midPos = Integer.MIN_VALUE;
                int secondPos = Integer.MIN_VALUE;

                //getting values for all 3 positions in the below row from
                //curr col c
                if (c - 1 >= 0) {
                    firstPos = listBelowCurrRow[c - 1];
                }
                midPos = listBelowCurrRow[c];
                if (c + 1 < COL) {
                    secondPos = listBelowCurrRow[c + 1];
                }

                //updating the curr value at matrix[r][c] with the max of all the 3
                //positions in the below row
                matrix[r][c] += Math.max(firstPos,
                        Math.max(midPos, secondPos));

                //at very top row == 0, calculate all the possible
                //max path sum in that row in all its col
                if (r == 0) {
                    maxPathSum = Math.max(maxPathSum, matrix[r][c]);
                }
            }
        }
        return maxPathSum;
    }

    public void rangeAdditionTwo(int m, int n, int[][] ops) {
        //https://leetcode.com/problems/range-addition-ii/
        //https://leetcode.com/problems/range-addition-ii/discuss/2759204/Java-Solution-oror-6-line-only-oror-Fast-oror-Easy
        int row = m;
        int col = n;
        for (int[] op : ops) {
            row = Math.min(row, op[0]);
            col = Math.min(col, op[1]);
        }
        //output
        System.out.println("Range addition two: " + (row * col));
    }

    public void smallestRectangleEnclosingBlackPixels(int[][] image) {
        //https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/
        //https://www.lintcode.com/problem/600/

        /*
         ....-----
         [[0, 0, 1, 0]]
         [[0, 1, 1, 0]]
         [[0, 1, 0, 0]]
         ....-----
         All black pixel region is covered under ---- which is this
         [[0,1]]
         [[1,1]]
         [[1,0]]
         //across the row
         topRow = 0 as first '1' is observed at image(0, 2)
         bottomRow = 2 as last '1' is observed at image(2, 1)
         //accross the col
         leftCol = 1 as first '1' is observed at image(1, 1)
         rightCol = 2 as last '1' is observed at image(1, 2)
         */
        int ROW = image.length;
        int COL = image[0].length;

        //topRow and leftCol are the initial row and col
        //point where we found the 1(black pixel)
        //that topRow and leftCol will enclose all these black pixels
        int topRow = ROW - 1;
        int leftCol = COL - 1;
        //bottomRow and rightCol are the last row and col
        //point where we found the 1(black pixel)
        //that bottomRow and rightCol will enclose all these black pixels
        int bottomRow = 0;
        int rightCol = 0;

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                if (image[row][col] == 1) {
                    topRow = Math.min(topRow, row);
                    bottomRow = Math.max(bottomRow, row);

                    leftCol = Math.min(leftCol, col);
                    rightCol = Math.max(rightCol, col);
                }
            }
        }

        //simialr like lengths be like end - start + 1
        int length = bottomRow - topRow + 1;
        int breadth = rightCol - leftCol + 1;

        int areaThatEncloseAllBlackPixels = length * breadth;
        //output
        System.out.println("Area that enclose all balck pixels: " + areaThatEncloseAllBlackPixels);
    }

    private boolean checkIfMoveIsLegal_IsOutOfBound(int row, int col, int ROW, int COL) {
        return row < 0 || row >= ROW || col < 0 || col >= COL;
    }

    private boolean checkIfMoveIsLegal_IsLegal(
            String[][] board, int row, int col,
            String color, int[] dir) {

        int ROW = board.length;
        int COL = board[0].length;
        //passed in row and col already have start point with
        //given color so need now to find a end point with same color
        //so we can simply start from next point in same dir
        row += dir[0];
        col += dir[1];

        int length = 1;

        while (!checkIfMoveIsLegal_IsOutOfBound(row, col, ROW, COL)) {
            //incr length for good line
            length++;
            String currCell = board[row][col];
            //if in the curr path in given dir[] from given row and col
            //we see any empty space(.) then that path is not valid
            if (currCell.equals(".")) {
                return false;
            }
            //if in the curr path in given dir[] from given row and col
            //we see same color in the endpoint then that path is a good line
            //like start point = [B W...W B] OR [W B...B W] == end point same as start
            if (currCell.equals(color)) {
                //but that good line should have a lenght of atleast 3
                return length >= 3;
            }
            //update row and col, straight in given dir[]
            row += dir[0];
            col += dir[1];
        }
        return false;
    }

    public void checkIfMoveIsLegal(String[][] board, int row, int col, String color) {
        //https://leetcode.com/problems/check-if-move-is-legal/
        //explanation: https://youtu.be/KxK33AcQZpQ
        board[row][col] = color;
        //need to check in all 8 dirs
        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1},
                {-1, -1},
                {-1, 1},
                {1, -1},
                {1, 1}
        };

        for (int[] dir : dirs) {
            //move curr row and col in same curr dir[]
            //and check if in that particular dir move is legal or not
            //if from any one dir we get legal move == true, answer is legal
            //for each dir we will be starting from same row and col point
            if (checkIfMoveIsLegal_IsLegal(board, row, col, color, dir)) {
                System.out.println("Move is legal");
                return;
            }
        }
        System.out.println("Move is not legal");
    }

    public void islandPerimeter(int[][] grid) {
        //https://leetcode.com/problems/island-perimeter/
        /*
         4-edged perimeter
         -----
         | 1 |
         -----

         if curr cell also have cell at upper row
         total perimeter for both cell are 8 but we see
         there is common edge in between that should be removed (i.e -2)
         -----
         | 1 |
         -----
         -----
         | 1 |
         -----
         like this and now the actual perimeter will be 6
         -----
         | 1 |
         | 1 |
         -----

         if curr cell also have cell at left col
         total perimeter for both cell are 8 but we see
         there is common edge in between that should be removed (i.e -2)
         ----- -----
         | 1 | | 1 |
         ----- -----
         like this and now the actual perimeter will be 6
         ----- ----
         | 1    1 |
         ----- ----
         */
        int ROW = grid.length;
        int COL = grid[0].length;

        int perimeter = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                //a single cell of 1 is 4-edged island
                if (grid[r][c] == 1) {
                    perimeter += 4;

                    //if upper cell also has 1 that means the curr cell and
                    //cell above will form 6-edged perimeter and both of them sharing
                    //one edge in common so removing the common edge from both cell
                    if (r > 0 && grid[r - 1][c] == 1) {
                        perimeter -= 2;
                    }
                    //if left cell also has 1 that means the curr cell and
                    //cell at left will form 6-edged perimeter and both of them sharing
                    //one edge in common so removing the common edge from both cell
                    if (c > 0 && grid[r][c - 1] == 1) {
                        perimeter -= 2;
                    }
                }
            }
        }
        //output:
        System.out.println("Island perimeter: " + perimeter);
    }

    public void rangeSumQuery2D(int[][] matrix, int[][] queries) {
        //https://leetcode.com/problems/range-sum-query-2d-immutable/
        //explanation: https://youtu.be/KE8MQuwE2yA
        int ROW = matrix.length;
        int COL = matrix[0].length;

        //convert matrix to prefix sum matrix
        for (int r = 0; r < ROW; r++) {
            int prefix = 0;
            for (int c = 0; c < COL; c++) {
                prefix += matrix[r][c];
                int aboveRow = r - 1 < 0 ? 0 : matrix[r - 1][c];
                matrix[r][c] = prefix + aboveRow;
            }
        }

        List<Integer> queriesSum = new ArrayList<>();
        for (int[] query : queries) {

            int topLeftRow = query[0];
            int topLeftCol = query[1];
            int bottomRightRow = query[2];
            int bottomRightCol = query[3];

            int bottomRightSum = matrix[bottomRightRow][bottomRightCol];
            int aboveRowSum = topLeftRow - 1 < 0 ? 0 : matrix[topLeftRow - 1][bottomRightCol];
            int leftColSum = topLeftCol - 1 < 0 ? 0 : matrix[bottomRightRow][topLeftCol - 1];
            int cornerValAboveTopLeft = (topLeftRow - 1 < 0 || topLeftCol - 1 < 0)
                    ? 0
                    : matrix[topLeftRow - 1][topLeftCol - 1];
            int sum = bottomRightSum - aboveRowSum - leftColSum + cornerValAboveTopLeft;
            queriesSum.add(sum);
        }
        //output
        System.out.println("Range sum queries in 2D: " + queriesSum);
    }

    public int kThSmallestElementInSortedMatrix(int[][] matrix, int k) {
        //..................................S: O(N.LogN), N = matrix ROW, COL
        //https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = matrix.length;
        int COL = matrix[0].length;

        PriorityQueue<Cell> minHeap = new PriorityQueue<>(
                (a, b) -> matrix[a.row][a.col] - matrix[b.row][b.col]);

        for (int r = 0; r < ROW; r++) {
            minHeap.add(new Cell(r, 0));
        }

        while (!minHeap.isEmpty()) {
            k--;
            Cell currCell = minHeap.poll();

            if (k == 0) {
                return matrix[currCell.row][currCell.col];
            }

            if (currCell.col + 1 < COL) {
                currCell.col++;
                minHeap.add(currCell);
            }
        }
        return -1;
    }

    public void equalRowAndColPairs(int[][] grid) {
        //https://leetcode.com/problems/equal-row-and-column-pairs/
        //grid == n * n ==> ROW == COL
        int ROW = grid.length;
        int COL = grid[0].length;
        String[] rowPatterns = new String[ROW];
        String[] colPatterns = new String[COL];

        //for each row r, create a row wise string
        for (int r = 0; r < ROW; r++) {
            //if curr rowPatterns[r] is null, assign it with empty string, where
            //we can concatenate all the grid[r][c] falling on row r
            if (rowPatterns[r] == null) {
                rowPatterns[r] = "";
            }
            //for each col c, create a col wise string
            for (int c = 0; c < COL; c++) {
                //if curr colPatterns[c] is null, assign it with empty string,
                //where we can concatenate all the grid[r][c] falling on col c
                if (colPatterns[c] == null) {
                    colPatterns[c] = "";
                }
                //',' is appended to handle cases [[11,1][1,11]]
                rowPatterns[r] += grid[r][c] + ",";
                colPatterns[c] += grid[r][c] + ",";
            }
        }

        int pairs = 0;
        for (String rowPattern : rowPatterns) {
            for (String colPattern : colPatterns) {
                if (rowPattern.equals(colPattern)) {
                    pairs++;
                }
            }
        }
        //output
        System.out.println("Pairs where row and col are same: " + pairs);
    }

    public void equalRowAndColPairs2(int[][] grid) {
        //https://leetcode.com/problems/equal-row-and-column-pairs/
        //slightly faster than above approach, however above aprroach is straight
        //forward
        //grid == n * n ==> ROW == COL
        int ROW = grid.length;
        int COL = grid[0].length;

        Map<String, Integer> colPatternsCount = new HashMap<>();

        for (int col = 0; col < COL; col++) {

            //create pattern for col-wise elements
            StringBuilder colPattern = new StringBuilder("[");
            for (int row = 0; row < ROW; row++) {

                colPattern.append(grid[row][col]);

                if (row != ROW - 1) {
                    colPattern.append(",");
                }
            }

            colPattern.append("]");
            colPatternsCount.put(
                    colPattern.toString(),
                    colPatternsCount.getOrDefault(colPattern.toString(), 0) + 1);
        }

        int pairs = 0;
        for (int row = 0; row < ROW; row++) {

            //create pattern for row-wise elements
            StringBuilder rowPattern = new StringBuilder("[");
            for (int col = 0; col < COL; col++) {
                rowPattern.append(grid[row][col]);
                if (col != COL - 1) {
                    rowPattern.append(",");
                }
            }
            rowPattern.append("]");

            //count pairs of rowPattern that matches with colPattern
            pairs += colPatternsCount.getOrDefault(rowPattern.toString(), 0);
        }
        //output
        System.out.println("Pairs where row and col are same (approach 2): " + pairs);
    }

    private int gameOfLife_GetAlivePopulationAround(int[][] board,
                                                    int row, int col, Map<String, Integer> state, int[][] dirs) {
        int alive = 0;
        for (int[] dir : dirs) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            //if isOutOfBounds
            if (newRow < 0 || newRow >= board.length
                    || newCol < 0 || newCol >= board[0].length) {
                continue;
            }
            int neighbour = board[newRow][newCol];
            //why we are checking "ALIVE_TO_DEAD"? because the board is maintaing
            //intermediate state of cells that was alive and now dead Or vice versa
            //(acc to rules). Since state.get("ALIVE_TO_DEAD") == 3 is a state
            //that tells the cell was ALIVE initially so we need to actually consider
            //this initial state
            if (neighbour == state.get("STAYS_ALIVE") || neighbour == state.get("ALIVE_TO_DEAD")) {
                alive++;
            }
        }
        return alive;
    }

    public void gameOfLife(int[][] board) {
        //https://leetcode.com/problems/game-of-life/
        //exlanation: https://youtu.be/T9Y82JH4-pY
        /*
        The board is made up of an m row n grid of cells, where each cell has an
        initial state: live (represented by a 1) or dead (represented by a 0).
        Each cell interacts with its eight neighbors (horizontal, vertical,
        diagonal) using the following four rules (taken from the above Wikipedia article):

        1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
        2. Any live cell with two or three live neighbors lives on to the next generation.
        3. Any live cell with more than three live neighbors dies, as if by over-population.
        4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
         */

        int ROW = board.length;
        int COL = board[0].length;

        //actual:
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
        System.out.println();

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1},
                {-1, -1},
                {-1, 1},
                {1, -1},
                {1, 1}
        };
        //intermediate state of population
        Map<String, Integer> state = new HashMap<>();
        state.put("STAYS_DEAD", 0); // acc to rule 0 -> 0
        state.put("STAYS_ALIVE", 1); // acc to rule 1 -> 1
        state.put("DEAD_TO_ALIVE", 2); // acc to rule 0 -> 1
        state.put("ALIVE_TO_DEAD", 3); // acc to rule 1 -> 0

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                int populationAroundCurrPerson = gameOfLife_GetAlivePopulationAround(board, r, c, state, dirs);

                //1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
                //3. Any live cell with more than three live neighbors dies, as if by over-population.
                if (board[r][c] == 1
                        && (populationAroundCurrPerson < 2 || populationAroundCurrPerson > 3)) {
                    board[r][c] = state.get("ALIVE_TO_DEAD"); //live cell now dead
                } else if (board[r][c] == 0 && populationAroundCurrPerson == 3) {
                    //4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
                    board[r][c] = state.get("DEAD_TO_ALIVE"); //dead cell now alive
                }
            }
        }

        //changing state back to result
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (board[r][c] == state.get("ALIVE_TO_DEAD")) {
                    board[r][c] = 0;
                } else if (board[r][c] == state.get("DEAD_TO_ALIVE")) {
                    board[r][c] = 1;
                }
            }
        }
        //output
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
        System.out.println();
    }

    private int largestImageOverlap_Convolute(int[][] img1, int[][] img2Padded, int xShift, int yShift) {
        int result = 0;
        for (int row = 0; row < img1.length; row++) {
            for (int col = 0; col < img1.length; col++) {
                result += img1[row][col] * img2Padded[row + yShift][col + xShift];
            }
        }
        return result;
    }

    public void largestImageOverlap(int[][] img1, int[][] img2) {
        //https://leetcode.com/problems/image-overlap/
        //https://leetcode.com/problems/image-overlap/solution/
        int N = img1.length;
        int maxOverLaps = 0;
        int[][] img2Padded = new int[3 * N - 2][3 * N - 2];
        for (int row = 0; row < N; row++) {
            for (int col = 0; col < N; col++) {
                img2Padded[row + N - 1][col + N - 1] = img2[row][col];
            }
        }

        for (int xShift = 0; xShift < 2 * N - 1; xShift++) {
            for (int yShift = 0; yShift < 2 * N - 1; yShift++) {
                maxOverLaps = Math.max(maxOverLaps,
                        largestImageOverlap_Convolute(img1, img2Padded, xShift, yShift));
            }
        }
        //output
        System.out.println("Largest image overlap between two images: " + maxOverLaps);
    }

    public int largestAreaInMatrixBetweenKBlockedRowCols(int n, int m, int[][] blocked) {
        //https://practice.geeksforgeeks.org/problems/enemy/1
        int k = blocked.length;
        if (k == 0) {
            return n * m;
        }

        List<Integer> rows = new ArrayList<>();
        List<Integer> cols = new ArrayList<>();

        rows.add(0);
        cols.add(0);

        rows.add(n + 1);
        cols.add(m + 1);

        for (int[] block : blocked) {
            rows.add(block[0]);
            cols.add(block[1]);
        }

        Collections.sort(rows);
        Collections.sort(cols);

        int maxRowEdge = 0;
        int maxColEdge = 0;

        for (int i = 0; i < rows.size() - 1; i++) {
            maxRowEdge = Math.max(maxRowEdge, rows.get(i + 1) - rows.get(i) - 1);
        }

        for (int i = 0; i < cols.size() - 1; i++) {
            maxColEdge = Math.max(maxColEdge, cols.get(i + 1) - cols.get(i) - 1);
        }

        return maxRowEdge * maxColEdge;
    }

    public void countUnguardedCellsInGrid(int m, int n, int[][] guards, int[][] walls) {
        //https://leetcode.com/problems/count-unguarded-cells-in-the-grid/
        Set<String> guardSet = new HashSet<>();
        Set<String> wallSet = new HashSet<>();
        Set<String> cellsWatchedbyGuards = new HashSet<>();

        int totalCell = m * n;

        for (int[] guard : guards) {
            guardSet.add(guard[0] + "," + guard[1]);
        }

        for (int[] wall : walls) {
            wallSet.add(wall[0] + "," + wall[1]);
        }

        for (int[] guard : guards) {

            int currRow = guard[0];
            int currCol = guard[1];

            //UP - NORTH
            currRow -= 1;
            while (currRow >= 0) {
                //seeing cells straight in NORTH dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }

                cellsWatchedbyGuards.add(currRow + "," + currCol);
                currRow--;
            }

            //DOWN - SOUTH
            currRow = guard[0] + 1;
            while (currRow < m) {
                //seeing cells straight in SOUTH dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }

                cellsWatchedbyGuards.add(currRow + "," + currCol);
                currRow++;
            }

            //LEFT - WEST
            currRow = guard[0];
            currCol = guard[1] - 1;
            while (currCol >= 0) {
                //seeing cells straight in WEST dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }

                cellsWatchedbyGuards.add(currRow + "," + currCol);
                currCol--;
            }

            //RIGHT - EAST
            currCol = guard[1] + 1;
            while (currCol < n) {
                //seeing cells straight in EAST dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }

                cellsWatchedbyGuards.add(currRow + "," + currCol);
                currCol++;
            }
        }
        //output
        //not guarded cells =
        //total cells
        //- (cell occuipied with guards already + cells watched by guards + cells blocked by walls)
        int unoccupiedCells = totalCell - (guards.length + cellsWatchedbyGuards.size() + walls.length);

        System.out.println("Unguarded cells: " + unoccupiedCells);
    }

    public int minOperationsToMakeUniValuedGrid(int[][] grid, int x) {
        //https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/description/
        //based on minMovesToMakeArrayEqualTwo()
        int ROW = grid.length;
        int COL = grid[0].length;

        int totalElements = ROW * COL;

        List<Integer> elements = new ArrayList<>();

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                elements.add(grid[row][col]);
            }
        }

        Collections.sort(elements);

        int medianIndex = totalElements % 2 == 0 ? (totalElements - 1) / 2 : totalElements / 2;

        int medianVal = elements.get(medianIndex);

        int moves = 0;

        for (int val : elements) {

            //to make grid uni-valued, we will try to convert all other elements
            //to be same as 'medianVal'
            int diff = Math.abs(medianVal - val);

            //inorder to make the value of grid[][] univalued we must convert
            //all other values to a medianVal for that we must incr or decr the
            //curr val with given 'x' that means either curr val + x or val - x
            //so diff between the target 'medianVal' and curr val is strictly
            //divisible by x means diff % x has to be strictly divisible means
            //only remainder reqired is (==> 0) which in turn means, we make 'x'
            //incr or decr to curr val so that we reach to target medianVal exactly
            //ex: medianVal = 2, curr val = 1, x = 2
            //with this val + x ==> 1 + 2 ==> 3 we will never make val equal to
            //target, how?
            //diff = abs(medianVal - val) ==> 2 - 1 ==> 1
            //diff % x ==> 1 % 2 != 0
            if (diff % x != 0) {
                return -1;
            }

            //number of time we need to incr or decr curr val with x to make it
            //equal to target medianVal
            int incrOrDecr = diff / x;

            moves += incrOrDecr;
        }

        return moves;
    }

    public int firstCompletelyPaintedRowOrCol(int[] paint, int[][] matrix) {
        //https://leetcode.com/problems/first-completely-painted-row-or-column/description/
        /*

        num in paint[] is also contained in matrix[r][c]
        so paint[i] = matrix[r][c] = num and all the num value in both paint[]
        and matrix[][] are unique as num is one of these values [1 to ROW * COL]

        This question requires that we should return an index 'i' from paint[]
        where uptil this i-th index either a row or col in matrix must have been
        completely painted.

        we know that we have rows = ROW and each contains cells that counts to COL
        similarly we have cols = COL and each contains cells that counts to ROW

        //hence each unpaintedCellsInEachRow has cell equals to COL
        row1 = [COL]
        row2 = [COL]
        row3 = [COL]

        //hence each unpaintedCellsInEachCol has cell equals to ROW
        col1    col2    col3
        [ROW]   [ROW]   [ROW]

        each time we get a num from paint[i] then num in matrix must be painted
        that num in matrix[][] is store in numCellsMap as int[]{row, col}

        then this num = matrix[][] = cells(row, col) should be painted in
        unpaintedCellsInEachRow on row
        and
        unpaintedCellsInEachCol on col

        if at any time
        unpaintedCellsInEachRow[row] == 0
        or unpaintedCellsInEachCol[col] == 0
        means we have painted either a row or col in matrix[][]
        return that 'i'

         */
        int len = paint.length;

        int ROW = matrix.length;
        int COL = matrix[0].length;

        int[] unpaintedCellsInEachRow = new int[ROW];
        Arrays.fill(unpaintedCellsInEachRow, COL);

        int[] unpaintedCellsInEachCol = new int[COL];
        Arrays.fill(unpaintedCellsInEachCol, ROW);

        //<num, Cell(r, c)>
        Map<Integer, int[]> numCellsMap = new HashMap<>();

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                numCellsMap.put(matrix[r][c], new int[]{r, c});
            }
        }

        for (int i = 0; i < len; i++) {

            int num = paint[i];

            int[] currCell = numCellsMap.get(num);

            int row = currCell[0];
            int col = currCell[1];

            unpaintedCellsInEachRow[row]--;
            if (unpaintedCellsInEachRow[row] == 0) {
                return i;
            }

            unpaintedCellsInEachCol[col]--;
            if (unpaintedCellsInEachCol[col] == 0) {
                return i;
            }
        }
        return len - 1;
    }

    public void sortTheStudentByTheirKThScore(int[][] score, int k) {
        //https://leetcode.com/problems/sort-the-students-by-their-kth-score/description/
        //ROW = number of students
        int ROW = score.length;
        //COL = number of subjects
        int COL = score[0].length;
        //where score[row][col] = score obtained by student row-th in its col-th
        //subject

        //sort the score row-wise in which the score obtained by 'student' in its
        //k-th subject score[student][k] should be highest to lowest that why using
        //TreeMap with Collections.reverseOrder(), also given that each value
        //in score[][] is distinct
        TreeMap<Integer, int[]> sortByKThScore = new TreeMap<>(Collections.reverseOrder());

        for (int student = 0; student < ROW; student++) {
            int kThScore = score[student][k];
            sortByKThScore.put(kThScore, score[student]);
        }

        int index = 0;
        for (int[] scoreRow : sortByKThScore.values()) {
            //each index-th row is now repleaced with different score[row] that
            //is in sorted order
            score[index++] = scoreRow;
        }
        //output
        System.out.println("Sort the student by their k-th score: ");
        for (int[] row : score) {
            System.out.println(Arrays.toString(row));
        }
    }

    public int smallestCommonElement(int[][] matrix) {
        //https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/
        int ROW = matrix.length;
        int COL = matrix[0].length;

        Map<Integer, Integer> freqs = new HashMap<>();

        for (int col = 0; col < COL; col++) {

            for (int row = 0; row < ROW; row++) {

                int val = matrix[row][col];

                freqs.put(val, freqs.getOrDefault(val, 0) + 1);

                if (freqs.get(val) == ROW) {
                    return val;
                }
            }
        }

        return -1;
    }

    public String reverseString(String str) {

        int len = str.length();
        char[] ch = str.toCharArray();

        //.....................reverse by length
        //.....................O(N)
        for (int i = 0; i < len / 2; i++) {
            char temp = ch[i];
            ch[i] = ch[len - i - 1];
            ch[len - i - 1] = temp;
        }

        //output
        System.out.println("output reverse by length: " + String.valueOf(ch));

        //....................reverse by two pointer
        //....................O(N)
        int f = 0;
        int l = len - 1;
        ch = str.toCharArray();

        while (f < l) {

            char temp = ch[f];
            ch[f] = ch[l];
            ch[l] = temp;
            f++;
            l--;

        }

        //output
        System.out.println("output reverse by two pointer: " + String.valueOf(ch));

        //............................reverse by STL
        String output = new StringBuilder(str)
                .reverse()
                .toString();
        System.out.println("output reverse by STL: " + output);

        return output;

    }

    public boolean isStringPallindrome(String str) {
        return str.equals(reverseString(str));
    }

    public boolean isStringPallindrome(String str, int start, int end) {
        //based on two pointers
        while (end > start) {
            if (str.charAt(start) != str.charAt(end)) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }

    public void printDuplicatesCharInString(String str) {
        System.out.println("For: " + str);

        Map<Character, Integer> countMap = new HashMap<>();
        for (char c : str.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }

        countMap.entrySet().stream()
                .filter(e -> e.getValue() > 1)
                .forEach(e -> System.out.println(e.getKey() + " " + e.getValue()));

    }

    public void romanStringToDecimal(String str) {

        //actual
        System.out.println("roman: " + str);

        Map<Character, Integer> roman = new HashMap<>();
        roman.put('I', 1);
        roman.put('V', 5);
        roman.put('X', 10);
        roman.put('L', 50);
        roman.put('C', 100);
        roman.put('D', 500);
        roman.put('M', 1000);

        int decimal = 0;
        for (int i = 0; i < str.length(); i++) {

            char c = str.charAt(i);
            if (i > 0 && roman.get(str.charAt(i - 1)) < roman.get(c)) {
                decimal += roman.get(c) - 2 * roman.get(str.charAt(i - 1));
            } else {
                decimal += roman.get(c);
            }
        }

        //output
        System.out.println("Decimal: " + decimal);
    }

    public void integerToRomanString(int num) {

        Map<Integer, String> map = new HashMap<>();
        map.put(null, "");
        map.put(0, "");
        map.put(1, "I");
        map.put(2, "II");
        map.put(3, "III");
        map.put(4, "IV");
        map.put(5, "V");
        map.put(6, "VI");
        map.put(7, "VII");
        map.put(8, "VIII");
        map.put(9, "IX");
        map.put(10, "X");
        map.put(20, "XX");
        map.put(30, "XXX");
        map.put(40, "XL");
        map.put(50, "L");
        map.put(60, "LX");
        map.put(70, "LXX");
        map.put(80, "LXXX");
        map.put(90, "XC");
        map.put(100, "C");
        map.put(200, "CC");
        map.put(300, "CCC");
        map.put(400, "CD");
        map.put(500, "D");
        map.put(600, "DC");
        map.put(700, "DCC");
        map.put(800, "DCCC");
        map.put(900, "CM");
        map.put(1000, "M");
        map.put(2000, "MM");
        map.put(3000, "MMM");
        int actualNum = num;
        int pow = 0;
        StringBuilder sb = new StringBuilder();
        while (num != 0) {

            // System.out.println(num +" -- " +(Math.pow(10, mul) * (num%10))+" -- "+map.get((int)(Math.pow(10, mul++) * (num%10))));
            int remainder = num % 10;
            int tens = (int) Math.pow(10, pow++);
            sb.insert(0, map.get((int) (tens * remainder)));
            num /= 10;
        }
        //output
        System.out.println("Given " + actualNum + " as roman string: " + sb.toString());
    }

    public void longestCommonSubsequence(String a, String b) {

        //memoization
        int[][] memo = new int[a.length() + 1][b.length() + 1];
        //base cond
        for (int[] x : memo) {
            Arrays.fill(x, 0);
        }

        for (int x = 1; x < a.length() + 1; x++) {
            for (int y = 1; y < b.length() + 1; y++) {
                if (a.charAt(x - 1) == b.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x - 1][y], memo[x][y - 1]);
                }
            }
        }

        int l = a.length();
        int m = b.length();
        StringBuilder sb = new StringBuilder();
        while (l > 0 && m > 0) {

            if (a.charAt(l - 1) == b.charAt(m - 1)) {
                sb.insert(0, a.charAt(l - 1));
                l--;
                m--;
            } else {

                if (memo[l - 1][m] > memo[l][m - 1]) {
                    l--;
                } else {
                    m--;
                }
            }
        }

        //output
        System.out.println("Longest common subseq: " + sb.toString());
    }

    public String countAndSay_Helper(int n) {

        //https://leetcode.com/problems/count-and-say/
        //base cond
        if (n == 1) {
            return "1";
        }

        String ans = countAndSay_Helper(n - 1);

        StringBuilder sb = new StringBuilder();
        char ch = ans.charAt(0);
        int counter = 1;
        //for i==ans.length() i.e very last itr of loop
        //this itr will only invoke else cond below
        for (int i = 1; i <= ans.length(); i++) {
            //i<ans.length() bound the calculations upto string length
            if (i < ans.length() && ans.charAt(i) == ch) {
                counter++;
            } else {
                sb.append(counter).append(ch);
                //i<ans.length() bound the calculations upto string length
                if (i < ans.length()) {
                    ch = ans.charAt(i);
                }
                counter = 1;
            }
        }
        return sb.toString();
    }

    public void countAndSay(int n) {
        System.out.println("Count and say: " + countAndSay_Helper(n));
    }

    public void removeConsecutiveDuplicateInString(String str) {

        //https://www.geeksforgeeks.org/remove-consecutive-duplicates-string/
        char[] ch = str.toCharArray();
        int start = 0;
        int end = 1;

        while (end < ch.length) {

            if (ch[start] != ch[end]) {
                ch[start + 1] = ch[end];
                start++;
            }
            end++;
        }

        System.out.println("output: " + String.valueOf(ch, 0, start + 1));
    }

    private void printSentencesFromCollectionOfWords_Propagte_Recursion(String[][] words,
                                                                        int m, int n,
                                                                        String[] output) {
        // Add current word to output array
        output[m] = words[m][n];

        // If this is last word of
        // current output sentence,
        // then print the output sentence
        if (m == words.length - 1) {
            for (int i = 0; i < words.length; i++) {
                System.out.print(output[i] + " ");
            }
            System.out.println();
            return;
        }

        // Recur for next row
        for (int i = 0; i < words.length; i++) {
            if (!"".equals(words[m + 1][i]) && m < words.length) {
                printSentencesFromCollectionOfWords_Propagte_Recursion(words, m + 1, i, output);
            }
        }
    }

    public void printSentencesFromCollectionOfWords(String[][] words) {

        //https://www.geeksforgeeks.org/recursively-print-all-sentences-that-can-be-formed-from-list-of-word-lists/
        String[] output = new String[words.length];

        // Consider all words for first
        // row as starting points and
        // print all sentences
        for (int i = 0; i < words.length; i++) {
            if (words[0][i] != "") {
                printSentencesFromCollectionOfWords_Propagte_Recursion(words, 0, i, output);
            }
        }
    }

    public void longestPrefixAlsoSuffixInString_KMPAlgo(String s) {

        int n = s.length();
        int[] lps = new int[n];
        int prefixIndex = 0, suffixIndex = 1;
        while (suffixIndex < n) {
            if (s.charAt(prefixIndex) == s.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }

        System.out.println("Length of longest prefix: " + prefixIndex);
        System.out.println("Longest prefix substring: " + (prefixIndex == 0 ? "" : s.substring(0, prefixIndex)));
    }

    public String reorganizeString(String S) {
        //https://leetcode.com/problems/reorganize-string/
        int N = S.length();
        Map<Character, Long> map = S.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        PriorityQueue<Character> heap = new PriorityQueue<>(
                //if freq are same for two char
                //sort then alphabetically else max freq first
                (e1, e2) -> map.get(e1) == map.get(e2)
                        ? e1 - e2
                        : (int) (map.get(e2) - map.get(e1))
        );

        //check all unique char in string S and put it in heap
        //alternatively stream api : for(char chr :  S.chars().mapToObj(c -> (char)c).collect(Collectors.toSet()))
        for (char ch : map.keySet()) {
            if (map.get(ch) > (N + 1) / 2) {
                return "";
            }
            heap.add(ch);
        }

        StringBuilder sb = new StringBuilder();
        while (heap.size() >= 2) {

            char chA = heap.poll();
            char chB = heap.poll();

            sb.append(chA);
            sb.append(chB);

            map.put(chA, map.get(chA) - 1);
            if (map.get(chA) > 0) {
                heap.add(chA);
            }

            map.put(chB, map.get(chB) - 1);
            if (map.get(chB) > 0) {
                heap.add(chB);
            }
        }

        if (!heap.isEmpty()) {
            sb.append(heap.poll());
        }

        return sb.toString();
    }

    public void longestCommonPrefix(String[] strs) {

        //https://leetcode.com/problems/longest-common-prefix/
        if (strs == null || strs.length == 0) {
            return;
        }

        if (strs.length == 1) {
            System.out.println("Longest common prefix in list of strings: " + strs[0]);
            return;
        }

        String str = strs[0]; // first string as starting point
        String result = str;
        int index = 0;
        for (int i = 1; i < strs.length; i++) {
            String s = strs[i];
            int minLen = Math.min(s.length(), str.length());
            while (index < minLen && str.charAt(index) == s.charAt(index)) {
                index++;
            }
            String pref = str.substring(0, index);
            if (pref.length() < result.length()) {
                result = pref;
            }
            index = 0;
        }
        System.out.println("Longest common prefix in list of strings: " + result);
    }

    public void secondMostOccuringWordInStringList(String[] list) {

        Map<String, Integer> map = new HashMap<>();
        for (String s : list) {
            map.put(s, map.getOrDefault(s, 0) + 1);
        }

        PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>(
                (e1, e2) -> e1.getValue() - e2.getValue()
        );

        for (Map.Entry<String, Integer> e : map.entrySet()) {
            minHeap.add(e);
            if (minHeap.size() > 2) {
                minHeap.poll();
            }
        }

        System.out.println("Second most occuring word: " + minHeap.poll().getKey());
    }

    public boolean checkIsomorphicStrings_1(String s1, String s2) {

        int m = s1.length();
        int n = s2.length();

        if (m != n) {
            System.out.println("Not isomorphic strings");
            return false;
        }

        int SIZE = 256; //to handle numric & alphabetic ascii ranges
        boolean[] marked = new boolean[SIZE];
        int[] map = new int[SIZE];
        Arrays.fill(map, -1);

        for (int i = 0; i < m; i++) {
            if (map[s1.charAt(i)] == -1) {

                if (marked[s2.charAt(i)] == true) {
                    return false;
                }

                marked[s2.charAt(i)] = true;
                map[s1.charAt(i)] = s2.charAt(i);

            } else if (map[s1.charAt(i)] != s2.charAt(i)) {
                return false;
            }
        }

        return true;
    }

    public boolean checkIsomorphicStrings_2(String s1, String s2) {

        //........................T: O(N)
        //EASIER EXPLAINATION
        int m = s1.length();
        int n = s2.length();

        if (m != n) {
            System.out.println("Not isomorphic strings");
            return false;
        }

        Map<Character, Character> map = new HashMap<>();
        for (int i = 0; i < m; i++) {
            char sChar = s1.charAt(i);
            char tChar = s2.charAt(i);

            if (map.containsKey(sChar) && map.get(sChar) != tChar) {
                return false;
            }
            map.put(sChar, tChar);
        }

        map.clear();

        for (int i = 0; i < m; i++) {
            char sChar = s1.charAt(i);
            char tChar = s2.charAt(i);

            if (map.containsKey(tChar) && map.get(tChar) != sChar) {
                return false;
            }
            map.put(tChar, sChar);
        }

        return true;
    }

    public int transformOneStringToAnotherWithMinOprn(String src, String target) {

        //count if two strings are same length or not
        int m = src.length();
        int n = target.length();

        if (m != n) {
            //if length are not same, strings can't be transformed
            return -1;
        }

        //check if the two strings contain same char and their count should also be same
        int[] charCount = new int[256];
        for (int i = 0; i < m; i++) {

            charCount[src.charAt(i)]++;
            charCount[target.charAt(i)]--;
        }

        //if same char are there and count are equal then charCount should have been balanced out to 0
        for (int count : charCount) {
            if (count != 0) {
                return -1;
            }
        }

        int srcIndex = m - 1;
        int targetIndex = n - 1;

        int result = 0;

        while (srcIndex >= 0) {

            if (src.charAt(srcIndex) == target.charAt(targetIndex)) {
                targetIndex--;
            } else {
                result++;
            }

            srcIndex--;
        }

        return result;
    }

    public void arrangeAllWordsAsTheirAnagrams(List<String> words) {

        Map<String, List<String>> anagramGroups = new HashMap<>();
        for (String str : words) {

            char[] ch = str.toCharArray();
            Arrays.sort(ch);
            String sortedString = String.valueOf(ch);

            anagramGroups.putIfAbsent(sortedString, new ArrayList<>());
            anagramGroups.get(sortedString).add(str);
        }

        //output:
        System.out.println("Output: " + anagramGroups);
    }

    public void characterAddedAtFrontToMakeStringPallindrome(String str) {

        //https://www.geeksforgeeks.org/minimum-characters-added-front-make-string-palindrome/
        int charCount = 0;
        while (str.length() > 0) {

            if (isStringPallindrome(str)) {
                break;
            } else {
                charCount++;
                //removing 1 char from end until we get a subtring which is pallindrome
                //the no of char removed (charCount) is the number that needs to be added at front
                str = str.substring(0, str.length() - 1);
            }
        }

        //output:
        System.out.println("No. of character to be added at front to make it pallindrome: " + charCount);
    }

    public void shortestPallindrome(String s) {
        //https://leetcode.com/problems/shortest-palindrome
        //https://leetcode.com/problems/longest-happy-prefix/
        //another approach to characterAddedAtFrontToMakeStringPallindrome()
        //KMP-LPS approach
        String rev = new StringBuilder(s).reverse().toString();
        String str = s + "#" + rev;
        int N = str.length();
        int n = s.length();

        int[] lps = new int[N];
        int prefixIndex = 0;
        int suffixIndex = 1;

        while (suffixIndex < N) {
            if (str.charAt(prefixIndex) == str.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }
        //output
        String shortestPallindrome = rev.substring(0, n - lps[N - 1]) + s;
        System.out.println("Shortest pallindrome required to be formed: " + shortestPallindrome);
    }

    public boolean checkIfOneStringRotationOfOtherString(String str1, String str2) {
        return (str1.length() == str2.length())
                && ((str1 + str1).indexOf(str2) != -1);
    }

    private void printAllSubSequencesOfAString_Helper(String str, int start, int N,
                                                      String current, Set<String> subseq) {

        if (start == N) {
            subseq.add(current);
            return;
        }

        for (int i = start; i < N; i++) {
            printAllSubSequencesOfAString_Helper(str, i + 1, N, current + str.charAt(i), subseq);
            printAllSubSequencesOfAString_Helper(str, i + 1, N, current, subseq);
        }
    }

    public void printAllSubSequencesOfAString(String str) {

        int N = str.length();
        Set<String> subseq = new HashSet<>();
        printAllSubSequencesOfAString_Helper(str, 0, N, "", subseq);

        //output:
        System.out.println("All possible subsequences of string: " + subseq);
    }

    public boolean balancedParenthesisEvaluation(String s) {
        //https://leetcode.com/problems/valid-parentheses/
        Stack<Character> stack = new Stack<>();
        for (char ch : s.toCharArray()) {

            if (ch == '{' || ch == '[' || ch == '(') {
                stack.push(ch);
            } else if (!stack.isEmpty() && stack.peek() == '(' && ch == ')') {
                stack.pop();
            } else if (!stack.isEmpty() && stack.peek() == '{' && ch == '}') {
                stack.pop();
            } else if (!stack.isEmpty() && stack.peek() == '[' && ch == ']') {
                stack.pop();
            } else {
                return false;
            }
        }

        return stack.isEmpty();
    }

    public void firstNonRepeatingCharacterFromStream(String stream) {
        //LinkedHashSet is better use as compared to ArrayList
        //because arraylist.contains() is O(N) for searching a value
        //but linkedhashset.contains() is O(1) for searching a value
        Set<Character> linkedHashSet = new LinkedHashSet<>();
        Set<Character> visited = new HashSet<>();
        for (int i = 0; i < stream.length(); i++) {
            char ch = stream.charAt(i);
            if (!visited.contains(ch)) {

                if (linkedHashSet.contains(ch)) {
                    linkedHashSet.remove((Character) ch);
                    visited.add(ch);
                } else {
                    linkedHashSet.add(ch);
                }
            }

            System.out.println("First non repeating character till " + stream.substring(0, i + 1));
            System.out.println((linkedHashSet.isEmpty() ? "#" : linkedHashSet.iterator().next() + ""));
        }
    }

    public boolean wordBreak_Recursive(String str, Set<String> set) {

        //https://www.geeksforgeeks.org/word-break-problem-dp-32/
        int n = str.length();
        if (n == 0 || set.contains(str)) {
            return true;
        }

        for (int i = 1; i <= n; i++) {
            if (set.contains(str.substring(0, i)) && wordBreak_Recursive(str.substring(i, n), set)) {
                return true;
            }
        }
        return false;
    }

    public boolean wordBreak_DP_Problem(String str, Set<String> set) {
        //https://leetcode.com/problems/word-break/
        //https://leetcode.com/problems/word-break/discuss/1068441/Detailed-Explanation-of-Top-Down-and-Bottom-Up-DP
        //similar to longestIncreasingSubseq()
        boolean[] memo = new boolean[str.length() + 1];
        //base cond
        memo[0] = true; // str with no length is also true

        for (int i = 1; i <= str.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (set.contains(str.substring(j, i)) && memo[j]) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[str.length()];
    }

    public void longestSubstringWithoutRepeatingChar(String str) {
        //https://leetcode.com/problems/longest-substring-without-repeating-characters/
        //SLIDING WINDOW ALGO
        int n = str.length();

        int start = 0;
        int end = 0;

        int maxLen = 0;

        //as per question str consists of english letters, digits, symbols and spaces.
        //hence we need that much ascii space ==> 256
        boolean[] visited = new boolean[256];

        String substr = "";

        while (end < n) {

            if (!visited[str.charAt(end)]) {

                visited[str.charAt(end)] = true;

                if (maxLen < (end - start + 1)) {
                    maxLen = end - start + 1;
                    substr = str.substring(start, start + maxLen);
                }
                end++;
            } else {

                visited[str.charAt(start)] = false;
                start++;
            }
        }

        //output:
        System.out.println("Longest subtring without repeating char: " + maxLen + " (" + substr + ")");
    }

    public void countSubstringsWithoutRepeatingChar(String str) {
        //https://leetcode.com/problems/longest-substring-without-repeating-characters/
        //SLIDING WINDOW ALGO
        int n = str.length();

        int start = 0;
        int end = 0;

        int countSubstsWithoutRepeatingChars = 0;

        //if either upper or lower case english letter is asked, use 26
        boolean[] visited = new boolean[256];

        while (end < n) {

            if (!visited[str.charAt(end)]) {

                visited[str.charAt(end)] = true;

                countSubstsWithoutRepeatingChars += (end - start + 1);

                end++;
            } else {

                visited[str.charAt(start)] = false;
                start++;
            }
        }

        //output
        System.out.println("Count subtring without repeating char: " + countSubstsWithoutRepeatingChars);
    }

    public void minimumWindowSubstring(String s, String t) {

        //Explanation: https://www.youtube.com/watch?j=nMaKzLWceFg&feature=youtu.be
        //SLIDING WINDOW ALGO
        //prepare the count map for string t
        //to know how many char we need to find in string s
        Map<Character, Integer> tMap = new HashMap<>();
        for (char ch : t.toCharArray()) {
            tMap.put(ch, tMap.getOrDefault(ch, 0) + 1);
        }

        int tCount = 0;
        int start = 0;
        int end = 0;
        int minLenWindow = Integer.MAX_VALUE;
        int substrIndex = 0;
        int N = s.length();
        while (end < N) {

            char chEnd = s.charAt(end);
            //each we find the char in string s that is also in string t
            //we decreament the count of that char from map
            //to know how much of that char (chEnd) we needed and how much we have found
            if (tMap.containsKey(chEnd)) {
                //we choose 1 char from string s that is also in string t
                //so we will reduce the freq of this char, freq of this char >= 0
                //shows how much char is req before we found some extra occurences
                //of this char in string s because we don't care about the extra chars
                //only char[freq to 0]
                tMap.put(chEnd, tMap.get(chEnd) - 1);
                //eacg time we are reduciing freq we are taking a char so tCount++
                //below if block won't consider any extra occuerences of this char
                if (tMap.get(chEnd) >= 0) {
                    tCount++;
                }
            }

            //below while loop with cond tCount == t.length()
            //signifies that now we have all char of string t in string s
            //we can calculate window and at same time try to minimize the window size
            while (tCount == t.length()) {

                if (minLenWindow > (end - start + 1)) {
                    minLenWindow = end - start + 1;
                    substrIndex = start;
                }

                //adjust the start pointer now
                char chStart = s.charAt(start);
                if (tMap.containsKey(chStart)) {
                    tMap.put(chStart, tMap.get(chStart) + 1);
                    if (tMap.get(chStart) > 0) {
                        tCount--;
                    }
                }
                start++;
            }
            end++;
        }

        //output:
        String output = minLenWindow > s.length() ? "" : s.substring(substrIndex, substrIndex + minLenWindow);
        System.out.println("Min window substring containg all char of string t in string s: "
                + (minLenWindow > s.length() ? -1 : minLenWindow) + " : "
                + output);
    }

    public void countAllOccurencesOfPatternInGivenString(String txt, String pat) {
        //........................T: O(N)
        //https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
        //SLIDING WINDOW
        Map<Character, Integer> patMap = new HashMap<>();
        for (char chPat : pat.toCharArray()) {
            patMap.put(chPat, patMap.getOrDefault(chPat, 0) + 1);
        }

        int totalOccurences = 0;
        int patCharCount = 0;
        int patLen = pat.length();
        int txtLen = txt.length();
        int start = 0;
        int end = 0;
        List<Integer> occuerencesIndex = new ArrayList<>();
        List<String> occuerencesSubstring = new ArrayList<>();
        while (end < txtLen) {

            char chEnd = txt.charAt(end);
            if (patMap.containsKey(chEnd)) {
                patMap.put(chEnd, patMap.get(chEnd) - 1);
                if (patMap.get(chEnd) >= 0) {
                    patCharCount++;
                }
            }

            //once window for pattern is reached
            //balance out by moving this window
            //and removing start from patCharCount
            while ((end - start + 1) == patLen) {
                //if the curr window also contains the same char as
                //that of pattern string (patCharCount == patLen)
                if (patCharCount == patLen) {
                    totalOccurences++;
                    occuerencesIndex.add(start);
                    occuerencesSubstring.add(txt.substring(start, start + patLen));
                }

                char chStart = txt.charAt(start);
                if (patMap.containsKey(chStart)) {
                    patMap.put(chStart, patMap.get(chStart) + 1);
                    if (patMap.get(chStart) > 0) {
                        patCharCount--;
                    }
                }
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Total occurences: " + totalOccurences);
        System.out.println("All the indexes: " + occuerencesIndex);
        System.out.println("All the substring of anagrams: " + occuerencesSubstring);
    }

    public void partitionLabels(String str) {

        //problem: https://leetcode.com/problems/partition-labels/
        //explanation: https://youtu.be/5NCjHqx2v-k
        List<Integer> result = new ArrayList<>();
        List<String> substring = new ArrayList<>();
        int n = str.length();
        Map<Character, Integer> lastIndexes = new HashMap<>();
        for (int i = 0; i < n; i++) {
            lastIndexes.put(str.charAt(i), i);
        }

        int start = 0;
        int end = 0;
        int maxEnd = 0;
        while (end < n) {
            maxEnd = Math.max(maxEnd, lastIndexes.get(str.charAt(end)));
            if (end == maxEnd) {
                int partitionLen = end - start + 1;
                result.add(partitionLen);
                substring.add(str.substring(start, start + partitionLen));
                start = end + 1;
            }
            end++;
        }

        //output:
        System.out.println("All the partition lengths: " + result + " \nPartition strings: " + substring);
    }

    public void longestRepeatingCharacterByKReplacement(String str, int K) {
        //https://leetcode.com/problems/longest-repeating-character-replacement/
        //explanation: https://youtu.be/gqXU1UyA8pk
        //SLIDING WINDOW
        int[] charFreq = new int[26];
        int start = 0;
        int end = 0;
        int maxLen = 0;
        int mostFreqCharTill = 0;
        int n = str.length();
        while (end < n) {

            char chEnd = str.charAt(end);
            charFreq[chEnd - 'A']++;

            mostFreqCharTill = Math.max(mostFreqCharTill, charFreq[chEnd - 'A']);
            //let suppose curr win len (end - start + 1) has substr = ..."BABB"...
            //mostFreqCharTill = charFreq[B] = 3
            //now see out these BABB if you leave mostFreqChar(B) you are left with
            //A's like this winLen = 4, B = 3, A = 1
            //then winLen - mostFreqChar(B) ==> 4 - 3 = 1(i.e freq of A)
            //now you just have replace them, least freq chars (which we are allowed replace only K)
            //if these least freq char are more than K we must minimize our win
            while ((end - start + 1) - mostFreqCharTill > K) {
                charFreq[str.charAt(start) - 'A']--;
                start++;
            }

            maxLen = Math.max(maxLen, end - start + 1);
            end++;
        }

        //output:
        System.out.println("Max length: " + maxLen);
    }

    public void minWhiteBlockChangeToBlackBlockInKLength(String blocks, int k) {
        //https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/
        //based on SLIDING WINDOW & longestRepeatingCharacterByKReplacement()
        int n = blocks.length();
        int start = 0;
        int end = 0;
        int minWhiteBlockChange = Integer.MAX_VALUE;
        int mostFreqBlackBlocks = 0;
        Map<Character, Integer> freq = new HashMap<>();

        while (end < n) {
            char chEnd = blocks.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);
            if (chEnd == 'B') {
                mostFreqBlackBlocks = Math.max(mostFreqBlackBlocks, freq.get(chEnd));
            }

            //in the given window, find the diff between total char(winLen) - mostFreqBlackBlock
            if (end - start + 1 == k) {
                minWhiteBlockChange = Math.min(minWhiteBlockChange,
                        //winLen - mostFreqBlackblock
                        //will give the least white blocks exist in the curr winLen
                        //track in all the win of size k, where are the least freq white blocks
                        (end - start + 1) - mostFreqBlackBlocks);
                char chStart = blocks.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                start++;
            }
            end++;
        }
        //output
        System.out.println("Min white block change to have k consecutive black blocks: " + minWhiteBlockChange);
    }

    public void maximizeConfusionInExam(String answerKey, int k) {
        //https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
        //based on SLIDING WINDOW
        //& minWhiteBlockChangeToBlackBlockInKLength() & longestRepeatingCharacterByKReplacement()
        /*
        intuition here is to check
        1. if we replace original 'F' aswers with wrong = 'T' values then how long
        of a consecutive length of T(s) we can generate

        2. if we replace original 'T' aswers with wrong = 'F' values then how long
        of a consecutive length of F(s) we can generate

        need to pick the maxLen from both 1. and 2. points hence need to do
        2 sliding window from both the above mentioned 2 cases

         */
        int n = answerKey.length();

        int[] freq = new int[26];

        int mostFreq = 0;

        int maxConfusion = 0;

        int start = 0;
        int end = 0;

        //1. here in this while() loop, we will check how many original answers with
        //'F' values can be replaced with wrong 'T' to generate max confusions == maxLen
        while (end < n) {

            char chEnd = answerKey.charAt(end);
            int chEndIndex = chEnd - 'A';
            freq[chEndIndex]++;

            if (chEnd == 'T') {
                mostFreq = Math.max(mostFreq, freq[chEndIndex]);
            }

            while ((end - start + 1) - mostFreq > k) {
                char chStart = answerKey.charAt(start);
                int chStartIndex = chStart - 'A';
                freq[chStartIndex]--;
                start++;
            }

            maxConfusion = Math.max(maxConfusion, (end - start + 1));

            end++;
        }

        start = 0;
        end = 0;
        mostFreq = 0;
        freq = new int[26];

        //2. here in this while() loop, we will check how many original answers with
        //'T' values can be replaced with wrong 'F' to generate max confusions == maxLen
        while (end < n) {

            char chEnd = answerKey.charAt(end);
            int chEndIndex = chEnd - 'A';
            freq[chEndIndex]++;

            if (chEnd == 'F') {
                mostFreq = Math.max(mostFreq, freq[chEndIndex]);
            }

            while ((end - start + 1) - mostFreq > k) {
                char chStart = answerKey.charAt(start);
                int chStartIndex = chStart - 'A';
                freq[chStartIndex]--;
                start++;
            }
            maxConfusion = Math.max(maxConfusion, (end - start + 1));
            end++;
        }

        //output
        System.out.println("Maximize confusion in exam : " + maxConfusion);
    }

    public void maximizeConfusionInExam2(String answerKey, int k) {
        //https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
        //based on SLIDING WINDOW in SINGLE PASS

        int n = answerKey.length();

        int[] charFreq = new int[26];

        int maxConfusion = 0;

        int start = 0;
        int end = 0;

        while (end < n) {

            char chEnd = answerKey.charAt(end);
            //keep the freq count for either 'T' or 'F'
            charFreq[chEnd - 'A']++;

            //to create a max confusion we can either
            //1. convert original 'T's to 'F'
            //2. OR convert original 'F's to 'T'
            //but optimally we should take the min of either 'T' or 'F' BUT
            //any of the original answer is replaced more than given k then we
            //need to adjust window
            while (Math.min(charFreq['T' - 'A'], charFreq['F' - 'A']) > k) {
                char chStart = answerKey.charAt(start++);
                charFreq[chStart - 'A']--;
            }

            //count the window length in which we can either convert all Fk
            //'T's to 'F's
            //OR 'F's to 'T's
            maxConfusion = Math.max(maxConfusion, (end - start + 1));

            end++;
        }

        //output
        System.out.println("Maximize confusion in exam : " + maxConfusion);
    }

    private void generateBalancedParenthesis_Helper(int n, String curr, int open, int close, List<String> result) {

        //any req parenthesis of size n needs 2 * n parenthesis to balance
        //ex: if n = 1 => "{" to balance it need "}" which "{}" is n * 2
        if (curr.length() == 2 * n) {
            result.add(curr);
            return;
        }

        if (open < n) {
            generateBalancedParenthesis_Helper(n, curr + "{", open + 1, close, result);
        }

        if (close < open) {
            generateBalancedParenthesis_Helper(n, curr + "}", open, close + 1, result);
        }
    }

    public void generateBalancedParenthesis(int n) {
        //https://leetcode.com/problems/generate-parentheses
        //https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/
        List<String> result = new ArrayList<>();
        generateBalancedParenthesis_Helper(n, "", 0, 0, result);
        //output:
        System.out.println("All balanced parenthesis: " + result);
    }

    public void scoreOfParenthesis(String str) {

        //https://leetcode.com/problems/score-of-parentheses
        //explanatin: https://youtu.be/jfmJusJ0qKM
        int score = 0;
        Stack<Integer> stack = new Stack<>();
        for (char ch : str.toCharArray()) {

            if (ch == '(') {
                stack.push(score);
                score = 0;
            } else {
                score = stack.pop() + Math.max(score * 2, 1);
            }
        }

        //output:
        System.out.println("Score: " + score);
    }

    public void minimumCharRemovalToMakeValidParenthesis(String str) {

        //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses
        class CharIndex {

            char ch;
            int index;

            public CharIndex(char ch, int index) {
                this.ch = ch;
                this.index = index;
            }
        }

        StringBuilder sb = new StringBuilder();
        Stack<CharIndex> stack = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            sb.append(c);
            if (c == '(' || c == ')') {

                if (!stack.isEmpty() && stack.peek().ch == '(' && c == ')') {
                    stack.pop();
                } else {
                    stack.push(new CharIndex(c, i));
                }
            }
        }

        while (!stack.isEmpty()) {
            sb.deleteCharAt(stack.pop().index);
        }

        //output:
        System.out.println("Balanced string: " + sb.toString());
    }

    public boolean repeatedSubstringPattern(String str) {
        //https://leetcode.com/problems/repeated-substring-pattern/
        //explanantion: https://youtu.be/bClIZj66dVE
        int len = str.length();

        for (int substringLen = len / 2; substringLen >= 1; substringLen--) {

            if (len % substringLen == 0) {

                int repeatSubstring = len / substringLen;

                String substring = str.substring(0, substringLen);

                StringBuilder newString = new StringBuilder();

                while (repeatSubstring > 0) {

                    newString.append(substring);
                    repeatSubstring--;
                }

                if (newString.toString().equals(str)) {
                    return true;
                }
            }
        }

        return false;
    }

    private int longestPallindromicSubstring_ExpandFromMiddle(String str, int left, int right) {

        if (str == null || left > right) {
            return 0;
        }

        while (left >= 0 && right < str.length() && str.charAt(left) == str.charAt(right)) {
            left--;
            right++;
        }

        //total pallindromic char b/w left and right
        return right - left - 1;
    }

    public void longestPallindromicSubstring(String str) {

        //.....................T: O(N^2)
        //https://leetcode.com/problems/longest-palindromic-substring/
        //https://leetcode.com/problems/palindromic-substrings/
        //explanation: https://youtu.be/y2BD4MJqV20
        int start = 0;
        int end = 0;

        for (int i = 0; i < str.length(); i++) {

            //case to handle odd length string
            //there will be exactly one middle char in that
            //ex: "racecar" middle char is 'e'
            int len1 = longestPallindromicSubstring_ExpandFromMiddle(str, i, i);
            //case to handle even length string
            //the middle will in b/w the two char of (str.length / 2)  and ((str.length /2) + 1)
            //ex: "aabbaa" middle char will be in b/w b|b
            int len2 = longestPallindromicSubstring_ExpandFromMiddle(str, i, i + 1);

            int len = Math.max(len1, len2);

            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + (len / 2);
            }
        }

        //output:
        System.out.println("Longest pallindromic substring: " + str.substring(start, end + 1));
    }

    public void maxNumberOfNonOverlappingPallindromeSubstrings(String str, int k) {
        //https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/
        //somewhat based on longestPallindromicSubstring()
        int n = str.length();

        class Helper {

            int lastOverlappedCharIndex = 0;
            int pallindromicSubstringCount = 0;

            void expandFromMiddle(String str, int left, int right, int k) {

                while (left >= lastOverlappedCharIndex && right < n) {

                    //pallindrome break condition
                    if (str.charAt(left) != str.charAt(right)) {
                        break;
                    }

                    //as per question, required substring length should be
                    //'atleast k'
                    if (right - left + 1 >= k) {
                        pallindromicSubstringCount++;
                        //this statement below means that,
                        //as we are expanding from middle that means from a center
                        //point we are expanding the left ptr to left-side and right
                        //ptr to right-side hence the substring formed between them
                        //str[left to right] is incrementedly pallindromic in nature
                        //otherwise above if() block would have 'break' it
                        //Now each time we expand right ptr, we assume that this
                        //is the final char of the curr pallindromic subtring hence this
                        //right ptr also says that the next pallindromic subtring
                        //should be checked after this 'lastOverlappedCharIndex'
                        //because as per question, we can only consider non-overlappiing
                        //pallindromic substrings
                        lastOverlappedCharIndex = right + 1;
                        break;
                    }
                    left--;
                    right++;
                }
            }
        }

        Helper helper = new Helper();

        for (int i = 0; i < n; i++) {

            helper.expandFromMiddle(str, i, i, k);
            helper.expandFromMiddle(str, i, i + 1, k);
        }
        //output
        System.out.println("Max number of non overlapping pallindrome substrings : " + helper.pallindromicSubstringCount);
    }

    public boolean stringComparisionAfterProcessingBackspaceChar(String a, String b) {

        //.............................T: O(M+N)
        //.............................S: O(1)
        //https://leetcode.com/problems/backspace-string-compare/solution/
        int i = a.length() - 1;
        int j = b.length() - 1;

        int skipA = 0;
        int skipB = 0;

        while (i >= 0 || j >= 0) {

            while (i >= 0) {
                if (a.charAt(i) == '#') {
                    skipA++;
                    i--;
                } else if (skipA > 0) {
                    skipA--;
                    i--;
                } else {
                    break;
                }
            }

            while (j >= 0) {
                if (b.charAt(j) == '#') {
                    skipB++;
                    j--;
                } else if (skipB > 0) {
                    skipB--;
                    j--;
                } else {
                    break;
                }
            }

            if (i >= 0 && j >= 0 && a.charAt(i) != b.charAt(j)) {
                return false;
            }

            //if one string length is smaller than others or run out of characters than the
            //other string
            if ((i >= 0) != (j >= 0)) {
                return false;
            }

            i--;
            j--;
        }
        return true;
    }

    public void stringZigZag(String str, int row) {

        if (row == 1) {
            //edge case
            System.out.println("String zig zag: " + str);
            return;
        }

        String[] zigZag = new String[row];
        Arrays.fill(zigZag, "");

        int iRow = 0;
        boolean isGoingDown = true;

        for (int i = 0; i < str.length(); i++) {

            zigZag[iRow] += str.charAt(i);

            if (isGoingDown) {
                iRow++;
            } else {
                iRow--;
            }

            if (iRow == row - 1) {
                isGoingDown = false;
            } else if (iRow == 0) {
                isGoingDown = true;
            }
        }

        StringBuilder sb = new StringBuilder();
        for (String s : zigZag) {
            sb.append(s);
        }

        //output
        System.out.println("String zig zag: " + sb.toString());
    }

    private List<String> stepsToOpenTheLock_AllCombinations(String originalLockStr,
                                                            Set<String> deadEnd, Set<String> visitedCombination) {

        List<String> allCombinations = new ArrayList<>();

        for (int wheelNumber = 0; wheelNumber < 4; wheelNumber++) {

            char[] lockStrClone = String.valueOf(originalLockStr).toCharArray();

            //backwards combinations 2->1, 8->7 so on...
            if (lockStrClone[wheelNumber] == '0') {
                lockStrClone[wheelNumber] = '9';
            } else {
                lockStrClone[wheelNumber] = (char) ((int) lockStrClone[wheelNumber] - 1);
            }

            String newLockStr = String.valueOf(lockStrClone);

            //new lock string pattern should not be a dead end pattern
            //and should not be a already-generated-pattern
            //(Set->add(data) returns true if data is not already present else returns false)
            if (!deadEnd.contains(newLockStr) && visitedCombination.add(newLockStr)) {
                allCombinations.add(newLockStr);
            }

            //upwards combinatons 1->2, 5->6 so on
            lockStrClone = String.valueOf(originalLockStr).toCharArray();
            if (lockStrClone[wheelNumber] < '9') {

                lockStrClone[wheelNumber] = (char) ((int) lockStrClone[wheelNumber] + 1);
                newLockStr = String.valueOf(lockStrClone);

                //new lock string pattern should not be a dead end pattern
                //and should not be a already-generated-pattern
                //(Set->add(data) returns true if data is not already present else returns false)
                if (!deadEnd.contains(newLockStr) && visitedCombination.add(newLockStr)) {
                    allCombinations.add(newLockStr);
                }
            }
        }
        return allCombinations;
    }

    public int stepsToOpenTheLock(String[] deadends, String target) {

        //https://leetcode.com/problems/open-the-lock
        //https://leetcode.com/problems/open-the-lock/discuss/1123396/Java-BFS-with-very-detailed-explanations
        String start = "0000";
        Set<String> deadEnd = new HashSet<>(Arrays.asList(deadends));
        Set<String> visitedCombination = new HashSet<>();
        Queue<String> q = new LinkedList<>();

        int steps = 0;

        if (start.equals(target)) {
            return steps;
        }

        if (deadEnd.contains(start)) {
            return -1;
        }

        visitedCombination.add(start);
        q.add(start);

        while (!q.isEmpty()) {

            steps++;
            int size = q.size();

            for (int i = 0; i < size; i++) {

                String lockStr = q.poll();
                List<String> allCombinations = stepsToOpenTheLock_AllCombinations(lockStr, deadEnd, visitedCombination);
                for (String combination : allCombinations) {
                    if (combination.equals(target)) {
                        return steps;
                    }
                    q.add(combination);
                }
            }
        }

        return -1;
    }

    public void longestSubstringWithKUniqueCharacter(String str, int K) {
        //https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/
        //https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description/
        //https://practice.geeksforgeeks.org/problems/longest-k-unique-characters-substring0853/1#
        //SLIDING WINDOW
        int n = str.length();
        int start = 0;
        int end = 0;
        int maxLen = 0;
        int index = 0;
        Map<Character, Integer> map = new HashMap<>();

        while (end < n) {

            char chEnd = str.charAt(end);
            map.put(chEnd, map.getOrDefault(chEnd, 0) + 1);

            if (map.size() == K) {
                if (maxLen < end - start + 1) {
                    maxLen = end - start + 1;
                    index = start;
                }
            }

            while (map.size() > K) {
                char chStart = str.charAt(start);
                map.put(chStart, map.get(chStart) - 1);
                if (map.get(chStart) <= 0) {
                    map.remove(chStart);
                }
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Max length substring with K unique char: " + (maxLen == 0 ? -1 : maxLen));
        if (maxLen != 0) {
            System.out.println("Substring with K unique char: " + str.substring(index, index + maxLen));
        }
    }

    public void smallestSubstringWithKUniqueCharacter(String str, int K) {
        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
        int n = str.length();
        Map<Character, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int firstIndex = 0;
        int minLen = n + 1;
        while (end < n) {
            char chEnd = str.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);

            //if in freq map we have got all the K unique char
            //we will try to minimize the window to find the smallest substring
            while (freq.size() == K) {
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    firstIndex = start;
                }

                char chStart = str.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                if (freq.get(chStart) <= 0) {
                    freq.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //output
        if (minLen == n + 1) {
            System.out.println("Smallest substring with K unique character not possible: -1");
            return;
        }
        System.out.println("Smallest substring with K unique character: " + minLen);
        System.out.println("Smallest substring with K unique character substring: "
                + str.substring(firstIndex, firstIndex + minLen));
    }

    public void smallestSubarrayWithKDistinctElements(int[] nums, int K) {
        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
        //based on smallestSubstringWithKUniqueCharacter()
        int n = nums.length;
        Map<Integer, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int firstIndex = 0;
        int lastIndex = 0;
        int minLen = n + 1;
        while (end < n) {
            int valEnd = nums[end];
            freq.put(valEnd, freq.getOrDefault(valEnd, 0) + 1);

            //if in freq map we have got all the K distinct elements
            //we will try to minimize the window to find the smallest subarray
            while (freq.size() == K) {
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    firstIndex = start;
                    lastIndex = end;
                }

                int valStart = nums[start];
                freq.put(valStart, freq.getOrDefault(valStart, 0) - 1);
                if (freq.get(valStart) <= 0) {
                    freq.remove(valStart);
                }
                start++;
            }
            end++;
        }
        //output
        if (minLen == n + 1) {
            System.out.println("Smallest subarray with K distinct elements not possible: -1");
            return;
        }
        System.out.println("Smallest subarray with K distinct elements: " + minLen);
        for (int i = firstIndex; i <= lastIndex; i++) {
            System.out.print(nums[i] + " ");
        }
        System.out.println();
    }

    public void largestNumberFromSetOfNumbers(String[] nums) {

        //https://leetcode.com/problems/largest-number/
        //https://practice.geeksforgeeks.org/problems/largest-number-formed-from-an-array1117/1
        //https://www.geeksforgeeks.org/given-an-array-of-numbers-arrange-the-numbers-to-form-the-biggest-number/
        //ex 3, 30, 34, 5, 9
        //int priority queue will have the numbers based on the max(ab, ba) combinations
        //if a  = 3, b = 30 then ab = 330 & ba = 303 max(330, 303) so on
        //a, b are going to store in this camparion only
        PriorityQueue<String> combinations = new PriorityQueue<>((a, b) -> {
            String ab = a + b;
            String ba = b + a;
//            System.out.println(ab + " & " + ba + " compareTo " + ab.compareTo(ba));
            return ab.compareTo(ba) > 0 ? -1 : 1;
        });

        StringBuilder sb = new StringBuilder();

        combinations.addAll(Arrays.asList(nums));

        while (!combinations.isEmpty()) {
            sb.append(combinations.poll());
        }

        //remove any starting zeroes
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }

        //output
        System.out.println("Largest number formed from the given set of numbers: " + sb.toString());
    }

    public long smallestNumber(long num) {
        //https://leetcode.com/problems/smallest-value-of-the-rearranged-number
        boolean isNegative = num < 0;
        //converting the given num to its positive value
        num = Math.abs(num);
        //convert the given num to its char[] arr form
        char[] numArr = String.valueOf(num).toCharArray();
        int n = numArr.length;
        //sorting the char[] arr so that all the smaller digits
        //comes first, we will just need to pick the one by one and form a string
        Arrays.sort(numArr);

        int index = 0;
        StringBuilder smallerNumber = new StringBuilder();

        //in case if our num was negative, then picking the digits from the end
        //will give us the smaller number
        //like +5 > +2 but -2 > -5
        //sorted arr[] = [2,5] for positive pick from left to right
        //for negative pick from right to left
        if (isNegative) {
            index = n - 1;
            while (index >= 0) {
                smallerNumber.append(numArr[index--]);
            }
            return -1 * Long.parseLong(smallerNumber.toString());
        }

        //we are working for positive num cases, there is a edge case
        //if our inital num had zero in it
        //like 54321000 ==> sorted arr[] = [0,0,0,1,2,3,4,5]
        //now if we simply pick from left to right our numStr will formed as
        //00012345 which is equivalent to 12345 but without zeroes we can't omit
        //all zeroes and we can't keep zeroes in starting
        //so fetch all the zeroes from starting and form zeroes str = "000"
        //below loop will break at index where numArr[index] != '0' that means '1'
        //we will simply put all the zeroes after first non-zero digit (i.e, '1')
        StringBuilder zeroes = new StringBuilder();
        while (index < n && numArr[index] == '0') {
            zeroes.append(numArr[index++]);
        }
        //index here is at first non-zero digit in sorted numArr
        smallerNumber.append(index >= n ? zeroes.toString() : numArr[index] + zeroes.toString());
        //we have considered the first non-zero digit
        //like this "1" + "000" = "1000"
        //now we can start from next index onwards and starting picking
        //digits one by one
        index += 1;
        while (index < n) {
            smallerNumber.append(numArr[index++]);
        }
        return Long.parseLong(smallerNumber.toString());
    }

    public void stringCompression(char[] arr) {
        //https://leetcode.com/problems/string-compression/
        //explanation: https://youtu.be/IhJgguNiYYk
        int n = arr.length;
        int start = 0;
        int end = 0;
        int index = 0;
        while (end < n) {
            start = end;
            while (end < n && arr[start] == arr[end]) {
                end++;
            }
            arr[index++] = arr[start];
            int count = end - start;
            if (count <= 1) {
                continue;
            }
            for (char digit : String.valueOf(count).toCharArray()) {
                arr[index++] = digit;
            }
        }

        //output
        for (int i = 0; i < index; i++) {
            System.out.print(arr[i]);
        }
        System.out.println();
    }

    public boolean longPressedNames(String name, String typed) {

        //https://leetcode.com/problems/long-pressed-name/
        char[] nameCh = name.toCharArray();
        char[] typedCh = typed.toCharArray();

        int i = 0;
        int j = 0;

        while (i < name.length() && j < typed.length()) {

            if (nameCh[i] == typedCh[j]) {
                i++;
                j++;
            } else if (j > 0 && typedCh[j] == typedCh[j - 1]) {
                j++;
            } else {
                return false;
            }
        }

        if (i != name.length()) {
            return false;
        } else {
            while (j < typed.length()) {
                if (typedCh[j] != typedCh[j - 1]) {
                    return false;
                }
                j++;
            }
        }
        return true;
    }

    private void interleavingOfTwoStrings_Helper(
            String str1, String str2, int indexI, int indexJ, StringBuilder sb, List<String> res) {

        if (sb.length() == str1.length() + str2.length()) {
            res.add(sb.toString());
            return;
        }

        if (indexI < str1.length()) {
            sb.append(str1.charAt(indexI));
            interleavingOfTwoStrings_Helper(
                    str1, str2, indexI + 1, indexJ, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }

        if (indexJ < str2.length()) {
            sb.append(str2.charAt(indexJ));
            interleavingOfTwoStrings_Helper(
                    str1, str2, indexI, indexJ + 1, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public void interleavingOfTwoStrings(String a, String b) {
        //.............................T: O(2 ^ (M + N)) M = a.length(), N = b.length()
        //https://www.geeksforgeeks.org/print-all-interleavings-of-given-two-strings/
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        interleavingOfTwoStrings_Helper(a, b, 0, 0, sb, res);
        //output
        System.out.println("Interleaving of two strings: " + res);
    }

    private void printAllPermutationOfString_Helper(char[] chArr, int index, List<String> res) {

        if (index == chArr.length) {
            res.add(String.valueOf(chArr));
        }

        for (int i = index; i < chArr.length; i++) {

            //swap
            char temp = chArr[index];
            chArr[index] = chArr[i];
            chArr[i] = temp;

            //recursive call
            printAllPermutationOfString_Helper(chArr, index + 1, res);

            //swap back the char to its original place
            //to keep chaArr original before swaping and for next recursive call
            temp = chArr[index];
            chArr[index] = chArr[i];
            chArr[i] = temp;
        }
    }

    public void printAllPermutationOfDistinctCharInString(String str) {
        //.............................T: O(N!) factorial(N), N = str.length()
        //https://leetcode.com/problems/permutations/
        //https://leetcode.com/problems/permutations-ii/
        //explanantion: https://www.youtube.com/watch?j=GuTPwotSdYw
        //we are fixing char at index location perform operations on rest of
        //remaining chArr so each time N * N-1 * N-2 ....0 = N!
        char[] chArr = str.toCharArray();
        List<String> res = new ArrayList<>();

        printAllPermutationOfString_Helper(chArr, 0, res);

        //output
        System.out.println("All permutation of given string: " + res);
    }

    public void longestSubstringHavingAllVowelsInOrder(String word) {

        //https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/
        /*
         the string only contains char [a,e,i,o,i]
         */
        int maxLen = 0;
        int currLen = 1;
        int vowelCount = 1;
        int n = word.length();

        for (int i = 1; i < n; i++) {
            if (word.charAt(i - 1) == word.charAt(i)) {
                //if curr and prev char is same/repeating
                currLen++;
            } else if (word.charAt(i - 1) < word.charAt(i)) {
                //this if increment vowelCount because
                //actual vowel order is a, e, i, o, i
                //where a < e < i < o < i (ASCII values)
                vowelCount++;
                currLen++;
            } else {
                //reset both variables when vowel order doesn't matches
                vowelCount = 1;
                currLen = 1;
            }

            if (vowelCount == 5) {
                maxLen = Math.max(maxLen, currLen);
            }
        }

        //output
        System.out.println("Longest substring having all vowels in order: " + maxLen);
    }

    public void arithematicExpressionEvaluationBasicCalculator(String expr) {

        //https://leetcode.com/problems/basic-calculator-ii/
        int n = expr.length();
        int currNum = 0;
        int lastNum = 0;
        int result = 0;

        char opr = '+';

        for (int i = 0; i < n; i++) {
            char ch = expr.charAt(i);
            if (Character.isDigit(ch)) {
                currNum = (currNum * 10) + (ch - '0');
            }

            if (!Character.isDigit(ch) && ch != ' ' || i == n - 1) {
                if (opr == '+' || opr == '-') {
                    result += lastNum;
                    lastNum = (opr == '+') ? currNum : -currNum;
                } else if (opr == '*') {
                    lastNum = lastNum * currNum;
                } else if (opr == '/') {
                    lastNum = lastNum / currNum;
                }
                opr = ch;
                currNum = 0;
            }
        }
        result += lastNum;

        //output
        System.out.println("Evaluation: " + result);
    }

    public void basicCalculator(String str) {
        //https://leetcode.com/problems/basic-calculator/
        //https://leetcode.com/problems/basic-calculator/discuss/2832644/simple-and-easy-solution-in-java-oror-basic-calculatororor
        int n = str.length();
        Stack<Integer> stack = new Stack<>();
        int index = 0;
        int sum = 0;
        int sign = +1;

        while (index < n) {
            char ch = str.charAt(index);
            if (Character.isDigit(ch)) {
                int num = 0;
                while (index < n && Character.isDigit(str.charAt(index))) {
                    num = num * 10 + (str.charAt(index) - '0');
                    index++;
                }
                //loop break when the curr index-th char is not a digit
                //we need to step back one index because index is increamented
                //below then the curr index-th char will be considered in next
                //iteration
                index -= 1;
                num *= sign;
                sum += num;
                sign = +1;
            } else if (ch == '(') {
                stack.push(sum);
                stack.push(sign);
                sum = 0;
                sign = +1;
            } else if (ch == ')') {
                //in the above if-block we added prev sum first & sign later for
                //that prev iteration, now if we reach this if-block we will first
                //pop prevSign & prevSum of prev iteration to curr sum & sign that
                //we have proccessed between curr brackets '()'
                //prevSum prevSign (curr inner expression)
                int prevSign = stack.pop();
                int prevSum = stack.pop();
                //why we are multiplying the curr sum with prevSign? thats based
                //on maths: -(+123) == -123 OR +(-123) == -123 OR +(+123) == 123
                //ex: 1 + (1 + 1) - (1 - 3) ==> + (1 + 1) ==> + (2) ==> +2
                //but - (1 - 3) ==> - (-2) ==> +2 because - * -2 == +2
                sum *= prevSign;
                sum += prevSum;
            } else if (ch == '-') {
                sign = -1;
            }
            index++;
        }
        //output
        System.out.println("Basic calculator expression evaluation: " + sum);
    }

    public void evaluateBracketPatternAndReplaceWithGivenWord(String s, List<List<String>> replaceWith) {

        //https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string
        Map<String, String> map = new HashMap<>();
        for (List<String> list : replaceWith) {
            map.put(list.get(0), list.get(1));
        }

        boolean bracketStart = false;
        String key = "";
        StringBuilder sb = new StringBuilder();
        int i = 0;
        int n = s.length();

        while (i < n) {
            char ch = s.charAt(i++);

            //all such char which are not of pattern : (SomeChar)
            if (Character.isAlphabetic(ch) && bracketStart == false) {
                sb.append(ch);
            } else if (Character.isAlphabetic(ch) && bracketStart == true) {
                //all such char which are part of pattern : (SomeChar)
                //key = SomeChar not including (, )
                key += ch;
            } else if (ch == '(') {
                //if bracket starts
                bracketStart = true;
            } else if (bracketStart == true && ch == ')') {
                //if bracket flag is true and ending bracket has arrived
                //means at this point, key = SomeChar has been formed
                String replace = map.getOrDefault(key, "?"); //if key is not provided, replace with ?
                sb.append(replace);
                key = ""; //reset for next key generation
                bracketStart = false; //reset to find next bracket start
            }
        }

        //output
        System.out.println("Bracket pattern evaluated: " + sb.toString().trim());
    }

    private void allPhoneDigitLetterCombinations_Helper(
            String digits, int digitIndex, String currCombination, String[] pad, List<String> combinations) {

        if (digitIndex == digits.length()) {
            combinations.add(currCombination);
            return;
        }

        //digit of key pad @digitIndex from string digits
        int digit = digits.charAt(digitIndex);

        //iterate over all letters represented by this digit on key pad
        for (char letter : pad[digit].toCharArray()) {

            allPhoneDigitLetterCombinations_Helper(
                    digits, digitIndex + 1, currCombination + letter, pad, combinations);
        }
    }

    public void allPhoneDigitLetterCombinations(String digits) {

        //https://leetcode.com/problems/letter-combinations-of-a-phone-number
        /*
         think of keypad based phones, letters are arranged in some number of keypad
         digits provided, form all combinations of letters from each digit in digits
         */
        List<String> combinations = new ArrayList<>();

        if (digits.length() == 0) {
            return;
        }

        //representation of phone keypad
        String[] pad = new String[10];

        pad[0] = "";
        pad[1] = "";
        pad[2] = "abc";
        pad[3] = "def";
        pad[4] = "ghi";
        pad[5] = "jkl";
        pad[6] = "mno";
        pad[7] = "pqrs";
        pad[8] = "tuv";
        pad[9] = "wxyz";

        allPhoneDigitLetterCombinations_Helper(digits, 0, "", pad, combinations);

        //output
        System.out.println("All combinations as the digits given: ");
        combinations.stream().forEach(s -> System.out.print(s + " "));
        System.out.println();
    }

    public boolean checkIfOneCharSwapMakeStringEqual(String s1, String s2) {

        //https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/
        if (s1.length() != s2.length()) {
            return false;
        }

        int n = s1.length();

        char swapedA = '.';
        char swapedB = '.';
        char swapedC = '.';
        char swapedD = '.';

        int swapCount = 0;

        for (int i = 0; i < n; i++) {

            if (s1.charAt(i) != s2.charAt(i)) {
                swapCount++;
                if (swapCount == 1) {
                    swapedA = s1.charAt(i);
                    swapedB = s2.charAt(i);
                } else if (swapCount == 2) {
                    swapedC = s1.charAt(i);
                    swapedD = s2.charAt(i);
                } else {
                    return false;
                }
            }
        }

        return swapCount == 0
                || (swapedA == swapedD && swapedB == swapedC);
    }

    public void largestSubstringBetweenTwoSameChar(String str) {

        //https://leetcode.com/problems/largest-substring-between-two-equal-characters/
        /*
         ex "abca", two same char a & a, set of char between them bc of len = 2
         */
        int[] startingIndexes = new int[26];
        Arrays.fill(startingIndexes, -1);
        int max = -1;
        int end = 0;
        while (end < str.length()) {
            char ch = str.charAt(end);
            if (startingIndexes[ch - 'a'] == -1) {
                //starting index of any char
                startingIndexes[ch - 'a'] = end;
            } else {
                //char chr is seen more than once in else{}
                //calculate max set of char b/w curr seen char chr and prev
                //index of same char chr
                //end = index of curr chr - indexes[chr - 'a'] index of same char chr - 1
                max = Math.max(max, end - startingIndexes[ch - 'a'] - 1);
            }
            end++;
        }

        /*
         partitionLabel() approach
         int[] lastCharIndexes = new int[26];
         for(int i = 0; i < s.length(); i++){
         lastCharIndexes[s.charAt(i) - 'a'] = i;
         }

         int maxLen = -1;

         for(int i = 0; i < s.length(); i++){
         char chr = s.charAt(i);
         int end = lastCharIndexes[chr - 'a'];
         maxLen = Math.max(maxLen, end - i - 1);
         }

         return maxLen;
         */
        //output
        System.out.println("Largest subtring of chars between two same char: " + max);
    }

    public boolean determineIfTwoStringCanBeMadeClose(String str1, String str2) {

        //https://leetcode.com/problems/determine-if-two-strings-are-close/
        if (str1.length() != str2.length()) {
            return false;
        }

        Map<Character, Integer> str1Map = new HashMap<>();
        for (char c : str1.toCharArray()) {
            str1Map.put(c, str1Map.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> str2Map = new HashMap<>();
        for (char c : str2.toCharArray()) {
            str2Map.put(c, str2Map.getOrDefault(c, 0) + 1);
        }

        //same char of str1 should be in str2
        for (char key : str1Map.keySet()) {
            if (!str2Map.containsKey(key)) {
                return false;
            }
        }

        //same char of str2 should be in str1
        for (char key : str2Map.keySet()) {
            if (!str1Map.containsKey(key)) {
                return false;
            }
        }

        //values list of their freq should be equal
        List<Integer> str1Val = str1Map.values().stream().sorted().collect(Collectors.toList());
        List<Integer> str2Val = str2Map.values().stream().sorted().collect(Collectors.toList());

        if (!str1Val.equals(str2Val)) {
            return false;
        }
        return true;
    }

    public void minCharacterRequiredToMakeStringTAnagramOfS(String s, String t) {
        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/
        Map<Character, Long> sMap = s.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        Map<Character, Long> tMap = t.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        //if freq of a char in t is less than the freq of same char in s
        //freq(t.char, defaultIfSameCharNotPresent = 0) < freq(s.char)
        //req chars will be freq(s.char) - freq(t.char, defaultIfSameCharNotPresent = 0)
        long req = 0;
        for (char key : sMap.keySet()) {
            long freqT = tMap.getOrDefault(key, 0l);
            if (freqT < sMap.get(key)) {
                req += sMap.get(key) - freqT;
            }
        }

        //output
        System.out.println("Minimum character required to make string t anagram of s: " + req);
    }

    public void minCharacterRemovedToMakeStringTAndSAnagrams(String s, String t) {

        //https://www.geeksforgeeks.org/remove-minimum-number-characters-two-strings-become-anagram/
        //OPTIMISED from above link
        Map<Character, Long> sMap = s.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));
        //reduce the freq of char of string t from freq Map(sMap) of string s
        //this reduce will balance all the common char of both strings(anagrams)
        //all the char left in map should be removed, where String T & S are anagrams
        for (char ch : t.toCharArray()) {
            sMap.put(ch, sMap.getOrDefault(ch, 0l) - 1l);
        }

        long removed = 0;
        for (char c = 'a'; c <= 'z'; c++) {
            removed += Math.abs(sMap.getOrDefault(c, 0l));
        }

        //output
        System.out.println("Minimum character removed to make string t & s anagrams: " + removed);
    }

    public void convertPostfixToInfixExpression(String postfix) {

        //https://www.geeksforgeeks.org/postfix-to-infix/
        //Approach similar to postfix expression evaluation
        Stack<String> stack = new Stack<>();

        for (char ch : postfix.toCharArray()) {

            if (Character.isLetterOrDigit(ch)) {
                stack.push(ch + "");
            } else {
                String c2 = stack.pop();
                String c1 = stack.pop();

                String str = "(";
                str += c1;
                str += ch;
                str += c2;
                str += ")";
                stack.push(str);
            }
        }

        //output
        System.out.println("Infix expression: " + stack.peek());
    }

    private int convertInfixToPostfixExpression_OperatorPrecedence(char ch) {
        switch (ch) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return -1;
        }
    }

    public void convertInfixToPostfixExpression(String infix) {

        Stack<Character> bracketsAndOperatorStack = new Stack<>();
        StringBuilder sb = new StringBuilder();

        for (char ch : infix.toCharArray()) {

            if (Character.isLetterOrDigit(ch)) {
                sb.append(ch);
            } else if (ch == '(') {
                bracketsAndOperatorStack.push(ch);
            } else if (ch == ')') {
                while (!bracketsAndOperatorStack.isEmpty() && bracketsAndOperatorStack.peek() != '(') {
                    sb.append(bracketsAndOperatorStack.pop());
                }
                //this pop is to remove the '(' that broke the while loop above
                bracketsAndOperatorStack.pop();
            } else {
                while (!bracketsAndOperatorStack.isEmpty()
                        && convertInfixToPostfixExpression_OperatorPrecedence(ch)
                        <= convertInfixToPostfixExpression_OperatorPrecedence(bracketsAndOperatorStack.peek())) {
                    sb.append(bracketsAndOperatorStack.pop());
                }
                bracketsAndOperatorStack.push(ch);
            }
        }

        while (!bracketsAndOperatorStack.isEmpty()) {
            sb.append(bracketsAndOperatorStack.pop());
        }

        //output
        System.out.println("Postfix expression: " + sb.toString());
    }

    public void flipStringToMonotoneIncrease(String str) {
        //https://leetcode.com/problems/flip-string-to-monotone-increasing/
        //explanation: https://youtu.be/NlTjorKsn-Y
        /*
         A string of '0's and '1's is monotone increasing if it consists of some
         number of '0's (possibly 0), followed by some number of '1's
         (also possibly 0.)
         //example of monotones
         ex: 00000
         ex: 11111
         ex: 00011
         */
        int one = 0;
        int flip = 0;
        for (char ch : str.toCharArray()) {
            //count 1's that are coming after the consecutive 0's(possibly none)
            //intutions says that any 0 coming after 1s those will be counted in flip++
            //if no 1 has been counted so far one will remain 0 indicating
            //we don't need to do any flips ==> flips = min(one, flip)
            if (ch == '1') {
                one++;
            } else {
                flip++;
            }
            flip = Math.min(one, flip);
        }

        //output
        System.out.println("Min flip of either 0 or 1 to create monotone string: " + flip);
    }

    public void minDeletionCostToAvoidRepeatingChar(String str, int[] cost) {

        //https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/
        /*
         ex: "abaac", cost[] = {1,2,3,4,5}
         delete char = 'a' from index 2 which cost[2] = 3 and by that str will be
         abac ('a' at index 2 removed) and there are no char repeating after itself
         */
        int n = str.length();
        int res = 0;
        for (int i = 0; i < n - 1; i++) {
            if (str.charAt(i) == str.charAt(i + 1)) {
                if (cost[i] < cost[i + 1]) {
                    res += cost[i]; //min(cost[i], cost[i + 1]) = cost[i]
                } else {
                    res += cost[i + 1]; //min(cost[i], cost[i + 1]) = cost[i + 1]
                    //since here in else block the cost[i + 1] < cost[i]
                    //updating cost[i + 1] with greater cost[i] signifies that we have
                    //deleted a char with min cost (here cost[i + 1]) but we still
                    //have a char with a value cost[i], incase we found a same char at s[(i + 1) + 1]
                    //ex: s = "aaa" cost[4,1,1] first mid 'a' will be deleted
                    //as s[0] == 'a' have cost[0] == 4 && s[0 + 1] == 'a' have cost[0 + 1] == 1
                    //minCost = 1 but at the same time update cost[0 + 1] = cost[0] == 4
                    //meaning s[0 + 1] & cost[0 + 1] is deleted
                    cost[i + 1] = cost[i];
                }
            }
        }

        //output:
        System.out.println("Deletion cost: " + res);
    }

    public void removeAdjacentDuplicateKCharInString(String str, int K) {

        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string
        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/
        class Pair {

            char chr;
            int count;

            public Pair(char ch, int count) {
                this.chr = ch;
                this.count = count;
            }
        }

        Stack<Pair> stack = new Stack();
        for (char ch : str.toCharArray()) {

            //count the freq of chars in stack seq
            if (!stack.isEmpty() && stack.peek().chr == ch) {

                stack.push(new Pair(ch, stack.peek().count + 1));

            } else {

                stack.push(new Pair(ch, 1));
            }

            //the freq of a char in stack seq reaches 'k' start removing it
            if (!stack.isEmpty() && stack.peek().count == K) {
                while (!stack.isEmpty() && stack.peek().chr == ch) {
                    stack.pop();
                }
            }

        }

        String res = "";
        while (!stack.isEmpty()) {
            res = stack.pop().chr + res;
        }

        //output
        System.out.println("Remove K adjacent char and print remaining: " + res);
    }

    public int minSwapRequiredToMakeBinaryStringAlternate(String binaryString) {
        //..................................T: O(N), N = length of string
        //..................................S: O(1), countArr[2][2], 4 storage area in arr
        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/
        //Sol: https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/discuss/1990131/Java-counting

        /*
         row\col    count 0, count 1
         evenIndex 0[   0        0  ]
         oddIndex  1[   0        0  ]
         */
        int evenIndex = 0;
        int oddIndex = 1;
        int[][] countZeroAndOne = new int[2][2];
        for (int i = 0; i < binaryString.length(); i++) {
            char ch = binaryString.charAt(i);
            countZeroAndOne[i % 2][ch - '0']++;
        }

        if ((countZeroAndOne[evenIndex][0] == 0 && countZeroAndOne[oddIndex][1] == 0)
                || (countZeroAndOne[evenIndex][1] == 0 && countZeroAndOne[oddIndex][0] == 0)) {
            return 0;
        }

        if ((countZeroAndOne[evenIndex][0] != countZeroAndOne[oddIndex][1])
                && (countZeroAndOne[evenIndex][1] != countZeroAndOne[oddIndex][0])) {
            return -1;
        }

        int res1 = countZeroAndOne[evenIndex][0] == countZeroAndOne[oddIndex][1]
                ? countZeroAndOne[evenIndex][0]
                : Integer.MAX_VALUE;

        int res2 = countZeroAndOne[evenIndex][1] == countZeroAndOne[oddIndex][0]
                ? countZeroAndOne[evenIndex][1]
                : Integer.MAX_VALUE;

        return Math.min(res1, res2);
    }

    public void minimumIndexSumOfTwoStringArray(String[] list1, String[] list2) {
        //................................T: O(M + N), M = list1.length, N = list2.length
        //................................S: O(M), hashmap for list1
        //https://leetcode.com/problems/minimum-index-sum-of-two-lists/
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < list1.length; i++) {
            map.put(list1[i], i);
        }

        List<String> strs = new ArrayList<>();
        int minIndexSum = Integer.MAX_VALUE;
        for (int i = 0; i < list2.length && i <= minIndexSum; i++) {
            if (map.containsKey(list2[i])) {
                int currIndexSum = map.get(list2[i]) + i;
                if (currIndexSum < minIndexSum) {
                    minIndexSum = currIndexSum;
                    strs.clear();
                    strs.add(list2[i]);
                } else if (currIndexSum == minIndexSum) {
                    strs.add(list2[i]);
                }
            }
        }
        //Output
        //return  strs.toArray(new String[strs.size()]);
        System.out.println("Min index sum: " + strs);
    }

    public int firstUniqueCharacterInString(String str) {
        //https://leetcode.com/problems/first-unique-character-in-a-string/
        Map<Character, Long> freq = str.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));
        for (int i = 0; i < str.length(); i++) {
            if (freq.get(str.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }

    private boolean substringWithConcatenationsOfGivenWords_Check(int index, String str,
                                                                  int lengthPerWord,
                                                                  int subStringLength,
                                                                  int wordsLength,
                                                                  Map<String, Integer> wordsCounter) {

        Map<String, Integer> remaining = new HashMap<>(wordsCounter);
        int wordsUsed = 0;

        for (int i = index; i < index + subStringLength; i += lengthPerWord) {
            String sub = str.substring(i, i + lengthPerWord);
            if (remaining.getOrDefault(sub, 0) != 0) {
                remaining.put(sub, remaining.get(sub) - 1);
                wordsUsed++;
            } else {
                return false;
            }
        }
        return wordsUsed == wordsLength;
    }

    public void substringWithConcatenationsOfGivenWords(String str, String[] words) {
        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/
        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution/
        //BRUTE FORCE approach
        //make below variable global so that there is no need to pass them as
        //method paramters
        int N = str.length();
        int wordsLength = words.length;
        //length of each word will be same in given words[]
        int lengthPerWord = words[0].length();
        //total length of the string formed from concatenating the words in words[]
        int subStringLength = wordsLength * lengthPerWord;
        Map<String, Integer> wordsCounter = new HashMap<>();

        List<Integer> indexes = new ArrayList<>();

        for (String word : words) {
            wordsCounter.put(word, wordsCounter.getOrDefault(word, 0) + 1);
        }

        //all substrings of size subStringLength in given str
        for (int i = 0; i < N - subStringLength + 1; i++) {
            if (substringWithConcatenationsOfGivenWords_Check(i, str,
                    lengthPerWord,
                    subStringLength,
                    wordsLength,
                    wordsCounter)) {
                indexes.add(i);
            }
        }
        //output
        System.out.println("Indexes of all the subtrings that contains concatenations of given words[](word can be in jumbled ordered) "
                + indexes);
    }

    public void maximumWordsThatYouCanType(String text, String brokenLetters) {
        //https://leetcode.com/problems/maximum-number-of-words-you-can-type/
        Set<Character> brokenLetterSet = brokenLetters
                .chars()
                .mapToObj(ch -> (char) ch)
                .collect(Collectors.toSet());

        String[] splitWords = text.split(" ");
        int brokenWordCount = 0;

        //using standard lib indexOf()
//        for (String word : splitWords) {
//            for (char brokenChar : brokenChars) {
//                if (word.indexOf(brokenChar) >= 0) {
//                    brokenWordCount++;
//                    break;
//                }
//            }
//        }
        for (String word : splitWords) {
            //check if the chars of curr word is there in brokenLetterSet
            //because if that char exist in set then this curr word is also
            //broken hence increase brokenWordCount and break as we found a
            //broken char
            for (char charInWord : word.toCharArray()) {
                if (brokenLetterSet.contains(charInWord)) {
                    brokenWordCount++;
                    break;
                }
            }
        }

        //output
        //Maximum Number of Words You Can Type = Total Words You Have - All Broken Words
        int wordsCanBeTyped = splitWords.length - brokenWordCount;
        System.out.println("Maxmum words that you can type : " + wordsCanBeTyped);
    }

    public boolean checkIfParenthesisStringCanBeValid(String s, String locked) {
        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/
        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1905993/Keep-a-Range-1-Pass-O(n)-Java
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        int max = 0;
        int min = 0;

        for (int i = 0; i < n; i++) {
            max += locked.charAt(i) == '0' || s.charAt(i) == '(' ? 1 : -1;
            min += locked.charAt(i) == '0' || s.charAt(i) == ')' ? -1 : 1;
            if (max < 0) {
                return false;
            }
            min = Math.max(0, min);
        }
        return min == 0;
    }

    public void largestOddNumInGivenNumString(String numString) {
        //https://leetcode.com/problems/largest-odd-number-in-string/
        int n = numString.length();
        int lastChar = numString.charAt(n - 1);
        int lastDigit = lastChar - '0';

        //if last digit of a num is odd then the whole num is odd itself
        //ex: 7, 27, 427,...so on
        if (lastDigit % 2 == 1) {
            System.out.println("Largest odd number in given num string: " + numString);
            return;
        }

        //we already checked lastDigit above, it was not odd
        //so start end from second last char index
        int end = n - 2;
        //loop until we reach a odd char/digit from end
        while (end >= 0 && (numString.charAt(end) - '0') % 2 != 1) {
            end--;
        }
        //output
        //end-index at which we will find the first odd chr/digit from end
        //0 to that end-index will be our largest odd string
        System.out.println("Largest odd number in given num string: " + numString.substring(0, end + 1));
    }

    public void smallestStringWithGivenLengthNAndCharSumValueK(int n, int k) {
        //https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/
        char[] smallestString = new char[n];
        //lexicographically smallest string of length n can be full of 'a'
        Arrays.fill(smallestString, 'a');
        //we have taken n length string full of 'a'
        k = k - n;
        int index = n - 1;
        while (index >= 0 && k > 0) {
            int minAscii = Math.min(25, k); // at max we can choose 25 == z
            smallestString[index--] = (char) (minAscii + 'a');
            k -= minAscii;
        }
        //output
        System.out.println("Lexicographically smallest string of length n and char sum k: "
                + String.valueOf(smallestString));
    }

    public void replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar(String str) {
        //https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/
        int n = str.length();

        char[] arr = str.toCharArray();
        for (int i = 0; i < n; i++) {

            if (arr[i] == '?') {

                int left = i - 1;
                int right = i + 1;

                char leftCh = '.';
                char rightCh = '.';

                if (left >= 0) {
                    leftCh = arr[left];
                }

                if (right < n) {
                    rightCh = arr[right];
                }

                //generate a new char from leftCh + 1 (next Acsii value as char)
                //if that is a valid char use that char at ith '?' otherwise default 'a'
                char candidateChar = (char) (leftCh + 1);
                arr[i] = Character.isAlphabetic(candidateChar) ? candidateChar : 'a';

                //if it happens to be that our newly generated char at ith
                //pos is also similar to its rightCh char, we have choose a new
                //candidate char which will be rightCh + 1 (next Acsii value as char)
                if (arr[i] == rightCh) {
                    candidateChar = (char) (rightCh + 1);
                    arr[i] = Character.isAlphabetic(candidateChar) ? candidateChar : 'a';
                }
            }
        }
        //output
        System.out.println("Removing ? and no consecutive char are repeating: "
                + String.valueOf(arr));
    }

    public String simplifyPath(String path) {
        //https://leetcode.com/problems/simplify-path/
        //https://leetcode.com/problems/crawler-log-folder/
        //explanation: https://youtu.be/qYlHrAKJfyA
        path += "/";
        Stack<String> filesOrDirs = new Stack<>();
        StringBuilder canonicalPath = new StringBuilder();
        String currFilesOrDirs = "";
        for (char ch : path.toCharArray()) {

            if (ch == '/') {

                if (currFilesOrDirs.equals("..")) {
                    //".." represent as move to parent dir in filesysytem
                    //so poping means removing curr file or dir and moving to parent file or dir
                    if (!filesOrDirs.isEmpty()) {
                        filesOrDirs.pop();
                    }
                } else if (!currFilesOrDirs.equals("") && !currFilesOrDirs.equals(".")) {
                    //cases when there // there will be currFilesOrDirs == "" and
                    //"." represent as current working dir, we don't to do anything with that
                    //if currFilesOrDirs is none of that, push in stack
                    filesOrDirs.push(currFilesOrDirs);
                }
                //reset
                currFilesOrDirs = "";
            } else {
                currFilesOrDirs += ch;
            }
        }

        if (filesOrDirs.isEmpty()) {
            return "/";
        }

        while (!filesOrDirs.isEmpty()) {
            canonicalPath.insert(0, "/" + filesOrDirs.pop());
        }
        return canonicalPath.toString();
    }

    public void findCommonCharacters(String[] words) {
        //https://leetcode.com/problems/find-common-characters/
        //https://leetcode.com/problems/intersection-of-two-arrays-ii/
        //https://leetcode.com/problems/find-the-difference-of-two-arrays/
        List<Character> result = new ArrayList<>();
        int[] minFreq = new int[26];
        Arrays.fill(minFreq, Integer.MAX_VALUE);
        for (String word : words) {
            //calculate freq of each charater in the curr word
            int[] currFreq = new int[26];
            for (char ch : word.toCharArray()) {
                currFreq[ch - 'a']++;
            }

            //choose min of freq of each char from curr word or any prev words
            for (int i = 0; i < 26; i++) {
                minFreq[i] = Math.min(
                        minFreq[i],
                        currFreq[i]
                );
            }
        }

        for (int i = 0; i < 26; i++) {
            int freq = minFreq[i];
            while (freq != 0) {
                result.add((char) (i + 'a'));
                freq--;
            }
        }
        //output
        System.out.println("All common chars from the given words[]: " + result);
    }

    private int[] wordSubsets_WordFreq(String word) {
        int[] freq = new int[26];
        for (char ch : word.toCharArray()) {
            freq[ch - 'a']++;
        }
        return freq;
    }

    public void wordSubsets(String[] wordsA, String[] wordsB) {
        //https://leetcode.com/problems/word-subsets/
        //somewhat based on findCommonCharacters()
        List<String> result = new ArrayList<>();
        int[] maxFreq = new int[26];
        //all the words in wordsB, calculate each words freq and create max freq
        //array, this max Freq array will tell the amount of char[i] in maxFreq[i]
        //need from each word in wordsA.
        for (String b : wordsB) {
            int[] bFreq = wordSubsets_WordFreq(b);
            for (int i = 0; i < 26; i++) {
                maxFreq[i] = Math.max(maxFreq[i], bFreq[i]);
            }
        }

        for (String a : wordsA) {
            int[] aFreq = wordSubsets_WordFreq(a);
            boolean inValid = false;
            for (int i = 0; i < 26; i++) {
                //if the curr i-th char freq in aFreq is less that what we need
                //as subset i.e maxFreq[i] that means that word a is invalid
                //try another word.
                //in short, in order to curr word a to be in our result,
                //all of its char should have min freq value as that of maxFreq
                if (aFreq[i] < maxFreq[i]) {
                    inValid = true;
                    break;
                }
            }
            if (!inValid) {
                result.add(a);
            }
        }
        //output
        System.out.println("All words where word from wordsB is subset in words from wordsA: " + result);
    }

    public void searchSuggestionSystem_TrieBased(String[] words, String search) {
        //https://leetcode.com/problems/search-suggestions-system/
        //https://practice.geeksforgeeks.org/problems/phone-directory4628/1
        class TrieNode {

            Map<Character, TrieNode> map;
            List<String> words;

            public TrieNode() {
                map = new HashMap<>();
                words = new ArrayList<>();
            }
        }

        class TrieUtil {

            private TrieNode ROOT;
            //this map is used for output purpose, not req by question
            Map<String, List<String>> wordsPerSearchedChar;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
                this.wordsPerSearchedChar = new HashMap<>();
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                for (char ch : word.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.words.add(word);
                    } else {
                        TrieNode node = new TrieNode();
                        node.words.add(word);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            void prefixSearch(String search, List<List<String>> result) {

                TrieNode currNode = ROOT;

                String searchPrefix = "";

                for (char ch : search.toCharArray()) {

                    searchPrefix += ch;

                    if (currNode != null && currNode.map.containsKey(ch)) {

                        currNode = currNode.map.get(ch);
                        result.add(currNode.words.subList(0, Math.min(3, currNode.words.size())));

                    } else {
                        result.add(Collections.emptyList());
                        //making it null, because here it is a prefix mismatch from 'ch'
                        //hence further no list addition should take place other than
                        //empty list
                        currNode = null;
                    }

                    this.wordsPerSearchedChar.put(searchPrefix, result.get(result.size() - 1));
                }
            }
        }

        int n = words.length;
        List<List<String>> result = new ArrayList<>();

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        //sort the words list before adding to trie because if we add sorted list
        //then each word will also be added in sorted manner in trienode.words list
        Arrays.sort(words);

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        trieUtil.prefixSearch(search, result);

        //output
        System.out.println("Search suggestions system: " + result);
        System.out.println("Search suggestions system words per char: " + trieUtil.wordsPerSearchedChar);
    }

    public void searchSuggestionSystem(String[] words, String search) {
        //https://leetcode.com/problems/search-suggestions-system/
        //explanation: https://youtu.be/D4T2N0yAr20

        int n = words.length;
        //this map is used for output purpose, not req by question
        Map<Character, List<String>> wordsPerSearchedChar = new HashMap<>();
        List<List<String>> result = new ArrayList<>();
        //sort lexicographically order
        Arrays.sort(words);
        int reqAtMost = 3;
        int start = 0;
        int end = n - 1;

        for (int i = 0; i < search.length(); i++) {
            char searchChar = search.charAt(i);
            List<String> curr = new ArrayList<>();

            while (end >= start
                    //cond is to skip all those words from start which are
                    //1. smaller than our search word ex: search = "apple", word[start] = "app"
                    //at i = 3 search[3] = l where i >= "app".length()
                    //2. the curr searchChar at ith pos is not matching with the ith char
                    //of word[start].charAt(i) ex search = "apple", word[start] = "ape"
                    //at i = 2 searchChar = p !=  word[start].charAt(i) = e
                    && (i >= words[start].length()
                    || words[start].charAt(i) != searchChar)) {
                start++;
            }

            while (end >= start
                    //cond is to skip all those words from end which are
                    //1. smaller than our search word ex: search = "apple", word[end] = "app"
                    //at i = 3 search[3] = l where i >= "app".length()
                    //2. the curr searchChar at ith pos is not matching with the ith char
                    //of word[end].charAt(i) ex search = "apple", word[end] = "ape"
                    //at i = 2 searchChar = p !=  word[end].charAt(i) = e
                    && (i >= words[end].length()
                    || words[end].charAt(i) != searchChar)) {
                end--;
            }

            //we need atmost 3 words but if we get any less amount then consume that much
            int wordsToConsume = Math.min(reqAtMost, end - start + 1);
            for (int j = 0; j < wordsToConsume; j++) {
                curr.add(words[start + j]);
            }
            result.add(curr);
            //map is used for output purpose only
            wordsPerSearchedChar.put(searchChar, curr);
        }
        //output
        System.out.println("Search suggestions system: " + result);
        System.out.println("Search suggestions system words per char: " + wordsPerSearchedChar);
    }

    public int maximumLengthOfSubstringThatExistsAsSubseqInOtherString(String main, String curr) {
        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
        int currLenCovered = 0;
        int mainLen = main.length();
        for (int i = 0; i < mainLen; i++) {
            if (currLenCovered == curr.length()) {
                break;
            }
            if (main.charAt(i) == curr.charAt(currLenCovered)) {
                currLenCovered++;
            }
        }
        //output
        String substr = curr.substring(0, currLenCovered);
        System.out.println("Maximum length of substring exists as subseq in main string: "
                + currLenCovered + " substr " + substr);
        return currLenCovered;
    }

    public boolean isSubsequence(String main, String curr) {
        //https://leetcode.com/problems/is-subsequence/
        //https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/
        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
        //https://practice.geeksforgeeks.org/problems/find-patterns0606/1
        int currLenCovered = 0;
        int mainLen = main.length();
        int currLen = curr.length();
        for (int i = 0; i < mainLen; i++) {
            if (currLenCovered == currLen) {
                return true;
            }
            if (main.charAt(i) == curr.charAt(currLenCovered)) {
                currLenCovered++;
            }
        }
        return currLen == currLenCovered;
    }

    public boolean isSubsequenceUsingCyclicIncreaments(String str1, String str2) {
        //https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/description/
        //based on isSubsequence()
        int str1Length = str1.length();
        int str2Length = str2.length();

        int str2LengthCovered = 0;

        for (int index = 0; index < str1Length; index++) {

            if (str2LengthCovered == str2Length) {
                return true;
            }

            //(str1.charAt(index) - 'a') means curr char in str1 position
            //((str1.charAt(index) - 'a') + 1) means next cyclic char's position
            //ex: curr str1 char @index = 'a', next cyclic char should be 'b'
            //similarly 'z' ==> 'a'
            char nextCyclicCharFromStr1 = (char) (((((str1.charAt(index) - 'a') + 1) + 26) % 26) + 'a');

            //either both the char of str1 and str2 can match directly
            //ELSE next cyclic char from str1 @index should macth with char in str2
            if (str1.charAt(index) == str2.charAt(str2LengthCovered)) {
                str2LengthCovered++;
            } else if (nextCyclicCharFromStr1 == str2.charAt(str2LengthCovered)) {
                str2LengthCovered++;
            }

        }

        return str2LengthCovered == str2Length;
    }

    public int shortestWayToFormAString(String main, String target) {
        //https://leetcode.com/problems/shortest-way-to-form-string/description/
        //https://leetcode.ca/all/1055.html
        //MY GOOGLE INTERVIEW QUESTION
        class Helper {

            //same as maximumLengthOfSubstringThatExistsAsSubseqInOtherString()
            int maxLengthOfSubseqMatched(String main, String target, int targetStartIndex) {

                int targetEndIndex = targetStartIndex;
                int mainLen = main.length();

                for (int i = 0; i < mainLen; i++) {

                    if (targetEndIndex == target.length()) {
                        //calculate length between the target start & end index
                        return (targetEndIndex - targetStartIndex);
                    }

                    if (main.charAt(i) == target.charAt(targetEndIndex)) {
                        targetEndIndex++;
                    }
                }
                //if targetEndIndex == targetStartIndex means no chars of target
                //string matched as subseq in main string
                return targetEndIndex == targetStartIndex ? -1 : (targetEndIndex - targetStartIndex);
            }
        }

        Helper helper = new Helper();

        int targetLen = target.length();
        int targetStart = 0;
        int partition = 0;

        while (targetStart < targetLen) {

            int length = helper.maxLengthOfSubseqMatched(main, target, targetStart);

            //no subseq found in main string that matches some prefix part of curr
            //string, hence target string can't be formed
            if (length < 0) {
                return -1;
            }

            //a subseq found in main string that matches some prefix part of
            //target string, hence we can make a partition in target string
            partition++;

            //move to next target start char to check as subseq
            targetStart += length;
        }

        return partition;
    }

    public void shortestWayToFormAString2(String main, String curr) {
        //https://leetcode.com/problems/shortest-way-to-form-string/description/
        //https://leetcode.ca/all/1055.html
        //MY GOOGLE INTERVIEW QUESTION
        /*
         main = "aaaabbc"
         curr = "abcbbabc"
         partition in curr string should be 3 as abc | bb | abc
         */
        int partitions = 0;
        String prefixStr = curr;
        int prefixLengthCurrCovered = 0;
        Set<String> cache = new HashSet<>();
        while (prefixStr.length() > 0) {
            //checks if prefixStr is already processed before then we don't
            //need to call the below fun again for same
            //ex: curr = "abcbbabc" first prefix abc will again going
            //to be checked later after bb
            if (cache.contains(prefixStr)) {
                prefixLengthCurrCovered = prefixStr.length();
                prefixStr = prefixStr.substring(prefixLengthCurrCovered);
                partitions++;
                continue;
            }
            //if prefixStr is not cached previously
            //we must find a prefix in curr that exists as subseq in main
            prefixLengthCurrCovered = maximumLengthOfSubstringThatExistsAsSubseqInOtherString(
                    main, prefixStr);
            //if any prefix is not present as subseq the length will return as 0
            //that means we can't divide curr string
            if (prefixLengthCurrCovered == 0) {
                System.out.println("No partition is possible");
                return;
            }
            //if any prefix of curr found as subseq cache what prefix is that
            //ex: curr = "abcbbabc" first prefix = "abc" exists as subseq in "aaaabbc"
            //save substring(0, prefixLengthCurrCovered) i.e, first "abc" and so on...
            cache.add(prefixStr.substring(0, prefixLengthCurrCovered));
            //remove the prefix that has been found
            //like above first "abc" is found as subseq now reduce our actual prefixStr
            //substring(prefixLengthCurrCovered) ==> "bbabc" and so on...
            prefixStr = prefixStr.substring(prefixLengthCurrCovered);
            //if we can do all this we mean that we have a partition
            partitions++;
        }
        //output
        System.out.println("Shortest way to form  string (Approach 2 with cache): " + partitions);
    }

    public void numberOfMatchingSubseq(String main, String[] words) {
        //https://leetcode.com/problems/number-of-matching-subsequences/
        int n = words.length;
        Set<String> alreadyFound = new HashSet<>();
        Set<String> notFound = new HashSet<>();
        int totalMatch = 0;
        for (String word : words) {

            if (notFound.contains(word)) {
                continue;
            } else if (alreadyFound.contains(word)) {
                totalMatch++;
            } else if (isSubsequence(main, word)) {
                totalMatch++;
                alreadyFound.add(word);
            } else {
                notFound.add(word);
            }
        }
        //output
        System.out.println("Total words matches that exists as subseq in main string: " + totalMatch);
    }

    public void numberOfMatchingSubseq2(String main, String[] words) {
        //https://leetcode.com/problems/number-of-matching-subsequences/
        //based on BINARY SEARCH
        class Helper {

            int findStrictlyGreateValueThanPivot(List<Integer> indices, int prevIndex) {

                int n = indices.size();
                int start = 0;
                int end = n - 1;

                while (end >= start) {

                    int mid = start + (end - start) / 2;

                    if ((mid == 0 || indices.get(mid - 1) <= prevIndex) && prevIndex < indices.get(mid)) {
                        return indices.get(mid);
                    } else if (indices.get(mid) <= prevIndex) {
                        start = mid + 1;
                    } else {
                        end = mid - 1;
                    }
                }

                return -1;
            }

        }

        int n = main.length();

        Map<Character, List<Integer>> charToIndices = new HashMap<>();

        for (int index = 0; index < n; index++) {
            charToIndices.putIfAbsent(main.charAt(index), new ArrayList<>());
            charToIndices.get(main.charAt(index)).add(index);
        }

        Helper helper = new Helper();

        int totalMatch = 0;

        for (String word : words) {

            int prevIndex = -1;
            int lengthCovered = 0;

            for (char chr : word.toCharArray()) {

                if (!charToIndices.containsKey(chr)) {
                    break;
                }

                List<Integer> indices = charToIndices.get(chr);

                int index = helper.findStrictlyGreateValueThanPivot(indices, prevIndex);

                if (index == -1) {
                    break;
                }

                prevIndex = index;

                lengthCovered++;
            }

            if (lengthCovered == word.length()) {
                totalMatch++;
            }
        }

        //output
        System.out.println("Total words matches that exists as subseq in main string (approach Binary Search): " + totalMatch);
    }

    public void appendCharsToMakeStringSubseq(String main, String curr) {
        //https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/
        //based on maximumLengthOfSubstringThatExistsAsSubseqInOtherString()
        int n = curr.length();
        int seqMatched = maximumLengthOfSubstringThatExistsAsSubseqInOtherString(main, curr);
        int amountOfCharsToAppend = n - seqMatched;
        String chars = curr.substring(seqMatched);
        //output
        System.out.println("Number of chars to append in String main to make string curr subseq of main: "
                + amountOfCharsToAppend + " chars include: " + chars);
    }

    public void minimumSwapsToMakeParenthesisStringBalanced(String str) {
        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
        //explanation: https://youtu.be/3YDBT9ZrfaU
        int closingBrackets = 0;
        int maxClosingBrackets = 0;
        for (char bracket : str.toCharArray()) {
            closingBrackets += (bracket == ']') ? 1 : -1;
            maxClosingBrackets = Math.max(maxClosingBrackets, closingBrackets);
        }
        //output
        //each time we make a swap, we will be balance two brackets
        int swaps = (maxClosingBrackets + 1) / 2;
        System.out.println("Min swaps to make parenthesis string balanced : " + swaps);
    }

    public void minimumAdditionsToMakeParenthesisStringValid(String str) {
        //https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
        int balancedBrackets = 0;
        int inserts = 0;
        for (char bracket : str.toCharArray()) {
            balancedBrackets += bracket == '(' ? 1 : -1;
            if (balancedBrackets == -1) {
                inserts++;
                balancedBrackets++;
            }
        }
        //output
        System.out.println("Min additions to make parenthesis string valid: "
                + (balancedBrackets + inserts));
    }

    public boolean areAlienWordsSorted(String[] words, String alienAlphabet) {
        //https://leetcode.com/problems/verifying-an-alien-dictionary/
        //explanation: https://youtu.be/OVgPAJIyX6o

        //save the index of all the char in this alienAlphabet letter set
        int[] alphabetIndex = new int[26];
        for (int i = 0; i < alienAlphabet.length(); i++) {
            char ch = alienAlphabet.charAt(i);
            alphabetIndex[ch - 'a'] = i;
        }

        //iterate over all the adjacent words
        for (int i = 0; i < words.length - 1; i++) {
            //curr and next words are always adjacent
            String currWord = words[i];
            String nextWord = words[i + 1];

            for (int j = 0; j < currWord.length(); j++) {
                //since it is given that the words[] is lexcographically sorted
                //then in that case these words "app" & "apple" will be sorted like this
                //but edge cases like "apple" & "app" they are not sorted as "app" is small
                //so j loop running on "apple", there will come a iteration
                //where j == 3 >= "app".length() till this point no char mismatch is found
                //it will not be found later on as "app" will have no char to check
                if (j >= nextWord.length()) {
                    return false;
                }

                int currCharIndex = currWord.charAt(j) - 'a';
                int nextCharIndex = nextWord.charAt(j) - 'a';

                if (currCharIndex != nextCharIndex) {
                    //since words are sorted so
                    //ex curr = "app", next = "cat" they are sorted, first mismatch char is a & c
                    //in normal english index/ascii index value is like a < c
                    //but suppose curr = "cat", next = "app" was given then c < a is a false condition
                    //similary in given alienAplhabet nextChar should have higher index value than currChar
                    //if this case comes opposite currChar have higher index value than nextChar
                    //then alien word[] dictionary is not sorted.
                    if (alphabetIndex[currCharIndex] > alphabetIndex[nextCharIndex]) {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }

    public void generateNumberFollowingPattern(String pattern) {
        //https://leetcode.com/problems/di-string-match/
        //https://leetcode.com/problems/di-string-match/solution/
        int n = pattern.length();
        int low = 0;
        int high = n;
        int index = 0;
        int[] result = new int[n + 1];
        for (char ch : pattern.toCharArray()) {
            if (ch == 'I') {
                result[index++] = low;
                low++;
            } else {
                result[index++] = high;
                high--;
            }
        }
        result[index] = low;
        //output
        System.out.println(pattern + " number following this pattern: " + Arrays.toString(result));
    }

    public void generateSmallestNumberFromDIString(String pattern) {
        //https://leetcode.com/problems/construct-smallest-number-from-di-string/
        //somewhat based on generateNumberFollowingPattern()
        //number pattern should contain digits[1 to 9]
        //ex: "D" output "21" as 1 is dec from 2
        //ex: "IIDDD" output "126543" as 1 < 2 < 6 > 5 > 4 > 3
        int n = pattern.length();
        int num = 1;
        String numStr = "";
        Stack<Integer> stack = new Stack<>();
        for (char ch : pattern.toCharArray()) {
            if (ch == 'D') {
                stack.push(num);
                num++;
            } else {
                stack.push(num);
                num++;
                while (!stack.isEmpty()) {
                    numStr += stack.pop();
                }
            }
        }
        stack.push(num);
        while (!stack.isEmpty()) {
            numStr += stack.pop();
        }
        System.out.println("Smallest number following given DI pattern: " + numStr);
    }

    public void minMovesToMakeStringPallindrome(String str) {
        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/
        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/discuss/2191696/USING-TWO-POINTER-oror-SIMPLEST-SOLUTION

        int n = str.length();

        char[] charArr = str.toCharArray();

        int start = 0;
        int end = n - 1;

        int swaps = 0;

        while (end > start) {
            //greedily compare start and end char update pointer if they are same
            if (charArr[start] == charArr[end]) {
                start++;
                end--;
                continue;
            }

            int currEnd = end;
            //if the start and end chars are not same, try to find the char
            //equal to charArr[start] from the currEnd
            while (charArr[start] != charArr[currEnd]) {
                currEnd--;
            }

            //currEnd would be the char that match to char[start]
            //adjacentNextIndex = currEnd + 1 == adjacent index
            //swap(currEnd, nextToCurrEnd)
            int nextIndex = currEnd + 1;
            //swap
            char temp = charArr[currEnd];
            charArr[currEnd] = charArr[nextIndex];
            charArr[nextIndex] = temp;

            swaps++;
        }
        //output
        System.out.println("Min moves(swaps) to make the string pallindrome: " + swaps);
    }

    public void largestThreeSameDigitNumInString(String num) {
        //https://leetcode.com/problems/largest-3-same-digit-number-in-string/
        //SLIDING WINDOW approach
        int n = num.length();
        int start = 0;
        int end = 0;
        Map<Character, Integer> counter = new HashMap<>();
        int maxEffectiveNum = Integer.MIN_VALUE;

        String result = "";

        while (end < n) {

            char chEnd = num.charAt(end);
            counter.put(chEnd, counter.getOrDefault(chEnd, 0) + 1);

            //same digit and length to be 3
            //so counter size should remain 1 for a single/same digit process
            //like "777" map['7' = 3] size == 1
            if (counter.size() == 1
                    //window here req to be 3
                    && (end - start + 1) == 3) {

                int currEffectiveNum = chEnd - '0';
                //incase we already have processed "777"
                //so currEffectiveNum = 7, maxEffectiveNum also be currEffectiveNum == 7
                //later on we see "333"
                //then currEffectiveNum = 3
                //but we already have a maxEffectiveNum as 7
                //so our result will not be updated to "333"
                if (currEffectiveNum > maxEffectiveNum) {
                    maxEffectiveNum = currEffectiveNum;
                    //same digits of length 3
                    result = currEffectiveNum + "" + currEffectiveNum + "" + currEffectiveNum;
                }
            }

            //if we need same digit of length 3
            //incase we added 2 different digit then map.size > 1
            //so we will move our window from start
            while (counter.size() > 1) {
                char chStart = num.charAt(start);
                counter.put(chStart, counter.getOrDefault(chStart, 0) - 1);
                if (counter.get(chStart) <= 0) {
                    counter.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //output
        System.out.println("Largest same digit num of length 3: " + result);
    }

    public void minFlipsToMakeBinaryStringAlternating(String str) {
        //https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
        //explanation: https://youtu.be/MOeuK6gaC2A
        //SLIDING WINDOW approach
        /*
         You are given a binary string s. You are allowed to perform two types of
         operations on the string in any sequence:

         Type-1: Remove the character at the start of the string s and append
         it to the end of the string.
         Type-2: Pick any character in s and flip its value, i.e., if its value
         is '0' it becomes '1' and vice-versa.
         Return the minimum number of type-2 operations you need to perform
         such that s becomes alternating.
         */

        int actualLen = str.length();

        //to achieve Type-1 operation
        str = str + str;

        int appenedStrlen = str.length();

        String targetAltStr1 = "";
        String targetAltStr2 = "";

        //generate the possible alternating binary strings that is of same length
        //as of our actual str (n)
        for (int i = 0; i < appenedStrlen; i++) {
            targetAltStr1 += i % 2 == 0 ? "0" : "1";
            targetAltStr2 += i % 2 == 0 ? "1" : "0";
        }

        int start = 0;
        int end = 0;

        int bitDiffTarget1 = 0;
        int bitDiffTarget2 = 0;

        int minFlips = appenedStrlen;

        while (end < appenedStrlen) {

            if (str.charAt(end) != targetAltStr1.charAt(end)) {
                bitDiffTarget1++;
            }
            if (str.charAt(end) != targetAltStr2.charAt(end)) {
                bitDiffTarget2++;
            }

            while (end - start + 1 > actualLen) {
                if (str.charAt(start) != targetAltStr1.charAt(start)) {
                    bitDiffTarget1--;
                }
                if (str.charAt(start) != targetAltStr2.charAt(start)) {
                    bitDiffTarget2--;
                }
                start++;
            }

            if (end - start + 1 == actualLen) {
                minFlips = Math.min(minFlips, Math.min(bitDiffTarget1, bitDiffTarget2));
            }
            end++;
        }
        //output
        System.out.println("Min flips to make binary string alternating: " + minFlips);
    }

    private boolean decodedString_IsStringDigit(String str) {
        char ch = str.charAt(0);
        return ch >= '0' && ch <= '9';
    }

    public void decodedString(String expression) {
        //https://leetcode.com/problems/decode-string/
        //explanation: https://youtu.be/qB0zZpBJlh8
        int n = expression.length();
        Stack<String> stack = new Stack<>();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < n; i++) {
            char ch = expression.charAt(i);

            if (ch == ']') {

                String substr = "";
                //ex stack be like [ '[', 'b', 'c' ] then closing bracket comes ']'
                //then form this inner sub string "bc" until we meet its opening bracket '[' in stack
                while (!stack.isEmpty() && !stack.peek().equals("[")) {
                    substr = stack.pop() + substr;
                }

                //pop the opening bracket '[' from the above loop check
                stack.pop();

                String numStr = "";
                //each decoded string has some num K as "K[substr]", where we need to
                //repeat this substr * K time. In the loop below we will form this num K
                //as numStr
                while (!stack.isEmpty() && decodedString_IsStringDigit(stack.peek())) {
                    numStr = stack.pop() + numStr;
                }

                int num = Integer.parseInt(numStr);
                String repeatSubStrNumTimes = "";
                for (int rep = 0; rep < num; rep++) {
                    repeatSubStrNumTimes += substr;
                }

                //till here we have processed the sub-expression
                //in format "num[substr]", we will push this sub-expression
                stack.push(repeatSubStrNumTimes);

            } else {
                //stringified form of curr char chr
                stack.push(ch + "");
            }
        }

        //forming result from all the processed sub-expressions
        String joined = String.join("", stack);
//        while (!stack.isEmpty()) {
//            sb.insert(0, stack.pop());
//        }

        //output:
//        System.out.println("Decoded string: " + sb.toString());
        System.out.println("Decoded string: " + joined);
    }

    public void reverseSubstringsBetweenParenthesis(String str) {
        //https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
        //somewhat similar to decodedString()
        Stack<String> stack = new Stack<>();
        StringBuilder substr = new StringBuilder();

        for (char ch : str.toCharArray()) {
            if (ch == ')') {

                //reset stringbuilder before processing each inner substrings
                substr.setLength(0);
                while (!stack.isEmpty() && !stack.peek().equals("(")) {
                    substr.append(stack.pop());
                }

                //pop out the '(' from above loop
                stack.pop();

                stack.push(substr.reverse().toString());

            } else {
                stack.push(String.valueOf(ch));
            }
        }

        substr.setLength(0);
        while (!stack.isEmpty()) {
            substr.append(stack.pop());
        }
        System.out.println("Reverse substrings between parenthesis: " + substr.reverse().toString());
    }

    public boolean validPallindromeTwo(String str) {
        //https://leetcode.com/problems/valid-palindrome-ii/
        //explanation: https://youtu.be/JrxRYBwG6EI
        int n = str.length();
        int start = 0;
        int end = n - 1;

        while (end > start) {
            if (str.charAt(start) == str.charAt(end)) {
                start++;
                end--;
                continue;
            }

            //not include char at start-th index ==> start + 1
            //include end char do end + 1
            String skipStart = str.substring(start + 1, end + 1);
            //skip end char
            String skipEnd = str.substring(start, end);

            return isStringPallindrome(skipStart) || isStringPallindrome(skipEnd);
        }
        return true;
    }

    public void textJustification(String[] words, int maxWidth) {
        //https://leetcode.com/problems/text-justification/
        //https://www.interviewbit.com/problems/justified-text/hints/
        //https://leetcode.com/problems/rearrange-spaces-between-words/description/
        int n = words.length;
        List<String> texts = new ArrayList<>();
        int SPACE = 1;
        int start = 0;
        int end = 0;

        while (start < n) {

            int lineLength = -1;
            end = start;
            while (end < n && (words[end].length() + SPACE + lineLength) <= maxWidth) {
                lineLength += words[end].length() + SPACE;
                end++;
            }

            //(end - word) denotes the number of words choosen to be fit into the
            //curr line of the text
            //ex: [this, is, an, example] ==> means when the above while() loop
            //breaks then start = 0, end = 3 and words choosen [this, is, an] as
            //'maxWidth' allows this much words
            int wordsInLine = end - start;
            int spaces = 1;
            int extras = 0;

            //if there is just 1 word in the curr line of text then no spaces are
            //required to be set(as there is just 1 word so where the spaces be
            //put, only at the remaining end side of maxWidth - text.length() of
            //curr line)
            //BUT if there are more than 1 word in curr line of text and we need
            //to put spaces at (words - 1) positions in between these choosen words
            //ex: [this, is, an, example] words choosen for curr line of text is
            //[this, is, an] so there are 3 words and space to be put at these '_'
            //"this_is_an" (==> '_' = wordsInLine - 1)
            if (wordsInLine != 1 && end != n) {
                spaces = (maxWidth - lineLength) / (wordsInLine - 1) + SPACE;
                extras = (maxWidth - lineLength) % (wordsInLine - 1);
            }

            //add the first word in the curr line of text
            StringBuilder text = new StringBuilder(words[start]);

            //start fron next word and put spaces required in between
            for (int pick = start + 1; pick < end; pick++) {
                //add min spaces req between two words
                for (int space = 0; space < spaces; space++) {
                    text.append(" ");
                }
                //if any extra spaces are also req, that should also be added
                if (extras-- > 0) {
                    text.append(" ");
                }
                //after adding all the spaces, we can add the curr jth word
                text.append(words[pick]);
            }

            int remaining = maxWidth - text.length();
            while (remaining-- > 0) {
                text.append(" ");
            }
            texts.add(text.toString());
            start = end;
        }
        //output
        System.out.println("Text justification: " + texts);
    }

    public void positionsOfLargeGroups(String str) {
        //https://leetcode.com/problems/positions-of-large-groups/
        //SLIDING WINDOW approach
        List<List<Integer>> positions = new ArrayList<>();
        int n = str.length();
        Map<Character, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        while (end < n) {

            char chEnd = str.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);

            //size == 2 means we now have discontinuity from a potential large group,
            //in that discontinuity we can add previous group if it was >= 3
            //we are not calculating window length as (end - start + 1) because
            //end is already ahead of large group where we found a discontinuity,
            //so length to be considered here till end - 1
            if (freq.size() == 2) {
                if (end - start >= 3) {
                    positions.add(Arrays.asList(start, end - 1));
                }
            }

            //large group will be of same chars whose freq is >= 3
            //if we have more than 1 char in our freq map, we need to adjust our window
            //to find next coming large groups because if previous was a large groups, it
            //would have been calculated in above if block
            while (freq.size() > 1) {
                char chStart = str.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                if (freq.get(chStart) <= 0) {
                    freq.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //this if block is handle cases of str = "aaa", "abcaaaa"
        //here after end > n, we are not able to check the very last large groups of str
        //so need this cond here also
        if (end - start >= 3) {
            positions.add(Arrays.asList(start, end - 1));
        }
        //output
        System.out.println("Positions of all the large groups of strings: " + positions);
    }

    public void positionsOfLargeGroups2(String str) {
        //https://leetcode.com/problems/positions-of-large-groups/
        //based on TWO POINTER, OPTIMIZED approach from above implementation
        List<List<Integer>> intervals = new ArrayList<>();
        int n = str.length();
        int start = 0;
        int end = 0;

        while (end < n) {

            if (end + 1 < n && str.charAt(end) == str.charAt(end + 1)) {
                end++;
                continue;
            }

            if (end - start + 1 >= 3) {
                intervals.add(Arrays.asList(start, end));
            }

            start = end + 1;
            end++;
        }

        //output
        System.out.println("Positions of all the large groups of strings: " + intervals);
    }

    public void minTimeToType(String word) {
        //https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/
        //based on Greedy
        /*
        In a circular keyboard, we can either move clockwise or counter clockwise dir
        to reach a char from the word. To have a min time, choose the min time taken
        to reach the dest char from curr pointer and taking up the dest char counts as 1 unit of time
         */
        char currPointer = 'a';
        int time = 0;
        for (char destChar : word.toCharArray()) {
            //calculating the time taken to reach to dest char from the curr pointer
            int clockwiseTime = Math.abs(currPointer - destChar);
            int counterClockwiseTime = 26 - Math.abs(currPointer - destChar);

            //moving to dest char in less time possible
            time += Math.min(clockwiseTime, counterClockwiseTime);

            //picking that dest char takes 1 unit time;
            time += 1;

            //our curr pointer is now at dest char
            currPointer = destChar;
        }
        //output
        System.out.println("Min time to type the given word from a circular keyboard: " + time);
    }

    public void maxVowelCountInSubstringOfKLength(String str, int k) {
        //https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
        //based on SLIDING WINDOW
        int n = str.length();
        int start = 0;
        int end = 0;
        int maxVowelCount = 0;
        int currVowelCount = 0;

        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));

        while (end < n) {
            char chEnd = str.charAt(end);
            if (vowels.contains(chEnd)) {
                currVowelCount++;
            }

            if (end - start + 1 == k) {
                maxVowelCount = Math.max(maxVowelCount, currVowelCount);
                char chStart = str.charAt(start);
                if (vowels.contains(chStart)) {
                    currVowelCount--;
                }
                start++;
            }
            end++;
        }
        //output
        System.out.println("max vowel counts in a subtring of size k: " + maxVowelCount);
    }

    public void minAmountOfTimeToCollectGarbage(String[] garbage, int[] travel) {
        //https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
        //explanation: https://youtu.be/xSLisYdX8Co
        //Acc to question, for each garbage type, truck has to start from garbage[0]
        //and in order to pick a single type of garbage, it might have to travel all
        //the houses(i-th) with travel[]
        //so save the total time to travel as prefix sum to find the i-th travel time
        int n = travel.length;
        int travelTimePrefixSum = 0;
        for (int i = 0; i < n; i++) {
            travelTimePrefixSum += travel[i];
            travel[i] = travelTimePrefixSum;
        }

        //after that, need to find the very last i-th house where a particular
        //type of garbage is found(G, P, M), this lastIndex will tell the travel
        //time as travel[lastIndex - 1] till i-th house to find the last instance
        //of that particular garbage
        int glassLastIndex = -1;
        int paperLastIndex = -1;
        int metalLastIndex = -1;

        //Acc to questions, apart from travel time, there is also picking up time
        //that is to pick each type of garbage from [0 to m] houses, it will take
        //1 unit of time. we will simply calculate the total no of garbage of each
        //type * 1 == PickingTime
        int glassPickingTime = 0;
        int paperPickingTime = 0;
        int metalPickingTime = 0;

        int m = garbage.length;
        for (int i = 0; i < m; i++) {
            String house = garbage[i];
            for (char garbageType : house.toCharArray()) {

                if (garbageType == 'G') {
                    //last index or last nouse where Glass garbage found
                    //because truck will have to travel till this house(i) to pick
                    glassLastIndex = i;
                    glassPickingTime++;
                }

                if (garbageType == 'P') {
                    //last index or last nouse where Paper garbage found
                    //because truck will have to travel till this house(i) to pick
                    paperLastIndex = i;
                    paperPickingTime++;
                }

                if (garbageType == 'M') {
                    //last index or last nouse where Metal garbage found
                    //because truck will have to travel till this house(i) to pick
                    metalLastIndex = i;
                    metalPickingTime++;
                }
            }
        }

        //totalTime to pick & travel for each type of garbage
        //why (lastIndex > 0) condition, acc to question, travel[] time is given
        //to reach the (i + 1)-th house from i-th house, so by this to reach
        //house (lastIndex == 0) time is 0 and any house(lastIndex > 0)
        //we can take (lastIndex - 1)-th house time(DRY RUN)
        int totalTimeForGlassGarbage = glassPickingTime + (glassLastIndex > 0 ? travel[glassLastIndex - 1] : 0);
        int totalTimeForPaperGarbage = paperPickingTime + (paperLastIndex > 0 ? travel[paperLastIndex - 1] : 0);
        int totalTimeForMetalGarbage = metalPickingTime + (metalLastIndex > 0 ? travel[metalLastIndex - 1] : 0);

        //output
        System.out.println("Total time to collect garbage by pick & travel: "
                + (totalTimeForGlassGarbage + totalTimeForPaperGarbage + totalTimeForMetalGarbage));
    }

    public void minSuffixFlipInBinaryString(String target) {
        //https://leetcode.com/problems/minimum-suffix-flips/
        /*
        base string acc to quest is of same length as that of target string
        baseString.length == target.length == N
        base string will initially have all the values '0' i.e baseString = "0" * N

        ex: target = "101"
        initial curr = "000"

        with each flips to match currState to targetState
        steps increases
        and since we flipped currState to targetState so currState = targetState

        ##1 i = 0
        currState = 0, targetState = 1
        currState[i to n] ==> currState[0 to n] ==> "[111]", currState = targetState = 1

        ##2 i = 1
        currState = 1, targetState = 0
        currState[i to n] ==> currState[1 to n] ==> "1[00]", currState = targetState = 0

        ##2 i = 2
        currState = 0, targetState = 1
        currState[i to n] ==> currState[2 to n] ==> "10[1]", currState = targetState = 1

         */
        int steps = 0;
        //currState represents the curr char in the baseString
        char currState = '0';
        for (char targetState : target.toCharArray()) {
            if (targetState != currState) {
                steps++;
                currState = targetState;
            }
        }
        //output
        System.out.println("Min suffix flips to make base string equal to target string: " + steps);
    }

    public String longestWordInDictionary(String[] words) {
        //https://leetcode.com/problems/longest-word-in-dictionary/
        Set<String> wordSet = new HashSet<>();
        for (String word : words) {
            wordSet.add(word);
        }

        //sort the words[] as longest length first to smallest at end
        //if lengths are same then sort lexicographically
        Arrays.sort(words, (a, b) -> a.length() == b.length()
                ? a.compareTo(b)
                : b.length() - a.length());

        for (String word : words) {
            //since longest word is the first word now, so possibly it is the
            //good word, only if all of its prefix substring exists in the wordSet/wors[]
            boolean isGoodWord = true;
            for (int i = 1; i < word.length(); i++) {
                //if for the curr longest word 'word' any prefixSubstring
                //doesn't exists as separate word in words[]/wordSet then it can't
                //be a good word, mark isGoodWord = false and break.
                String prefixSubstring = word.substring(0, i);
                if (!wordSet.contains(prefixSubstring)) {
                    isGoodWord = false;
                    break;
                }
            }
            //if from above loop isGoodWord is still true, its our answer
            if (isGoodWord) {
                return word;
            }
        }
        return "";
    }

    public String longestWordInDictionary_Trie(String[] words) {
        //https://leetcode.com/problems/longest-word-in-dictionary/
        //https://leetcode.com/problems/longest-word-with-all-prefixes/description/
        //based on TRIE
        class TrieNode {

            Map<Character, TrieNode> nodes;
            boolean isEndOfWord;

            public TrieNode() {
                nodes = new HashMap<>();
                isEndOfWord = false;
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {
                    if (currRoot.nodes.containsKey(ch)) {
                        currRoot = currRoot.nodes.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currRoot.nodes.put(ch, node);
                        currRoot = node;
                    }
                }

                currRoot.isEndOfWord = true;
            }

            boolean isValid(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    //if curr ch is exist in trie then move to its next node
                    if (currRoot.nodes.containsKey(ch)) {
                        currRoot = currRoot.nodes.get(ch);
                    }

                    //since we need this pattern
                    //ex: words[] = [a, ap, app, appl, apple]
                    //[a]->endOfWord=true
                    //a[p]->endOfWord=true
                    //ap[p]->endOfWord=true
                    //app[l]->endOfWord=true
                    //appl[e]->endOfWord=true
                    //if any prefix string of word is not existing as separate
                    //valid word in words[] then return false;
                    if (!currRoot.isEndOfWord) {
                        return false;
                    }
                }

                //if the curr word itself is a valid word
                return currRoot.isEndOfWord;
            }
        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        //sort the words[] in their decreasing lengths means longest length word
        //first and smaller length word at end. If two words have same length
        //sort the words in lexicographically order
        Arrays.sort(words, (a, b) -> a.length() == b.length()
                ? a.compareTo(b) : Integer.compare(b.length(), a.length()));

        //put the sorted words in trie
        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        //since we already sorted our words, and have longest word in the starting
        //we just need to check is curr longest word is valid, if it is valid return
        //that word right away
        for (String word : words) {
            //a word is valid only if each of their prefixes exist as valid words
            //in words[]
            //ex: words[] = [a, ap, app, appl, apple]
            //[a]->endOfWord=true
            //a[p]->endOfWord=true
            //ap[p]->endOfWord=true
            //app[l]->endOfWord=true
            //appl[e]->endOfWord=true
            if (trieUtil.isValid(word)) {
                return word;
            }
        }
        return "";
    }

    public void minInsertionsToBalanceAParenthesisString(String str) {
        //https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
        str = str.replace("))", "]");
        int openBrackets = 0;
        int balanced = 0;
        for (char bracket : str.toCharArray()) {
            if (bracket == '(') {
                openBrackets++;
            } else {
                if (openBrackets > 0) {
                    balanced += bracket == ')' ? 1 : 0;
                    openBrackets--;
                } else {
                    balanced += bracket == ']' ? 1 : 2;
                }
            }
        }
        //output
        System.out.println("Min insertions to make parenthesis string balanced: " + (balanced + openBrackets * 2));
    }

    public void shiftingLetterTwo_BruteForce(String str, int[][] shifts) {
        //https://leetcode.com/problems/shifting-letters-ii/
        int n = str.length();
        char[] arr = str.toCharArray();
        for (int[] shift : shifts) {

            int startIndex = shift[0];
            int endIndex = shift[1];
            //0 == backward move 1 unit back ex: a -1 == z
            //1 == forward move 1 unit ahead ex: a +1 == b
            int move = shift[2] == 0 ? -1 : 1;
            while (startIndex <= endIndex) {
                int val = ((arr[startIndex] - 'a' + move) % 26 + 26) % 26;
                arr[startIndex] = (char) (val + 'a');
                startIndex++;
            }
        }
        //output
        System.out.println("Shifting letters two: " + String.valueOf(arr));
    }

    public void shiftingLetterTwo(String str, int[][] shifts) {
        //https://leetcode.com/problems/shifting-letters-ii/
        //based on prefixSum
        int n = str.length();
        char[] arr = str.toCharArray();
        int[] moves = new int[n + 1];
        for (int[] shift : shifts) {

            int startIndex = shift[0];
            int endIndex = shift[1];
            //0 == backward move 1 unit back ex: a -1 == z
            //1 == forward move 1 unit ahead ex: a +1 == b
            int move = shift[2] == 0 ? -1 : 1;
            moves[startIndex] += move;
            moves[endIndex + 1] += -move;
        }

        for (int i = 1; i <= n; i++) {
            moves[i] += moves[i - 1];
        }

        for (int i = 0; i < n; i++) {
            int val = ((arr[i] - 'a' + moves[i]) % 26 + 26) % 26;
            arr[i] = (char) (val + 'a');
        }

        //output
        System.out.println("Shifting letters two: " + String.valueOf(arr));
    }

    private boolean pallindromePairs_IsPallindrome(String str, int left, int right) {
        if (left > right) {
            return false;
        }
        while (right > left) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    public void pallindromePairs(String[] words) {
        //https://leetcode.com/problems/palindrome-pairs/
        //https://leetcode.com/problems/palindrome-pairs/discuss/2585763/Java-100-149ms-or-HashMap-based-solution-w-Video-Explanation
        int n = words.length;
        List<List<Integer>> pairs = new ArrayList<>();
        Map<String, Integer> indexMap = new HashMap<>();
        //tree set to automatically sort the length of word
        Set<Integer> lengthTreeSet = new TreeSet<>();

        for (int i = 0; i < n; i++) {
            String currWord = words[i];
            indexMap.put(currWord, i);
            lengthTreeSet.add(currWord.length());
        }

        for (int i = 0; i < n; i++) {

            String currWord = words[i];
            int currWordLen = currWord.length();
            String revCurrWord = new StringBuilder(currWord).reverse().toString();

            //if the reverse of currWord exist as distinct word with a distinct
            //index value other than actual currWord
            if (indexMap.containsKey(revCurrWord) && indexMap.get(revCurrWord) != i) {
                pairs.add(Arrays.asList(i, indexMap.get(revCurrWord)));
            }

            for (int length : lengthTreeSet) {

                if (currWordLen == length) {
                    break;
                }

                if (pallindromePairs_IsPallindrome(revCurrWord, 0, currWordLen - length - 1)) {
                    String substr = revCurrWord.substring(currWordLen - length);
                    if (indexMap.containsKey(substr)) {
                        pairs.add(Arrays.asList(i, indexMap.get(substr)));
                    }
                }

                if (pallindromePairs_IsPallindrome(revCurrWord, length, currWordLen - 1)) {
                    String substr = revCurrWord.substring(0, length);
                    if (indexMap.containsKey(substr)) {
                        pairs.add(Arrays.asList(indexMap.get(substr), i));
                    }
                }
            }
        }
        //output
        System.out.println("Pallindrome pairs: " + pairs);
    }

    public void longestPallindromeByConcatenatingTwoLetterWords(String[] words) {
        //https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/
        int n = words.length;
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        int wordAndRevLength = 0;
        int singleMiddlePallindromeWordLength = 0;
        int otherPallindromeWordLength = 0;

        for (String word : words) {
            String revWord = new StringBuilder(word).reverse().toString();

            if (word.equals(revWord) && freq.containsKey(word)) {

                //here we have self-pallindrome words
                //like [gg, ll, aa]
                //if a self-pallindrome word is odd in freq
                //1-unit of this word can be made middle pallindrome word of
                //the whole pallindormic word
                if (freq.get(word) % 2 != 0) {
                    //all words are 2 letter words so middle-self-pallindrome word
                    //is also of 2 length long
                    singleMiddlePallindromeWordLength = 2;
                    if (freq.get(word) > 1) {
                        //above we have taken 1-unit of word as middle pallindrome
                        //we can arrange the remaining words after that, freq of
                        //left over words * 2char
                        otherPallindromeWordLength += (freq.get(word) - 1) * 2;
                    }
                } else {
                    otherPallindromeWordLength += freq.get(word) * 2;
                }
                freq.remove(word);
            } else if (freq.containsKey(word) && freq.containsKey(revWord)) {
                //here the the curr word is not a self-pallindromic word, that means
                //we need to find a counter reverse word of the curr word, if that exist
                //we can pick min of either of the freq i.e, min(freq[word], freq[revWord])
                //min is taken because that much of pallindrome string can be formed
                //lc....cl ==> lcty...ytcl
                int freqWord = freq.get(word);
                int freqRevWord = freq.get(revWord);

                int minTaken = Math.min(freqWord, freqRevWord);

                //2 * minTaken == 2char * min taken of freq[word]
                //2 * minTaken == 2char * min taken of freq[revWord]
                //like 2char * freq[lc] + 2char * freq[cl]
                wordAndRevLength += (2 * minTaken + 2 * minTaken);

                //now since we have consumed minTaken words from either of
                //word or revWord, we must remove both the words from freq map
                //why remove? because minTake is min freq of either word or revWord
                //and we exactly taking this min freq that means after taking this
                //either of the word or revWord will loose all of it freq means
                //freq[word] - minTake == 0  or freq[revWord] - minTake == 0
                //so need to remove that word whoose freq becomes 0 but at the same
                //time its counter/rev word will be of no use for next time
                freq.remove(word);
                freq.remove(revWord);

            }
        }
        //output
        System.out.println("Longest pallindrome by concatenating two letter words: "
                + (wordAndRevLength + otherPallindromeWordLength + singleMiddlePallindromeWordLength));
    }

    public void findAndReplaceInString(String str, int[] indices, String[] sources, String[] targets) {
        //https://leetcode.com/problems/find-and-replace-in-string/
        //based on brute force
        int n = str.length();
        int m = indices.length;

        String[] result = new String[n];
        Arrays.fill(result, "");

        //stringified char arr[]
        for (int i = 0; i < n; i++) {
            result[i] += str.charAt(i);
        }

        for (int i = 0; i < m; i++) {

            int index = indices[i];
            String source = sources[i];
            String target = targets[i];

            int sourceLen = source.length();

            if (str.charAt(index) == source.charAt(0)) {

                int substrLen = Math.min(index + sourceLen, n);
                String substring = str.substring(index, substrLen);
                if (substring.equals(source)) {
                    result[index] = target;
                    for (int j = index + 1; j < substrLen; j++) {
                        result[j] = "";
                    }
                }
            }
        }
        //output
        System.out.println("Replaced sources with target strings: " + String.join("", result));
    }

    public void removeStarsFromString_StackBased(String str) {
        //......................T: O(N + N), N = str.length()
        //first O(N) to process stars in the given string
        //second O(N) to form the result string from the stack
        //https://leetcode.com/problems/removing-stars-from-a-string/
        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
        //this approach was giving TLE
        Stack<Character> stack = new Stack<>();
        for (char ch : str.toCharArray()) {
            if (ch == '*') {
                stack.pop();
            } else {
                stack.push(ch);
            }
        }

        String result = "";
        if (!stack.isEmpty()) {
            while (!stack.isEmpty()) {
                result = stack.pop() + result;
            }
        }
        //output
        System.out.println("Remove stars from string: " + result);
    }

    public void removeStarsFromString(String str) {
        //......................T: O(N), N = str.length()
        //https://leetcode.com/problems/removing-stars-from-a-string/
        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
        //based on removeStarsFromString_StackBased() but OPTIMISED
        //this approach saves the extra O(N) time, for forming the result string back
        //from stack, here StringBuilder behaves as stack and also the result string
        //which is trivial for edge cases like long inputs/string without '*' etc
        StringBuilder sb = new StringBuilder();
        for (char ch : str.toCharArray()) {
            if (ch == '*') {
                //just like the stack approach, when ever we are seeing a '*' char
                //we were popping out the last char added to stack, here also,
                //deleting the last char added to stringbuilder
                sb.deleteCharAt(sb.length() - 1);
            } else {
                sb.append(ch);
            }
        }
        //output
        System.out.println("Remove stars from string: " + sb.toString());
    }

    public void distinctEchoSubstrings(String str) {
        //https://leetcode.com/problems/distinct-echo-substrings/
        //https://leetcode.com/problems/distinct-echo-substrings/discuss/2351050/easy-c%2B%2B-solution-oror-two-pointer
        //BRUTE FORCE
        int n = str.length();
        int half = n / 2;
        Set<String> echoSubstrs = new HashSet<>();
        int currLen = 0;

        while (currLen <= half) {
            int firstStringIndex = 0;
            int secondStringIndex = currLen;
            int matchedChars = 0;

            while (secondStringIndex < n) {
                if (str.charAt(firstStringIndex) == str.charAt(secondStringIndex)) {
                    matchedChars++;
                } else {
                    matchedChars = 0;
                }

                if (matchedChars == currLen) {
                    int echoStringStart = firstStringIndex - currLen + 1;
                    String substr = str.substring(echoStringStart, echoStringStart + currLen);
                    if (!substr.equals("")) {
                        echoSubstrs.add(substr);
                    }
                    matchedChars--;
                }
                firstStringIndex++;
                secondStringIndex++;
            }
            currLen++;
        }
        //output
        System.out.println("Distinct echo substrings: " + echoSubstrs.size());
        System.out.println("Distinct echo substrings: " + echoSubstrs);
    }

    public void findDuplicateFilesInSystem(String[] paths) {
        //https://leetcode.com/problems/find-duplicate-file-in-system/
        //simple BRUTE FORCE
        List<List<String>> filePathsOfCommonContent = new ArrayList<>();
        Map<String, List<String>> commonContents = new HashMap<>();

        for (String path : paths) {

            String[] split = path.split(" ");
            //as per the given input pattern, dir will be at 0-th index
            String dir = split[0];
            int infoLen = split.length;

            for (int i = 1; i < infoLen; i++) {
                //currInfo will be of pattern file-name.ext(file-content)
                String currInfo = split[i];
                //contentBracketIndex will be index of '('
                int contentBracketIndex = currInfo.indexOf('(');
                //from contentBracketIndex, we can fetch the file-name, i.e from
                //[0 to contentBracketIndex - 1]
                String fileName = currInfo.substring(0, contentBracketIndex);
                //from contentBracketIndex, we can fetch the file-content, i.e from
                //[contentBracketIndex + 1 to currInfo.length() - 1]
                //i.e, in between brackets (file-content)
                String fileContent = currInfo.substring(contentBracketIndex + 1, currInfo.length() - 1);

                commonContents.putIfAbsent(fileContent, new ArrayList<>());
                commonContents.get(fileContent).add(dir + "/" + fileName);
            }
        }

        for (String fileContent : commonContents.keySet()) {
            //in order to be in our result, a file content has to be duplicated
            //atleast in 2 files, that why if the count file paths for this content
            //is just 1 that would means it is not duplicate
            if (commonContents.get(fileContent).size() > 1) {
                filePathsOfCommonContent.add(commonContents.get(fileContent));
            }
        }
        //output
        System.out.println("File paths in system having duplicate file content: " + filePathsOfCommonContent);
    }

    public void longestLengthSubstringOfContigousLetters(String str) {
        //https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/
        //based on TWO POINTER
        int n = str.length();
        if (n <= 1) {
            System.out.println("Length of subtring with contigous letter: " + n);
            return;
        }

        int start = 0;
        int end = 1;
        //a single letter char can be considered as contigous letter
        int maxLen = 1;

        while (end < n) {

            //if curr and prev chars are contiguous meaning a < b < c or l < m < n < o
            //if two chars are contiguous their diff is only 1
            if (str.charAt(end) - str.charAt(end - 1) == 1) {
                maxLen = Math.max(maxLen, (end - start + 1));
            } else {
                start = end;
            }

            end++;
        }
        //output
        System.out.println("Length of subtring with contigous letter: " + maxLen);
    }

    public void workersGettingAlertsMoreThanTriceInAnHour(
            String[] names, String[] times) {
        //https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/
        int n = names.length;
        List<String> alertees = new ArrayList<>();
        Map<String, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            String worker = names[i];
            String time = times[i];
            map.putIfAbsent(worker, new ArrayList<>());

            //convert time into minutes
            String[] split = time.split(":");
            int HH = Integer.parseInt(split[0]);
            int HHToMin = HH * 60; //1 hr = 60min ==> HH hr = HH * 60min
            int MM = Integer.parseInt(split[1]);
            int totalTimeInMin = HHToMin + MM;

            map.get(worker).add(totalTimeInMin);
        }

        for (String worker : map.keySet()) {
            List<Integer> workerTimes = map.get(worker);
            Collections.sort(workerTimes);

            for (int i = 0; i < workerTimes.size() - 2; i++) {
                //i is the index of curr time of card usage
                //i + 2 is the index of time of card usage at 3 position
                //3rd time and curr time has an overall time diff of
                //less than equals to 1 hr (== 60min), that means this worker
                //has used his card 3times within an hour, so put him in alertees
                if (workerTimes.get(i + 2) - workerTimes.get(i) <= 60) {
                    alertees.add(worker);
                    break;
                }
            }
        }
        //output
        Collections.sort(alertees);
        System.out.println("Workers got alerts for using key-cards 3 or more times in an hour: " + alertees);
    }

    public void pushDominoes(String dominoes) {
        //https://leetcode.com/problems/push-dominoes/
        //https://leetcode.com/problems/push-dominoes/solution/
        int n = dominoes.length();
        char[] arr = dominoes.toCharArray();
        int[] forces = new int[n];

        int force = 0;

        //calculate the rightward(R) force applied from left to right
        //the force will immediately becomes 0 as soon as its encounters
        //leftward(L) force. Acc to physics, force applied initailly will
        //tends to loose its effect as moving ahead until it regains
        //another rightward(R) force OR stopped by leftward(L) force making it 0
        for (int i = 0; i < n; i++) {
            //if seeing a rightward force our force will get regained by n
            if (arr[i] == 'R') {
                force = n;
            } else if (arr[i] == 'L') {
                //if seeing a leftward force but we are moving left to right
                //for calculating rightward force, this leftward force will make
                //it 0
                force = 0;
            } else {
                //if not gaining any rightward force and not stopped by
                //leftward force means that this domino will see the effect
                //of force applied and also loosed its effect in the movement
                //so that why Math.max(force - 1, 0), force can be -ve
                //that why max with 0
                force = Math.max(force - 1, 0);
            }
            forces[i] = force;
        }

        //calculate the leftward(L) force applied from right to left
        //the force will immediately becomes 0 as soon as its encounters
        //rightward(R) force. Acc to physics, force applied initailly will
        //tends to loose its effect as moving ahead until it regains
        //another leftward(L) force OR stopped by rightward(R) force making it 0
        for (int i = n - 1; i >= 0; i--) {
            //if seeing a leftward force,, our force will get regained by n
            if (arr[i] == 'L') {
                force = n;
            } else if (arr[i] == 'R') {
                //if seeing a rightward force but we are moving right to left
                //for calculating leftward force, this rightward force will make
                //it 0
                force = 0;
            } else {
                //if not gaining any leftward force and not stopped by
                //rightward force means that this domino will see the effect
                //of force applied and also loosed its effect in the movement
                //so that why Math.max(force - 1, 0), force can be -ve
                //that why max with 0
                force = Math.max(force - 1, 0);
            }

            //earlier we have seen the rightward force, that will be counter
            //balanced by leftward force that why, -= force
            forces[i] -= force;
        }

        StringBuilder sb = new StringBuilder();
        for (int currForce : forces) {
            sb.append(
                    currForce > 0
                            ? 'R'
                            : (currForce < 0 ? 'L' : '.'));
        }
        //output
        System.out.println("Domino effect after applying force: " + sb.toString());
    }

    private boolean longestUncommonSubseqTwo_IsSubseq(String a, String b) {
        int aLen = a.length();
        int bLen = b.length();
        while (aLen > 0 && bLen > 0) {
            int i = a.length() - aLen;
            int j = b.length() - bLen;
            if (a.charAt(i) == b.charAt(j)) {
                aLen--;
            }
            bLen--;
        }
        return aLen == 0;
    }

    public void longestUncommonSubseqTwo(String[] words) {
        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/
        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/discuss/1428729/C%2B%2B-or-JAVA-or-Python3-2-Approaches-oror-Easy-to-Understand
        int n = words.length;
        int maxLen = -1;
        for (int i = 0; i < n; i++) {
            boolean inValid = false;
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    continue;
                }
                if (longestUncommonSubseqTwo_IsSubseq(words[i], words[j])) {
                    inValid = true;
                    break;
                }
            }
            if (!inValid) {
                maxLen = Math.max(maxLen, words[i].length());
            }
        }
        //output
        System.out.println("Longest uncommon subseq: " + maxLen);
    }

    public void numberOfAtoms(String formula) {
        //https://leetcode.com/problems/number-of-atoms/
        Stack<Map<String, Integer>> stack = new Stack<>();
        //appending these brackets to process formula in between
        formula = "(" + formula + ")";
        int n = formula.length();
        StringBuilder result = new StringBuilder();

        int index = 0;

        while (index < n) {

            char ch = formula.charAt(index);

            //Any starting char which is small caps will be an invalid chem
            //only valid are all caps single letter M, K, S.....etc
            //OR first letter caps followed by small letter Ma, Kb, Sc.....etc
            //and in the third else-block we are processing the OR case directly
            if (Character.isAlphabetic(ch) && Character.isLowerCase(ch)) {
                index++;
                continue;
            }

            if (ch == '(') {
                stack.push(new HashMap<>());
            } else if (ch == ')' && stack.size() > 1) {
                //since we have to process two steps in this if-block
                //thats why stack.size() > 1 is req

                //each closing ')' will process the formula in two ways
                //1. (some_chem)some_num
                //the chem composition inside ( ) will be multiplied by some_num
                //2. (some_prev_chem(some_chem)some_num)
                //the step1 solved chem formula will then be merged with its prev
                //chem formula which is additive in natue
                //here we are solving
                //1. (some_chem)some_num
                StringBuilder num = new StringBuilder();
                index += 1;
                while (index < n && Character.isDigit(formula.charAt(index))) {
                    num.append(formula.charAt(index));
                    index++;
                }

                //the above loop will break at a char which is not a digit
                //and also we have index++ below for while() but we still need to
                //consider this curr char for next iteration so taking a step back
                index -= 1;

                int mul = num.length() == 0 ? 1 : Integer.parseInt(num.toString());

                Map<String, Integer> currChemComp = stack.peek();
                for (String chem : currChemComp.keySet()) {
                    currChemComp.put(chem, currChemComp.get(chem) * mul);
                }

                //here we are solving
                //2. (some_prev_chem(some_chem)some_num)
                //we need prev comp so need to pop the curr one from stack
                //though we have the currChemComp above we can use it
                stack.pop();

                Map<String, Integer> prevChemComp = stack.peek();
                for (String chem : currChemComp.keySet()) {
                    //if some chem is also there in prevChemComp, just add both their
                    //atoms else put the chem back to prevChemComp whatever we have
                    //in the currChemComp
                    if (prevChemComp.containsKey(chem)) {
                        prevChemComp.put(chem, prevChemComp.get(chem) + currChemComp.get(chem));
                    } else {
                        prevChemComp.put(chem, currChemComp.get(chem));
                    }
                }
            } else if (Character.isAlphabetic(ch)) {
                //this will fetch the chem formula that would either be
                //1. Single caps letter followed by nums (ex: M, M2, K, K234 etc)
                //2. Single caps letter followed by small letter of the same chem formula
                //followed by nums (ex: Ma, Ma2, Kb, Kb234 etc)
                StringBuilder chem = new StringBuilder(String.valueOf(ch));
                index += 1;
                while (index < n
                        && Character.isAlphabetic(formula.charAt(index))
                        && Character.isLowerCase(formula.charAt(index))) {
                    chem.append(formula.charAt(index));
                    index++;
                }

                //right after a chem formula, we are expecting some num or none.
                //loop and form num string as long as we can have digits
                StringBuilder num = new StringBuilder();
                while (index < n && Character.isDigit(formula.charAt(index))) {
                    num.append(formula.charAt(index));
                    index++;
                }

                //the above loop will break at a char which is not a digit
                //and also we have index++ below for while() but we still need to
                //consider this curr char for next iteration so taking a step back
                index -= 1;

                Map<String, Integer> currChemComp = stack.peek();
                currChemComp.put(chem.toString(),
                        currChemComp.getOrDefault(chem.toString(), 0)
                                + (num.length() == 0 ? 1 : Integer.parseInt(num.toString())));
            }
            index++;
        }
        //output
        Map<String, Integer> processedFormula = stack.peek();
        List<String> chems = new ArrayList<>(processedFormula.keySet());
        Collections.sort(chems);

        for (String chem : chems) {
            result.append(chem)
                    //if a specific chem has an atom == 1, we need not to
                    //print 1 for it just the name of chem only
                    .append(processedFormula.get(chem) == 1
                            ? ""
                            : processedFormula.get(chem));
        }
        System.out.println("Processed chemical formula: " + result.toString());
    }

    public boolean sentenceSimilarity(String[] sentence1, String[] sentence2, String[][] similarPairs) {
        //https://leetcode.com/problems/sentence-similarity/description/

        int m = sentence1.length;
        int n = sentence2.length;

        if (m != n) {
            return false;
        }

        Map<String, Set<String>> similars = new HashMap<>();

        for (String[] pair : similarPairs) {

            String first = pair[0];
            String second = pair[1];

            similars.putIfAbsent(first, new HashSet<>());
            similars.get(first).add(second);

            similars.putIfAbsent(second, new HashSet<>());
            similars.get(second).add(first);
        }

        for (int i = 0; i < n; i++) {

            String word1 = sentence1[i];
            String word2 = sentence2[i];

            //skip, if the i-th words form both the sentence are already same
            if (word1.equals(word2)) {
                continue;
            }

            //here, word1 and word2 are not same, we will find from similars map
            //whether word1 have similar pair for word2 OR word2 have similar
            //pair for word1
            //return false, as there is no similar word for word1 that matches
            //word2
            if (!(similars.containsKey(word1) && similars.get(word1).contains(word2))) {
                return false;
            }

            //return false, as there is no similar word for word2 that matches
            //word1
            if (!(similars.containsKey(word2) && similars.get(word2).contains(word1))) {
                return false;
            }

        }

        return true;
    }

    public void sentenceSimilarityThree(String sent1, String sent2) {
        //https://leetcode.com/problems/sentence-similarity-iii/

        boolean isSentencesSimilar = true;

        String[] splitSent1 = sent1.split(" ");
        String[] splitSent2 = sent2.split(" ");

        Deque<String> frontWords = new LinkedList<>(Arrays.asList(splitSent1));
        Deque<String> endWords = new LinkedList<>(Arrays.asList(splitSent2));

        while (!frontWords.isEmpty() && !endWords.isEmpty()) {
            //if first words of two sentences are same remove those first words
            if (frontWords.peekFirst().equals(endWords.peekFirst())) {
                frontWords.removeFirst();
                endWords.removeFirst();
            } else if (frontWords.peekLast().equals(endWords.peekLast())) {
                //if last words of two sentences are same remove those last words
                frontWords.removeLast();
                endWords.removeLast();
            } else {
                //if no words are same from front and back of the sentences
                //sentences can't be similar
                isSentencesSimilar = false;
                break;
            }
        }
        //output
        System.out.println("Sentence similarity: " + isSentencesSimilar);
    }

    public void sumOfPrefixScoresOfString(String[] words) {
        //https://leetcode.com/problems/sum-of-prefix-scores-of-strings/
        //https://practice.geeksforgeeks.org/problems/geek-and-strings3030/1
        //based on TRIE DATA STRUCTURE
        /*
        Trie data stucture here will be used as prefix tree and will store the count
        of prefixes occured in all the strings in given words[]
        for ex:
        words[] = ["abc","ab","bc","b"]
        prefixTree:
        ..............................*
        .............a={2, Map<Char, Node>}, b={2, Map<Char, Node>}
        .............b={2, Map<Char, Node>}, c={1, Map<Char, Node>}
        .............c={1, Map<Char, Node>}
        here a = 2 means prefix a occurs in 2 words i.e, [a]b, [a]bc
        here ab = 2 means prefix ab occurs in 2 words i.e, [ab], [ab]c
        here abc = 1 means prefix abc occurs in 1 words i.e, [abc]

        so for given word[i] its score will be no of prefixes of this string occured
        like word[i] =
        "abc" ==> prefix a occurs in 2 string
        "abc" ==> prefix ab occurs in 2 string
        "abc" ==> prefix abc occurs in 1 string
        score[i] = "abc" = 2 + 2 + 1 = 5

        like word[i] =
        "ab" ==> prefix a occurs in 2 string
        "ab" ==> prefix ab occurs in 2 string
        score[i] = "ab" = 2 + 2 = 4

        like word[i] =
        "bc" ==> prefix b occurs in 2 string
        "bc" ==> prefix bc occurs in 1 string
        score[i] = "bc" = 2 + 1 = 3

        like word[i] =
        "b" ==> prefix b occurs in 2 string
        score[i] = "b" = 2 = 2

         */
        class TrieNode {

            Map<Character, TrieNode> map;
            int prefixCount;

            public TrieNode() {
                map = new HashMap<>();
                prefixCount = 0;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {

                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.prefixCount++;
                    } else {
                        TrieNode node = new TrieNode();
                        node.prefixCount = 1;
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            int getCount(String str) {
                TrieNode currNode = ROOT;
                int count = 0;
                for (char ch : str.toCharArray()) {

                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        count += currNode.prefixCount;
                    }
                }
                return count;
            }

        }

        TrieNode ROOT = new TrieNode();

        TrieUtil trieUtil = new TrieUtil(ROOT);

        //actual logic
        int n = words.length;
        int[] scores = new int[n];

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        for (int i = 0; i < n; i++) {
            scores[i] = trieUtil.getCount(words[i]);
        }

        //output
        System.out.println("Sum of prefix score of strings: " + Arrays.toString(scores));
    }

    public void trieAddAndSearchWords() {
        //https://leetcode.com/problems/design-add-and-search-words-data-structure/
        //based on TRIE DATA STRUCTURE
        class TrieNode {

            Map<Character, TrieNode> map;
            boolean isEnd;

            public TrieNode() {
                map = new HashMap<>();
                isEnd = false;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
                currNode.isEnd = true;
            }

            boolean searchInTrieDFS(TrieNode root, int index, String str) {
                TrieNode currNode = root;
                for (int i = index; i < str.length(); i++) {
                    char ch = str.charAt(i);
                    if (ch == '.') {
                        //if we '.' then we need to try all the possible combination
                        //of char from the curr trie node and move forward to
                        //i + 1 char and next trie node
                        for (char fill : currNode.map.keySet()) {
                            if (searchInTrieDFS(currNode.map.get(fill), i + 1, str)) {
                                return true;
                            }
                        }
                        return false;
                    } else if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return false;
                    }
                }
                return currNode.isEnd;
            }

            boolean searchInTrie(String str) {
                return searchInTrieDFS(ROOT, 0, str);
            }

        }

        //input 1
        System.out.println("Input 1");
        List<String> commands = new ArrayList<>(Arrays
                .asList("addWord", "addWord", "addWord", "search", "search", "search", "search"));
        List<String> values = new ArrayList<>(Arrays
                .asList("bad", "dad", "mad", "pad", "bad", ".ad", "b.."));

        TrieNode ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (int i = 0; i < commands.size(); i++) {
            if (commands.get(i).equals("addWord")) {
                trieUtil.addToTrie(values.get(i));
            } else if (commands.get(i).equals("search")) {
                System.out.println(values.get(i) + " found: " + trieUtil.searchInTrie(values.get(i)));
            }
        }

        //input 2
        System.out.println("Input 2");
        commands = new ArrayList<>(Arrays
                .asList("addWord", "addWord", "search", "search", "search", "search", "search", "search"));
        values = new ArrayList<>(Arrays
                .asList("a", "a", ".", "a", "aa", "a", ".a", "a."));

        ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        trieUtil = new TrieUtil(ROOT);

        for (int i = 0; i < commands.size(); i++) {
            if (commands.get(i).equals("addWord")) {
                trieUtil.addToTrie(values.get(i));
            } else if (commands.get(i).equals("search")) {
                System.out.println(values.get(i) + " found: " + trieUtil.searchInTrie(values.get(i)));
            }
        }
    }

    public void checkIfSearchWordExistAsPrefixInAnyWordOfSentence(String sentence, String searchWord) {
        //https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
        //https://leetcode.com/problems/counting-words-with-a-given-prefix/
        //based on TRIE DATA STRUCTURE
        class TrieNode {

            Map<Character, TrieNode> map;
            int minIndex;

            public TrieNode() {
                map = new HashMap<>();
                minIndex = Integer.MAX_VALUE;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str, int index) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        //if two or more words of the sentence have the same prefix
                        //then we need to maintain the minIndex of word upto that
                        //prefix
                        currNode.minIndex = Math.min(currNode.minIndex, index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.minIndex = index;
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            int getIndex(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return -1;
                    }
                }
                return currNode.minIndex;
            }
        }

        TrieNode ROOT = new TrieNode();

        TrieUtil trieUtil = new TrieUtil(ROOT);

        String[] split = sentence.split(" ");
        int n = split.length;
        for (int i = 0; i < n; i++) {
            trieUtil.addToTrie(split[i], i + 1);
        }
        int wordIndex = trieUtil.getIndex(searchWord);
        //output
        System.out.println("Index of word where searchWord exists as prefix: " + wordIndex);
    }

    public String breakAPallindrome(String pallindrome) {
        //https://leetcode.com/problems/break-a-palindrome/
        int n = pallindrome.length();

        //string like "a" or "b" we can't replace it with any other char because
        //a single char will always remain pallindrome, so just return ""
        if (n == 1) {
            return "";
        }

        char[] chrArr = pallindrome.toCharArray();

        for (int i = 0; i < n; i++) {

            if (chrArr[i] == 'a') {
                continue;
            }

            //to make the pallindromic string break and also lexicographically
            //smaller, replace its first non 'a' char index to 'a'
            //here we find i-th char which is not 'a', now if we replace this i-th
            //non-'a' char with 'a' then new string 'check' should not be pallidromic
            //if it is not pallindromic then this exact replaced string 'check' is our
            //result
            char original = chrArr[i];
            chrArr[i] = 'a';

            String check = String.valueOf(chrArr);

            //new string 'check' should not be pallindromic, means we break the
            //pallindrome and it is also lexicographically smaller string
            if (!check.equals(new StringBuilder(check).reverse().toString())) {
                return check;
            }

            //if above if() didn't work, means curr replacement of 'a' char at curr
            //i-th index is still a pallindromic string so we will reset the i-th
            //char with its original value and try the next i-th index for replacement
            chrArr[i] = original;
        }

        //edge case if given string is "aaa" then
        //firstly all the chars are already 'a' char meaning we will never find
        //a non-'a' char in above loop
        //now here to break this pallindrome and still be lexicographically smaller
        //we will just add char 'b' to last index as 'b' is next smaller char
        //after 'a'
        chrArr[n - 1] = 'b';

        return String.valueOf(chrArr);
    }

    public void countNumberOfHomogenousSubstring(String str) {
        //https://leetcode.com/problems/count-number-of-homogenous-substrings/
        //https://leetcode.com/problems/count-number-of-homogenous-substrings/discuss/1064530/JavaC%2B%2BPython-Straight-Forward
        //https://leetcode.com/problems/consecutive-characters/
        int n = str.length();
        int prevCharAscii = 0;
        int result = 0;
        int count = 0;
        int mod = 1000000007;
        for (int i = 0; i < n; i++) {
            count = str.charAt(i) == prevCharAscii ? count + 1 : 1;
            prevCharAscii = str.charAt(i);
            result = (result + count) % mod;
        }
        //output
        System.out.println("Count number of homogenous substrings: " + result);
    }

    public void numberOfSubstringWithOnlyOnes(String str) {
        //https://leetcode.com/problems/number-of-substrings-with-only-1s/
        //based on countNumberOfHomogenousSubstring()
        int n = str.length();
        int index = 0;
        int result = 0;
        int mod = 1000000007;
        int count = 0;
        for (int i = 0; i < n; i++) {
            count = str.charAt(i) == '1' ? count + 1 : 0;
            result = (result + count) % mod;
        }
        //output
        System.out.println("Number of substrings with only 1s: " + result);
    }

    public void increasingDecreasingString(String str) {
        //https://leetcode.com/problems/increasing-decreasing-string/
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : str.toCharArray()) {
            freq.put(ch, freq.getOrDefault(ch, 0) + 1);
        }

        StringBuilder sb = new StringBuilder();
        while (!freq.isEmpty()) {

            //with this loop of ('a' to 'z') which is itself a incrementing char loop
            //we will pick a char 'ch' and put it in the string 'sb' only if it is
            //present in our actual string 'str', with this way we made first incrementing
            //set of string in 'sb'. Also we picked one valid 'ch' from str freq map
            //we also need to reduce its freq, if it is reduced to 0 then remove
            //that 'ch' from freq map as well
            for (char ch = 'a'; ch <= 'z'; ch++) {
                if (freq.containsKey(ch)) {
                    sb.append(ch);
                    freq.put(ch, freq.getOrDefault(ch, 0) - 1);
                    if (freq.get(ch) <= 0) {
                        freq.remove(ch);
                    }
                }
            }

            //with this loop of ('z' to 'a') which is itself a decreamenting char loop
            //we will pick a char 'ch' and put it in the string 'sb' only if it is
            //present in our actual string 'str', with this way we made first decreamenting
            //set of string in 'sb'. Also we picked one valid 'ch' from str freq map
            //we also need to reduce its freq, if it is reduced to 0 then remove
            //that 'ch' from freq map as well
            for (char ch = 'z'; ch >= 'a'; ch--) {
                if (freq.containsKey(ch)) {
                    sb.append(ch);
                    freq.put(ch, freq.getOrDefault(ch, 0) - 1);
                    if (freq.get(ch) <= 0) {
                        freq.remove(ch);
                    }
                }
            }
        }
        //output
        System.out.println("Arrange the string: " + str + " in increasing decreasing order: " + sb.toString());
    }

    public void optimalStringPartitions(String str) {
        //https://leetcode.com/problems/optimal-partition-of-string/
        /*
        approach is to greedily take the unique chars in curr partition,
        as soon as we hit a char again that is visited[char] we have previously
        seen that means we know its the breaking point because all the
        char upto this point were unique and now we are seeing duplicate char
        so increase the partitions count and reset the visited[]
        ex: "abacaba", visited[26] = [false,false,false....]
        chr: a visited[a] = true
        chr: b visited[b] = true
        chr: a if(visited[a] == true) means a break point do a partitions here and reset
        visited[] and continue again

         */
        boolean[] visited = new boolean[26];
        int partitions = 0;

        for (char ch : str.toCharArray()) {

            if (visited[ch - 'a']) {
                partitions++;
                Arrays.fill(visited, false);
            }
            visited[ch - 'a'] = true;
        }
        //output
        System.out.println("optimal string partitions: " + (partitions + 1));
    }

    public void largestMergeOfTwoStrings(String str1, String str2) {
        //https://leetcode.com/problems/largest-merge-of-two-strings/
        StringBuilder word1 = new StringBuilder(str1);
        StringBuilder word2 = new StringBuilder(str2);
        StringBuilder merge = new StringBuilder();

        while (word1.length() != 0 && word2.length() != 0) {

            if (word1.charAt(0) > word2.charAt(0)) {

                merge.append(word1.charAt(0));
                word1.deleteCharAt(0);
            } else if (word1.charAt(0) < word2.charAt(0)) {

                merge.append(word2.charAt(0));
                word2.deleteCharAt(0);
            } else {

                int diff = word1.compareTo(word2);

                if (diff > 0) {
                    merge.append(word1.charAt(0));
                    word1.deleteCharAt(0);
                } else {
                    merge.append(word2.charAt(0));
                    word2.deleteCharAt(0);
                }
            }
        }

        if (word1.length() != 0) {
            merge.append(word1.toString());
        }

        if (word2.length() != 0) {
            merge.append(word2.toString());
        }

        //output
        System.out.println("Lexicographically largest merge of two string: " + merge);
    }

    public void repeatedDNASequences(String dna) {
        //https://leetcode.com/problems/repeated-dna-sequences/
        List<String> repeatedSeq = new ArrayList<>();
        int n = dna.length();
        Map<String, Integer> seqFreq = new HashMap<>();
        //required seq should be of length 10
        for (int i = 0; i <= n - 10; i++) {
            String seq = dna.substring(i, i + 10);
            seqFreq.put(seq, seqFreq.getOrDefault(seq, 0) + 1);
        }

        //any dna seq that is occuring more than once
        for (String seq : seqFreq.keySet()) {
            if (seqFreq.get(seq) > 1) {
                repeatedSeq.add(seq);
            }
        }
        //output
        System.out.println("Repeated DNA sequneces: " + repeatedSeq);
    }

    public void numberOfLaserBeamsInBank(String[] bank) {
        //https://leetcode.com/problems/number-of-laser-beams-in-a-bank/

        int laserBeams = 0;

        //initially there were no prev row hence laser devices in that row is 0
        int prevRowLaserDevices = 0;

        for (String row : bank) {

            //count laser devices in curr row
            int currRowLaserDevices = 0;

            for (char device : row.toCharArray()) {
                //if curr 'row' has a laser device(==> 1), increase the laser
                //device count seen in this row
                if (device == '1') {
                    currRowLaserDevices++;
                }
            }

            //number of laser beams formed between prev row laser devices and
            //curr row laser devices is the multiplication of the devices
            laserBeams += (prevRowLaserDevices * currRowLaserDevices);

            //update the prev row laser devices count with curr row laser devices
            //count only if curr row has some laser device (==> != 0)
            if (currRowLaserDevices != 0) {
                prevRowLaserDevices = currRowLaserDevices;
            }

        }
        //output
        System.out.println("Number of laser beams: " + laserBeams);
    }

    public boolean isPossibleToConstructKPallindromeString(String str, int k) {
        //https://leetcode.com/problems/construct-k-palindrome-strings/
        /*
        hints:
        1. If the s.length < k we cannot construct k strings from s and answer
        is false.
        2. If the number of characters that have odd counts is > k then the
        minimum number of palindrome strings we can construct is > k and answer
        is false.
        3. Otherwise you can construct exactly k palindrome strings and answer
        is true (why ?).

        ex: str = "leetcode", k = 3 result is false
        freq = {e = 3, l = 1, t = 1, c = 1, o = 1, d = 1}
        charWithOddFreq = [l, t, c, o, d, e] = 6 > k ==> 6 > 3

        false how? try to form k pallindrome strings using all its char
        1. "ele" | char-left: [e, t, c, o, d]
        now the char-left can not form any combined pallindrome string but
        each char separately like,
        2. "e"
        3. "t"
        4. "c"
        5. "o"
        6. "d"

        6 pallindrome strings > k so false

        ex: str = "aafaaeaagaahaak", k = 3, result is false
        freq = {a = 10, f = 1, e = 1, g = 1, h = 1, k = 1}
        charWithOddFreq = [f, e, g, h, k] = 6 > k ==> 5 > 3

        false how? try to form k pallindrome strings using all its char
        1. "aafaa" | char-left: [e, a, a, g, a, a, h, a, a, k]
        2. "aagaa" | char-left: [e, h, a, a, k]
        3. "aka" | char-left: [e, h]
        now the char-left can not form any combined pallindrome string but
        each char separately like,
        4. "e"
        5. "h"

        we form k == 3 pallindrome strings but we couldn't use all the chars of
        given string

        in simple terms, total chars having the even freqs can be arranged into
        k strings but total chars with odd freqs if they are not less or equal k
        (==> <= k), then all such chars will take more than k strings separately

         */
        int n = str.length();
        if (n < k) {
            return false;
        }

        int[] freqs = new int[26];
        for (char chr : str.toCharArray()) {
            freqs[chr - 'a']++;
        }

        int countCharsWithOddFreq = 0;

        for (char chr = 'a'; chr <= 'z'; chr++) {

            if (freqs[chr - 'a'] % 2 == 1) {
                countCharsWithOddFreq++;
            }
        }
        return countCharsWithOddFreq <= k;
    }

    public void orderlyQueue(String str, int k) {
        //https://leetcode.com/problems/orderly-queue/
        //https://leetcode.com/problems/orderly-queue/solution/
        //explanation: https://www.youtube.com/watch?j=qr-_tEll_e4&t=3s
        int n = str.length();
        char[] charArr = str.toCharArray();
        String result = "";
        if (k > 1) {
            Arrays.sort(charArr);
            result = String.valueOf(charArr);
        } else {
            //if k == 1
            result = str;
            for (int i = 0; i < n; i++) {
                //rotate the string by appending first[0, i - 1] prefix string
                //to end of remaining[i, n] string
                String rotateStr = str.substring(i) + str.substring(0, i);
                if (rotateStr.compareTo(result) < 0) {
                    result = rotateStr;
                }
            }
        }
        //output
        System.out.println("Orderly queue and lexicographically smaller string: " + result);
    }

    public void makeTheStringGreat(String str) {
        //https://leetcode.com/problems/make-the-string-great/
        //here also using the string builder as stack, this saves the time for
        //generating the string back from the chars from the stack
        StringBuilder sb = new StringBuilder();
        for (char ch : str.toCharArray()) {
            //case like: eE where peek == e, chr == E, then remove both
            if (!sb.isEmpty()
                    && (Character.isUpperCase(ch)
                    && Character.toLowerCase(ch) == sb.charAt(sb.length() - 1))) {
                sb.deleteCharAt(sb.length() - 1);
            } else if (!sb.isEmpty()
                    && (Character.isLowerCase(ch)
                    && Character.toUpperCase(ch) == sb.charAt(sb.length() - 1))) {
                //case like: Ee where peek == E, chr == e, then remove both
                sb.deleteCharAt(sb.length() - 1);
            } else {
                sb.append(ch);
            }
        }

        //output
        System.out.println("Great string: " + sb.toString());
    }

    public void sumOfBeautyOfAllSubstring(String str) {
        //https://leetcode.com/problems/sum-of-beauty-of-all-substrings/
        //based on BRUTE FORCE and use of hashmap is giving TLE, I don't know!!! :(
        int n = str.length();
        int sum = 0;

        //generate possible substrings of string 'str' from below nested loops
        for (int start = 0; start < n; start++) {

            int[] chrFreq = new int[26];

            for (int end = start; end < n; end++) {

                char chr = str.charAt(end);
                chrFreq[chr - 'a']++;

                //calculate the min & max freq of chars for the substring[istart, end]
                int maxFreq = 0;
                int minFreq = Integer.MAX_VALUE;

                for (int freq : chrFreq) {
                    //skip, if freq == 0 means that char was never there in the
                    //substring but if we choose this freq then this 0 will be
                    //minFreq which is wrong if we consider it, thats why choose
                    //those chars that exist in curr substring[start, end] means
                    //char whose freq != 0
                    if (freq == 0) {
                        continue;
                    }

                    minFreq = Math.min(minFreq, freq);
                    maxFreq = Math.max(maxFreq, freq);
                }
                //calculate beauty of substring forming between (i to j) th index
                sum += (maxFreq - minFreq);
            }
        }
        //output
        System.out.println("Sum of beauty of all substrings: " + sum);
    }

    public void shortEncodingOfWords(String[] words) {
        //https://leetcode.com/problems/short-encoding-of-words/
        /*
        words[] = [time, me, bell]
        trie ROOT..........[e],[l]
        ................../.......\
        ................[m].......[l]
        ................/...........\
        ..............[i]...........[e]
        ............../...............\
        ............[t]...............[b]

        here time & me are grouped as their suffix matches: [ti[me]] encoded
        [ti[me]]'#'
        [bell]'#'

        [ti[me]]'#'[bell]'#' == time#bell# == 10 length of encoding

         */
        class TrieNode {

            Map<Character, TrieNode> map;

            public TrieNode() {
                map = new HashMap<>();
            }
        }

        class TrieUtil {

            TrieNode ROOT;
            int addHASHChar = 1;
            int wordEncodingLength = 0;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                //running loop from end of the word, that way we will add word
                //in suffix form, all those words having same suffix will be
                //grouped in single string
                for (int i = word.length() - 1; i >= 0; i--) {
                    char ch = word.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            //level/ depth traversal of N-ary tree
            //with below method, we are doing the level traversal.
            //means we go till end of word in trie and add level( == length of word)
            //and add '#' char ( == length of 1)
            void countEncodingLengthHelper(TrieNode root, int level) {

                if (root.map.isEmpty()) {
                    wordEncodingLength += (level + addHASHChar);
                    return;
                }

                for (char ch : root.map.keySet()) {
                    countEncodingLengthHelper(root.map.get(ch), level + 1);
                }
            }

            void countEncodingLength() {
                countEncodingLengthHelper(ROOT, 0);
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        trieUtil.countEncodingLength();
        //output
        System.out.println("Short encoding of word: " + trieUtil.wordEncodingLength);
    }

    public void makingFileNamesUnique(String[] names) {
        //https://leetcode.com/problems/making-file-names-unique/
        int n = names.length;

        List<String> uniqueNames = new ArrayList<>();
        Map<String, Integer> files = new HashMap<>();

        for (int i = 0; i < n; i++) {

            String name = names[i];

            if (!files.containsKey(name)) {

                uniqueNames.add(name);
                files.put(name, files.getOrDefault(name, 0) + 1);
                continue;
            }

            //get the count of the name that is already contained in map
            int fileCount = files.get(name);

            Set<String> uniqueFileNames = files.keySet();
            //a default new name for the curr name that is already there
            //now we need to check this new name is already existing in map
            //or not, if this name exist then we have to try out another
            //name combination
            String newFileName = name + "(" + fileCount + ")";
            while (uniqueFileNames.contains(newFileName)) {
                fileCount++;
                newFileName = name + "(" + fileCount + ")";
            }

            //above loop will break when we have a newFileName unique in the map
            //and also this newFileName is a version of curr name
            uniqueNames.add(newFileName);
            //since we have used the count of 'name' that already existed
            //so for next time we see same 'name' it should have a updated count
            files.put(name, files.getOrDefault(name, 0) + 1);
            //our newFileName that is just formed is unique in uniqueFileNames
            //that should also be added in the map
            files.put(newFileName, files.getOrDefault(newFileName, 0) + 1);
        }
        //output
        System.out.println("Unique file names: " + uniqueNames);
    }

    public void maxOccurenceSubstringFollowingCondition(
            String str, int maxUniqueLetters, int minSize, int maxSize) {
        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/
        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/discuss/2841277/Python-Hash-Solution
        //based on SLIDING WINDOW
        /*
        return the maximum number of ocurrences of any substring under the following rules:
        1. The number of unique characters in the substring must be less than or equal to maxUniqueLetters.
        2. The substring size must be between minSize and maxSize inclusive.
         */
        int n = str.length();
        int start = 0;
        int end = 0;
        Map<String, Integer> substrToUniqueChars = new HashMap<>();
        while (end < n) {

            //rule 2.
            int window = (end - start + 1);
            while (minSize <= window && window <= maxSize) {

                //a substring in the range of minSize & maxSize
                String substr = str.substring(start, start + window);

                //get the unique chars from this substring in the form of set
                Set<Character> uniqueCharInSubstr = substr.chars().mapToObj(c -> (char) c)
                        .collect(Collectors.toSet());

                //rule 1.
                //if the unique char is set is less than equal to maxUniqueLetter
                //we can consider this substring
                if (uniqueCharInSubstr.size() <= maxUniqueLetters) {
                    substrToUniqueChars.put(substr, substrToUniqueChars.getOrDefault(substr, 0) + 1);
                }
                start++;
                //update the windowSize
                window = end - start + 1;
            }
            end++;
        }
        int maxOccuerenceSubstr = substrToUniqueChars.isEmpty()
                ? 0
                : //getting max occr of substring from all those subtrings that
                //followed the condition
                substrToUniqueChars.values()
                        .stream()
                        .sorted(Collections.reverseOrder())
                        .findFirst().get();
        //output
        System.out.println("Max occuerence of subtring following cond: " + maxOccuerenceSubstr);
    }

    public void prefixAndSuffixSearch(String[] words, String[][] prefixAndSuffix) {
        //https://leetcode.com/problems/prefix-and-suffix-search/
        class TrieNode {

            Map<Character, TrieNode> map;
            Set<Integer> indexes;

            public TrieNode() {
                map = new HashMap<>();
                indexes = new HashSet<>();
            }
        }

        class TrieUtil {

            TrieNode ROOTPref;
            TrieNode ROOTSuff;
            Map<String, Integer> cache;

            public TrieUtil(TrieNode ROOTPref, TrieNode ROOTSuff) {
                this.ROOTPref = ROOTPref;
                this.ROOTSuff = ROOTSuff;
                cache = new HashMap<>();
            }

            void addToTrie(String word, int index) {

                TrieNode currNode = ROOTPref;
                for (char ch : word.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.indexes.add(index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.indexes.add(index);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }

                currNode = ROOTSuff;
                //running loop from end of the word, that way we will add word
                //in suffix form
                for (int i = word.length() - 1; i >= 0; i--) {
                    char ch = word.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.indexes.add(index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.indexes.add(index);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            Set<Integer> searchPref(String str) {
                TrieNode currNode = ROOTPref;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return Collections.emptySet();
                    }
                }
                return currNode.indexes;
            }

            Set<Integer> searchSuff(String str) {
                TrieNode currNode = ROOTSuff;
                for (int i = str.length() - 1; i >= 0; i--) {
                    char ch = str.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return Collections.emptySet();
                    }
                }
                return currNode.indexes;
            }

            int prefSuffixMatchIndex(String pref, String suff) {

                String key = pref + "," + suff;
                if (cache.containsKey(key)) {
                    return cache.get(key);
                }

                Set<Integer> prefMatchIndex = searchPref(pref);
                Set<Integer> suffMatchIndex = searchSuff(suff);

                if (prefMatchIndex.isEmpty() || suffMatchIndex.isEmpty()) {
                    cache.put(key, -1);
                    return -1;
                }

                //common indexes are those index of words where the searched
                //pref and suff matches
                //(ex: "me", "moonchime", prefAndSuff["m", "e"])
                //here m and e matches with both "[m][e]" & "[m]oonchim[e]"
                //but if there is a tie with multiple words, choose the max index
                List<Integer> common = new ArrayList<>();
                for (int index : prefMatchIndex) {
                    if (suffMatchIndex.contains(index)) {
                        common.add(index);
                    }
                }

                if (common.isEmpty()) {
                    cache.put(key, -1);
                    return -1;
                }

                //for choosing the max index, if there are multiple matches of
                //the search
                Collections.sort(common);
                cache.put(key, common.get(common.size() - 1));
                return common.get(common.size() - 1);
            }

        }

        TrieNode ROOTPref = new TrieNode();
        TrieNode ROOTSuff = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOTPref, ROOTSuff);

        for (int i = 0; i < words.length; i++) {
            trieUtil.addToTrie(words[i], i);
        }

        System.out.println("Prefix And Suffix aearch: ");
        for (String[] prefSuff : prefixAndSuffix) {
            String pref = prefSuff[0];
            String suff = prefSuff[1];
            System.out.println(pref + " and " + suff + " search: " + trieUtil.prefSuffixMatchIndex(pref, suff));
        }
    }

    public void magicDictionary(String[] words, String[] searches) {
        //https://leetcode.com/problems/implement-magic-dictionary/

        Map<String, Boolean> searchPossible = new HashMap<>();

        Map<Integer, List<String>> wordsByLengths = new HashMap<>();

        //create a map where lengths as key and all the words having same lengths
        //will be grouped together
        for (String word : words) {
            wordsByLengths.putIfAbsent(word.length(), new ArrayList<>());
            wordsByLengths.get(word.length()).add(word);
        }

        for (String word : searches) {

            int len = word.length();
            //if curr search word's length doesn't exist in the map, then this
            //word can't be searched
            if (!wordsByLengths.containsKey(len)) {
                searchPossible.put(word, false);
                continue;
            }

            //if the curr search word's length exists in the map, we will move
            //through all the words of this len and check which candidate word
            //is valid (valid : search word can be changed with one char and it
            //matches with candidate word)
            for (String candidate : wordsByLengths.get(len)) {

                int changeOneChar = 0;

                for (int i = 0; i < len; i++) {
                    //count the char that doesn't match in these two words
                    if (word.charAt(i) != candidate.charAt(i)) {
                        changeOneChar++;
                    }
                    //if changeOneChar unmatched chars is greater than 1 that means
                    //this search word can't be searched because we can change
                    //only 1 char to match with candidate word
                    if (changeOneChar > 1) {
                        searchPossible.put(word, false);
                        break;
                    }
                }
                //if there is one char change required this word can be searched
                if (changeOneChar == 1) {
                    searchPossible.put(word, true);
                    break;
                }
                //this point is reached here when changeOneChar == 0
                //like if search word and candidate word are same, "hello" == "hello"
                searchPossible.put(word, false);
            }
        }
        //output
        System.out.println("Magic dictionary : " + searchPossible);
    }

    private boolean peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
            Set<String> child, Set<String> parent) {
        if (child.size() > parent.size()) {
            return false;
        }
        return parent.containsAll(child);
    }

    public void peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(List<List<String>> favouriteCompanies) {
        //https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
        int n = favouriteCompanies.size();
        Map<Integer, Set<String>> companiesMap = new HashMap<>();
        Set<Integer> persons = new HashSet<>();
        for (int i = 0; i < n; i++) {
            companiesMap.put(i, new HashSet<>());
            companiesMap.get(i).addAll(favouriteCompanies.get(i));
            persons.add(i);
        }

        for (int person1 = 1; person1 < n; person1++) {
            if (!persons.contains(person1)) {
                continue;
            }
            for (int person2 = 0; person2 < person1; person2++) {
                if (!persons.contains(person2)) {
                    continue;
                }
                if (peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
                        companiesMap.get(person1), companiesMap.get(person2))) {
                    persons.remove(person1);
                }

                if (peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
                        companiesMap.get(person2), companiesMap.get(person1))) {
                    persons.remove(person2);
                }
            }
        }
        System.out.println("Persons whose favourite companies not subset of another list: "
                + persons.stream().sorted().collect(Collectors.toList()));
    }

    public void printWordsVertically(String text) {
        //https://leetcode.com/problems/print-words-vertically/description/
        /*
        text = "TO BE OR NOT TO BE"
        split[] = [TO, BE, OR, NOT, TO, BE]
        now each word will occupy a col, here col == 6
        "TBONTB"
        "OEROOE"
        "   T"
        now row is actually the word with max length(), here NOT with length == 3

        verticalWordsGrid[6][3] = [
        ['T', 'B', 'O', 'N', 'T', 'B'],
        ['O', 'E', 'R', 'O', 'O', 'E'],
        [' ', ' ', ' ', 'T', ' ', ' ']]

        for output we need to trim spaces from end if any, that why
        last row = [' ', ' ', ' ', 'T', ' ', ' ']
        is trimmed to [' ', ' ', ' ', 'T']

        AND each row be converted to string
        "TBONTB"
        "OEROOE"
        "   T"
         */
        List<String> verticalWords = new ArrayList<>();
        String[] split = text.split(" ");
        //ROW = max length of a word in text that can be expanded vertically
        //will become the number of rows
        int ROW = 0;
        for (String word : split) {
            ROW = Math.max(ROW, word.length());
        }
        //col = number of words in split[] because each word will occupy
        //vertically one col
        int COL = split.length;

        char[][] verticalWordsGrid = new char[ROW][COL];

        int currWordCol = 0;
        for (String word : split) {
            //each char from curr word will be put in each row but in specific wordInCol
            //since the below for loop is running for max length of words( == ROW)
            //this curr word may be less than the ROW so add spaces for such rows
            for (int row = 0; row < ROW; row++) {
                verticalWordsGrid[row][currWordCol] = row >= word.length()
                        ? ' ' : word.charAt(row);
            }
            //now the next word will be put in the next col
            currWordCol++;
        }

        for (char[] charsInRow : verticalWordsGrid) {
            //works as left trim, trims spaces from end
            int skipSpacesFromEnd = COL - 1;
            while (skipSpacesFromEnd >= 0 && charsInRow[skipSpacesFromEnd] == ' ') {
                skipSpacesFromEnd--;
            }
            verticalWords.add(String.valueOf(charsInRow, 0, skipSpacesFromEnd + 1));
        }
        //output
        System.out.println("vertical words: " + verticalWords);
    }

    public void bullsAndCows(String secret, String guess) {
        //https://leetcode.com/problems/bulls-and-cows/description/
        /*
        1. The number of "bulls", which are digits in the guess that are in the
        correct position.
        2. The number of "cows", which are digits in the guess that are in your
        secret number but are located in the wrong position. Specifically, the
        non-bull digits in the guess that could be rearranged such that they
        become bulls.
        Constraints given:
        1. secret.length == guess.length
        2. secret and guess consist of digits only.
         */
        int m = secret.length();
        int n = guess.length();

        char[] secretArr = secret.toCharArray();
        char[] guessArr = guess.toCharArray();

        Map<Character, Integer> secretMap = new HashMap<>();
        Map<Character, Integer> guessMap = new HashMap<>();

        int cows = 0;
        int bulls = 0;

        for (int i = 0; i < m; i++) {
            //bulls are those i-th guess values that are exactly same as
            //secret values and also at same i-th location
            if (secretArr[i] == guessArr[i]) {
                bulls++;
                //after processing the bull chars mark them with '.'
                secretArr[i] = guessArr[i] = '.';
            }

            //count the freq of all the other char in secret that are not bull chars
            if (secretArr[i] != '.') {
                secretMap.put(secretArr[i], secretMap.getOrDefault(secretArr[i], 0) + 1);
            }

            //count the freq of all the other char in guess that are not bull chars
            if (guessArr[i] != '.') {
                guessMap.put(guessArr[i], guessMap.getOrDefault(guessArr[i], 0) + 1);
            }
        }

        //here check which other chars of our guess matches with secret but are not
        //at the exact locations as that of secret chars, take the min of them
        //because the min of both are those chars that we can rearrange to match
        //with secret string
        for (char guessChar : guessMap.keySet()) {
            if (secretMap.containsKey(guessChar)) {
                cows += (Math.min(secretMap.get(guessChar), guessMap.get(guessChar)));
            }
        }
        //output
        String score = bulls + "A" + cows + "B";
        System.out.println("Bulls and cows score: " + score);
    }

    private boolean expressiveWords_IsWordStrechable(String strechy, String word) {
        int m = strechy.length();
        int n = word.length();

        int strechyIndex = 0;
        int wordIndex = 0;

        while (strechyIndex < m && wordIndex < n) {
            if (strechy.charAt(strechyIndex) != word.charAt(wordIndex)) {
                return false;
            }

            int originalChar = word.charAt(wordIndex);

            int sameCharCountStrechy = 0;
            while (strechyIndex < m && strechy.charAt(strechyIndex) == originalChar) {
                sameCharCountStrechy++;
                strechyIndex++;
            }

            int sameCharCountWord = 0;
            while (wordIndex < n && word.charAt(wordIndex) == originalChar) {
                sameCharCountWord++;
                wordIndex++;
            }

            //in the original word, the min char of 'originalChar' is req as
            //sameCharCountWord but in given strechy string we get the less
            //count sameCharCountStrechy for same 'originalChar' then this
            //strechy string can't be fromed from curr word as it lacks atleast
            //sameCharCountWord amount of char in strechy string
            if (sameCharCountStrechy < sameCharCountWord) {
                return false;
            }

            //if the strechy string have the sameCharCountStrechy for the curr
            //'originalChar' which is more than what is req from curr word i.e,
            //sameCharCountWord then it is fine but this sameCharCountStrechy
            //should be equal or more than 3(as per question), in case it is less
            //than that return false;
            if (sameCharCountStrechy > sameCharCountWord && sameCharCountStrechy < 3) {
                return false;
            }
        }
        //checking if both the strings are processed till their last chars,
        //if any of the string is ended before the other string, the curr word
        //can't be streched to given strechy string
        return strechyIndex == m && wordIndex == n;
    }

    public void expressiveWords(String strechy, String[] words) {
        //https://leetcode.com/problems/expressive-words/description/
        int expressiveWords = 0;
        for (String word : words) {
            if (expressiveWords_IsWordStrechable(strechy, word)) {
                expressiveWords++;
            }
        }
        //output
        System.out.println("Words that can be expressed as strechy: " + expressiveWords);
    }

    public void customSortString(String order, String str) {
        //https://leetcode.com/problems/custom-sort-string/description/
        //somewhat similar to sortLinkedListInRelativeOrderOfArr()
        char[] strArr = str.toCharArray();
        //create the freq map for given string str
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : strArr) {
            freq.put(ch, freq.getOrDefault(ch, 0) + 1);
        }

        //first put those chars from string str that relatively in order with
        //string order in the same freq as they are in string str
        int index = 0;
        for (char chOrder : order.toCharArray()) {
            //if the certain chr from string order is not present in string str
            //we can pick the default freq of that char as 0, in that case while()
            //loop will anyhow not run
            int chOrderFreq = freq.getOrDefault(chOrder, 0);
            freq.remove(chOrder);

            while (chOrderFreq > 0) {
                strArr[index++] = chOrder;
                chOrderFreq--;
            }
        }
        //after putting all the chars that were in string order, put all those
        //chars that are left in string str from freq map
        for (char ch : freq.keySet()) {
            int chFreq = freq.get(ch);
            while (chFreq > 0) {
                strArr[index++] = ch;
                chFreq--;
            }
        }
        //output
        System.out.println("Custom sort string relative to given order: " + String.valueOf(strArr));
    }

    public boolean buddyStrings(String str, String goal) {
        //https://leetcode.com/problems/buddy-strings/description/
        int m = str.length();
        int n = goal.length();
        if (m != n) {
            return false;
        }

        if (str.equals(goal)) {
            int[] freq = new int[26];
            for (char ch : str.toCharArray()) {
                freq[ch - 'a']++;
            }

            //case for s = "aa" & goal = "aa"
            for (int count : freq) {
                if (count > 1) {
                    return true;
                }
            }

            //case for s = "ab" & goal = "ab"
            return false;
        }

        int firstSwap = -1;
        int secondSwap = -1;
        for (int i = 0; i < m; i++) {
            if (goal.charAt(i) != str.charAt(i)) {
                if (firstSwap == -1) {
                    firstSwap = i;
                } else if (secondSwap == -1) {
                    secondSwap = i;
                } else {
                    return false;
                }
            }
        }

        return secondSwap != -1
                && str.charAt(firstSwap) == goal.charAt(secondSwap)
                && str.charAt(secondSwap) == goal.charAt(firstSwap);
    }

    public void maxNumberOfBalloonsFromText(String text) {
        //https://leetcode.com/problems/maximum-number-of-balloons/description/
        //freq of chars in word balloon
        int b = 1, a = 1, l = 2, o = 2, n = 1;

        int[] freq = new int[26];
        for (char ch : text.toCharArray()) {
            freq[ch - 'a']++;
        }

        int minBalloonsInText = Integer.MAX_VALUE;
        //find the min picks of char in 'balloon', each time the char picks get minimized
        //that much of balloon word can be formed out of chars present in text
        minBalloonsInText = Math.min(minBalloonsInText, freq['b' - 'a'] / b);
        minBalloonsInText = Math.min(minBalloonsInText, freq['a' - 'a'] / a);
        minBalloonsInText = Math.min(minBalloonsInText, freq['l' - 'a'] / l);
        minBalloonsInText = Math.min(minBalloonsInText, freq['o' - 'a'] / o);
        minBalloonsInText = Math.min(minBalloonsInText, freq['n' - 'a'] / n);
        //output
        System.out.println("Min balloon word formed from text: " + minBalloonsInText);
    }

    public void findLongestString(String[] words) {
        //https://practice.geeksforgeeks.org/problems/8d157f11af5416087251513cfc38ffc4d23be308/1
        //based on TRIE
        class TrieNode {

            Map<Character, TrieNode> map;
            boolean isEnd;

            public TrieNode() {
                map = new HashMap<>();
                isEnd = false;
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {
                        currRoot = currRoot.map.get(ch);
                    } else {
                        TrieNode nextRoot = new TrieNode();
                        currRoot.map.put(ch, nextRoot);
                        currRoot = nextRoot;
                    }
                }
                //marks the end of a word
                currRoot.isEnd = true;
            }

            boolean isValidLongestWord(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {
                        currRoot = currRoot.map.get(ch);
                    }
                    //else part is not required, because we added all the words
                    //of words[] arrays, and TRIE only have all these words only
                    //so there will be no case where a word from words[] doesn't
                    //exist in TRIE, we only need to check that the curr 'word'
                    //have all of its prefixes exiting as individual words in this
                    //words[]/TRIE

                    //if curr prefix string is not a word in itself in the
                    //given words[] then we must return false because each
                    //prefix part of the curr 'word' should be a word existing
                    //in the words[]
                    if (!currRoot.isEnd) {
                        return false;
                    }
                }
                //if the complete word is actaully a word from the given array
                return currRoot.isEnd;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        //sort the words[] by longest length first if two words have same length
        //then sort them in their lexicographical order
        Arrays.sort(words, (a, b) -> a.length() == b.length()
                ? a.compareTo(b)
                : Integer.compare(b.length(), a.length()));

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        String longestWord = "";
        for (String word : words) {
            if (trieUtil.isValidLongestWord(word)) {
                longestWord = word;
                break;
            }
        }
        //output
        System.out.println("Longest word : " + longestWord);
    }

    public void applyDiscountToPrices(String sentence, int discount) {
        //https://leetcode.com/problems/apply-discount-to-prices/description/
        sentence = sentence.trim();
        String[] words = sentence.split(" ");
        StringBuilder reform = new StringBuilder();

        for (String word : words) {
            //if a word is not empty string(== "") or it start with '$' sign
            //then get the amount value of this '$amount'
            if (!word.isEmpty() && word.charAt(0) == '$') {

                long amount = 0;
                int n = word.length();
                //index = 1 because 0-th char at curr word is '$'
                int index = 1;
                //assuming that all the $amount words are valid, but they can be
                //invalid as well then we dont given discount to them but keep
                //them as it is in reform string
                boolean isValid = true;

                while (index < n) {
                    //if the curr index-char in word is not a digit, it becomes
                    //a invalid word ex: "$", "$1e5", "$10$"
                    if (!Character.isDigit(word.charAt(index))) {
                        isValid = false;
                        break;
                    }

                    amount = (amount * 10l) + (word.charAt(index) - '0');
                    index++;
                }

                //if word is invalid or amount is 0 then keep them as it is
                if (!isValid || amount == 0) {
                    reform.append(word).append(" ");
                    continue;
                }

                double discountReduction = (double) amount * ((double) discount / 100.0);
                double discountedAmount = (double) amount - discountReduction;
                //format("%.2f") here will round off our discountedAmount to upto
                //2 decimal places
                String discountedAmountString = String.format("%.2f", discountedAmount);
                reform.append('$').append(discountedAmountString).append(" ");

            } else {
                reform.append(word).append(" ");
            }
        }
        //output
        System.out.println("Apply discount to valid prices in sentence: " + reform.toString().trim());
    }

    public void removeAllOccurencesOfSubstring(String main, String pattern) {
        //....................T: O((M - N) * (M + N))
        //time complexity for KMP pattern matching is O(M + N),
        //M = length of main string, N = length of pattern string
        //in worst case if main string is built only from pattern
        //ex: main = "abcabcabcabc", pattern = "abc", let lengths be M & N respec.
        //first time KMP = O(M + N)
        //we will loop untill there is no pattern in main string OR main string is empty(== "")
        //here in this example our main string will be empty
        //since pattern is there in main string,
        //our main string will be reduced by N chars ==> "abcabcabc" ==> M - N
        //second time KMP = O((M - N) + N)
        //our main string will be reduced again by N chars ==> "abcabc" ==> M - N - N ==> M - 2N
        //third time KMP = O((M - 2N) + N)
        //our main string will be reduced again by N chars ==> "abc" ==> M - N - N - N ==> M - 3N
        //fourth time KMP = O((M - 3N) + N)
        //our main string will be reduced again by N chars ==> "" ==> M - N - N - N - N ==> M - 4N
        //fourth time KMP = O((M - 4N) + N)
        //https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
        //based on KMP pattern matching also
        //KMP pattern matching algo helper
        class Helper {

            int[] createLPS(String pattern) {
                int n = pattern.length();
                int[] lps = new int[n];
                int prefIndex = 0;
                int suffIndex = 1;

                while (suffIndex < n) {
                    if (pattern.charAt(prefIndex) == pattern.charAt(suffIndex)) {
                        prefIndex++;
                        lps[suffIndex] = prefIndex;
                        suffIndex++;
                    } else if (prefIndex == 0) {
                        lps[suffIndex] = prefIndex;
                        suffIndex++;
                    } else {
                        prefIndex = lps[prefIndex - 1];
                    }
                }
                return lps;
            }

            int matchPattern(String main, String pattern) {
                int m = main.length();
                int n = pattern.length();

                int[] lps = createLPS(pattern);

                int mainIndex = 0;
                int patternIndex = 0;

                while (mainIndex < m) {
                    if (main.charAt(mainIndex) == pattern.charAt(patternIndex)) {
                        mainIndex++;
                        patternIndex++;
                    } else if (patternIndex == 0) {
                        mainIndex++;
                    } else {
                        patternIndex = lps[patternIndex - 1];
                    }

                    if (patternIndex == n) {
                        return mainIndex - n;
                    }
                }
                //incase pattern is not found in main string
                return -1;
            }

        }

        //actual:
        System.out.println("actual main string: " + main);

        int n = pattern.length();
        Helper helper = new Helper();

        //first pattern matchedIndex
        int matchedIndex = helper.matchPattern(main, pattern);

        //with this loop we find the pattern in main string
        //remove the found pattern to make a new main string
        //do this untill there are no pattern left in the main string
        while (matchedIndex >= 0) {
            //entering this while() loop when matchedIndex is some valid index
            //(i.e, >= 0, meaning starting index of the pattern is found in main string)
            //now with this matchedIndex, we must remove this pattern and create a
            //new main string
            //new main string = main[0, matcheIndex - 1] + main[matchedIndex + n]
            //meaning all the chars in main string from 0-th char to char before
            //the pattern(== matchedIdex) and all the chars after the last
            //index of pattern(== matchedIndex + n)
            //string substring() takes (0, n - 1) so (0, matchedIndex) == (0, matchedIndex - 1)
            //ex: main = "daabcbaabcbc", pattern = "abc"
            //now first pattern will be found at index == matchedIndex == 2
            //main = da{abc}baabcbc
            //new main string will be = da + baabcbc = "dabaabcbc"
            main = main.substring(0, matchedIndex) + "" + main.substring(matchedIndex + n);
            //now find the pattern again with the new main string
            matchedIndex = helper.matchPattern(main, pattern);
        }
        //output
        System.out.println("Main string after removing all occurences of " + pattern + " is: " + main);
    }

    public String decodeStringAtIndex(String str, int k) {
        //https://leetcode.com/problems/decoded-string-at-index/description/
        //https://leetcode.com/problems/decoded-string-at-index/solutions/156733/decoded-string-at-index/
        int n = str.length();
        long size = 0;
        //first calculate the size of the string whenever the repeatition occur
        //by number in string as per the quest
        for (char ch : str.toCharArray()) {

            size = Character.isDigit(ch) ? size * (ch - '0') : size + 1;
        }

        //secondly, do a backward check
        for (int i = n - 1; i >= 0; i--) {

            char ch = str.charAt(i);

            k %= size;

            if (k == 0 && Character.isLetter(ch)) {
                return String.valueOf(ch);
            }

            size = Character.isDigit(ch) ? size / (ch - '0') : size - 1;

        }
        return "";
    }

    public void namingACompany(String[] ideas) {
        //https://leetcode.com/problems/naming-a-company/description/
        //https://leetcode.com/problems/naming-a-company/solutions/3081799/naming-a-company/

        long totalIdeas = 0;

        //char-array-map which maps first char of i-th idea from ideas[] to rest
        //of its subtring
        //ex: ideas[i] = "coffee" = substrs['c'] = ["offee"]
        Set<String>[] substrs = new HashSet[26];

        for (String idea : ideas) {

            char firstChar = idea.charAt(0);

            if (substrs[firstChar - 'a'] == null) {
                substrs[firstChar - 'a'] = new HashSet<>();
            }

            substrs[firstChar - 'a'].add(idea.substring(1));
        }

        for (char chrI = 'a'; chrI <= 'y'; chrI++) {

            if (substrs[chrI - 'a'] == null) {
                continue;
            }

            for (char chrJ = (char) (chrI + 1); chrJ <= 'z'; chrJ++) {

                if (substrs[chrJ - 'a'] == null) {
                    continue;
                }

                long commonSubstr = 0;

                //if two chars chrI & chrJ, have same common substring parts
                //ex: [c]offee, [t]offee, now offee is common subtring that
                //appears in both. now if we swap 'c' -> 't' and vice versa
                //the names will remain the same hence such common subtring
                //are to be excluded while formig unique names
                for (String substr : substrs[chrI - 'a']) {
                    //any common substr in two diff char set of initials
                    //(i.e, char i & j)
                    if (substrs[chrJ - 'a'].contains(substr)) {
                        commonSubstr++;
                    }
                }

                //we found common substring that exist in both char set and
                //we are excluding those common substring and rest substring
                //will form unique names if we swap first char of their word
                //now *2 because company name is 2 word so we can place these
                //words in 2 positions
                //ex: 'xyz lmn' and 'lmn xyz'
                totalIdeas += (2
                        * (substrs[chrI - 'a'].size() - commonSubstr)
                        * (substrs[chrJ - 'a'].size() - commonSubstr));
            }
        }
        //output
        System.out.println("Total names for company: " + totalIdeas);
    }

    private int greatestCommonDivisorOfStrings_GCD(int x, int y) {
        if (y == 0) {
            return x;
        }
        return greatestCommonDivisorOfStrings_GCD(y, x % y);
    }

    public String greatestCommonDivisorOfStrings(String str1, String str2) {
        //https://leetcode.com/problems/greatest-common-divisor-of-strings/description/
        if (!(str1 + str2).equals(str2 + str1)) {
            return "";
        }
        int gcdlength = greatestCommonDivisorOfStrings_GCD(str1.length(), str2.length());
        return str1.substring(0, gcdlength);
    }

    public void numberOfGoodWaysToSplitString(String str) {
        //https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/
        /*
        str = "aacaba"
        left = {}, right = {}

        right = {a = 4, b = 1, c = 1}

        for(i = 0 to i < n - 1)
        --- i = 0, chr = a
        --- left = {a = 1}, right = {a = 3, b = 1, c = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) FALSE

        --- i = 1, chr = a
        --- left = {a = 2}, right = {a = 2, b = 1, c = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) FALSE

        --- i = 2, chr = c
        --- left = {a = 2, c = 1}, right = {a = 2, b = 1, c = 0}
        --- right[c] <= 0 == right = {a = 2, b = 1}
        --- if(left.size == right.size) == (2 == 2) TRUE
        ----- ways++ == 1

        --- i = 3, chr = a
        --- left = {a = 3, c = 1}, right = {a = 1, b = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) == (2 == 2) TRUE
        ----- ways++ == 2

        --- i = 4, chr = b
        --- left = {a = 3, c = 1, b = 1}, right = {a = 1, b = 0}
        --- right[a] <= 0 == right = {a = 1}
        --- if(left.size == right.size) FALSE

         */
        int n = str.length();
        //left will hold the char freq for left part of string
        Map<Character, Integer> left = new HashMap<>();
        //right will hold the char freq for right part of string
        Map<Character, Integer> right = new HashMap<>();

        int ways = 0;

        //initailly the right will have the char freq for complete string, this
        //right freq map will help in a ways where each time a char chr is moved
        //from right to left, we don't have to run a separate loop from [i, n] to
        //calculate distinct char in right part every time, this optimize here
        for (char ch : str.toCharArray()) {
            right.put(ch, right.getOrDefault(ch, 0) + 1);
        }

        //here in this loop, we will try to split the string in left and right
        //parts. At each index i left will incr the count of char in left part
        //string (i.e str[0, i]) and right will decr the count of char in right
        //and move it to left. Now after moving a char from right to left, if its
        //freq reduced to 0 (means not char 'chr' exist in right part anymore) then
        //remove that char from right
        //running loop from i = 0 to i < n - 1 means it will run for [0, n - 2]
        //the last (n - 1)-th char will still be considered for right string part
        //as both left & right string part should be non-empty
        for (int i = 0; i < n - 1; i++) {
            char ch = str.charAt(i);
            //update the left by adding a char chr to it
            left.put(ch, left.getOrDefault(ch, 0) + 1);
            //the char chr added in left must have taken from right part
            right.put(ch, right.getOrDefault(ch, 0) - 1);
            //now after the char chr moved to left part, if no occuerence of chr
            //exist anymore in right part(== (right.get(chr) <= 0)) then remove it
            if (right.get(ch) <= 0) {
                right.remove(ch);
            }

            //after simulating two string parts left & right respect check if we
            //got same number of distinct chars in both parts the incr ways
            if (left.size() == right.size()) {
                ways++;
            }
        }
        //output
        System.out.println("Number of good ways to split string: " + ways);
    }

    public int repeatedStringMatch(String mainStr, String checkStr) {
        //https://leetcode.com/problems/repeated-string-match/description/
        int mainStrLen = mainStr.length();
        int checkStrLen = checkStr.length();
        int repeat = checkStrLen / mainStrLen;
        //since we are taking our first main string in repeatition
        //so its count should start from 1
        StringBuilder strRepeat = new StringBuilder(mainStr);
        int repeatCount = 1;

        for (int i = 0; i < repeat + 2; i++) {
            if (strRepeat.toString().contains(checkStr)) {
                return repeatCount;
            }

            strRepeat.append(mainStr);
            repeatCount++;
        }
        return -1;
    }

    public void rewardTopKStudents(
            String[] positiveFeedbacks, String[] negativeFeedbacks,
            String[] reports, int[] studentId, int k) {
        //based on HEAP
        //https://leetcode.com/problems/reward-top-k-students/description/

        List<Integer> topKStudents = new ArrayList<>();

        int n = studentId.length;

        Set<String> positiveSet = new HashSet<>(Arrays.asList(positiveFeedbacks));
        Set<String> negativeSet = new HashSet<>(Arrays.asList(negativeFeedbacks));

        Map<Integer, Integer> idAndScores = new HashMap<>();

        for (int i = 0; i < n; i++) {
            //id of curr i-th student
            int id = studentId[i];
            //report prepared by curr student with id at i-th index
            String report = reports[i];
            //if the curr student with id was prevously processes then there must
            //be some prev scores else default is 0
            int currScore = idAndScores.getOrDefault(id, 0);

            //for each word in reoprt prepared by curr student,
            //if word in positive feedback gain +3 score
            //if word in negative feedback loose -1 score
            for (String word : report.split(" ")) {
                if (positiveSet.contains(word)) {
                    currScore += 3;
                }
                if (negativeSet.contains(word)) {
                    currScore -= 3;
                }
            }

            //put the curr total score achieved by student with id
            idAndScores.put(id, idAndScores.getOrDefault(id, 0) + currScore);
        }

        //find the top k student which students with higher scores
        //but if scores are same then pick the student with lower id
        //below priority queue will keep data having higher scores or lower id
        //in end and keep lower scores or higher id at top to keep only K students
        PriorityQueue<Integer> minHeapIdAndScores = new PriorityQueue<>(
                (a, b) -> idAndScores.get(a) == idAndScores.get(b)
                        ? b - a : idAndScores.get(a) - idAndScores.get(b));

        for (int id : idAndScores.keySet()) {
            minHeapIdAndScores.add(id);
            if (minHeapIdAndScores.size() > k) {
                minHeapIdAndScores.poll();
            }
        }

        while (!minHeapIdAndScores.isEmpty()) {
            topKStudents.add(0, minHeapIdAndScores.poll());
        }

        //output
        System.out.println("Reward top k student: " + topKStudents);
    }

    public void alphabetBoardPath(String target) {
        //https://leetcode.com/problems/alphabet-board-path/description/
        //https://leetcode.com/problems/alphabet-board-path/solutions/3120261/easy-faster-efficient-java-soln/
        /*
        alphabet board:
        [a  b  c  d  e]
        [f  g  h  i  j]
        [k  l  m  n  o]
        [p  q  r  s  t]
        [u  v  w  x  y]
        [z            ]
         */
        //initial position
        int x = 0;
        int y = 0;
        StringBuilder path = new StringBuilder();
        for (char ch : target.toCharArray()) {
            //dest row & col location for curr char so that we can move initial
            //row & col to the dest row & col
            //to keep the curr char chr in the alphabet board / & % by 5
            //divide '/', bound dest chr row into 6 rows
            //mod '%', bound dest chr col into 5 cols
            int destX = (ch - 'a') / 5;
            int destY = (ch - 'a') % 5;

            //order of these while loops matter!!!
            while (destX < x) {
                x--;
                path.append("U");
            }

            while (destY > y) {
                y++;
                path.append("R");
            }

            while (destY < y) {
                y--;
                path.append("L");
            }

            while (destX > x) {
                x++;
                path.append("D");
            }

            //"!" means picking the target char chr
            path.append("!");
        }
        //output
        System.out.println("Alphabet board path : " + path);
    }

    public int takeKOfEachCharFromLeftRight(String str, int k) {
        //https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/
        //based on SLIDING WINDOW
        /*
        str = "aabaaaacaabc", k = 2
        acc to quest, we need to pick atleast k chars of each a, b, c from left
        & right

        intuition:
        First we will calculate the freq of each chars of the string
        freq[] = int[3]

        we will remove few chars and check that after removing these chars we
        must have remaining chars equal or more than k
        i.e == freq[0] < k || freq[1] < k || freq[2] < k
        if we have freq of each chars(a, b, c) atleast k then inner while loop
        will not work

        after that we will calculate the chars we are actually considering
        min = Math.min(min, n - (end - start + 1));

        freq[] = {a = 8, b = 2, c = 2}

        end = 0, start = 0
        str = "aabaaaacaabc"

        #1
        end = 0, start = 0
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 7, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 11
        end++ ==> 1
        means: remove[a] remaining[abaaaacaabc] is a valid pick

        #2
        end = 1, start = 0
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 10
        end++ ==> 2
        means: remove[aa] remaining[baaaacaabc] is a valid pick

        #3
        end = 2, start = 0
        chEnd = str[end] = b
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 1, c = 2}
        //now freq[b] < k == true, while() will work and try fetch chars from start
        //untill freq[b] > k
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        ===> 1.
        chStart = start[start] = a;
        freq[a]++ == freq[a]++ == {a = 7, b = 1, c = 2}
        start++ ==> 1
        ===> 2.
        chStart = start[start] = a;
        freq[a]++ == freq[a]++ == {a = 8, b = 1, c = 2}
        start++ ==> 2
        ===> 3.
        chStart = start[start] = b;
        freq[a]++ == freq[a]++ == {a = 8, b = 2, c = 2}
        start++ ==> 3
        //now each freq[] > k, while() END
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 2 ==> 12
        end++ ==> 3
        means: remove[] remaining[aabaaaacaabc] is a valid pick

        #4
        end = 3, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 7, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 3 ==> 11
        end++ ==> 4
        means: remaining[aab] remove[a] remaining[aaacaabc] is a valid pick

        #5
        end = 4, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 4 ==> 10
        end++ ==> 5
        means: remaining[aab] remove[aa] remaining[aacaabc] is a valid pick

        #6
        end = 5, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 5, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 5 ==> 9
        end++ ==> 6
        means: remaining[aab] remove[aaa] remaining[acaabc] is a valid pick

        #7
        end = 6, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 4, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 6 ==> 8 ***ANSWER***
        end++ ==> 7
        means: remaining[aab] remove[aaaa] remaining[caabc] is a valid pick


        .....REST ITERATIONS.....

         */
        int n = str.length();
        //freq[0] = 'a', freq[1] = 'b', freq[2] = 'c'
        int[] freq = new int[3];

        //count the freq of all the a, b, c char in str
        for (char ch : str.toCharArray()) {
            freq[ch - 'a']++;
        }

        //if freq of any of char is less than k then it is not possible
        if (freq[0] < k || freq[1] < k || freq[2] < k) {
            return -1;
        }

        int end = 0;
        int start = 0;
        int min = n;

        while (end < n) {

            //try to remove chars
            char chEnd = str.charAt(end);
            freq[chEnd - 'a']--;

            //after removing chars from our freq[], if freq of all the remaining
            //chars are enough(i.e, atleast k means >= k) then we need not to
            //run this while()
            //only if any freq is less than k then we need to fetch chars from
            //start ptr untill freq of chars again > k
            while (freq[0] < k || freq[1] < k || freq[2] < k) {
                char chStart = str.charAt(start);
                freq[chStart - 'a']++;
                start++;
            }

            //here we will calculate the size of string left after removing chars
            //the remaining chars will basically tell you min size of string which
            //contains a, b, c atleast k times
            min = Math.min(min, n - (end - start + 1));
            end++;
        }
        return min;
    }

    public boolean swapAdjacentLRString(String start, String end) {
        //https://leetcode.com/problems/swap-adjacent-in-lr-string/description/
        //Explanation: https://leetcode.com/problems/swap-adjacent-in-lr-string/solutions/873004/easy-to-understand-explanation-with-picture/
        if (start.length() != end.length()) {
            return false;
        }

        String strStart = start.replace("X", "");
        String strEnd = end.replace("X", "");

        if (!strStart.equals(strEnd)) {
            return false;
        }

        List<Integer> startL = new ArrayList<>();
        List<Integer> startR = new ArrayList<>();
        List<Integer> endL = new ArrayList<>();
        List<Integer> endR = new ArrayList<>();

        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == 'L') {
                startL.add(i);
            } else if (start.charAt(i) == 'R') {
                startR.add(i);
            }
        }

        for (int i = 0; i < end.length(); i++) {
            if (end.charAt(i) == 'L') {
                endL.add(i);
            } else if (end.charAt(i) == 'R') {
                endR.add(i);
            }
        }

        for (int i = 0; i < startL.size(); i++) {
            if (startL.get(i) < endL.get(i)) {
                return false;
            }
        }

        for (int i = 0; i < startR.size(); i++) {
            if (startR.get(i) > endR.get(i)) {
                return false;
            }
        }

        return true;
    }

    public void removeOutermostParenthesis(String str) {
        //https://leetcode.com/problems/remove-outermost-parentheses/description/
        int n = str.length();
        int balanced = 0;
        int outerMostStart = 0;
        StringBuilder sb = new StringBuilder();
        for (int outerMostEnd = 0; outerMostEnd < n; outerMostEnd++) {
            char bracket = str.charAt(outerMostEnd);
            if (bracket == '(') {
                balanced++;
            } else {
                //if bracket is closing, remove the count of opening brackets
                //until it again balanced(== 0)
                balanced--;
                //when the outermost opening bracket is balanced by outermost
                //closing bracket then this balanced will be 0. Now to remove
                //these outermost bracket we will pick the substring in between
                //these outermost start & end that is
                //(== substring(outerMostStart + 1, outerMostEnd))
                //ex: str = "(()())" str.substring(start + 1, end) == "()()"
                if (balanced == 0) {
                    sb.append(str.substring(outerMostStart + 1, outerMostEnd));
                    //update outermost start to start from next opening bracket
                    //where the balanced counter will again calculate
                    outerMostStart = outerMostEnd + 1;
                }
            }
        }
        //output
        System.out.println("Remove Outermost parenthesis : " + sb);
    }

    public void minAdditionToMakeValidString(String word) {
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/description/
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/solutions/3421831/java-c-python-easy-and-concise-with-explanation/
        int n = word.length();
        int count = 0;
        char prevChar = 'z';
        for (char ch : word.toCharArray()) {
            //with this cond: chr <= prevChar we are basically checking the valid
            //"abc", "ab", "ac", "bc" sequences
            //if the chr <= prevChar is true means we need to fulfil the "abc"
            //pattern
            //ex: "cba" now 'c' needs its own a,b before c so thats 2 char
            //'b' needs its own a,c before and after this 'b' so thats 2 char
            //'a' needs its own b,c after this 'a' so thats 2 char
            //so total becomes 6 chars required.
            //now each of this 'c', 'b', 'a' is breaking the "abc" pattern so
            //count will be 3 once loop ends
            //now with count 3 we are basically saying that to balance
            //this "cba" we need 3 "abc" pattern appened at end (for that we have
            //count * 3) that make this string as "cbaabcabcabc"
            //but also we already have 3 chars as "cba" which will be common in
            //this so we also adjust this as (count * 3) - n = 3 * 3 - 3 = 6 chars
            count += ch <= prevChar ? 1 : 0;
            prevChar = ch;
        }
        //output
        int required = count * 3 - n;
        System.out.println("Min addition to make valid string : " + required);
    }

    public boolean stringsDifferByOneChar1(String[] words) {
        //.....................T: O(N * M), N length of words[], M length of each word
        //.....................T: O(M * N), for each index [0 to M - 1], it will remove
        //a char and eventually will try to remove all M chars one by one from a single
        //word, hence in this process we will make M diff words and there are N words in
        //words[] so in worst case it might generate M * N words in seen set
        //https://leetcode.com/problems/strings-differ-by-one-character/
        //https://leetcode.ca/2020-03-02-1554-Strings-Differ-by-One-Character/
        //THIS WILL THROW 'MEMORY LIMIT EXCEEDED' on Leetcode(premium)
        Set<String> seen = new HashSet<>();
        for (String word : words) {
            //for every curr word, we will create possible words with 1 char removed
            //for every char index i, each removed char is marked as '*'
            for (int i = 0; i < word.length(); i++) {
                String wordWithoutOneChar = word.substring(0, i) + "*" + word.substring(i + 1);
                //if the word formed by removing 1 char at every i-th index is already
                //seen previously that means we have 2 strings to satisfy our req
                if (seen.contains(wordWithoutOneChar)) {
                    return true;
                }
                seen.add(wordWithoutOneChar);
            }
        }
        return false;
    }

    public boolean stringsDifferByOneChar2(String[] words) {
        //https://leetcode.com/problems/strings-differ-by-one-character/
        //https://leetcode.com/problems/strings-differ-by-one-character/solutions/2065288/java-solution-that-actually-works-based-on-new-test-cases/
        //https://leetcode.ca/2020-03-02-1554-Strings-Differ-by-One-Character/
        //based on RABIN KARP ALGO/ ROLLING HASH ALGO
        int n = words.length;

        HashSet<Long> set = new HashSet<>();

        long mod = (long) Math.pow(10, 20) + 7;

        int len = words[0].length();

        long[] word2hash = new long[n];

        for (int i = 0; i < n; i++) {

            for (int j = 0; j < len; j++) {

                word2hash[i] = (word2hash[i] * 26 + words[i].charAt(j) - 'a') % mod;
            }
        }

        long base = 1;

        for (int j = len - 1; j >= 0; j--) {

            set.clear();

            for (int i = 0; i < n; i++) {

                long newHash = (word2hash[i] - base * (words[i].charAt(j) - 'a')) % mod;

                if (set.contains(newHash)) {
                    return true;
                }

                set.add(newHash);
            }

            base = 26 * base % mod;
        }

        return false;
    }

    public void stringMirror(String str) {
        //https://practice.geeksforgeeks.org/problems/d385b9d635b7b10eef6bf365b84922aaeec9eb98/1
        int n = str.length();
        StringBuilder prev = new StringBuilder();
        prev.append(str.charAt(0));

        for (int i = 1; i < n; i++) {
            if (prev.charAt(i - 1) > str.charAt(i)) {
                prev.append(str.charAt(i));
            } else if (i > 1 && prev.charAt(i - 1) == str.charAt(i)) {
                prev.append(str.charAt(i));
            } else {
                break;
            }
        }

        String currStr = prev.toString();
        prev.reverse();
        String lexicographicallySmallerMirrorString = currStr + prev.toString();
        //output
        System.out.println("Lexicographically smaller mirror string : " + lexicographicallySmallerMirrorString);
    }

    public void maxNestedDepthOfParenthesis(String expression) {
        //https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/
        /*
        intuition here is, we need to only consider brackets ('(' or ')') in the
        given string expression

        opening brackets increases its depth when there are some nested brackets
        are inside it so if we see an opening bracket depth++
        and
        closing brackets decreses its depth when there are some nested brackets
        are inside it so if we see an closing bracket depth--

        but in between we need to calculate the depth it went inside because of
        the nested structure of parenthesis

        ex: "((()))", its maxDepth is 3
        depth == 1 ==> (........)
        depth == 2 ==>   (....)
        depth == 3 ==>    (..)

        another ex: "()()()", its maxDepth is 1
        depth == 1 ==> ()...()..()
        how? initially depth == 0,
        first opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0

        second opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0

        third opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0

        hence on nesting depth increases(just like a tree)

         */
        int n = expression.length();
        int depth = 0;
        int maxDepth = 0;

        for (char ch : expression.toCharArray()) {
            if (ch == '(' || ch == ')') {

                boolean open = (ch == '(');

                if (open) {
                    depth++;
                }

                maxDepth = Math.max(maxDepth, depth);

                if (!open) {
                    depth--;
                }
            }
        }
        //output
        System.out.println("Max nested depth of parenthesis : " + maxDepth);
    }

    public void maxNestedDepthOfTwoValidParenthesisString(String seq) {
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/358419/confused-by-this-problem-i-was-too-here-is-how-it-became-crystal-clear/
        //based on maxNestedDepthOfParenthesis()
        //question statement is very bad to understand
        int n = seq.length();
        int[] result = new int[n];
        int depth = 0;
        for (int i = 0; i < n; i++) {
            char bracket = seq.charAt(i);
            boolean open = (bracket == '(');

            if (open) {
                depth++;
            }

            result[i] = depth % 2;

            if (!open) {
                depth--;
            }
        }
        //output
        System.out.println("Max nested depth of two valid parenthesis strings : " + Arrays.toString(result));
    }

    public void replaceWords(List<String> dictionary, String sentence) {
        //https://leetcode.com/problems/replace-words/description/
        //based on TRIE
        class TrieNode {

            Map<Character, TrieNode> map;
            String word;
            boolean isEndOfWord;

            public TrieNode() {
                map = new HashMap<>();
                word = "";
                isEndOfWord = false;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {

                        currRoot = currRoot.map.get(ch);

                    } else {

                        TrieNode node = new TrieNode();
                        currRoot.map.put(ch, node);
                        currRoot = node;
                    }
                }

                currRoot.word = word;
                currRoot.isEndOfWord = true;
            }

            String getSmallerPrefixOrSame(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {

                        currRoot = currRoot.map.get(ch);
                        //if given 'word' has a prefix that is also marked as
                        //a word in trie return that word as soon we meet this
                        if (currRoot.isEndOfWord) {
                            return currRoot.word;
                        }

                    } else {
                        //prefix mismatch, hence return same given 'word' as it is
                        return word;
                    }
                }

                //case when the given 'word' is a full prefix match and also marked
                //as a word then return the prefix word(==> currRoot.word) but if
                //still this prefix is not marked as a word in trie then return
                //given 'word'
                return currRoot.isEndOfWord ? currRoot.word : word;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (String word : dictionary) {
            trieUtil.addToTrie(word);
        }

        StringBuilder replacedSentence = new StringBuilder();

        for (String word : sentence.split(" ")) {
            replacedSentence.append(trieUtil.getSmallerPrefixOrSame(word));
            replacedSentence.append(" ");
        }
        //output
        System.out.println("Replace word (Trie) : " + replacedSentence.toString().trim());
    }

    public void sentenceScreenFitting(String[] words, int rows, int cols) {
        //https://leetcode.com/problems/sentence-screen-fitting/
        //explanation: https://www.youtube.com/watch?j=1ChX4Cpz0bU
        String text = String.join(" ", words) + " ";

        int len = text.length();

        int cursor = 0;

        for (int row = 0; row < rows; row++) {

            cursor += cols;

            while (cursor % len >= 0 && text.charAt(cursor % len) != ' ') {
                cursor--;
            }

            cursor++;
        }
        //output
        int sentenceFitted = cursor / len;
        System.out.println("Sentence screen fitting : " + sentenceFitted);
    }

    public void addingSpacesToString(String str, int[] spaces) {
        //https://leetcode.com/problems/adding-spaces-to-a-string/description/
        /*
        this question seems to be easy but requires time optimization as the
        constraint given is large

        constraints:
        1 <= s.length <= 3 * 10^5
        s consists only of lowercase and uppercase English letters.
        1 <= spaces.length <= 3 * 10^5
        0 <= spaces[i] <= s.length - 1
        All the values of spaces are strictly increasing.
         */

        int startIndex = 0;
        StringBuilder updatedString = new StringBuilder();

        for (int spaceIndex : spaces) {
            String substr = str.substring(startIndex, startIndex + (spaceIndex - startIndex));
            updatedString.append(substr).append(" ");
            startIndex = spaceIndex;
        }

        //adding the last substring segemnt till str.length
        updatedString.append(str.substring(startIndex));

        //output
        System.out.println("Adding spaces to string : " + updatedString);
    }

    public boolean isOneEditDistance(String str1, String str2) {
        //https://leetcode.com/problems/one-edit-distance/description/

        int str1Length = str1.length();
        int str2Length = str2.length();

        //str2 has smaller length than str1, reverse the call by changing strings
        //str1 becomes str2 and str2 becomes str1 for next call
        if (str2Length < str1Length) {
            return isOneEditDistance(str2, str1);
        }

        //since we are targeting only 1 edit we can make, but if the lengths of
        //both the strings has a diff of more than 1 it means we would need to
        //make that much edits which is not alowed hence return false
        if (Math.abs(str1Length - str2Length) > 1) {
            return false;
        }

        for (int i = 0; i < str1Length; i++) {

            //skip, if two chars of both strings are same
            if (str1.charAt(i) == str2.charAt(i)) {
                continue;
            }

            //here, i-th char of both string don't match meaning the 1 edit
            //that we can make, we must make on this i-th char only
            //2 choices on both the string to make edit on i-th char
            //1. edit the i-th char then remaining strings should match
            //ex: str1 = "axbedf", str2 = "acbedf"
            //i-th char that don't match ==> i = 1 ==> 'x' != 'c'
            //then str1[i + 1] = "bedf" == str2[i + 1] = "bedf"
            return str1.substring(i + 1).equals(str2.substring(i + 1))
                    //2. edit the i-th char then remaining of str2 should match
                    //with str1 starting from i-th char
                    //ex: str1 = "abedf", str2 = "acbedf"
                    //i-th char that don't match ==> i = 1 ==> 'b' != 'c'
                    //then str1[i] = "bedf" == str2[i + 1] = "bedf"
                    || str1.substring(i).equals(str2.substring(i + 1));
        }

        //here, they both are same means in the above for() all the chars have
        //'skipped' and didn't make 1 edit hence we check the diff in lengths
        //cases like
        //ex: str1 = "abc", st2 = "abc" for() all chars skipped as i < str1Length
        //but here abs(3 - 3) != 1 means 1 edit can't be made
        //another case
        //ex: str1 = "abc", st2 = "abcd" for() all chars skipped as i < str1Length
        //but here abs(3 - 4) == 1 means 1 edit can be made
        return Math.abs(str1Length - str2Length) == 1;
    }

    public void wordsWithinTwoEditsOfDictionary(String[] queries, String[] dictionary) {
        //https://leetcode.com/problems/words-within-two-edits-of-dictionary/description/
        //based on BRUTE FORCE approach as the given constraints are small
        List<String> validQueryWords = new ArrayList<>();
        int MAX_EDIT_LIMIT = 2;

        for (String query : queries) {
            for (String word : dictionary) {

                //given: both words in queries[] and dictionary[] have same length 'n'
                int n = word.length();
                //initial edits made on 'query' word to make it equal to 'word'
                //from dictionary[]
                //max edits can be made is just MAX_EDIT_LIMIT = 2
                //0 == means both 'query' & 'word' were already equal
                //1 == means made 1 edit in 'query' and it will be equal to 'word'
                //2 == means made 2 edit in 'query' and it will be equal to 'word'
                int edits = 0;

                for (int i = 0; i < n; i++) {

                    //if a char is mismatching in 'query' with that of 'word' means
                    //we must make an edit here, hence edits++
                    if (query.charAt(i) != word.charAt(i)) {
                        edits++;
                    }

                    //each time we see a char mismatch in 'query' we made some edit
                    //in above if(), now if those edits are more than our max
                    //limit(==> MAX_EDIT_LIMIT) break here, as this 'query' word
                    //is not a valid word
                    if (edits > MAX_EDIT_LIMIT) {
                        break;
                    }
                }

                //edits made above are under max limit(==> MAX_EDIT_LIMIT) hence
                //this 'query' word is a valid so add it in our valid list and
                //break here as we know 'query' is valid and there is no need
                //to check any other 'word' further from dictionary[]
                if (edits <= MAX_EDIT_LIMIT) {
                    validQueryWords.add(query);
                    break;
                }
            }
        }
        //output
        System.out.println("Words within two edits of dictionary : " + validQueryWords);
    }

    public void findDivisibiltyArrayOfString(String word, int m) {
        //https://leetcode.com/problems/find-the-divisibility-array-of-a-string/description/
        //based on REMAINDERS
        /*
        word = "998244353", m = 3

        numberRemainder = 0

        ##1
        i = 0, digit = 9
        ==> numberRemaider = 0 * 10 + (9) ==> 9
        ==> numberRemainder % m = 9 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1

        ##2
        i = 1, digit = 9
        ==> numberRemaider = 0 * 10 + (9) ==> 9
        ==> numberRemainder % m = 9 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1

        ##3
        i = 2, digit = 8
        ==> numberRemaider = 0 * 10 + (8) ==> 8
        ==> numberRemainder % m = 8 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0

        ##4
        i = 3, digit = 2
        ==> numberRemaider = 2 * 10 + (2) ==> 22
        ==> numberRemainder % m = 22 % 3 = 1
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0

        ##5
        i = 4, digit = 4
        ==> numberRemaider = 1 * 10 + (4) ==> 14
        ==> numberRemainder % m = 14 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0

        ##6
        i = 5, digit = 4
        ==> numberRemaider = 2 * 10 + (4) ==> 24
        ==> numberRemainder % m = 24 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1

        ##7
        i = 6, digit = 3
        ==> numberRemaider = 0 * 10 + (3) ==> 3
        ==> numberRemainder % m = 3 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1

        ##8
        i = 7, digit = 5
        ==> numberRemaider = 0 * 10 + (5) ==> 5
        ==> numberRemainder % m = 5 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0

        ##9
        i = 8, digit = 3
        ==> numberRemaider = 2 * 10 + (3) ==> 23
        ==> numberRemainder % m = 23 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0

         */
        int n = word.length();
        //if any number so formed from word[0 to i] % m == 0 then put 1 else 0
        int[] divisibiltyArray = new int[n];

        long numberRemainder = 0;

        for (int i = 0; i < n; i++) {

            char digit = word.charAt(i);
            //we only care about the previous number's remainder with given m
            numberRemainder = (numberRemainder * 10 + (digit - '0'));
            numberRemainder %= m;

            //if number formed within word[0 to i] and divisible by given m
            //then put 1 else 0
            divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0;
        }
        //output
        System.out.print("Divisibilty array of string : " + Arrays.toString(divisibiltyArray));
    }

    private boolean maxProdOfWordlength_ShareCommonLetters(
            boolean[][] wordsIndexToUniqueChars, int mainWordIndex, String currWord) {

        for (char ch : currWord.toCharArray()) {
            //the char of 'curr word' is also present in main word denoted as
            //mainWordIndex then return true
            if (wordsIndexToUniqueChars[mainWordIndex][ch - 'a']) {
                return true;
            }
        }
        return false;
    }

    public void maxProdOfWordlength(String[] words) {
        //https://leetcode.com/problems/maximum-product-of-word-lengths/description/
        //based on BRUTE FORCE
        //This approach is not the optimized approach, as per question bit-masking
        //can optimize the time complexity but this solution is also accepted on leetcode
        int n = words.length;
        boolean[][] wordsIndexToUniqueChars = new boolean[n][26];

        for (int i = 0; i < n; i++) {
            String word = words[i];
            for (char ch : word.toCharArray()) {
                //for a curr word @i-th index of words[] contains chars 'ch' as true
                wordsIndexToUniqueChars[i][ch - 'a'] = true;
            }
        }

        int maxLengthProd = 0;
        for (int i = 0; i < n; i++) {

            String main = words[i];

            for (int j = i + 1; j < n; j++) {

                String curr = words[j];

                if (maxProdOfWordlength_ShareCommonLetters(wordsIndexToUniqueChars, i, curr)) {
                    continue;
                }

                maxLengthProd = Math.max(maxLengthProd, main.length() * curr.length());
            }
        }
        //output
        System.out.println("Max prod of word length : " + maxLengthProd);
    }

    public void kLengthedSubstringsWithUniqueChars(String str, int k) {
        //https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/description/
        //https://leetcode.ca/all/1100.html
        //based on SLIDING WINDOW
        int n = str.length();

        //edge case
        if (n < k) {
            System.out.println("Substrings with length k and having unique chars : NA");
            return;
        }

        int start = 0;
        int end = 0;

        Map<Character, Integer> uniqueCharsFreq = new HashMap<>();

        //put first k-lengthed substring in freq map;
        for (; end < k; end++) {
            char ch = str.charAt(end);
            uniqueCharsFreq.put(ch, uniqueCharsFreq.getOrDefault(ch, 0) + 1);
        }

        int substringCount = 0;
        List<String> substrings = new ArrayList<>();

        //if the first k-lengthed substring have all unique chars then freq map
        //will have keys equal to 'k' and hence its size will be same as 'k'
        //hence count should start from 1 also store this first k-lengthed substring
        if (uniqueCharsFreq.size() == k) {
            substringCount = 1;
            substrings.add(str.substring(start, end + 1));
        }

        while (end < n) {

            //here we will maintain the k-lengthed substring by adding char to @end
            //and reduce a char from @start if by reducing a char @start its freq becomes
            //0 then also remove that char
            char chEnd = str.charAt(end);
            uniqueCharsFreq.put(chEnd, uniqueCharsFreq.getOrDefault(chEnd, 0) + 1);

            char chStart = str.charAt(start);
            uniqueCharsFreq.put(chStart, uniqueCharsFreq.getOrDefault(chStart, 0) - 1);
            if (uniqueCharsFreq.get(chStart) <= 0) {
                uniqueCharsFreq.remove(chStart);
            }

            //as the curr window length is maintained as 'k' means we are considering
            //then next k-lengthed substring of str, now this k-lengthed substring
            //should have chars that are all unique, if that is the case then freq map
            //will have unique keys which will be equal to 'k'
            if (uniqueCharsFreq.size() == k) {
                //count how many such substrings are there
                substringCount++;
                //store all such substrings
                substrings.add(str.substring(start, end + 1));
            }

            end++;
            start++;
        }
        //output
        System.out.println("Substrings with length k and having unique chars : " + substringCount);
        System.out.println("Substrings with length k and having unique chars : " + substrings);
    }

    public boolean makeNumberOfDistinctCharsEqual(String word1, String word2) {
        //https://leetcode.com/problems/make-number-of-distinct-characters-equal/description/

        int[] word1Freq = new int[26];
        int[] word2Freq = new int[26];

        int distinctChrsWord1 = 0;
        int distinctChrsWord2 = 0;

        for (char chr : word1.toCharArray()) {

            word1Freq[chr - 'a']++;
            //if a new char counted as 1, will increase a distinct chars
            if (word1Freq[chr - 'a'] == 1) {
                distinctChrsWord1++;
            }
        }

        for (char chr : word2.toCharArray()) {

            word2Freq[chr - 'a']++;
            //if a new char counted as 1, will increase a distinct chars
            if (word2Freq[chr - 'a'] == 1) {
                distinctChrsWord2++;
            }
        }

        //char 'chi' represents chars in word1
        for (char chi = 'a'; chi <= 'z'; chi++) {

            //skip, if char 'chi' doesn't exists in word1
            if (word1Freq[chi - 'a'] == 0) {
                continue;
            }

            //char 'chj' represents chars in word2
            for (char chj = 'a'; chj <= 'z'; chj++) {

                //skip, if char 'chj' doesn't exists in word2
                if (word2Freq[chj - 'a'] == 0) {
                    continue;
                }

                //word1[...'chi'...] swap word2[...'chj'...]
                //swaps oprns include:
                //1. add chj to word1 & check if need to incr distinct char count
                //for word1
                //2. remove chi from from word1 & check if need to decr distinct
                //char count for word1
                //3. add chi to word2 & check if need to incr distinct char count
                //for word2
                //4. remove chj from from word2 & check if need to decr distinct
                //char count for word2
                //1............
                //swap char chj from word2 to word1 so now word1 will have 'chj'
                word1Freq[chj - 'a']++;
                //if this 'chj' is new distinct char added to word1, then incr
                //distinct char word1 count
                if (word1Freq[chj - 'a'] == 1) {
                    distinctChrsWord1++;
                }

                //2............
                //also swap 'chi' from word1 to word2 so now word1 will not have 'chi'
                word1Freq[chi - 'a']--;
                //if this 'chi' was a distinct char earlier,
                //then after decr this 'chi' if this distinct char from word1 freq is 0
                //means word1 lost an existing distinct char
                if (word1Freq[chi - 'a'] == 0) {
                    distinctChrsWord1--;
                }

                //3............
                //swap char chi from word1 to word2 so now word2 will have 'chi'
                word2Freq[chi - 'a']++;
                //if this 'chi' is new distinct char added to word2,
                //then incr distinct char word2 count
                if (word2Freq[chi - 'a'] == 1) {
                    distinctChrsWord2++;
                }

                //4............
                //also swap 'chj' from word2 to word1 so now word2 will not have 'chj'
                word2Freq[chj - 'a']--;
                //if this 'chj' was a distinct char earlier,
                //then after decr this 'chj' if this distinct char from word2 freq is 0
                //means word2 lost an existing distinct char
                if (word2Freq[chj - 'a'] == 0) {
                    distinctChrsWord2--;
                }

                //since we are allowed to have 'exactly one move' so in any 1 move
                //possible, if the distinct chars of both word1 & word2 are equal
                //then return true right away
                if (distinctChrsWord1 == distinctChrsWord2) {
                    return true;
                }

                //reverting the swap move done above
                word1Freq[chi - 'a']++;
                if (word1Freq[chi - 'a'] == 1) {
                    distinctChrsWord1++;
                }

                word1Freq[chj - 'a']--;
                if (word1Freq[chj - 'a'] == 0) {
                    distinctChrsWord1--;
                }

                word2Freq[chj - 'a']++;
                if (word2Freq[chj - 'a'] == 1) {
                    distinctChrsWord2++;
                }

                word2Freq[chi - 'a']--;
                if (word2Freq[chi - 'a'] == 0) {
                    distinctChrsWord2--;
                }
            }
        }
        return false;
    }

    private boolean concatenatedWords_IsConcatenated(
            String word, Set<String> wordsSet, Map<String, Boolean> cached) {

        int n = word.length();

        if (cached.containsKey(word)) {
            return cached.get(word);
        }

        for (int endIndex = 0; endIndex < n; endIndex++) {

            //ex: words[] = [cat, dog, catdog], and we are checking word = "catdog"
            //is formed from concatenation of words that also present in words[]
            //so we will break the 'word' into two parts
            //prefix = word[0 to i] and suffix = word[i + 1 to n]
            String prefix = word.substring(0, endIndex + 1);
            String suffix = word.substring(endIndex + 1);

            //there are now two possibilities where
            //1. both prefix and suffix exists as a valid word in words[]
            //ex: words[] have ["cat", "dog"] and a possible prefix & suffix
            //of curr 'word' = "[cat][dog]" is prefix = "cat" & suffix = "dog"
            if (wordsSet.contains(prefix) && wordsSet.contains(suffix)) {
                //cache the curr word result, so that if in future we end up
                //checking same word again, we get it from cache directly
                cached.put(word, true);
                //true, as curr 'word' is valid concatenated word
                return true;
            }

            //2. here prefix exists as a valid word in words[] but suffix doesn't
            //ex: words[] have ["cat", "do", "g"] now a possible prefix & suffix
            //of curr 'word' = "[cat][dog]" where prefix = "cat" exists in words[]
            //but suffix = "dog" doesn't, but to notice here we can also check if
            //this suffix can be called as concatenated word because in this ex
            //we can further break suffix = "dog" into prefix = "do" & suffix = "g"
            //which do exists as valid words in words[] = ["do", "g"]
            if (wordsSet.contains(prefix) && concatenatedWords_IsConcatenated(suffix, wordsSet, cached)) {
                //cache the curr word result, so that if in future we end up
                //checking same word again, we get it from cache directly
                cached.put(word, true);
                //true, as curr 'word' is valid concatenated word where suffix
                //can be sub-concatenated word
                return true;
            }
        }

        cached.put(word, false);
        //false, as above we could not find any valid break ups of curr 'word'
        return false;
    }

    public void concatenatedWords(String[] words) {
        //https://leetcode.com/problems/concatenated-words/description/
        //based on BRUTE FORCE + CACHING
        List<String> concatenatedWords = new ArrayList<>();
        int n = words.length;

        if (n == 1) {
            System.out.println("Concatenated words : " + concatenatedWords);
            return;
        }

        Set<String> wordsSet = new HashSet<>(Arrays.asList(words));
        Map<String, Boolean> cached = new HashMap<>();

        for (String word : words) {

            if (concatenatedWords_IsConcatenated(word, wordsSet, cached)) {
                concatenatedWords.add(word);
            }
        }

        //output
        System.out.println("Concatenated words : " + concatenatedWords);
    }

    public void longestRepeatingSubstring(String str) {
        //https://leetcode.com/problems/longest-repeating-substring/description/
        //https://leetcode.ca/all/1062.html
        //based on TRIE

        class TrieNode {

            Map<Character, TrieNode> nodes;

            public TrieNode() {
                this.nodes = new HashMap<>();
            }

        }

        int n = str.length();

        int longestRepeatingSubstring = 0;

        TrieNode ROOT = new TrieNode();

        //with below nested for() loops, we will be generating all the possible
        //substrings of given string 'str'. for each substring we will check if
        //the curr substring is seen before in the TRIE then we will just calculate
        //length of substring thus formed between [start to end]
        for (int start = 0; start < n; start++) {

            //from curr start, we will check further possible substrings, hence
            //TRIE might generate new substrings words from 'str' as
            //substring(start, end)
            TrieNode currRoot = ROOT;

            for (int end = start; end < n; end++) {

                char chr = str.charAt(end);

                //if the curr substring from [start to end] is already seen/saved
                //in TRIE earlier then we can calculate its length (end - start + 1)
                //as long as we if char 'chr' is part of TRIE word
                if (currRoot.nodes.containsKey(chr)) {

                    longestRepeatingSubstring = Math.max(
                            longestRepeatingSubstring,
                            end - start + 1);

                    currRoot = currRoot.nodes.get(chr);

                } else {

                    TrieNode node = new TrieNode();
                    currRoot.nodes.put(chr, node);
                    currRoot = node;
                }
            }
        }

        //output
        System.out.println("Longest repeating subtrings : " + longestRepeatingSubstring);
    }

    public void substringsBeginsAndEndsWithSameChar(String str) {
        //https://leetcode.com/problems/substrings-that-begin-and-end-with-the-same-letter/description/
        //https://leetcode.ca/2021-12-06-2083-Substrings-That-Begin-and-End-With-the-Same-Letter/
        /*
        str = "abcba"

        each single char substring is consider to be valid substring that begins
        and end with same chars

        hence "a", "b", "c", "b", "a"

        now counting freqs of each char helps in figuring other such substrings

        iterations:
        ##1.
        chr = a
        freqs[a]++ ==> 1
        count += freqs[a] = 0 + 1 ==> 1 {"a"}

        ##2.
        chr = b
        freqs[b]++ ==> 1
        count += freqs[b] = 1 + 1 ==> 2 {"a", "b"}

        ##3.
        chr = c
        freqs[c]++ ==> 1
        count += freqs[c] = 2 + 1 ==> 3 {"a", "b", "c"}

        ##4.
        chr = b
        freqs[b]++ ==> 2
        count += freqs[b] = 3 + 2 ==> 5 {"a", "b", "c", "bcb", "b"}

        ##5.
        chr = a
        freqs[a]++ ==> 2
        count += freqs[a] = 5 + 2 ==> 7 {"a", "b", "c", "bcb", "b", "abcba", "a"}


         */
        int n = str.length();
        int[] chrFreqs = new int[26];

        int substringsCount = 0;

        for (char chr : str.toCharArray()) {
            chrFreqs[chr - 'a']++;
            substringsCount += chrFreqs[chr - 'a'];
        }

        //output
        System.out.println("Substrings that begins and ends with same char : " + substringsCount);
    }

    public void minDeletionsToMakeStringBalanced1(String str) {
        //.............T: O(N), where N is length of string
        //.............S: O(N), for taking stack, in worst case stack can keep
        //all the chars of string str
        //https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/description/
        //based on STACK
        /*

        As per question requirement, a string will be balanced when the given
        string str don't have any 'b' char occuring before any 'a' char
        such that these char 'a' & 'b' should not form any pair(i, j) where i < j
        and str[i] = 'b' and str[j] = 'a' which means pair(i, j) ==> (b, a)

        ex of valid balanced string = "bbbb", "abbb", "aaab", "aaaa"
        in above examples all 'b's occure after all 'a's hence there will never
        be any pair(i, j) = (b, a)

         */
        Stack<Character> stack = new Stack<>();

        int deleteB = 0;

        for (char chr : str.toCharArray()) {
            //here, we will remove all those 'b's from str/stack who happens to
            //occur before any upcoming 'a' char in the string, this way, we will
            //prevent any pair(i, j) = (b, a) to occur in string
            if (!stack.isEmpty() && stack.peek() == 'b' && chr == 'a') {
                stack.pop();
                deleteB++;
            } else {
                stack.push(chr);
            }
        }
        //output
        System.out.println("Min deletions to make string balanced (approach 1 Stack): " + deleteB);
    }

    public void minDeletionsToMakeStringBalanced2(String str) {
        //.............T: O(N), where N is length of string
        //.............S: O(1)
        //https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/description/
        //OPTIMIZED
        /*

        As per question requirement, a string will be balanced when the given
        string str don't have any 'b' char occuring before any 'a' char
        such that these char 'a' & 'b' should not form any pair(i, j) where i < j
        and str[i] = 'b' and str[j] = 'a' which means pair(i, j) ==> (b, a)

        ex of valid balanced string = "bbbb", "abbb", "aaab", "aaaa"
        in above examples all 'b's occure after all 'a's hence there will never
        be any pair(i, j) = (b, a)

         */

        int aChr = 0;
        int bChr = 0;

        for (char chr : str.toCharArray()) {
            if (chr == 'a') {
                aChr++;
            }
        }

        int deletions = aChr;

        for (char chr : str.toCharArray()) {
            if (chr == 'b') {
                deletions = Math.min(deletions, aChr + bChr);
                bChr++;
            } else {
                aChr--;
            }
        }
        //output
        System.out.println("Min deletions to make string balanced (approach 2 without Stack): " + Math.min(deletions, bChr));
    }

    public void lexicographicallySmallestPallindrome(String str) {
        //https://leetcode.com/problems/lexicographically-smallest-palindrome/
        //based on TWO POINTER
        int n = str.length();
        char[] chrArr = str.toCharArray();
        int start = 0;
        int end = n - 1;

        //pallindorme is a string where the starting char matches the ending char
        while (end > start) {

            //if the two chars from their start and end ptr don't match, then
            //here we need to make it pallindrome,
            //for that we can assign both the start & end chars with same
            //value, so either chr @start = chr @end or vice versa
            //BUT, we also need to make this resulting pallindrome string
            //lexicographically smallest
            if (chrArr[start] != chrArr[end]) {
                //here we decide which char either from start & end will give
                //smallest char we will assign that smallest char to the other
                //index
                if (chrArr[start] < chrArr[end]) {
                    chrArr[end] = chrArr[start];
                } else {
                    chrArr[start] = chrArr[end];
                }
            }

            start++;
            end--;
        }
        //output
        str = String.valueOf(chrArr);
        System.out.println("Lexicographically smallest pallindrome : " + str);
    }

    public void groupShiftedStrings(String[] words) {
        //https://leetcode.com/problems/group-shifted-strings/description/
        class Helper {

            //in order for two words to be said in shifted sequence, their hashes
            //should remain same
            //word1 = "abc", word2 = "bcd"
            //hash(word1) = b - a, c - b ==> -1, -1
            //now they are negative +26 to balance and %26 to be in alphabetic
            //range and we can convert that 'hash' to a equivalent string
            //similarly
            //hash(word2) = c - b, d - c ==> -1, -1
            String getHash(String word) {

                int n = word.length();
                StringBuilder hashed = new StringBuilder();

                for (int i = 1; i < n; i++) {

                    int hash = ((word.charAt(i) - word.charAt(i - 1)) + 26) % 26;
                    hashed.append((char) (hash + 'a'));
                }

                return hashed.toString();
            }
        }

        Helper helper = new Helper();

        List<List<String>> shiftedString = new ArrayList<>();
        Map<String, List<String>> groups = new HashMap<>();

        for (String word : words) {

            String hash = helper.getHash(word);

            groups.putIfAbsent(hash, new ArrayList<>());
            groups.get(hash).add(word);
        }

        //output
        shiftedString.addAll(groups.values());
        System.out.println("Group shifted string : " + shiftedString);
    }

    public boolean stringTransformsIntoAnotherString(String str1, String str2) {
        //https://leetcode.com/problems/string-transforms-into-another-string/description/
        //based on checkIsomorphicStrings_2() little modified
        /*

        To convert str1 to str2, the following conditions must be satisfied:

        1. No character in str1 is mapped to multiple characters in str2.

        2. If the number of unique characters in str1 is 26, then either the
        number of unique letters in str2 should be strictly less than 26
        OR str1 equals str2.

         */
        int n = str1.length();

        //if both the strings are already same, then str1 can be transformed into
        //str2
        if (str1.equals(str2)) {
            return true;
        }

        Map<Character, Character> charMap = new HashMap<>();
        Set<Character> uniqueCharsStr2 = new HashSet<>();

        for (int i = 0; i < n; i++) {

            char chrStr1 = str1.charAt(i);
            char chrStr2 = str2.charAt(i);

            //return false, in case of a char 'chrStr1' is mapped to multiple
            //other chars chrStr2
            if (charMap.containsKey(chrStr1) && charMap.get(chrStr1) != chrStr2) {
                return false;
            }

            charMap.put(chrStr1, chrStr2);
            uniqueCharsStr2.add(chrStr2);
        }

        return uniqueCharsStr2.size() < 26;
    }

    public void shortestWordDistThree(String[] words, String word1, String word2) {
        //https://leetcode.com/problems/shortest-word-distance-iii/description/
        //https://leetcode.com/problems/shortest-word-distance/description/
        int n = words.length;

        //finding abs() with -n will provide a larger dist value and hence we
        //need to find min dist, this large value will not bother the logic
        //however, if we wish to default with -1 which is also OK but then
        //we need to provide check as (word1Index != -1 && word2Index != -1)
        //on 2 if() blocks below where we are calculating minDist
        int word1Index = -n;
        int word2Index = -n;

        int minDist = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {

            String currWord = words[i];

            if (currWord.equals(word1)) {
                word1Index = i;
            }

            if (word1.equals(word2) && word1Index != word2Index) {
                minDist = Math.min(minDist, Math.abs(word1Index - word2Index));
            }

            if (currWord.equals(word2)) {
                word2Index = i;
            }

            if (word1Index != word2Index) {
                minDist = Math.min(minDist, Math.abs(word1Index - word2Index));
            }
        }

        //output
        System.out.println("Shortest word distance three : " + minDist);
    }

    public void reverseWordsInStringTwo(char[] chrArr) {
        //https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
        int n = chrArr.length;

        class Helper {

            void reverse(char[] arr, int start, int end) {

                while (end > start) {
                    char temp = arr[start];
                    arr[start] = arr[end];
                    arr[end] = temp;

                    start++;
                    end--;
                }
            }
        }

        Helper helper = new Helper();

        //first reverse the whole chrArr[] string
        helper.reverse(chrArr, 0, n - 1);

        int start = 0;
        int end = 0;

        //loop over the reversed chrArr[] string
        while (end < n) {

            //find the first word, a word will end with a space ' ' char
            while (end < n && chrArr[end] != ' ') {
                end++;
            }

            //above loop will break when the end index is at space ' ' char
            //but the word with chars is in range [start to end - 1]
            //end - 1 means char just before space is the last char of curr word
            helper.reverse(chrArr, start, end - 1);

            //move end ptr to next char after the curr space ' ' char
            end += 1;
            //next word should start from new end-th char after space ' ' char
            start = end;
        }

        //output
        System.out.println("Reverse words in string two : " + Arrays.toString(chrArr));
    }

    public void removeDuplicateLettersToMakeLexicographicallySmallestString(String str) {
        //https://leetcode.com/problems/remove-duplicate-letters/description/
        //https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/
        //based on nextGreaterElementToRightInArray()
        /*

        iterations:

        ex: str = "cbacdcbc"

        //lexicographically smallest string from str having all unique chars
        output = "acdb"

        visited[26] = [false, false, ...., false]
        chrLastIndex[26] = [0, 0, ... 0]

        //put last index of each char
        for(index = 0 to index < n) chrLastIndex[chr] = index;

        str = "cbacdcbc"
        chrLastIndex[] = [a = 2, b = 6, c = 7, d = 4]

        stack = {}

        #1.
        index = 0
        chr = c
        if(visited[c]) ==> FALSE

        while(!stack.isEmpty()) ==> FALSE

        stack.append(chr) = {c} <-- PEEK
        visited[c] = true ==> [c = true]

        #2.
        index = 1
        chr = b
        if(visited[b]) ==> FALSE

        while(!stack.isEmpty() && stack.peek('c') > 'b' && 1 < lastIndex[stack.peek('c')](==> 7)) ==> TRUE
        //1 < lastIndex[stack.peek('c')](==> 7) means if we pop 'c' here we can again get
        //'c' later after curr 'index' i.e, at index ==> 7
        ==> visited[stack.peek('c')] = false ==> [c = false]
        ==> stack.pop('c') ==> {} <-- PEEK

        stack.append(chr) = {b} <-- PEEK
        visited[b] = true ==> [c = false, b = true]

        #3.
        index = 2
        chr = a
        if(visited[a]) ==> FALSE

        while(!stack.isEmpty() && stack.peek('b') > 'a' && 2 < lastIndex[stack.peek('b')](==> 6)) ==> TRUE
        //2 < lastIndex[stack.peek('b')](==> 6) means if we pop 'b' here we can again get
        //'b' later after curr 'index' i.e, at index ==> 6
        ==> visited[stack.peek('b')] = false ==> [c = false, b = false]
        ==> stack.pop('b') ==> {} <-- PEEK

        stack.append(chr) = {a} <-- PEEK
        visited[a] = true ==> [c = false, b = false, a = true]

        #4.
        index = 3
        chr = c
        if(visited[c]) ==> FALSE

        while(!stack.isEmpty() && stack.peek('a') > 'c') ==> FALSE

        stack.append(chr) = {a, c} <-- PEEK
        visited[a] = true ==> [c = true, b = false, a = true]

        #5.
        index = 4
        chr = d
        if(visited[d]) ==> FALSE

        while(!stack.isEmpty() && stack.peek('c') > 'd') ==> FALSE

        stack.append(chr) = {a, c, d} <-- PEEK
        visited[a] = true ==> [c = true, b = false, a = true, d = true]

        #6.
        index = 5
        chr = c
        if(visited[c]) ==> TRUE ==> SKIPPED

        #7.
        index = 6
        chr = b
        if(visited[b]) ==> FALSE

        while(!stack.isEmpty() && stack.peek('d') > 'b' && 6 < lastIndex[stack.peek('d')](==> 4)) ==> FALSE
        //6 < lastIndex[stack.peek('d')](==> 4) here, we see that curr 'chr' ==> 'b' is samller
        //than peek('d') ideally 'b' should pop out 'd' as 'd' > 'b' but if this pop oprn
        //made here then we will never have a char 'd' after this curr index ==> 6 because
        //last time char 'd' occured at index ==> 4 meaning no char 'd' after index 6
        //so this last index check prevents any char to pop out if we can't get it later

        stack.append(chr) = {a, c, d, b} <-- PEEK
        visited[a] = true ==> [c = true, b = true, a = true, d = true]

        #8.
        index = 7
        chr = c
        if(visited[c]) ==> TRUE ==> SKIPPED

        ...END...

        stack = {a, c, d, b}
        ==> "acdb" lexicographically smallest string having all unique chars

         */
        int n = str.length();

        boolean[] visited = new boolean[26];
        int[] chrLastIndex = new int[26];

        //save the last occuring index of each char from str
        for (int index = 0; index < n; index++) {
            chrLastIndex[str.charAt(index) - 'a'] = index;
        }

        //stringbuilder is used as stack(monotonic incr stack)
        StringBuilder stack = new StringBuilder();

        for (int index = 0; index < n; index++) {

            char chr = str.charAt(index);

            //since we need to remove duplicate letters, so if curr 'chr' is
            //already considered in curr lexicographically smallest string
            //then we need not to add the same char if visited again
            if (visited[chr - 'a']) {
                continue;
            }

            while (!stack.isEmpty()
                    //char at stack peek is greater than curr 'chr' then pop
                    //that 'chr' as we need to make lexicographically smallest
                    //string ex: peek = 'd' chr = 'a' ==> 'd' > 'a' ==> pop('d')
                    && stack.charAt(stack.length() - 1) > chr
                    //if we choose to pop the char at peek, means this peek char
                    //will be marked as unvisited(so that it can be added later)
                    //but this peek char CAN ONLY BE POPPED IF WE KNOW THAT THIS
                    //PEEK CHAR WILL ALSO OCCUR AFTER CURR INDEX otherwise if we
                    //just remove it and we didn't find the same char later in
                    //str then it means we will never make a smallest str that
                    //will contain all unique chars of str
                    //ex: peek = 'd', chr = 'a' ==> 'd' > 'a' ==> pop('d') only
                    //if 'd' also occurs after this char 'a' meaning after curr
                    //'index'
                    && index < chrLastIndex[stack.charAt(stack.length() - 1) - 'a']) {

                //mark the peek char as unvisited again, so that it can be
                //added later
                visited[stack.charAt(stack.length() - 1) - 'a'] = false;

                //pop the char at peek
                stack.deleteCharAt(stack.length() - 1);
            }

            //add a smallest char into the stack
            stack.append(chr);
            //as we have added a unique char here, to prevent visiting the same
            //char later on, mark this 'chr' as visited
            visited[chr - 'a'] = true;
        }

        String smallestStringWithUniqueChars = stack.toString();
        System.out.println("Remove duplicate letters to make lexicographically smallest string : "
                + smallestStringWithUniqueChars);
    }

    public void maxScoreAfterSplittingBinaryString(String str) {
        //https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/

        int n = str.length();

        int countRightZeroes = 0;
        int countRightOnes = 0;

        //count all the 0s & 1s as one right-substring part
        for (char chr : str.toCharArray()) {
            if (chr == '0') {
                countRightZeroes++;
            } else {
                countRightOnes++;
            }
        }

        //initailly 0s & 1s in left-substring part are 0
        int countLeftZeroes = 0;
        int countLeftOnes = 0;

        int maxScore = 0;

        //iterating over 0s & 1s of 'str', we will shift 0s or 1s from right side
        //to left side
        for (int i = 0; i < n - 1; i++) {

            char chr = str.charAt(i);

            //shifting 0s from right to left
            if (chr == '0') {
                //hence count of curr '0' will be reduced in right-substring
                countRightZeroes--;
                //also at the same time we added the same '0' to left-substring
                //incr the count of '0' in left side
                countLeftZeroes++;
            } else {
                //hence count of curr '1' will be reduced in right-substring
                countRightOnes--;
                //also at the same time we added the same '1' to left-substring
                //incr the count of '1' in left side
                countLeftOnes++;
            }

            //score of curr left & right substring partition is
            //count of 0s in left-substring + count 1s in right-substring
            maxScore = Math.max(maxScore, countLeftZeroes + countRightOnes);
        }

        //output
        System.out.println("Max score after splitting binary string : " + maxScore);
    }

    public void longestAbsoluteFilePath(String path) {
        //https://leetcode.com/problems/longest-absolute-file-path/description/

        int SLASH = 1;

        //the given 'path' is having '\n' & '\t' chars, after splitting path
        //on '\n', remaining path in split[] will have '\t' chars that should
        //be removed while counting for path length
        String[] pathSplit = path.split("\n");

        Stack<Integer> stack = new Stack<>();

        //this -1 balances off a '/' added to root dir of the given path
        //ideally, there is no '/' required before a root dir as "/root"
        //but the logic below will actually add this extra '/', this -1
        //will balance off that
        stack.push(-1);

        int maxPathLength = 0;

        for (String each : pathSplit) {

            //the way '\t' are given in string 'path' actually defines how
            //much depth a file or dir is in from its parent dir
            //except for root dir it will not have '\t' before it indicating
            //level 0 and also tabsCount will 0
            int level = 0;

            //same '\t' should be counted, but for root dir it will 0
            int tabsCount = 0;

            level = tabsCount = each.lastIndexOf("\t") + 1;

            while (level + 1 < stack.size()) {
                stack.pop();
            }

            //when we were processing the very first dir i.e, root dir this below
            //line stack.peek() + SLASH + (each.length() - tabsCount) will add '/'
            //to root as "/root" hence its length will be counted as "/root" = 5
            //but actualy its should be "root" and length should be "root" = 4
            //for that reason stack has initial length -1 to balance off as
            //stack.peek() + SLASH + (each.length() - tabsCount) as this
            //will be -1 + 1 + ("root".length - tabsCount) ==> (-1 + 1 + (4 - 0))
            //after spliting 'path' based on '\n' each file or dir name is having
            //'\t' chars in their starting, so to remove that -tabsCount from 'each'
            int currPathLength = stack.peek() + SLASH + (each.length() - tabsCount);

            stack.push(currPathLength);

            //max path length must be calculated if absolute path is ending with
            //file as some "file.ext"
            if (each.contains(".")) {
                maxPathLength = Math.max(maxPathLength, currPathLength);
            }
        }

        //output
        System.out.println("Longest absolute file path : " + maxPathLength);
    }

    public void sortVowelsInString(String str) {
        //https://leetcode.com/problems/sort-vowels-in-a-string/description/
        int n = str.length();
        char[] arr = str.toCharArray();

        Set<Character> checkIfVowel = new HashSet<>(
                Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));

        List<Character> vowels = new ArrayList<>();

        for (int i = 0; i < n; i++) {

            //if the curr i-th char is a vowel, save that vowels
            if (checkIfVowel.contains(arr[i])) {

                vowels.add(arr[i]);
                //mark the i-th char as empty '.' to put the sorted vowel
                //later on
                arr[i] = '.';
            }
        }

        //sort the vowel, it will automatically based on their ASCII values
        Collections.sort(vowels);

        int index = 0;

        for (int i = 0; i < n; i++) {

            if (arr[i] != '.') {
                continue;
            }

            //put the sorted vowel char at curr i-th empty '.' vowel spot
            arr[i] = vowels.get(index++);
        }

        //output
        System.out.println("Sort vowels in string : " + String.valueOf(arr));
    }

    public void minPenaltyForShop(String customers) {
        //https://leetcode.com/problems/minimum-penalty-for-a-shop/description/
        int n = customers.length();
        int maxPenalty = 0;
        int penalty = 0;
        int earliestClosingHour = -1;

        for (int hour = 0; hour < n; hour++) {

            penalty += customers.charAt(hour) == 'Y' ? 1 : -1;

            if (penalty > maxPenalty) {
                maxPenalty = penalty;
                earliestClosingHour = hour;
            }
        }

        //output
        earliestClosingHour += 1;
        System.out.println("Earliest closing hour to have min penalty for shop : " + earliestClosingHour);
    }

    public boolean removeLetterToEqualizeFreq(String word) {
        //https://leetcode.com/problems/remove-letter-to-equalize-frequency/description/
        //not easy as it is tagged on leetcode

        int n = word.length();

        char[] wordCharArr = word.toCharArray();

        //sort the char array of word, this will help in preventing deleting a same
        //char again and again, because deleting a char that has been checked before
        //will generate the same result
        //ex: word = "aabbccabc"
        //below for() loop simulates deleting each char of word and calculate the
        //freqs of rest of the chars of word, BUT observe deleteing char @delete
        //index = 0 i.e, word[0] = 'a' will have same freqs[] count as if we delete
        //any other occuerences of 'a' i.e, word[1] or word[6]
        //same is true for 'b' ==> word[2], word[3], word[7] and also for 'c'
        //this means freqs calculation should not be done on same char again & again
        //sort(wordCharArr) = [a,a,a,b,b,b,c,c,c], once we have calculated freqs
        //over a char @delete index, we can skip next delete index if both prev
        //char and curr char are same
        Arrays.sort(wordCharArr);

        int[] freqs = new int[26];

        for (char chr : wordCharArr) {
            freqs[chr - 'a']++;
        }

        //simulate deleting each char from string word @delete index
        for (int delete = 0; delete < n; delete++) {

            //avoid, calculating the freqs[] on same chars again & again
            if (delete == 0 || wordCharArr[delete - 1] != wordCharArr[delete]) {

                //as we are simulating deleting the char @delete index, freqs for
                //the char should be calculated(not including deleted char)
                freqs[wordCharArr[delete] - 'a']--;

                //after deleting a char @delete index and calculating the freqs for
                //rest the of chars in word, we will check here if the curr deletion
                //made the freqs of remaining chars 'equalized'
                int prevFreqVal = -1;
                //assuming that with current deletion, freqs of remaining chars can
                //be 'equalized'
                boolean equalizePossibleWithCurrentDeletion = true;

                for (int i = 0; i < 26; i++) {

                    //skip, if the char never existed in word
                    //OR if word had just one occurence of 'char' but that got
                    //deleted above so now its freqs is 0
                    //ex: word = "abcc", freqs['a'] = 1 above char @delete = 0 is
                    //deleted so freqs['a'] = 0
                    if (freqs[i] == 0) {
                        continue;
                    }

                    //if prevFreqsval is some valid freq from freqs[] AND the freqs[]
                    //of two chars are not equal (prevFreqVal != freqs[i]) meaning
                    //the curr delete have not made 'word' equalized, hence
                    //equalizePossibleWithCurrentDeletion is false
                    if (prevFreqVal != -1 && prevFreqVal != freqs[i]) {
                        //freqs of remaining chars don't match, equalized is not
                        //possible
                        equalizePossibleWithCurrentDeletion = false;
                        break;
                    }

                    prevFreqVal = freqs[i];
                }

                //return true right away, if the char deleted @delete index made the
                //freqs of remaining chars of 'word' equalized
                if (equalizePossibleWithCurrentDeletion) {
                    return true;
                }

                //if delete a char @delete index did not make rest of chars freqs
                //equalized then add back the char which was delete(by incr its freq)
                //and move to next delete index to check
                freqs[wordCharArr[delete] - 'a']++;
            }
        }

        return false;
    }

    public void numberOfValidClockTimes(String time) {
        //https://leetcode.com/problems/number-of-valid-clock-times/description/
        /*

        ex: "??:??"

        HH
        ?? ==> range = [00 to 23] ==> 24 hour possibilities

        MM
        ?? ==> range = [00 to 59] ==> 60 min possibilities

        total combinational possibilities = 24 * 60 ==> 1440

        also, to check following cases

        For HH:

        1. hour cases ==> "0?", "1?", "2?"
        hrSecond has following possibilities

        0 ==> [0 to 9] ==> 10 possibilities ==> [00 to 09] hour
        also
        1 ==> [0 to 9] ==> 10 possibilities ==> [10 to 19] hour
        but
        2 ==> [0 to 3] ==> 4 possibilities ==> [20 to 23] hour

        also adds up to 24 hour possibilities

        2. hour cases ==> "?9", "?9", "?3"
        hrFirst has following possibilities

        [0 to 9] ==> 2 possibilities ==> [0, 1] ==> [0{0 to 9}] hour or [1{0 to 9}] hour
        but
        [0 to 2] ==> 3 possibilities ==> [0,1,2] ==> [0{0 to 3}] hour, [1{0 to 3}] hour, [2{0 to 3}] hour


        For MM:

        for min its straight forward

        1. min cases ==> "0?", "1?", "2?", "3?", "4?", "5?"
        minSecond has following possibilities

        [0 to 9] ==> 10 possibilities ==> [00 to 59] min

        2. min cases ==> "?0", "?9"
        minFirst has following possibilities

        [0 to 5] ==> 6 possibilities ==> [0{0 to 9}, 1{0 to 9}, 2{0 to 9} ... 5{0 to 9}] min

         */

        char hourFirstPart = time.charAt(0);
        char hourSecondPart = time.charAt(1);
        char minFirstPart = time.charAt(3);
        char minSecondPart = time.charAt(4);

        int hourPossibilities = 1;

        if (hourFirstPart == '?' && hourSecondPart == '?') {
            hourPossibilities = 24;
        } else if (hourFirstPart == '?') {
            hourPossibilities = (hourSecondPart - '0') <= 3 ? 3 : 2;
        } else if (hourSecondPart == '?') {
            hourPossibilities = (hourFirstPart - '0') <= 1 ? 10 : 4;
        }

        int minPossibilities = 1;

        if (minFirstPart == '?' && minSecondPart == '?') {
            minPossibilities = 60;
        } else if (minFirstPart == '?') {
            minPossibilities = 6;
        } else if (minSecondPart == '?') {
            minPossibilities = 10;
        }

        int numberOfValidClockTimes = hourPossibilities * minPossibilities;
        System.out.println("Number of valid clock times : " + numberOfValidClockTimes);
    }

    public int maxRepeatingSubstring(String subsequence, String word) {
        //https://leetcode.com/problems/maximum-repeating-substring/description/
        //based on BRUTE FORCE USING KMP PATTERN MATCHING ALGO
        class Helper {

            int[] createLPSArray(String pattern) {

                int n = pattern.length();

                int[] lps = new int[n];

                int prefixIndex = 0;
                int suffixIndex = 1;

                while (suffixIndex < n) {

                    if (pattern.charAt(prefixIndex) == pattern.charAt(suffixIndex)) {
                        prefixIndex++;
                        lps[suffixIndex] = prefixIndex;
                        suffixIndex++;
                    } else if (prefixIndex == 0) {
                        lps[suffixIndex] = prefixIndex;
                        suffixIndex++;
                    } else {
                        prefixIndex = lps[prefixIndex - 1];
                    }
                }

                return lps;
            }

            boolean patternMatching(String subsequence, String pattern) {

                int m = subsequence.length();
                int n = pattern.length();

                int[] lps = createLPSArray(pattern);

                int subseqIndex = 0;
                int patternIndex = 0;

                while (subseqIndex < m) {

                    if (subsequence.charAt(subseqIndex) == pattern.charAt(patternIndex)) {
                        subseqIndex++;
                        patternIndex++;
                    } else if (patternIndex == 0) {
                        subseqIndex++;
                    } else {
                        patternIndex = lps[patternIndex - 1];
                    }

                    if (patternIndex == n) {
                        return true;
                    }
                }

                return false;
            }
        }

        Helper helper = new Helper();

        int subseqLength = subsequence.length();
        int wordLength = word.length();

        int maxRepeatsAllowed = (subseqLength / wordLength) + 1;

        StringBuilder repeats = new StringBuilder(word);

        for (int k = 0; k <= maxRepeatsAllowed; k++) {

            if (!helper.patternMatching(subsequence, repeats.toString())) {
                return k;
            }

            repeats.append(word);
        }

        return 0;
    }

    private int substringsWithKDistinctCharacters_SlidingWindowHelper(String str, int k) {

        int n = str.length();

        Map<Character, Integer> freqs = new HashMap<>();

        int substrings = 0;

        int start = 0;
        int end = 0;

        while (end < n) {

            freqs.put(str.charAt(end), freqs.getOrDefault(str.charAt(end), 0) + 1);

            while (freqs.size() > k) {

                freqs.put(str.charAt(start), freqs.getOrDefault(str.charAt(start), 0) - 1);

                if (freqs.get(str.charAt(start)) <= 0) {
                    freqs.remove(str.charAt(start));
                }

                start++;
            }

            substrings += (end - start + 1);

            end++;
        }

        return substrings;
    }

    public void substringsWithKDistinctCharacters(String str, int k) {
        //https://leetcode.com/problems/subarrays-with-k-different-integers/description/
        //https://leetcode.com/discuss/interview-question/370157
        //https://practice.geeksforgeeks.org/problems/count-number-of-substrings4528/1
        //based on SLIDING WINDOW, subarrayWithKDifferentIntegers()
        /*

        str = "aba", k = 2
        substrings = "ab", "ba", "aba"

        simple basic sliding window will fail on such examples so we need to think
        in a little different way

        intuition:
        here, if we were to find all the counts of substrings that have
        'atmost k' distinct chars
        (note: atmost k means, substrings can have 1 to atmax of k distinct chars)

        if k = 2, we would be generating substrings with
        ==> atmost k distinct chars = {"a", "ab", "b", "ba", "a", "aba"}

        also, we can easily find count of substrings with
        ==> atmost (k - 1) distinct chars = {"a", "b", "a"}

        if we subtract the common substrings from both the results we will see
        it will leave out count of substrings that will have 'exactly k distinct chars'
        and that we need as our result

        ==> substrings with 'atmost k' distinct chars - substrings with 'atmost (k - 1)' distinct chars
        ==> {"a", "ab", "b", "ba", "a", "aba"} - {"a", "b", "a"}
        ==> {"ab", "ba", "aba"} ==> substrings with exactly k distinct chars
        ==> count = 3

         */
        int substringsWithExactKDistinctChars
                = substringsWithKDistinctCharacters_SlidingWindowHelper(str, k)
                - substringsWithKDistinctCharacters_SlidingWindowHelper(str, k - 1);

        //output
        System.out.println("Substrings with exactly k distinct chars : " + substringsWithExactKDistinctChars);
    }

    public Node<Integer> reverseLinkedList_Iterative(Node<Integer> node) {
        System.out.println("Reverse linked list iterative");
        //actual
        new LinkedListUtil<>(node).print();

        Node<Integer> curr = node;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        while (curr != null) {

            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        //output
        new LinkedListUtil<>(prev).print();

        //to use by other methods when req
        return prev;
    }

    Node<Integer> reverseLinkedList_Recursive_NewHead;

    private Node<Integer> reverseLinkedList_Recursive_Helper(Node<Integer> node) {

        if (node.getNext() == null) {
            reverseLinkedList_Recursive_NewHead = node;
            return node;
        }

        Node<Integer> revNode = reverseLinkedList_Recursive_Helper(node.getNext());
        revNode.setNext(node);
        node.setNext(null);

        return node;
    }

    public void reverseLinkedList_Recursive(Node<Integer> node) {
        System.out.println("Reverse linked list recursive");
        //actual
        LinkedListUtil<Integer> ll = new LinkedListUtil<>(node);
        ll.print();

        reverseLinkedList_Recursive_Helper(node);

        //output
        LinkedListUtil<Integer> output = new LinkedListUtil<>(reverseLinkedList_Recursive_NewHead);
        output.print();

    }

    private Stack<Integer> sumOfNumbersAsLinkedList_ByStack_ToStack(Node<Integer> node) {

        Stack<Integer> s = new Stack<>();
        Node<Integer> temp = node;
        while (temp != null) {

            s.push(temp.getData());
            temp = temp.getNext();

        }

        return s;

    }

    public void sumOfNumbersAsLinkedList_ByStack(Node<Integer> n1, Node<Integer> n2) {

        //..................................T: O(N1 + N2) where N1 = n1.length, N2 = n2.length
        //..................................S: O(N1 + N2) because of 2 stacks used
        Stack<Integer> nS1 = sumOfNumbersAsLinkedList_ByStack_ToStack(n1);
        Stack<Integer> nS2 = sumOfNumbersAsLinkedList_ByStack_ToStack(n2);

        int carry = 0;
        LinkedListUtil<Integer> ll = new LinkedListUtil<>();
        while (!nS1.isEmpty() || !nS2.isEmpty()) {

            int sum = carry;

            if (!nS1.isEmpty()) {
                sum += nS1.pop();
            }

            if (!nS2.isEmpty()) {
                sum += nS2.pop();
            }

            carry = sum / 10;
            ll.addAtHead(sum % 10);

        }

        if (carry > 0) {
            ll.addAtHead(carry);
        }

        //output
        ll.print();

    }

    public void sumOfNumbersAsLinkedList_ByReversingList(Node<Integer> n1, Node<Integer> n2) {

        //OPTIMISED
        //..................................T: O(N1 + N2) where N1 = n1.length, N2 = n2.length
        //..................................S: O(1)
        Node<Integer> n1Rev = reverseLinkedList_Iterative(n1);
        Node<Integer> n2Rev = reverseLinkedList_Iterative(n2);

        Node<Integer> head = null;

        int carry = 0;
        while (n1Rev != null || n2Rev != null) {

            int sum = carry;

            if (n1Rev != null) {
                sum += n1Rev.getData();
                n1Rev = n1Rev.getNext();
            }

            if (n2Rev != null) {
                sum += n2Rev.getData();
                n2Rev = n2Rev.getNext();
            }

            //adding start ptr as head
            Node<Integer> start = new Node<>(sum % 10);
            start.setNext(head);
            head = start;
            carry = sum / 10;
        }

        if (carry > 0) {
            Node<Integer> start = new Node<>(carry);
            start.setNext(head);
            head = start;
        }

        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void removeDuplicateFromSortedLinkedList(Node<Integer> head) {

        //actual
        new LinkedListUtil<>(head).print();

        Node<Integer> curr = head;
        Node<Integer> temp = head.getNext();

        while (temp != null) {
            if (curr.getData() != temp.getData()) {
                curr.setNext(temp);
                curr = temp;
            }
            temp = temp.getNext();
        }

        curr.setNext(temp);

        //output
        new LinkedListUtil<>(head).print();
    }

    public void mergeKSortedLinkedList(Node<Integer>[] nodes) {

        //............................T: O(N*K*LogK)
        //............................S: O(K)
        //https://www.geeksforgeeks.org/merge-k-sorted-linked-lists-set-2-using-min-heap/
        //HEAP based method
        PriorityQueue<Node<Integer>> minHeap = new PriorityQueue<>(
                (o1, o2) -> o1.getData().compareTo(o2.getData())
        );

        //at this point we have added K node heads in minHeap
        //so the minheap size after this loop will K
        for (Node<Integer> node : nodes) {
            if (node != null) {
                minHeap.add(node);
            }
        }

        //head to point arbitary infinite value to start with
        Node<Integer> head = new Node<>(Integer.MIN_VALUE);
        //saving the actual head's ref
        Node<Integer> copyHead = head;
        while (!minHeap.isEmpty()) {

            //we poll out one node from heap
            Node<Integer> curr = minHeap.poll();
            //and add in one node
            //if its next node is not null
            //so the size of the min heap remains atmost K
            if (curr.getNext() != null) {
                minHeap.add(curr.getNext());
            }
            //isolate the current node by saying curr.next=NULL,
            //also curr.next node value is already preserved in
            //minHeap(above if block), if not null already
            curr.setNext(null);
            copyHead.setNext(curr);
            copyHead = copyHead.getNext();
        }

        //actual merged list starts with next of arbitary head pointer
        new LinkedListUtil<>(head.getNext()).print();
    }

    public void kThNodeFromEndOfLinkedList_1(Node node, int K) {
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //1. Approach
        //using additional space (Stack)
        //................O(N)+O(K)
        //time O(N) creating stack of N nodes from linked list + O(K) reaching out to Kth node
        //in the stack.
        //.......................space complexity O(N)
        Stack<Node> stack = new Stack<>();
        Node temp = node;
        //T: O(N)
        //S: O{N}
        while (temp != null) {
            stack.push(temp);
            temp = temp.getNext();
        }

        //T: O(K)
        while (!stack.isEmpty()) {

            K--;
            Object element = stack.pop().getData();
            if (K == 0) {
                System.out.println("Kth node from end is: " + element);
            }
        }
    }

    public void kThNodeFromEndOfLinkedList_2(Node node, int K) {
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //2. Approach
        //using Len - K + 1 formula
        //calculate the full length of the linked list frst
        //then move the head pointer upto (Len - K + 1) limit which
        // is Kth node from the end
        //.................T: O(N) + O(Len - K + 1)
        //1. calculating Len O(N)
        //2. moving to Len - k + 1 pointer is O(Len - K + 1)
        int len = 0;
        Node temp = node;
        while (temp != null) {
            temp = temp.getNext();
            len++;
        }

        //Kth node from end = len - K + 1
        temp = node;
        //i=1 as we consider the first node from 1 onwards
        for (int i = 1; i < (len - K + 1); i++) {
            temp = temp.getNext();
        }

        //output
        System.out.println("Kth node from end is: " + temp.getData());

    }

    public void kThNodeFromEndOfLinkedList_3(Node head, int K) {
        //https://leetcode.com/problems/remove-nth-node-from-end-of-list/
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
        //3. Approach (OPTIMISED)
        //Two pointer method
        //Theory:
        //maintain ref pointer, main pointer
        //both start from the head ref
        //move ref pointer to K dist. Once ref pointer reaches the K dist from main pointer
        //start moving the ref and main pointer one by one.
        //at the time ref pointer reaches the end of linked list
        //main pointer will be K dist behind the ref pointer(already at end now)
        //print the main pointer that will be answer
        //............T: O(N) S: O(1)
        Node front = head;
        Node back = head;

        while (front != null && K-- != 0) {
            front = front.getNext();
            if (front == null) {
                front = head;
            }
        }

        if (front == head) {
            //output
            System.out.println("Kth node from end is: " + back.getData());
            return;
        }

        //now ref is K dist ahead of main pointer
        //now move both pointer one by one
        //until ref reaches end of linked list
        //bt the time main pointer will be K dist behind the ref pointer
        while (front != null) {
            back = back.getNext();
            front = front.getNext();
        }

        //output
        System.out.println("Kth node from end is: " + back.getData());
    }

    public Node<Integer> swapLinkedListNodesInPair(Node<Integer> node) {

        //https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
        //https://leetcode.com/problems/swap-nodes-in-pairs/
        int K = 2; //because swap in pairs;
        Node current = node;
        Node next = null;
        Node prev = null;

        int count = 0;

        /* Reverse first k nodes of linked list */
        while (count < K && current != null) {
            next = current.getNext();
            current.setNext(prev);
            prev = current;
            current = next;
            count++;
        }

        /* next is now a pointer to (k+1)th node
         Recursively call for the list starting from current.
         And make rest of the list as next of first node */
        if (next != null) {
            node.setNext(swapLinkedListNodesInPair(next));
        }

        // prev is now head of input list
        return prev;
    }

    public Node<Integer> reverseLinkedListInKGroups(Node<Integer> head, int K) {
        //https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
        //https://leetcode.com/problems/reverse-nodes-in-k-group/
        Node current = head;
        int count = 0;
        //in case the passed LinkedList length is less than k
        while (count < K && current != null) {
            current = current.getNext();
            count++;
        }

        if (count < K) {
            return head;
        }

        current = head;
        Node next = null;
        Node prev = null;

        count = 0;

        /* Reverse first k nodes of linked list */
        while (count < K && current != null) {
            next = current.getNext();
            current.setNext(prev);
            prev = current;
            current = next;
            count++;
        }

        /* next is now a pointer to (k+1)th node
         Recursively call for the list starting from current.
         And make rest of the list as next of first node */
        if (next != null) {
            head.setNext(reverseLinkedListInKGroups(next, K));
        }

        // prev is now head of input list
        return prev;
    }

    public Node<Integer> reverseLinkedListInKGroupsAlternatively(Node<Integer> head, int K) {

        //Adaptation of reverseLinkedListInKGroups method
        //reverse first K groups
        Node<Integer> curr = head;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        int count = 0;

        while (count < K && curr != null) {

            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;

            count++;
        }

        //move straight K nodes without reversing
        count = 0;
        while (count < K && next != null) {

            head.setNext(next);
            head = head.getNext();
            next = next.getNext();
            count++;
        }

        //pass the alternate K group recursively
        if (next != null) {
            head.setNext(reverseLinkedListInKGroupsAlternatively(next, K));
        }

        return prev;
    }

    public boolean detectLoopCycleInLinkedList_HashBased(Node node) {

        //......................T: O(N)
        //......................S: O(N)
        Set<Node> set = new HashSet<>();
        Node temp = node;
        while (temp != null) {

            if (set.contains(temp)) {
                System.out.println("Hash Based Cycle at: " + temp.getData());
                return true;
            }
            set.add(temp);
            temp = temp.getNext();
        }

        System.out.println("Hash Based No cycle found");
        return false;
    }

    public boolean detectLoopCycleInLinkedList_Iterative(Node head) {

        //......................T: O(N)
        //......................S: O(1)
        Node slow = head;
        Node fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            if (slow == fast) {
                break;
            }
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        if (slow == fast) {
            slow = head;
            while (slow != fast.getNext()) {
                slow = slow.getNext();
                fast = fast.getNext();
            }

            //fast.next is where the loop starts...
            System.out.println("Iterative approach Cycle at: " + fast.getNext().getData());
            return true;
        }

        System.out.println("Iterative approach No cycle found");
        return false;
    }

    public void detectAndRemoveLoopCycleInLinkedList_HashBased(Node node) {

        //......................T: O(N)
        //......................S: O(N)
        Set<Node> set = new HashSet<>();
        Node loopEnd = null;
        Node temp = node;
        while (temp != null) {

            if (set.contains(temp)) {
                loopEnd.setNext(null);
                break;
            }

            set.add(temp);
            loopEnd = temp;
            temp = temp.getNext();
        }

        //output;
        System.out.println("Hash Based approach detect and remove a loop cycle in linked list output:");
        new LinkedListUtil(node).print();
    }

    public void detectAndRemoveLoopCycleInLinkedList_Iterative(Node head) {

        //......................T: O(N)
        //......................S: O(1)
        Node slow = head;
        Node fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            if (slow == fast) {
                break;
            }
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //if there is a loop in linked list
        if (slow == fast) {
            slow = head;
            while (slow != fast.getNext()) {
                slow = slow.getNext();
                fast = fast.getNext();
            }

            //fast is the node where it should end the loop
            fast.setNext(null);
        }

        //output
        System.out.println("Iterative approach detect and remove a loop cycle in linked list output:");
        new LinkedListUtil(head).print();
    }

    public void removeDuplicatesFromUnSortedLinkedList(Node<Integer> head) {
        //...............................T: O(N)
        //...............................S: O(N)
        //https://leetcode.com/problems/remove-duplicates-from-an-unsorted-linked-list/description/

        //actual:
        System.out.println("Actual linked list : ");
        new LinkedListUtil<>(head).print();

        Map<Integer, Integer> freqs = new HashMap<>();

        Node<Integer> curr = head;

        //count the freqs of each node's value, so in case any node occured
        //more than 1 time, means we need to wipe off all those duplicates
        while (curr != null) {

            freqs.put(curr.getData(), freqs.getOrDefault(curr.getData(), 0) + 1);
            curr = curr.getNext();
        }

        Node<Integer> newHead = new Node<>(-1);
        Node<Integer> copy = newHead;

        curr = head;

        //generate the same linked list in same order BUT only with those nodes
        //that are ONLY OCCURING 1 TIME
        while (curr != null) {

            if (freqs.get(curr.getData()) == 1) {

                copy.setNext(curr);
                copy = copy.getNext();
            }

            curr = curr.getNext();
        }

        copy.setNext(null);

        //output
        System.out.println("Remove duplicates from unsorted linked list (completely wipe off all duplicates) : ");
        new LinkedListUtil<>(newHead.getNext()).print();
    }

    public void removeDuplicatesFromUnSortedLinkedListOnlyConsecutive(Node<Integer> head) {
        //...............................T: O(N)
        //...............................S: O(1)

        //actual:
        System.out.println("Actual linked list : ");
        new LinkedListUtil<>(head).print();

        Node<Integer> curr = head;
        Node<Integer> temp = head.getNext();

        while (temp != null) {

            if (curr.getData() != temp.getData()) {
                curr.setNext(temp);
                curr = temp;
            }

            temp = temp.getNext();

        }

        curr.setNext(temp);

        //output
        System.out.println("Remove duplicates from unsorted linked list"
                + " (wipe off any extra occurence in consecutive order) : ");

        new LinkedListUtil<>(head).print();
    }

    public void removeDuplicatesFromUnSortedLinkedListAllExtraOccuernce(Node<Integer> head) {
        //...............................T: O(N)
        //...............................S: O(N)

        //actual:
        System.out.println("Actual linked list : ");
        new LinkedListUtil<>(head).print();

        Node<Integer> curr = head;
        Node<Integer> temp = head.getNext();

        Set<Integer> visited = new HashSet<>();
        visited.add(curr.getData());

        while (temp != null) {

            if (curr.getData() != temp.getData() && !visited.contains(temp.getData())) {
                curr.setNext(temp);
                curr = temp;
            }
            visited.add(temp.getData());
            temp = temp.getNext();
        }

        curr.setNext(temp);

        //output
        System.out.println("Remove duplicates from unsorted linked list (wipe off any extra occurence) : ");
        new LinkedListUtil<>(head).print();
    }

    public Node<Integer> findMiddleNodeOfLinkedList(Node<Integer> head) {

        if (head == null || head.getNext() == null) {
            return head;
        }

        Node<Integer> slow = head;
        Node<Integer> fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //middle node = slow
        return slow;
    }

    public Node<Integer> mergeSortInLinkedList_Asc_Recursion(Node<Integer> n1, Node<Integer> n2) {

        if (n1 == null) {
            return n2;
        }

        if (n2 == null) {
            return n1;
        }

        if (n1.getData() <= n2.getData()) {
            Node<Integer> a = mergeSortInLinkedList_Asc_Recursion(n1.getNext(), n2);
            n1.setNext(a);
            return n1;
        } else {
            Node<Integer> b = mergeSortInLinkedList_Asc_Recursion(n1, n2.getNext());
            n2.setNext(b);
            return n2;
        }
    }

    public Node<Integer> mergeSortDivideAndMerge(Node<Integer> node) {

        if (node == null || node.getNext() == null) {
            return node;
        }

        Node<Integer> middle = findMiddleNodeOfLinkedList(node);
        Node<Integer> secondHalf = middle.getNext();
        //from node to middle is first half, so middle.next = null
        //splites as 1. node -> middle.next->NULL 2. middle.next -> tail.next->NULL
        middle.setNext(null);

        return mergeSortInLinkedList_Asc_Recursion(mergeSortDivideAndMerge(node),
                mergeSortDivideAndMerge(secondHalf));
    }

    public Node<Integer> sortLinkedListAlreadySortedAsAbsoluteValue(Node<Integer> head) {
        //...............T: O(n), separatings & reverse
        //...............S: O(1), few variables
        //https://leetcode.com/problems/sort-linked-list-already-sorted-using-absolute-values/description/
        //based on TWO POINTERS
        //also based on mergeSortDivideAndMerge() BUT T: O(n * Log n)
        Node<Integer> positives = new Node<Integer>(-1);
        Node<Integer> copyPositive = positives;

        Node<Integer> negatives = new Node<Integer>(-1);
        Node<Integer> copyNegative = negatives;

        Node<Integer> curr = head;

        //separate out all the positives and negative values
        while (curr != null) {

            if (curr.getData() >= 0) {

                copyPositive.setNext(curr);
                copyPositive = copyPositive.getNext();
            } else {

                copyNegative.setNext(curr);
                copyNegative = copyNegative.getNext();
            }

            curr = curr.getNext();
        }

        //mark last positive node's end with null, if any
        //positives = -1 -> 0 -> 2 -> 5 -> [10] -> NULL
        copyPositive.setNext(null);

        //mark last negative node's end with null, if any
        //positives = -1 -> -5 -> [-10] -> NULL
        copyNegative.setNext(null);

        //negatives = -1 -> -5 -> -10 -> NULL
        //here, after this
        //negatives = -5 -> -10 -> NULL
        negatives = negatives.getNext();

        //if there are no negatives at all, return the positives.next as head
        if (negatives == null) {
            return positives.getNext();
        }

        //if we have some negative nodes, reverse the negative list
        //here, after this
        //negatives = -10 -> -5 -> NULL
        Node<Integer> prev = null;
        Node<Integer> next = null;
        //negatives points to node [-5]
        curr = negatives;

        while (curr != null) {

            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        //after reverse, negatives will still point to same node [-5]
        //but prev will point to the last node [-10] which after the
        //reverse will be the new head
        //append two end of the list
        //-10 -> [-5 -> 0] -> 2 -> 5 -> 10
        negatives.setNext(positives.getNext());

        //prev become the new head of the reversed negative list
        return prev;
    }

    public boolean checkIfLinkedListIsCircularLinkedList(Node node) {

        if (node == null || node.getNext() == node) {
            return true;
        }

        Node headRef = node;
        Node temp = node;
        while (temp.getNext() != headRef && temp.getNext() != null) {
            temp = temp.getNext();
        }
        return temp.getNext() == headRef;
    }

    private int quickSortInLinkedList_Partition(List<Integer> arr, int low, int high) {

        int pivot = arr.get(high);
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr.get(j) < pivot) {

                i++;
                //swap
                int temp = arr.get(i);
                arr.set(i, arr.get(j));
                arr.set(j, temp);
            }
        }

        int temp = arr.get(i + 1);
        arr.set(i + 1, arr.get(high));
        arr.set(high, temp);

        return i + 1;
    }

    private void quickSortInLinkedList_Helper(List<Integer> arr, int low, int high) {

        if (high >= low) {

            int pivotIndex = quickSortInLinkedList_Partition(arr, low, high);
            quickSortInLinkedList_Helper(arr, low, pivotIndex - 1);
            quickSortInLinkedList_Helper(arr, pivotIndex + 1, high);
        }
    }

    public void quickSortInLinkedList(Node<Integer> node) {

        if (node == null || node.getNext() == null) {
            new LinkedListUtil<Integer>(node).print();
            return;
        }

        List<Integer> intArr = new ArrayList<>();
        Node<Integer> temp = node;
        while (temp != null) {
            intArr.add(temp.getData());
            temp = temp.getNext();
        }

        quickSortInLinkedList_Helper(intArr, 0, intArr.size() - 1);

        // System.out.println(intArr);
        temp = node;
        for (int x : intArr) {

            temp.setData(x);
            temp = temp.getNext();
        }

        //output
        new LinkedListUtil<Integer>(node).print();
    }

    public void moveLastNodeToFrontOfLinkedList(Node<Integer> node) {

        Node curr = node;
        Node prev = null;

        while (curr.getNext() != null) {
            prev = curr;
            curr = curr.getNext();
        }

        prev.setNext(curr.getNext());
        curr.setNext(node);
        node = curr;

        //output:
        new LinkedListUtil<Integer>(node).print();
    }

    private int addOneToLinkedList_Helper(Node<Integer> node) {

        if (node.getNext() == null) {
            //adding 1 to very last node(or last digit of number in linkedlist form)
            int sum = node.getData() + 1;
            node.setData(sum % 10);
            return sum / 10;
        }

        int carry = addOneToLinkedList_Helper(node.getNext());
        int sum = carry + node.getData();
        node.setData(sum % 10);
        return sum / 10;
    }

    public void addOneToLinkedList(Node<Integer> head) {
        //https://leetcode.com/problems/plus-one-linked-list/description/
        //https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/description/
        if (head == null) {
            return;
        }

        int carry = addOneToLinkedList_Helper(head);
        //edge case for L [9 -> 9 -> 9 -> NULL] + 1 = [1 -> 0 -> 0 -> 0 -> NULL]
        //extra 1 is the newHead in this case...
        if (carry > 0) {
            Node<Integer> newHead = new Node<>(carry);
            newHead.setNext(head);
            head = newHead;
        }

        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void sortLinkedListOf012_2(Node<Integer> node) {

        //approach 1 is just using merger sort on linked list.
        //merge sort method is already been implemented
        //approach 2 will be similar to my approach of solving
        //sortArrayOf012_1()
        int[] count = new int[3]; //we just have 3 digits (0, 1, 2)
        Node<Integer> curr = node;
        while (curr != null) {
            count[curr.getData()]++;
            curr = curr.getNext();
        }

        //manipulate the linked list
        curr = node;
        for (int i = 0; i < 3; i++) { //O(3)

            while (count[i]-- != 0) {
                //O(N) as N = count[0]+count[1]+cout[2] == total no of node already in the linked list
                curr.setData(i);
                curr = curr.getNext();
            }
        }

        //output:
        new LinkedListUtil<Integer>(node).print();
    }

    public void reverseDoublyLinkedList(Node node) {

        //actual
        new LinkedListUtil(node).print();

        Node curr = node;
        Node nextToCurr = null;
        Node prevToCurr = null;
        while (curr != null) {

            nextToCurr = curr.getNext();
            curr.setNext(prevToCurr);
            curr.setPrevious(nextToCurr);
            prevToCurr = curr;
            curr = nextToCurr;
        }

        //output:
        //new head will pre prevToCurr
        new LinkedListUtil(prevToCurr).print();
    }

    public void intersectionOfTwoSortedLinkedList(Node<Integer> node1, Node<Integer> node2) {

        //....................T: O(M+N)
        //....................S: O(M+N)
        Set<Integer> node1Set = new HashSet<>();
        while (node1 != null) {
            node1Set.add(node1.getData());
            node1 = node1.getNext();
        }

        Set<Integer> node2Set = new HashSet<>();
        Node<Integer> newHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> copy = newHead;
        while (node2 != null) {

            //all the in node2 that is present in node1 set but same node2 should not be repested in node2 set
            if (node1Set.contains(node2.getData()) && !node2Set.contains(node2.getData())) {
                copy.setNext(node2);
                copy = copy.getNext();
            }
            node2Set.add(node2.getData());
            node2 = node2.getNext();
        }
        copy.setNext(null);
        //output:
        new LinkedListUtil<Integer>(newHead.getNext()).print();
    }

    private int lengthOfLinkedList(Node<Integer> node) {
        int len = 0;
        Node<Integer> curr = node;
        while (curr != null) {
            len++;
            curr = curr.getNext();
        }

        return len;
    }

    private Node<Integer> moveLinkedListNodeByDiff(Node<Integer> node, int diff) {

        int index = 0;
        Node<Integer> curr = node;
        while (index++ < diff) { //evaluates as index++ -> 0+1 -> 1 then 1 < diff
            curr = curr.getNext();
        }
        return curr;
    }

    private int intersectionPointOfTwoLinkedListByRef_Helper(Node<Integer> n1, Node<Integer> n2) {

        Node<Integer> currN1 = n1;
        Node<Integer> currN2 = n2;
        while (currN1 != null && currN2 != null) {

            //nodes get common by ref
            if (currN1 == currN2) {
                return currN1.getData();
            }

            currN1 = currN1.getNext();
            currN2 = currN2.getNext();
        }

        return -1;
    }

    public void intersectionPointOfTwoLinkedListByRef(Node<Integer> node1, Node<Integer> node2) {
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        //find length of node1 T: O(M)
        int M = lengthOfLinkedList(node1);
        //find length of node2 T: O(N)
        int N = lengthOfLinkedList(node2);

        //find the absolute diff in both the length
        //diff = abs(M - N)
        int diff = Math.abs(M - N);

        //if M > N move ptr in node1 by diff forward else move ptr in node2
        //once ptr is available move ptr and node1 or node2 till null and find the intersection point
        //by ref
        int intersectedData = -1;
        Node<Integer> curr = null;
        if (M > N) {
            curr = moveLinkedListNodeByDiff(node1, diff);
            intersectedData = intersectionPointOfTwoLinkedListByRef_Helper(curr, node2);
        } else {
            curr = moveLinkedListNodeByDiff(node2, diff);
            intersectedData = intersectionPointOfTwoLinkedListByRef_Helper(curr, node1);
        }

        //output:
        System.out.println("Two linked list are intersected at: " + intersectedData);
    }

    public void intersectionPointOfTwoLinkedListByRef_HashBased(Node<Integer> node1, Node<Integer> node2) {

        //................................T: O(N + M)
        //................................S: O(N)
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        Set<Node<Integer>> set1 = new HashSet<>();
        Node<Integer> curr = node1;
        while (curr != null) {
            set1.add(curr);
            curr = curr.getNext();
        }

        int intersectedData = -1;
        curr = node2;
        while (curr != null) {

            if (set1.contains(curr)) {
                intersectedData = curr.getData();
                break;
            }
            curr = curr.getNext();
        }

        //output:
        System.out.println("Two linked list are intersected at (hashbased): " + intersectedData);
    }

    public void intersectionPointOfTwoLinkedListByRef_Iterative(Node<Integer> headA, Node<Integer> headB) {
        //................................T: O(N + M)
        //................................S: O(1)
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        //explanation: https://youtu.be/D0X0BONOQhI
        Node<Integer> currA = headA;
        Node<Integer> currB = headB;

        while (currA != currB) {
            currA = currA == null ? headB : currA.getNext();
            currB = currB == null ? headA : currB.getNext();
        }

        //output:
        System.out.println("Two linked list are intersected at (iterative): " + currA.getData());
    }

    public boolean checkIfLinkedListPallindrome_1(Node<Integer> node) {

        //.........................T: O(N)
        //.........................S: O(N)
        //https://leetcode.com/problems/palindrome-linked-list
        //empty list or 1 node list is by default true
        if (node == null || node.getNext() == null) {
            return true;
        }

        Node<Integer> curr = node;
        Stack<Node<Integer>> stack = new Stack<>();
        while (curr != null) {
            stack.push(curr);
            curr = curr.getNext();
        }

        //pop stack and start checking from the head of list
        curr = node;
        while (!stack.isEmpty()) {

            Node<Integer> popped = stack.pop();
            if (curr.getData() != popped.getData()) {
                return false;
            }
            curr = curr.getNext();
        }

        //if while loop doesn't prove false
        return true;
    }

    public boolean checkIfLinkedListPallindrome_2(Node<Integer> node) {

        //.........................T: O(N)
        //.........................S: O(1)
        //https://leetcode.com/problems/palindrome-linked-list/
        //empty list or 1 node list is by default true
        if (node == null || node.getNext() == null) {
            return true;
        }

        //ex LL = 1->2->2->1->N
        //find the mid of the linked list
        Node<Integer> slow = node;
        Node<Integer> fast = node;
        while (fast != null && fast.getNext() != null) {
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //LL head = 1->2->2->1->N
        //LL slow = 2->1->N
        //from slow ptr reverse it
        Node<Integer> curr = slow;
        Node<Integer> prev = null;
        Node<Integer> next = null;
        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }
        //after reversing slow ptr
        //LL new Head(prev) = 1->2->N

        //now prev is the new head for the reversed-slow ptr
        curr = node; //actual head
        //now comparing
        //LL head = 1->2->2->1->N
        //prev = 1->2->N
        //if reversed-half of the linked list(prev) is equal to first-half-part of the actual linked list (head)
        //its pallindrme otherwise ret false
        while (prev != null) {
            if (curr.getData() != prev.getData()) {
                return false;
            }

            prev = prev.getNext();
            curr = curr.getNext();
        }

        //if while loop doesn't prove false
        return true;
    }

    public void reorderLinkedList(Node<Integer> head) {

        //First 2 approaches are in SomePracticeQuestion reorderList_1/reorderList_2
        //actual
        new LinkedListUtil<>(head).print();

        //explanantion: https://youtu.be/xRYPjDMSUFw
        //ex: 1-> 2-> 3-> 4-> 5-> NULL
        //slow = 3->..
        //break it into 2 list (2 half)
        //l1 = 1-> 2-> NULL
        //l2 = 3-> 4-> 5-> NULL
        //reverse(l2) = 5-> 4-> 3-> NULL
        //reorderMerger(l1, l2) = 1-> 5-> 2-> 4-> 3-> NULL
        if (head == null || head.getNext() == null) {
            return;
        }

        //find mid of the linked list
        Node<Integer> slow = head;
        Node<Integer> fast = head.getNext();
        while (fast != null && fast.getNext() != null) {
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        Node<Integer> mid = slow;

        Node<Integer> tempSecond = mid.getNext();
        mid.setNext(null);

        //reversing the second half of the list
        Node<Integer> curr = tempSecond;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        Node<Integer> second = prev;
        Node<Integer> first = head;

        while (second != null) {

            Node<Integer> firstNext = first.getNext();
            Node<Integer> secondNext = second.getNext();

            first.setNext(second);

            if (firstNext == null) {
                break;
            }

            second.setNext(firstNext);

            first = firstNext;
            second = secondNext;
        }
        //output
        new LinkedListUtil<>(head).print();
    }

    public void rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(Node<Integer> head) {

        //rearrange all node in linked list in such a way that nodes at odd index comes first and nodes at even index
        //comes last and nodex should maintain the order of their occurence in actual list
        //nodes data is not to be consider for even and odd but their INDEX ONLY
        //https://leetcode.com/problems/odd-even-linked-list/
        //explanation: https://youtu.be/C_LA6SOwVTM
        //actual
        Node<Integer> forPrinting = head;
        int index = 0;
        while (forPrinting != null) {
            System.out.print((++index) + ") " + forPrinting.getData() + "\t");
            forPrinting = forPrinting.getNext();
        }
        System.out.println();

        Node<Integer> odd = head; //at index 1)
        Node<Integer> even = head.getNext(); //at index 2)
        Node<Integer> evenHead = even; //saving the starting ref of even pointr i.e, index 2) in evenHead

        while (even != null && even.getNext() != null) {
            odd.setNext(even.getNext()); //next odd index we will get after even index i.e, 3) after 2)
            odd = odd.getNext(); //index 1) now pointing to the update i.e, index 3) and so on...
            even.setNext(odd.getNext()); //similarly next even index we will get after odd index i.e, 4) after 3)
            even = even.getNext(); //index 2) now pointing to the update i.e, index 4) and so on...
        }

        //odd last ref will be having even starting index ref (last nth odd index -> index 2)
        odd.setNext(evenHead);

        //output:
        new LinkedListUtil<Integer>(head).print();
    }

    public void linkedListComponent(Node<Integer> head, int[] subset) {

        //https://leetcode.com/problems/linked-list-components/
        //ex L = 0-> 1-> 2-> 3-> 4
        //subset[] = [0,3,1,4]
        //first consecutive segment = 0-> 1
        //second consecutive segment = 3-> 4
        //also 0, 1, 3, 4 are in subset, so total segment = 2
        //this logic updates count when consecutivity breaks like 0->1->2 (b/w 1 & 2) count++
        //--->curr = 1 if(set(1) == true && (1.next == null => false || !set(1.next.data(=> 2)) == true)) == TRUE
        //and 3->4->Null (b/w 4 & Null) count++
        //--->curr = 4 if(set(4) == true && (4.next == null => true || !set(4.next.data(=> 2)) == false)) == TRUE
        Set<Integer> set = IntStream.of(subset).boxed().collect(Collectors.toSet());

        Node<Integer> curr = head;
        int count = 0;

        while (curr != null) {
            if (set.contains(curr.getData())
                    && (curr.getNext() == null || !set.contains(curr.getNext().getData()))) {
                count++;
            }
            curr = curr.getNext();
        }

        //output
        System.out.println("Total consecutive segment of linkedlist that are also in subset: " + count);
    }

    public void partitionList(Node<Integer> head, int x) {

        //https://leetcode.com/problems/partition-list
        //explanation: https://youtu.be/K5AVJVjdmL0
        //SIMILAR to odd-even linked list rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd()
        //ex: 1-> 4-> 3-> 2-> 5-> 2-> Null, row = 3
        //all values less than row should come in first segment and in same
        //order of oocurence and values greater than row should come in
        //second segment and in same order of oocurence
        //value less than row and order oocurence 1, 2, 2
        //after loop:
        //---> beforeHead = Int.MIN, before = 1-> 2-> 2-> so beforeHead becomes Int.MIN-> 1-> 2-> 2->
        //---> afterHead = Int.MIN, after = 4-> 3-> 5-> so afterHead becomes Int.MIN-> 4-> 3-> 5->
        //after to be last segment so after.next = Null afterHead = Int.MIN-> 4-> 3-> 5-> Null
        //next of before to have head of second segment i.e 4, before.next = afterhead.next
        //now beforeHead = Int.MIN-> 1-> 2-> 2-> 4-> 3-> 5-> Null, now beforehead.next is our output
        //print: beforeHead.next = 1-> 2-> 2-> 4-> 3-> 5-> Null
        //actual
        new LinkedListUtil<>(head).print();
        System.out.println();

        if (head == null || head.getNext() == null) {
            return;
        }

        Node<Integer> curr = head;
        Node<Integer> beforeHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> before = beforeHead;
        Node<Integer> afterHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> after = afterHead;

        while (curr != null) {

            if (curr.getData() < x) {
                before.setNext(curr);
                before = before.getNext();
            } else {
                after.setNext(curr);
                after = after.getNext();
            }
            curr = curr.getNext();
        }

        after.setNext(null);
        before.setNext(afterHead.getNext());

        //output
        new LinkedListUtil<>(beforeHead.getNext()).print();
        System.out.println();
    }

    public void rotateLinkedListKTimes(Node<Integer> head, int K) {

        //https://leetcode.com/problems/rotate-list/
        //Actual
        new LinkedListUtil<>(head).print();

        Node<Integer> dummy = new Node<>(Integer.MIN_VALUE);
        dummy.setNext(head);
        Node<Integer> fast = dummy;
        Node<Integer> slow = dummy;

        int len = 0;

        while (fast.getNext() != null) {
            len++;
            fast = fast.getNext();
        }

        for (int j = len - K % len; j > 0; j--) {
            slow = slow.getNext();
        }

        fast.setNext(dummy.getNext());
        dummy.setNext(slow.getNext());
        slow.setNext(null);

        //output
        System.out.println("Rotate linked list " + K + " times output approach1: ");
        new LinkedListUtil<>(dummy.getNext()).print();
    }

    public void rotateLinkedListKTimes2(Node<Integer> head, int K) {

        //https://leetcode.com/problems/rotate-list/
        //explanation: https://youtu.be/BHr381Guz3Y
        //approach similar to rotateArrayByK
        //Actual
        new LinkedListUtil<>(head).print();

        //find len of the the linked list
        int len = 0;
        Node<Integer> curr = head;
        while (curr != null) {
            len++;
            curr = curr.getNext();
        }

        //K > len, mod it by len so that K remains under len range
        K = K % len;

        curr = head;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        //reverse linked list normally
        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        //this is the node where we will append the second part of reversed list
        //ex: LL [1,2,3,4,5]
        //above reverse LL: [5,4,3,2,1]
        //lastNodeInFirstKReverse == prev = 5
        //let say if k = 2, so first k nodes reverse will be [4, 5]
        //second part reversal = [1,2,3] now the 1 should be linked to 5 above
        //lastNodeInFirstKReverse.next = 1
        Node<Integer> lastNodeInFirstKReverse = prev;

        //reverse first K nodes
        int firstK = K;
        curr = prev; // prev is new head after reversing above
        prev = null;
        next = null;
        while (firstK > 0 && curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
            firstK--;
        }

        //after reversing first K nodes its prev will be new head
        Node<Integer> rotatedListHead = prev;

        //reverse remaining nodes of list
        if (next != null) {
            curr = next;
            prev = null;
            next = null;
            while (curr != null) {
                next = curr.getNext();
                curr.setNext(prev);
                prev = curr;
                curr = next;
            }
            //join two parts of the linked list
            lastNodeInFirstKReverse.setNext(prev);
        }

        //output
        System.out.println("Rotate linked list " + K + " times output approach2: ");
        new LinkedListUtil<>(rotatedListHead).print();
    }

    public void sortLinkedListInRelativeOrderOfArr(Node<Integer> head, int[] arr) {

        //https://leetcode.com/problems/relative-sort-array/
        //https://www.geeksforgeeks.org/sort-linked-list-order-elements-appearing-array/
        //get the freq of all the elements in linkedlist
        Map<Integer, Integer> map = new TreeMap<>();
        Node<Integer> curr = head;

        while (curr != null) {
            map.put(curr.getData(), map.getOrDefault(curr.getData(), 0) + 1);
            curr = curr.getNext();
        }

        //regenerate linked list as relative order of arr
        curr = head;
        for (int a : arr) {
            int count = map.get(a);
            while (count-- != 0) {
                curr.setData(a);
                curr = curr.getNext();
            }
            map.remove(a);
        }

        //keep the values which are not in the arr[]
        for (int key : map.keySet()) {
            int count = map.get(key);
            while (count-- != 0) {
                curr.setData(key);
                curr = curr.getNext();
            }
        }

        //output
        new LinkedListUtil<>(head).print();
    }

    public void splitLinkedListInKParts(Node<Integer> head, int k) {
        //https://leetcode.com/problems/split-linked-list-in-parts/

        Node<Integer>[] splits = new Node[k];

        int length = 0;

        //calculate the length of whole linked list
        for (Node<Integer> curr = head; curr != null; curr = curr.getNext()) {
            length++;
        }

        //as we need to divide the given linked list into 'k' parts, so each
        //part should have atleast 'numberOfNodesInEachSplit'
        int numberOfNodesInEachSplit = length / k;
        //in case where, whole linked list is not fully divided among 'k' parts
        //and some nodes are left as 'extras' then extras to be maintained in
        //'k' parts only. How? Ideally we need to adjust some 'extras' nodes
        //from the very starting into the initial 'k' parts
        int extras = length % k;

        Node<Integer> prev = null;
        Node<Integer> curr = head;

        //check curr != null here, as this will prevent Null Pointer Exception
        //in below for-block
        for (int split = 0; split < k && curr != null; split++) {

            //curr k-th 'split' will have the head of nodes it is holding
            //as 'curr'
            splits[split] = curr;

            //each k-th 'split' should have atleast 'numberOfNodesInEachSplit'
            //but if there are 'extras' (extras > 0) they should be adjusted
            //from the starting side of linked list and 1-extra node should be
            //placed in each split
            for (int node = 0; node < numberOfNodesInEachSplit + (extras > 0 ? 1 : 0); node++) {
                //prev will hold the last node in the curr k-th 'split'
                prev = curr;
                curr = curr.getNext();
            }

            //as each k-th 'split' have atleast 'numberOfNodesInEachSplit' or
            //few 'extras' but prev will be the last node of the k-tk split
            //hence we should make it a separate list part by breaking the link
            //at prev.next
            if (prev != null) {
                prev.setNext(null);
            }

            //we 'might' have taken 1 extra node in curr 'split' so reduce extras
            extras--;
        }

        //output
        for (int split = 0; split < k; split++) {

            System.out.print((split + 1) + " : ");

            Node<Integer> splittedHead = splits[split];

            if (splittedHead == null) {
                System.out.println("null");
                continue;
            }

            for (Node<Integer> node = splittedHead; node != null; node = node.getNext()) {
                System.out.print(node.getData() + " ");
            }

            System.out.println();
        }
    }

    public void trimLinkedListAndRemoveAllOccurencesOfGivenVal(Node<Integer> head, int val) {
        //............................T: O(N)
        //............................S: O(1)
        //https://leetcode.com/problems/remove-linked-list-elements
        //actual
        System.out.println("Actual");
        new LinkedListUtil<>(head).print();

        Node<Integer> prev = head;
        Node<Integer> curr = head.getNext();

        while (curr != null) {

            //we are moving all the val-to-remove curr ptr only once so T: remains O(N)
            //move curr ptr till curr.data value is same as val,
            //it will break when they don't match curr.data != val
            while (curr != null && curr.getData() == val) {
                curr = curr.getNext();
            }
            //since prev ptr was not moving, append this curr next to prev
            //this will break all links between prev and the val that needs to be removed
            prev.setNext(curr);
            //update the prev ptr to its next value
            prev = prev.getNext();
            //if curr is not already null, update curr as well
            if (curr != null) {
                curr = curr.getNext();
            }
        }

        //output
        //this cond will occur when val to remove occur at the starting of linked list
        head = head.getData() == val
                ? head.getNext()
                : head;
        new LinkedListUtil<>(head).print();
    }

    public void removeZeroSumConsecutiveNodesFromLinkedList(Node<Integer> head) {
        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/2079419/Java-two-pass-solution-using-prefix-sum
        int prefixSum = 0;
        Node<Integer> dummy = new Node<>(0);
        dummy.setNext(head);

        Map<Integer, Node<Integer>> prefixSumWithNode = new HashMap<>();
        Node<Integer> curr = dummy;
        while (curr != null) {
            prefixSum += curr.getData();
            prefixSumWithNode.put(prefixSum, curr);
            curr = curr.getNext();
        }

        prefixSum = 0;
        curr = dummy;
        while (curr != null) {
            prefixSum += curr.getData();
            curr.setNext(prefixSumWithNode.get(prefixSum).getNext());
            curr = curr.getNext();
        }
        //output
        new LinkedListUtil<>(dummy.getNext()).print();
    }

    public void mergeNodesInBetweenZeros(Node<Integer> head) {
        //https://leetcode.com/problems/merge-nodes-in-between-zeros/
        //actual
        new LinkedListUtil<Integer>(head).print();

        Node<Integer> curr = head;
        Node<Integer> next = head.getNext();

        while (next != null) {

            if (next.getData() == 0) {
                curr.setNext(next.getNext());
                curr = curr.getNext();
                next = next.getNext();
            } else {
                curr.setData(curr.getData() + next.getData());
            }
            if (next == null) {
                break;
            }
            next = next.getNext();
        }
        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void removeEveryNodeWhichHasStrictlyGreaterNodeToRight(Node<Integer> head) {
        //https://leetcode.com/problems/remove-nodes-from-linked-list/description/
        /*
        head: [5, 2, 13, 3, 8]
        remove 5, 2 as 13 is strictly greater value in right of [5, 2]
        ==> head: [13, 3, 8]
        remove 3 as 8 is strictly greater value in right of [3]
        ==> head: [13, 8]

        ##removing nodes
        stack = []
        curr = [5]...

        iterations
        #1.
        curr != null ==> 5 != null
        ___!stack.isEmpty ==> []  ==> FALSE
        ___stack.push(curr) ==> [5]
        ___curr = curr.next ==> 5.next ==> 2

        #2.
        curr != null ==> 2 != null
        ___!stack.isEmpty && stack.peek < curr ==> [5] && peek[5] < 2 ==> FALSE
        ___stack.push(curr) ==> [5, 2]
        ___curr = curr.next ==> 2.next ==> 13

        #3.
        curr != null ==> 13 != null
        ___!stack.isEmpty && stack.peek < curr ==> [5, 2] && peek[2] < 13 ==> TRUE
        ______stack.pop() ==> remove 2 as 2 < 13, remove 5 as 5 < 13 ==> []
        ___stack.push(curr) ==> [13]
        ___curr = curr.next ==> 13.next ==> 3

        #4.
        curr != null ==> 3 != null
        ___!stack.isEmpty && stack.peek < curr ==> [13] && peek[13] < 3 ==> FALSE
        ___stack.push(curr) ==> [13, 3]
        ___curr = curr.next ==> 3.next ==> 8

        #4.
        curr != null ==> 8 != null
        ___!stack.isEmpty && stack.peek < curr ==> [13, 3] && peek[3] < 8 ==> TRUE
        ______stack.pop() ==> remove 3 as 3 < 8 ==> [13]
        ___stack.push(curr) ==> [13, 8]
        ___curr = curr.next ==> 8.next ==> null

        ...curr != null ==> null != null..

        ##creating list again
        prev = null
        curr = null

        iterations
        #1.
        curr = stack.pop() ==> 8
        8.next = prev = null
        ==> 8 -> null
        prev = curr = 8
        ==> prev = 8 -> null
        head = curr = 8
        ==> head = 8 -> null

        #2.
        curr = stack.pop() ==> 13
        13.next = prev = 8
        ==> 13 -> 8 -> null
        prev = curr = 13
        ==> prev = 13 -> 8 -> null
        head = curr = 13
        ==> head = 13 -> 8 -> null

        ...stack empty...

        //list formed without reverse logic
        head = 13 -> 8 -> null

         */
        //actual:
        new LinkedListUtil<>(head).print();
        System.out.println();

        Node<Integer> curr = head;
        Stack<Node<Integer>> stack = new Stack<>();

        while (curr != null) {
            //each curr node is a value in the right and nodes in stack are those
            //nodes which are left of this curr node. if curr node(in right) is strictly
            //greater than the nodes in stack(to left of curr node) remove them
            while (!stack.isEmpty() && stack.peek().getData() < curr.getData()) {
                stack.pop();
            }
            //push the curr node in stack
            stack.push(curr);
            //update the curr node
            curr = curr.getNext();
        }

        //after above loop we have removed all the nodes that has strictly greater
        //value in their right so stack will have [13, 8] <-- PEEK
        //if we pop out values from stack it will be in reverse order
        //that means 8 -> 13
        //either create a linked list as this: 8 -> 13 -> NULL and then reverse it
        //OR
        //do below logic based on reversing linked list
        Node<Integer> prev = null;
        curr = null;
        while (!stack.isEmpty()) {
            curr = stack.pop();
            curr.setNext(prev);
            prev = curr;
        }
        //output
        //new head == prev
        new LinkedListUtil<>(prev).print();
        System.out.println();
    }

    public void insertGCDInLinkedList(Node<Integer> head) {
        //https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description/

        //actual:
        System.out.println("actual : ");
        new LinkedListUtil<>(head).print();

        if (head == null || head.getNext() == null) {
            System.out.println("Insert GCD in linked list : ");
            new LinkedListUtil<>(head).print();
            return;
        }

        Node<Integer> prev = head;
        Node<Integer> curr = head.getNext();

        while (curr != null) {

            //no relation between two questions!!
            //just reusing the GCD method call here
            int gcd = maxScoreOfNOperations_Recursive_Memoization_GetGCD(
                    prev.getData(), curr.getData());

            //create a node for 'gcd' we calculated for a pair of numbers
            //between (prev.val, curr.val)
            Node<Integer> gcdNode = new Node<>(gcd);

            //add gcdNode.next = prev.next
            gcdNode.setNext(prev.getNext());

            //put gcdNode in between prev and curr
            //prev.next = gcdNode
            prev.setNext(gcdNode);

            //after above ptr switching
            //prev -> gcdNode -> curr
            //shift ptrs to next pairs for gcd calculations
            prev = curr;
            curr = curr.getNext();
        }

        System.out.println("Insert GCD in linked list : ");
        new LinkedListUtil<>(head).print();
        System.out.println();
    }

    public void levelOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        Queue<TreeNode> childQueue = new LinkedList<>();

        List<List> levels = new ArrayList<>();
        List nodes = new ArrayList<>();

        while (!queue.isEmpty()) {

            TreeNode curr = queue.poll();
            nodes.add(curr.getData());

            if (curr.getLeft() != null) {
                childQueue.add(curr.getLeft());
            }
            if (curr.getRight() != null) {
                childQueue.add(curr.getRight());
            }

            if (queue.isEmpty()) {
                levels.add(nodes);
                nodes = new ArrayList<>();
                queue.addAll(childQueue);
                childQueue.clear();
            }
        }

        //output
        System.out.println("Level order iterative (childQueue based approach): ");
        for (List level : levels) {
            System.out.println(level);
        }
    }

    public void levelOrderTraversal_Iterative2(TreeNode root) {

        if (root == null) {
            return;
        }

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        List<List> levels = new ArrayList<>();
        List currLevelNodes;

        while (!queue.isEmpty()) {

            int size = queue.size();
            currLevelNodes = new ArrayList<>();

            for (int index = 0; index < size; index++) {
                TreeNode curr = queue.poll();

                currLevelNodes.add(curr.getData());

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }
                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }
            levels.add(currLevelNodes);
        }

        //output
        System.out.println("Level order iterative (size based approach): ");
        for (List level : levels) {
            System.out.println(level);
        }
    }

    public void levelOrderTraversal_Recursive_Helper(TreeNode<Integer> root, int level,
                                                     Map<Integer, List<Integer>> levelOrder) {

        if (root == null) {
            return;
        }

        levelOrder.putIfAbsent(level, new ArrayList<>());
        levelOrder.get(level).add(root.getData());

        levelOrderTraversal_Recursive_Helper(root.getLeft(), level + 1, levelOrder);
        levelOrderTraversal_Recursive_Helper(root.getRight(), level + 1, levelOrder);
    }

    public void levelOrderTraversal_Recursive(TreeNode<Integer> root) {
        Map<Integer, List<Integer>> levelOrder = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root, 0, levelOrder);

        //output:
        System.out.println("Level order recursive: ");
        for (List l : levelOrder.values()) {
            System.out.println(l);
        }
    }

    public void reverseLevelOrderTraversal(TreeNode<Integer> root) {

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        List<Integer> singleListReverseLevelOrder = new ArrayList<>();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);
        Queue<TreeNode<Integer>> intQ = new LinkedList<>();

        List<List<Integer>> level = new ArrayList<>();
        List<Integer> nodes = new ArrayList<>();

        while (!q.isEmpty()) {

            TreeNode<Integer> temp = q.poll();
            nodes.add(temp.getData());

            if (temp.getLeft() != null) {
                intQ.add(temp.getLeft());
            }

            if (temp.getRight() != null) {
                intQ.add(temp.getRight());
            }

            if (q.isEmpty()) {
                level.add(nodes);
                nodes = new ArrayList<>();
                q.addAll(intQ);
                intQ.clear();
            }

        }

        //output
        System.out.println();
        Collections.reverse(level);
        System.out.println("Level wise: " + level);

        for (List l : level) {
            singleListReverseLevelOrder.addAll(l);
        }
        System.out.println("Single node list: " + singleListReverseLevelOrder);
    }

    public void inOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 1) {
                System.out.print(currNode.getData() + " ");
            }

            if (status == 2) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }
        }

        System.out.println();
    }

    public void inOrderTraversal_Recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        inOrderTraversal_Recursive(root.getLeft());
        System.out.print(root.getData() + " ");
        inOrderTraversal_Recursive(root.getRight());
    }

    public void preOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                System.out.print(currNode.getData() + " ");
            }

            if (status == 1) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 2) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }
        }

        System.out.println();
    }

    public void preOrderTraversal_Iterative2(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode currRoot = root;

        while (!stack.isEmpty() || currRoot != null) {

            while (currRoot != null) {

                System.out.print(currRoot.getData() + " ");

                if (currRoot.getRight() != null) {
                    stack.push(currRoot.getRight());
                }

                currRoot = currRoot.getLeft();
            }

            if (!stack.isEmpty()) {
                currRoot = stack.pop();
            }
        }

        System.out.println();
    }

    public void preOrderTraversal_Recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        System.out.print(root.getData() + " ");
        preOrderTraversal_Recursive(root.getLeft());
        preOrderTraversal_Recursive(root.getRight());

    }

    public void postOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 1) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }

            if (status == 2) {
                System.out.print(currNode.getData() + " ");
            }
        }

        System.out.println();
    }

    public void postOrderTraversal_recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        postOrderTraversal_recursive(root.getLeft());
        postOrderTraversal_recursive(root.getRight());
        System.out.print(root.getData() + " ");

    }

    public int heightOfTree(TreeNode root) {

        if (root == null) {
            return -1;
        }

        return Math.max(heightOfTree(root.getLeft()),
                heightOfTree(root.getRight())) + 1;
    }

    public TreeNode mirrorOfTree(TreeNode root) {

        if (root == null) {
            return null;
        }

        TreeNode left = mirrorOfTree(root.getLeft());
        TreeNode right = mirrorOfTree(root.getRight());
        root.setLeft(right);
        root.setRight(left);

        return root;
    }

    private void leftViewOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, Integer> result) {
        if (root == null) {
            return;
        }

        if (!result.containsKey(level)) {
            result.put(level, root.getData());
        }

        //for left view
        leftViewOfTree_Helper(root.getLeft(), level + 1, result);
        leftViewOfTree_Helper(root.getRight(), level + 1, result);
    }

    public void leftViewOfTree(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(N), worst case of left-skewed tree
        Map<Integer, Integer> result = new TreeMap<>();
        leftViewOfTree_Helper(root, 0, result);

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public int leftViewOfTreeWithoutExtraSpace_MaxLevel;

    private void leftViewOfTreeWithoutExtraSpace_Helper(TreeNode<Integer> root,
                                                        int level, List<Integer> result) {
        if (root == null) {
            return;
        }

        if (level > leftViewOfTreeWithoutExtraSpace_MaxLevel) {
            leftViewOfTreeWithoutExtraSpace_MaxLevel = level;
            result.add(root.getData());
        }

        //for left view
        leftViewOfTreeWithoutExtraSpace_Helper(root.getLeft(), level + 1, result);
        leftViewOfTreeWithoutExtraSpace_Helper(root.getRight(), level + 1, result);
    }

    public void leftViewOfTreeWithoutExtraSpace(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(1)
        leftViewOfTreeWithoutExtraSpace_MaxLevel = -1;
        List<Integer> result = new ArrayList<>();
        leftViewOfTreeWithoutExtraSpace_Helper(root, 0, result);

        result.stream().forEach(e -> {
            System.out.print(e + " ");
        });

        System.out.println();
    }

    private void rightViewOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, Integer> result) {

        if (root == null) {
            return;
        }

        if (!result.containsKey(level)) {
            result.put(level, root.getData());
        }

        //for right view
        rightViewOfTree_Helper(root.getRight(), level + 1, result);
        rightViewOfTree_Helper(root.getLeft(), level + 1, result);
    }

    public void rightViewOfTree(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(N), worst case of right-skewed tree
        Map<Integer, Integer> result = new TreeMap<>();
        rightViewOfTree_Helper(root, 0, result);

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public int rightViewOfTreeWithoutExtraSpace_MaxLevel;

    private void rightViewOfTreeWithoutExtraSpace_Helper(TreeNode<Integer> root,
                                                         int level, List<Integer> result) {

        if (root == null) {
            return;
        }

        if (level > rightViewOfTreeWithoutExtraSpace_MaxLevel) {
            rightViewOfTreeWithoutExtraSpace_MaxLevel = level;
            result.add(root.getData());
        }

        //for right view
        rightViewOfTreeWithoutExtraSpace_Helper(root.getRight(), level + 1, result);
        rightViewOfTreeWithoutExtraSpace_Helper(root.getLeft(), level + 1, result);
    }

    public void rightViewOfTreeWithoutExtraSpace(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(1)
        rightViewOfTreeWithoutExtraSpace_MaxLevel = -1;
        List<Integer> result = new ArrayList<>();
        rightViewOfTreeWithoutExtraSpace_Helper(root, 0, result);

        result.stream().forEach(e -> {
            System.out.print(e + " ");
        });

        System.out.println();
    }

    public void topViewOfTree(TreeNode<Integer> root) {

        Queue<Pair<TreeNode<Integer>, Integer>> queue = new LinkedList<>();
        queue.add(new Pair<>(root, 0));

        Map<Integer, Integer> result = new TreeMap<>();

        while (!queue.isEmpty()) {

            Pair<TreeNode<Integer>, Integer> currPair = queue.poll();
            TreeNode<Integer> currNode = currPair.getKey();
            int vLevel = currPair.getValue();

            if (!result.containsKey(vLevel)) {
                result.put(vLevel, currNode.getData());
            }

            if (currNode.getLeft() != null) {
                queue.add(new Pair<>(currNode.getLeft(), vLevel - 1));
            }
            if (currNode.getRight() != null) {
                queue.add(new Pair<>(currNode.getRight(), vLevel + 1));
            }
        }

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public void verticalOrderTraversalOfBinaryTree(TreeNode root) {
        //https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
        //https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/
        //based on topViewOfTree()
        class Pair {

            TreeNode<Integer> node;
            int verticalLevel;

            public Pair(TreeNode node, int verticalLevel) {
                this.node = node;
                this.verticalLevel = verticalLevel;
            }
        }

        List<List<Integer>> verticalOrderLevels;
        Map<Integer, List<Integer>> treeMap;
        verticalOrderLevels = new ArrayList<>();

        treeMap = new TreeMap<>();

        int verticalLevel = 0;

        Queue<Pair> queue = new LinkedList<>();
        queue.add(new Pair(root, verticalLevel));

        while (!queue.isEmpty()) {

            List<Pair> currLevel = new ArrayList<>();

            int size = queue.size();
            for (int i = 0; i < size; i++) {

                Pair pair = queue.poll();

                currLevel.add(pair);

                if (pair.node.getLeft() != null) {
                    queue.add(new Pair(pair.node.getLeft(), pair.verticalLevel - 1));
                }

                if (pair.node.getRight() != null) {
                    queue.add(new Pair(pair.node.getRight(), pair.verticalLevel + 1));
                }
            }

            //sort the curr level nodes as asked in questions, a slight diff from above
            //top view method
            Collections.sort(currLevel, (a, b) -> a.node.getData() - b.node.getData());
            for (Pair levelPair : currLevel) {
                treeMap.putIfAbsent(levelPair.verticalLevel, new ArrayList<>());
                treeMap.get(levelPair.verticalLevel).add(levelPair.node.getData());
            }

        }
        verticalOrderLevels.addAll(treeMap.values());
        //output
        System.out.println("Vertical order traversal of binary tree: " + verticalOrderLevels);
    }

    public void bottomViewOfTree(TreeNode<Integer> root) {

        //pair: node,vlevels
        Queue<Pair<TreeNode<Integer>, Integer>> q = new LinkedList<>();
        q.add(new Pair<>(root, 0));

        Map<Integer, Integer> bottomView = new TreeMap<>();

        while (!q.isEmpty()) {

            Pair<TreeNode<Integer>, Integer> p = q.poll();
            TreeNode<Integer> n = p.getKey();
            int vLevel = p.getValue();

            //updates the vlevel with new node data, as we go down the tree in level order wise
            bottomView.put(vLevel, n.getData());

            if (n.getLeft() != null) {
                q.add(new Pair<>(n.getLeft(), vLevel - 1));
            }

            if (n.getRight() != null) {
                q.add(new Pair<>(n.getRight(), vLevel + 1));
            }

        }

        bottomView.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public void zigZagTreeTraversal(TreeNode<Integer> root, boolean isLeftToRight) {

        Stack<TreeNode<Integer>> stack = new Stack<>();
        stack.push(root);
        Stack<TreeNode<Integer>> childStack = new Stack<>();

        List<List<Integer>> level = new ArrayList<>();
        List<Integer> zigZagNodes = new ArrayList<>();

        while (!stack.isEmpty()) {

            TreeNode<Integer> curr = stack.pop();
            zigZagNodes.add(curr.getData());

            if (isLeftToRight) {

                if (curr.getRight() != null) {
                    childStack.push(curr.getRight());
                }

                if (curr.getLeft() != null) {
                    childStack.push(curr.getLeft());
                }
            } else {

                if (curr.getLeft() != null) {
                    childStack.push(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    childStack.push(curr.getRight());
                }
            }

            if (stack.isEmpty()) {

                isLeftToRight = !isLeftToRight;
                level.add(zigZagNodes);
                zigZagNodes = new ArrayList<>();
                stack.addAll(childStack);
                childStack.clear();
            }
        }

        //output
        System.out.println("Output: " + level);
    }

    private void minAndMaxInBST_Helper(TreeNode<Integer> root, List<Integer> l) {

        if (root == null) {
            return;
        }

        //inorder traversal
        minAndMaxInBST_Helper(root.getLeft(), l);
        if (root != null) {
            l.add(root.getData());
        }
        minAndMaxInBST_Helper(root.getRight(), l);
    }

    public void minAndMaxInBST(TreeNode<Integer> root) {
        List<Integer> inOrder = new ArrayList<>();
        minAndMaxInBST_Helper(root, inOrder);

        System.out.println("Min & Max in BST: " + inOrder.get(0) + " " + inOrder.get(inOrder.size() - 1));

    }

    TreeNode treeToDoublyLinkedList_Prev;
    TreeNode treeToDoublyLinkedList_HeadOfDLL;

    private void treeToDoublyLinkedList_Helper(TreeNode root) {
        if (root == null) {
            return;
        }

        treeToDoublyLinkedList_Helper(root.getLeft());

        if (treeToDoublyLinkedList_HeadOfDLL == null) {
            treeToDoublyLinkedList_HeadOfDLL = root;
        }

        if (treeToDoublyLinkedList_Prev != null) {
            root.setLeft(treeToDoublyLinkedList_Prev);
            treeToDoublyLinkedList_Prev.setRight(root);
        }

        treeToDoublyLinkedList_Prev = root;

        treeToDoublyLinkedList_Helper(root.getRight());
    }

    private void treeToDoublyLinkedList_Print(TreeNode head) {

        while (head != null) {

            System.out.print(head.getData() + " ");
            head = head.getRight();
        }
        System.out.println();
    }

    public void treeToDoublyLinkedList(TreeNode root) {

        //just resetting
        treeToDoublyLinkedList_Prev = null;
        treeToDoublyLinkedList_HeadOfDLL = null;

        treeToDoublyLinkedList_Helper(root);
        treeToDoublyLinkedList_Print(treeToDoublyLinkedList_HeadOfDLL);
    }

    private void checkIfAllLeafNodeOfTreeAtSameLevel_Helper(TreeNode root, int level, Set<Integer> levels) {

        if (root == null) {
            return;
        }

        //leaf
        if (root.getLeft() == null && root.getRight() == null) {
            levels.add(level);
        }

        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root.getLeft(), level + 1, levels);
        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root.getRight(), level + 1, levels);

    }

    public void checkIfAllLeafNodeOfTreeAtSameLevel(TreeNode root) {
        //..........................T: O(N), traversing all the nodes
        //..........................S: O(Leaf Nodes(M)), in worst case if all lead nodes are at different levels
        Set<Integer> levels = new HashSet<>();
        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root, 0, levels);

        System.out.println("Leaf at same level: " + (levels.size() == 1));
    }

    TreeNode<Integer> isTreeBST_Prev;

    private boolean isTreeBST_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return true;
        }

        boolean leftBst = isTreeBST_Helper(root.getLeft());

        if (isTreeBST_Prev != null && isTreeBST_Prev.getData() > root.getData()) {
            return false;
        }

        isTreeBST_Prev = root;

        boolean rightBst = isTreeBST_Helper(root.getRight());

        return leftBst && rightBst;
    }

    public void isTreeBST(TreeNode<Integer> root) {

        //just resetting
        isTreeBST_Prev = null;

        System.out.println("Tree is BST: " + isTreeBST_Helper(root));
    }

    private void kThLargestNodeInBST_Helper(TreeNode<Integer> root, int K, PriorityQueue<Integer> minHeap) {

        if (root == null) {
            return;
        }

        minHeap.add(root.getData());
        if (minHeap.size() > K) {
            minHeap.poll();
        }

        kThLargestNodeInBST_Helper(root.getLeft(), K, minHeap);
        kThLargestNodeInBST_Helper(root.getRight(), K, minHeap);
    }

    public void kTHLargestNodeInBST(TreeNode<Integer> root, int K) {
        //actual
        //inorder of BST is sorted nodes list
        inOrderTraversal_Iterative(root);

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        kThLargestNodeInBST_Helper(root, K, minHeap);

        System.out.println(K + " largest node from BST: " + minHeap.poll());
    }

    private int kTHLargestNodeInBSTWithoutHeap_Value;
    private int kTHLargestNodeInBSTWithoutHeap_CurrK;

    public void kTHLargestNodeInBSTWithoutHeap_Helper(TreeNode<Integer> root, int K) {
        if (root == null) {
            return;
        }
        //since it a BST the larger nodes are in right sub tree so
        //traversing the right subtree first to find the kth node
        kTHLargestNodeInBSTWithoutHeap_Helper(root.getRight(), K);

        kTHLargestNodeInBSTWithoutHeap_CurrK++;

        if (kTHLargestNodeInBSTWithoutHeap_CurrK == K) {
            kTHLargestNodeInBSTWithoutHeap_Value = root.getData();
            return;
        }
        kTHLargestNodeInBSTWithoutHeap_Helper(root.getLeft(), K);
    }

    public void kTHLargestNodeInBSTWithoutHeap(TreeNode<Integer> root, int K) {

        kTHLargestNodeInBSTWithoutHeap_CurrK = 0;
        kTHLargestNodeInBSTWithoutHeap_Value = Integer.MIN_VALUE;
        kTHLargestNodeInBSTWithoutHeap_Helper(root, K);
        System.out.println(K + " largest node from BST without heap: " + kTHLargestNodeInBSTWithoutHeap_Value);
    }

    private void kThSmallestNodeInBST_Helper(TreeNode<Integer> root, int K, PriorityQueue<Integer> maxHeap) {

        if (root == null) {
            return;
        }

        maxHeap.add(root.getData());
        if (maxHeap.size() > K) {
            maxHeap.poll();
        }

        kThSmallestNodeInBST_Helper(root.getLeft(), K, maxHeap);
        kThSmallestNodeInBST_Helper(root.getRight(), K, maxHeap);
    }

    public void kTHSmallestNodeInBST(TreeNode<Integer> root, int K) {
        //actual
        //inorder of BST is sorted nodes list
        inOrderTraversal_Iterative(root);

        //maxHeap
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
                (o1, o2) -> o2.compareTo(o1)
        );
        kThSmallestNodeInBST_Helper(root, K, maxHeap);

        System.out.println(K + " smallest node from BST: " + maxHeap.poll());
    }

    class Height {

        int height = 0;
    }

    private boolean isTreeHeightBalanced_Helper(TreeNode root, Height currHeight) {

        //this approach calculates height and check height balanced at the same time
        if (root == null) {
            currHeight.height = -1;
            return true;
        }

        Height leftTreeHeight = new Height();
        Height rightTreeHeight = new Height();

        boolean isLeftBal = isTreeHeightBalanced_Helper(root.getLeft(), leftTreeHeight);
        boolean isRightBal = isTreeHeightBalanced_Helper(root.getRight(), rightTreeHeight);

        //calculate the height for the current node
        currHeight.height = Math.max(leftTreeHeight.height, rightTreeHeight.height) + 1;

        //checking the cond if height balanced
        //if diff b/w left subtree or right sub tree is greater than 1 it's
        //not balanced
        if (Math.abs(leftTreeHeight.height - rightTreeHeight.height) > 1) {
            return false;
        }

        //if the above cond doesn't fulfil
        //it should check if both of the left or right sub tree are balanced or not
        return isLeftBal && isRightBal;
    }

    public void isTreeHeightBalanced(TreeNode root) {
        Height h = new Height();
        System.out.println("Is tree heght  balanced: " + isTreeHeightBalanced_Helper(root, h));
    }

    public boolean checkTwoTreeAreMirror(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        return root1.getData() == root2.getData()
                && checkTwoTreeAreMirror(root1.getLeft(), root2.getRight())
                && checkTwoTreeAreMirror(root1.getRight(), root2.getLeft());
    }

    private int convertTreeToSumTree_Sum(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int lSum = convertTreeToSumTree_Sum(root.getLeft());
        int rSum = convertTreeToSumTree_Sum(root.getRight());

        return lSum + rSum + root.getData();

    }

    public void convertTreeToSumTree(TreeNode<Integer> root) {

        //actual
        BinaryTree<Integer> bt = new BinaryTree<>(root);
        bt.treeBFS();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            TreeNode<Integer> t = q.poll();

            if (t.getLeft() != null) {
                q.add(t.getLeft());
            }

            if (t.getRight() != null) {
                q.add(t.getRight());
            }

            //leaf
            if (t.getLeft() == null && t.getRight() == null) {
                t.setData(0);
                continue;
            }

            // - t.getData() just don't include the value of that node itself
            t.setData(convertTreeToSumTree_Sum(t) - t.getData());

        }

        //output
        System.out.println();
        bt = new BinaryTree<>(root);
        bt.treeBFS();
        System.out.println();

    }

    private int convertTreeToSumTree_Recursion_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int data = root.getData();

        int lSum = convertTreeToSumTree_Recursion_Helper(root.getLeft());
        int rSum = convertTreeToSumTree_Recursion_Helper(root.getRight());

        //leaf
        if (root.getLeft() == null && root.getRight() == null) {
            root.setData(0);
            return data;
        } else {
            root.setData(lSum + rSum);
            return lSum + rSum + data;
        }
    }

    public void convertTreeToSumTree_Recursion(TreeNode<Integer> root) {

        //OPTIMISED
        //actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        convertTreeToSumTree_Recursion_Helper(root);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();

    }

    List<Integer> printKSumPathAnyNodeTopToDown_PathList;

    private void printKSumPathAnyNodeTopToDown_Helper(TreeNode<Integer> root, int K) {

        if (root == null) {
            return;
        }

        printKSumPathAnyNodeTopToDown_PathList.add(root.getData());

        printKSumPathAnyNodeTopToDown_Helper(root.getLeft(), K);
        printKSumPathAnyNodeTopToDown_Helper(root.getRight(), K);

        int pathSum = 0;
        for (int i = printKSumPathAnyNodeTopToDown_PathList.size() - 1; i >= 0; i--) {

            pathSum += printKSumPathAnyNodeTopToDown_PathList.get(i);
            if (pathSum == K) {
                //print actual nodes data
                for (int j = i; j < printKSumPathAnyNodeTopToDown_PathList.size(); j++) {
                    System.out.print(printKSumPathAnyNodeTopToDown_PathList.get(j) + " ");
                }
                System.out.println();
            }
        }
        //remove current node
        printKSumPathAnyNodeTopToDown_PathList.remove(printKSumPathAnyNodeTopToDown_PathList.size() - 1);
    }

    public void printKSumPathAnyNodeTopToDown(TreeNode<Integer> root, int K) {
        printKSumPathAnyNodeTopToDown_PathList = new ArrayList<>();
        printKSumPathAnyNodeTopToDown_Helper(root, K);
    }

    private TreeNode<Integer> lowestCommonAncestorOfTree_Helper(TreeNode<Integer> root, int N1, int N2) {

        if (root == null) {
            return null;
        }

        if (N1 == root.getData() || N2 == root.getData()) {
            return root;
        }

        TreeNode<Integer> leftNode = lowestCommonAncestorOfTree_Helper(root.getLeft(), N1, N2);
        TreeNode<Integer> rightNode = lowestCommonAncestorOfTree_Helper(root.getRight(), N1, N2);

        if (leftNode != null && rightNode != null) {
            return root;
        }

        return leftNode == null ? rightNode : leftNode;

    }

    public void lowestCommonAncestorOfTree(TreeNode<Integer> root, int N1, int N2) {
        //https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/description/
        System.out.println("Lowest common ancestor of " + N1 + " " + N2 + ": " + lowestCommonAncestorOfTree_Helper(root, N1, N2));
    }

    class CheckTreeIsSumTree {

        /*Helper class for checkTreeIsSumTree_Helper method*/ int data = 0;
    }

    public boolean checkTreeIsSumTree_Helper(TreeNode<Integer> root, CheckTreeIsSumTree obj) {

        if (root == null) {
            obj.data = 0;
            return true;
        }

        CheckTreeIsSumTree leftSubTreeSum = new CheckTreeIsSumTree();
        CheckTreeIsSumTree rightSubTreeSum = new CheckTreeIsSumTree();

        boolean isLeftSubTreeSumTree = checkTreeIsSumTree_Helper(root.getLeft(), leftSubTreeSum);
        boolean isRightSubTreeSumTree = checkTreeIsSumTree_Helper(root.getRight(), rightSubTreeSum);

        //calculating data for the current root node itself
        obj.data = root.getData() + leftSubTreeSum.data + rightSubTreeSum.data;

        //current root node should not be be leaf
        if (!(root.getLeft() == null && root.getRight() == null)
                && //current root is not equal to the sum of left and rigth sub tree
                (root.getData() != leftSubTreeSum.data + rightSubTreeSum.data)) {
            return false;
        }

        return isLeftSubTreeSumTree && isRightSubTreeSumTree;
    }

    public void checkTreeIsSumTree(TreeNode<Integer> root) {
        System.out.println("Check if a tree is sum tree: " + checkTreeIsSumTree_Helper(root, new CheckTreeIsSumTree()));
    }

    class TreeLongestPathNodeSum {

        /*Helper class for longestPathNodeSum method*/
        List<Integer> path = new ArrayList<>();
        List<Integer> nodeInLongestPath = new ArrayList<>();
        int maxLevel = 0;
        int longestPathSum = 0;
        int maxSumOfAnyPath = 0;
    }

    private void longestPathNodeSum_Helper(TreeNode<Integer> root,
                                           TreeLongestPathNodeSum obj, int level) {

        if (root == null) {
            return;
        }
        obj.path.add(root.getData());
        longestPathNodeSum_Helper(root.getLeft(), obj, level + 1);
        longestPathNodeSum_Helper(root.getRight(), obj, level + 1);

        int currPathSum = 0;
        //to find the max sum of any path this for() is outside of below if() block
        //otherwise only to find sum of longest path move this for() inside the if()
        //it will be optimised then
        for (int nodes : obj.path) {
            currPathSum += nodes;
        }

        if (level > obj.maxLevel) {
            obj.maxLevel = level;
            obj.longestPathSum = currPathSum;
            obj.nodeInLongestPath.clear();
            obj.nodeInLongestPath.addAll(obj.path);
        }

        obj.maxSumOfAnyPath = Math.max(obj.maxSumOfAnyPath, currPathSum);

        //remove the last added node
        obj.path.remove(obj.path.size() - 1);
    }

    public void longestPathNodeSum(TreeNode<Integer> root) {
        TreeLongestPathNodeSum obj = new TreeLongestPathNodeSum();
        longestPathNodeSum_Helper(root, obj, 0);
        System.out.println("The sum of nodes of longest path of tree: " + obj.longestPathSum);
        System.out.println("The length of longest path in the tree: " + obj.maxLevel);
        System.out.println("The nodes of longest path of tree: " + obj.nodeInLongestPath);
        System.out.println("The max sum of nodes that may occur on any path of tree: " + obj.maxSumOfAnyPath);
    }

    private void findPredecessorAndSuccessorInBST_Helper(TreeNode<Integer> root, int key, TreeNode<Integer>[] result) {

        if (root == null) {
            return;
        }

        if (root.getData() == key) {

            if (root.getLeft() != null) {
                //predecessor : rightmost node in the left subtree
                TreeNode<Integer> pred = root.getLeft();
                while (pred.getRight() != null) {
                    pred = pred.getRight();
                }
                result[0] = pred;
            }

            if (root.getRight() != null) {
                //successor : leftmost node in the right subtree
                TreeNode<Integer> succ = root.getRight();
                while (succ.getLeft() != null) {
                    succ = succ.getLeft();
                }
                result[1] = succ;
            }
            return;
        }

        //key is less than root data so move to whole left sub tree
        //ex: root = 2, key = 4
        //2 > 4 -> else
        if (key < root.getData()) {
            result[1] = root; //succ
            findPredecessorAndSuccessorInBST_Helper(root.getLeft(), key, result);
        } else {
            //else move to whole right sub tree
            //in else because 2 is not greater 4
            //inorder of bst is sorted list [2, 4] and 2 will be pred of 4
            result[0] = root; //pred
            findPredecessorAndSuccessorInBST_Helper(root.getRight(), key, result);
        }
    }

    public void findPredecessorAndSuccessorInBST(TreeNode<Integer> root, int key) {
        //..................................T: O(H), worst case: key can be the leaf node, H = height of BST
        //..................................S: O(H), function call stack
        //can use list also [0] : predecessor, [1] : successor
        //https://leetcode.com/problems/inorder-successor-in-bst/description/
        TreeNode<Integer>[] result = new TreeNode[2];
        findPredecessorAndSuccessorInBST_Helper(root, key, result);
        System.out.println("Predecessor and successor of BST: "
                + (result[0] != null ? result[0].getData() : "null") + " "
                + (result[1] != null ? result[1].getData() : "null"));

    }

    private int countNodesThatLieInGivenRange_Count = 0;

    private void countNodesThatLieInGivenRange_Helper(TreeNode<Integer> root, int low, int high) {

        if (root == null) {
            return;
        }

        if (root.getData() >= low && root.getData() <= high) {
            countNodesThatLieInGivenRange_Count++;
        }

        countNodesThatLieInGivenRange_Helper(root.getLeft(), low, high);
        countNodesThatLieInGivenRange_Helper(root.getRight(), low, high);
    }

    public void countNodesThatLieInGivenRange(TreeNode<Integer> root, int low, int high) {
        countNodesThatLieInGivenRange_Count = 0;
        countNodesThatLieInGivenRange_Helper(root, low, high);
        System.out.println("No. of nodes that lie in given range: " + countNodesThatLieInGivenRange_Count);
    }

    public void flattenBSTToLinkedList(TreeNode root) {

        //...........................T: O(N)
        //...........................S: O(N)
        if (root == null) {
            return;
        }

        /*Deque<TreeNode> dQueue = new ArrayDeque<>();
         dQueue.add(root);

         while (!dQueue.isEmpty()) {

         TreeNode curr = dQueue.removeFirst();

         if (curr.getRight() != null) {
         dQueue.addFirst(curr.getRight());
         }

         if (curr.getLeft() != null) {
         dQueue.addFirst(curr.getLeft());
         }

         if (!dQueue.isEmpty()) {
         curr.setRight(dQueue.peek());
         curr.setLeft(null);
         }

         }*/
 /*List<TreeNode> q = new ArrayList<>();
         q.add(root);
         while (!q.isEmpty()) {

         TreeNode curr = q.remove(0);

         if (curr.getRight() != null) {
         q.add(0, curr.getRight());
         }

         if (curr.getLeft() != null) {
         q.add(0, curr.getLeft());
         }

         if (!q.isEmpty()) {
         curr.setRight(q.get(0));
         curr.setLeft(null);
         }

         }*/
        //using LIFO stack
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {

            TreeNode curr = stack.pop();

            //we need left at peek of stack so pushing right first
            //and then left so that left can be at peek
            if (curr.getRight() != null) {
                stack.push(curr.getRight());
            }

            if (curr.getLeft() != null) {
                stack.push(curr.getLeft());
            }

            if (!stack.isEmpty()) {

                curr.setRight(stack.peek());
                curr.setLeft(null);
            }
        }

        //output:
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    private TreeNode flattenBSTToLinkedList_Recursion_Current;

    public void flattenBSTToLinkedList_Recursion_Helper(TreeNode root) {
        if (root == null) {
            return;
        }

        TreeNode left = root.getLeft();
        TreeNode right = root.getRight();

        if (flattenBSTToLinkedList_Recursion_Current != null) {
            flattenBSTToLinkedList_Recursion_Current.setLeft(null);
            flattenBSTToLinkedList_Recursion_Current.setRight(root);
        }

        flattenBSTToLinkedList_Recursion_Current = root;

        flattenBSTToLinkedList_Recursion_Helper(left);
        flattenBSTToLinkedList_Recursion_Helper(right);
    }

    public void flattenBSTToLinkedList_Recursion(TreeNode root) {
        //...........................T: O(N)
        //...........................S: O(1), As we are not taking extra stack other than function call stack
        flattenBSTToLinkedList_Recursion_Current = null;
        flattenBSTToLinkedList_Recursion_Helper(root);
        //output:
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    private void diagonalTraversalOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, List<Integer>> result) {

        if (root == null) {
            return;
        }

        result.putIfAbsent(level, new ArrayList<>());
        result.get(level).add(root.getData());

        diagonalTraversalOfTree_Helper(root.getLeft(), level + 1, result);
        diagonalTraversalOfTree_Helper(root.getRight(), level, result);
    }

    public void diagonalTraversalOfTree(TreeNode<Integer> root) {

        Map<Integer, List<Integer>> result = new TreeMap<>();
        diagonalTraversalOfTree_Helper(root, 0, result);
        System.out.println("Diagonal traversal of tree");
        for (Map.Entry<Integer, List<Integer>> e : result.entrySet()) {
            System.out.println(e.getValue());
        }
    }

    private int diameterOfTree_Helper(TreeNode<Integer> root, Height height) {

        if (root == null) {
            height.height = 0;
            return 0;
        }

        Height leftSubTreeHeight = new Height();
        Height rightSubTreeHeight = new Height();

        int leftTreeDiameter = diameterOfTree_Helper(root.getLeft(), leftSubTreeHeight);
        int rightTreeDiameter = diameterOfTree_Helper(root.getRight(), rightSubTreeHeight);

        //current node height
        height.height = Math.max(leftSubTreeHeight.height, rightSubTreeHeight.height) + 1;

        return Math.max(
                Math.max(leftTreeDiameter, rightTreeDiameter),
                leftSubTreeHeight.height + rightSubTreeHeight.height + 1);
    }

    public void diameterOfTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/diameter-of-binary-tree/
        //https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/
        int diameter = diameterOfTree_Helper(root, new Height());
        //gives the total no of nodes forming that diameter
        System.out.println("Diameter of tree (nodes in diameter): " + diameter);
        //gives the no. of edges between these nodes
        System.out.println("Diameter of tree (edges in diameter): " + (diameter - 1));
    }

    class CheckIfBinaryTreeIsMaxHeapClass {

        /*Helper class for checkIfBinaryTreeIsMaxHeap method*/
        int data;
    }

    private boolean checkIfBinaryTreeIsMaxHeap_Helper(TreeNode<Integer> root, CheckIfBinaryTreeIsMaxHeapClass obj) {

        if (root == null) {
            obj.data = Integer.MIN_VALUE;
            return true;
        }

        CheckIfBinaryTreeIsMaxHeapClass leftSubTree = new CheckIfBinaryTreeIsMaxHeapClass();
        CheckIfBinaryTreeIsMaxHeapClass rightSubTree = new CheckIfBinaryTreeIsMaxHeapClass();

        boolean isLeftMaxHeap = checkIfBinaryTreeIsMaxHeap_Helper(root.getLeft(), leftSubTree);
        boolean isRightMaxHeap = checkIfBinaryTreeIsMaxHeap_Helper(root.getRight(), rightSubTree);

        //calculating current node's object
        obj.data = root.getData();

        //if root's data is less than its immediate left OR right child return false
        if (root.getData() < leftSubTree.data || root.getData() < rightSubTree.data) {
            return false;
        }

        return isLeftMaxHeap && isRightMaxHeap;
    }

    public void checkIfBinaryTreeIsMaxHeap(TreeNode<Integer> root) {
        System.out.println("Given binary tree is max heap: "
                + checkIfBinaryTreeIsMaxHeap_Helper(root, new CheckIfBinaryTreeIsMaxHeapClass()));
    }

    public boolean checkIfAllLevelsOfTwoTreesAreAnagrams_1(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        //this approach performs level order traversal first and then anagrams checking
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        Map<Integer, List<Integer>> levelOrder1 = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root1, 0, levelOrder1); //T: O(N)

        Map<Integer, List<Integer>> levelOrder2 = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root2, 0, levelOrder2); //T: O(N)

        //if both tree are of different levels then two trees acn't be anagrams
        if (levelOrder1.size() != levelOrder2.size()) {
            return false;
        }

        //T: O(H) H = height of tree
        for (int level = 0; level < levelOrder1.size(); level++) {

            List<Integer> l1 = levelOrder1.get(level);
            List<Integer> l2 = levelOrder2.get(level);

            //sort: T: O(Logl1) + O(Logl2)
            Collections.sort(l1);
            Collections.sort(l2);

            //if levels of two trees after sorting are not equal then they are not anagram
            //ex l1.sort: [2,3], l2.sort: [3,4] then l1 != l2
            if (!l1.equals(l2)) {
                return false;
            }
        }

        return true;
    }

    public boolean checkIfAllLevelsOfTwoTreesAreAnagrams_2(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        //this approach performs level order traversal and anagrams checking at the same time
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        Queue<TreeNode<Integer>> q1 = new LinkedList<>();
        Queue<TreeNode<Integer>> q2 = new LinkedList<>();
        q1.add(root1);
        q2.add(root2);

        Queue<TreeNode<Integer>> intQ1 = new LinkedList<>();
        Queue<TreeNode<Integer>> intQ2 = new LinkedList<>();

        List<Integer> l1 = new ArrayList<>();
        List<Integer> l2 = new ArrayList<>();

        while (!q1.isEmpty() && !q2.isEmpty()) {

            TreeNode<Integer> curr1 = q1.poll();
            TreeNode<Integer> curr2 = q2.poll();

            l1.add(curr1.getData());
            l2.add(curr2.getData());

            if (curr1.getLeft() != null) {
                intQ1.add(curr1.getLeft());
            }

            if (curr1.getRight() != null) {
                intQ1.add(curr1.getRight());
            }

            if (curr2.getLeft() != null) {
                intQ2.add(curr2.getLeft());
            }

            if (curr2.getRight() != null) {
                intQ2.add(curr2.getRight());
            }

            if (q1.isEmpty() && q2.isEmpty()) {

                Collections.sort(l1);
                Collections.sort(l2);

                //if after sorting the nodes at a paticular level from both
                //the tree are not equal
                //ex l1.sort: [2,3], l2.sort: [3,4] then l1 != l2
                if (!l1.equals(l2)) {
                    return false;
                }

                l1.clear();
                l2.clear();

                //intQ holds the immediate child nodes of a parent node
                //if the no. of immediate child nodes are different then further
                //checking for anagrams are not req.
                //ex T1: 1.left = 2, 1.right = 3
                //T2: 1.left = 2
                //at parent node = 1 intQ will hold immediate childs
                //intQ1 = [2,3], intQ2 = [2] here intQ1.size != intQ2.size
                if (intQ1.size() != intQ2.size()) {
                    return false;
                }

                q1.addAll(intQ1);
                q2.addAll(intQ2);

                intQ1.clear();
                intQ2.clear();
            }
        }

        //if none of the cond in while is false then all the levels in both tree are anagrams
        return true;
    }

    private boolean areTwoTreeIsoMorphic_Helper(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        return root1.getData() == root2.getData()
                && ((areTwoTreeIsoMorphic_Helper(root1.getLeft(), root2.getRight()) && areTwoTreeIsoMorphic_Helper(root1.getRight(), root2.getLeft()))
                || (areTwoTreeIsoMorphic_Helper(root1.getLeft(), root2.getLeft()) && areTwoTreeIsoMorphic_Helper(root1.getRight(), root2.getRight())));
    }

    public boolean areTwoTreeIsoMorphic(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        return areTwoTreeIsoMorphic_Helper(root1, root2);
    }

    private String findDuplicateSubtreeInAGivenTree_Inorder(TreeNode<Integer> root,
                                                            Map<String, Integer> map, List<TreeNode<Integer>> subtrees) {

        if (root == null) {
            return "";
        }

        String str = "(";
        str += findDuplicateSubtreeInAGivenTree_Inorder(root.getLeft(), map, subtrees);
        str += String.valueOf(root.getData());
        str += findDuplicateSubtreeInAGivenTree_Inorder(root.getRight(), map, subtrees);
        str += ")";

//        System.out.println(str);
        if (map.containsKey(str) && map.get(str) == 1) {
            //System.out.println(root.getData()+ " "); //print the starting node of suplicate subtree
            subtrees.add(root);
        }

        map.put(str, map.getOrDefault(str, 0) + 1);

        return str;
    }

    public void findDuplicateSubtreeInAGivenTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/construct-string-from-binary-tree/
        Map<String, Integer> map = new HashMap<>();
        List<TreeNode<Integer>> subtrees = new ArrayList<>();
        findDuplicateSubtreeInAGivenTree_Inorder(root, map, subtrees);

        //output:
        //print level order of found subtrees
        for (TreeNode<Integer> tree : subtrees) {
            levelOrderTraversal_Recursive(tree);
        }
    }

    private void allNodesAtKDistanceFromRoot(TreeNode<Integer> root, int level,
                                             int K, List<Integer> result) {

        if (root == null) {
            return;
        }

        if (level == K) {
            result.add(root.getData());
        }

        allNodesAtKDistanceFromRoot(root.getLeft(), level + 1, K, result);
        allNodesAtKDistanceFromRoot(root.getRight(), level + 1, K, result);
    }

    private int printAllTheNodesAtKDistanceFromTargetNode_DFS(TreeNode<Integer> root, int target,
                                                              int K, List<Integer> result) {

        if (root == null) {
            return -1;
        }

        if (root.getData() == target) {
            //search all the nodes at K dist below the target node
            allNodesAtKDistanceFromRoot(root, 0, K, result);
            return 1;
        }

        int left = printAllTheNodesAtKDistanceFromTargetNode_DFS(root.getLeft(), target, K, result);

        if (left != -1) {
            if (left == K) {
                result.add(root.getData());
                return -1;
            }
            allNodesAtKDistanceFromRoot(root.getRight(), left + 1, K, result);
            return left + 1;
        }

        int right = printAllTheNodesAtKDistanceFromTargetNode_DFS(root.getRight(), target, K, result);

        if (right != -1) {
            if (right == K) {
                result.add(root.getData());
                return -1;
            }
            allNodesAtKDistanceFromRoot(root.getLeft(), right + 1, K, result);
            return right + 1;
        }

        return -1;
    }

    public void printAllTheNodesAtKDistanceFromTargetNode(TreeNode<Integer> root, int target, int K) {
        //https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
        //https://leetcode.com/problems/closest-leaf-in-a-binary-tree/description/
        List<Integer> result = new ArrayList<>();
        printAllTheNodesAtKDistanceFromTargetNode_DFS(root, target, K, result);
        //output:
        System.out.println("All nodes at K distance from target node: " + result);
    }

    private boolean deleteTreeNodesAndReturnForest_Helper(TreeNode<Integer> root,
                                                          Set<Integer> deleteSet, List<TreeNode<Integer>> result) {

        if (root == null) {
            return false;
        }

        boolean deleteLeft = deleteTreeNodesAndReturnForest_Helper(root.getLeft(), deleteSet, result);
        boolean deleteRight = deleteTreeNodesAndReturnForest_Helper(root.getRight(), deleteSet, result);

        if (deleteLeft) {
            root.setLeft(null);
        }

        if (deleteRight) {
            root.setRight(null);
        }

        if (deleteSet.contains(root.getData())) {

            if (root.getLeft() != null) {
                result.add(root.getLeft());
            }

            if (root.getRight() != null) {
                result.add(root.getRight());
            }
            return true;
        }

        return deleteLeft && deleteRight && deleteSet.contains(root.getData());

    }

    private TreeNode<Integer> deleteTreeNodesAndReturnForest_Helper2(TreeNode<Integer> root,
                                                                     Set<Integer> deleteSet, List<TreeNode<Integer>> result) {

        //Easier explanation
        if (root == null) {
            return null;
        }

        root.setLeft(deleteTreeNodesAndReturnForest_Helper2(root.getLeft(), deleteSet, result));
        root.setRight(deleteTreeNodesAndReturnForest_Helper2(root.getRight(), deleteSet, result));

        if (deleteSet.contains(root.getData())) {

            if (root.getLeft() != null) {
                result.add(root.getLeft());
            }

            if (root.getRight() != null) {
                result.add(root.getRight());
            }

            return null;
        }

        return root;
    }

    public void deleteTreeNodesAndReturnForest(TreeNode<Integer> root, int[] toDelete) {

        List<TreeNode<Integer>> result = new ArrayList<>();

        if (root == null) {
            return;
        }

        Set<Integer> deleteSet = new HashSet<>();
        for (int x : toDelete) {
            deleteSet.add(x);
        }

//        boolean res = deleteTreeNodesAndReturnForest_Helper(root, deleteSet, result);
//
//        if (res == false || (res && !deleteSet.contains(root.getData()))) {
//            result.add(root);
//        }
        //Easier explanation
        //if curr root is not in delete set then root node is also a forest
        if (!deleteSet.contains(root.getData())) {
            result.add(root);
        }
        root = deleteTreeNodesAndReturnForest_Helper2(root, deleteSet, result);

        //output:
        for (TreeNode<Integer> curr : result) {
            levelOrderTraversal_Iterative(curr);
            System.out.println();
        }
    }

    private TreeNode<Integer> constructBinaryTreeFromInorderPreorderArray_Helper(
            int preIndex, int inStart, int inEnd, Map<Integer, Integer> inorderMap, int[] preorder) {

        if (preIndex >= preorder.length || inStart > inEnd) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(preorder[preIndex]);

        int index = inorderMap.get(preorder[preIndex]);

        root.setLeft(constructBinaryTreeFromInorderPreorderArray_Helper(
                preIndex + 1, inStart, index - 1, inorderMap, preorder));
        root.setRight(constructBinaryTreeFromInorderPreorderArray_Helper(
                preIndex + 1 + (index - inStart), index + 1, inEnd, inorderMap, preorder));

        return root;
    }

    public void constructBinaryTreeFromInorderPreorderArray(int[] inorder, int[] preorder) {

        System.out.println("Inorder & Preorder");
        if (inorder.length != preorder.length) {
            return;
        }

        int n = inorder.length;

        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            inorderMap.put(inorder[i], i);
        }

        TreeNode<Integer> root = constructBinaryTreeFromInorderPreorderArray_Helper(
                0, 0, n - 1, inorderMap, preorder);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> constructBinaryTreeFromInorderPostorderArray_Helper(
            int[] postorder, int postIndex, int inStart, int inEnd,
            Map<Integer, Integer> inorderMap) {
        if (inStart > inEnd || postIndex < 0 || postIndex > postorder.length) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(postorder[postIndex]);
        int index = inorderMap.get(postorder[postIndex]);

        root.setLeft(constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder,
                // current root minus what's on the right side on the inorder array minus 1
                postIndex - (inEnd - index) - 1,
                inStart,
                index - 1,
                inorderMap
        ));

        root.setRight(constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder,
                // the next right side node will be the next one (backwards) on the postorder list
                postIndex - 1,
                index + 1,
                inEnd,
                inorderMap
        ));

        return root;
    }

    public void constructBinaryTreeFromInorderPostorderArray(int[] inorder, int[] postorder) {
        //https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
        System.out.println("Inorder & Postorder");
        if (inorder.length != postorder.length) {
            return;
        }

        int n = inorder.length;
        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            inorderMap.put(inorder[i], i);
        }

        TreeNode<Integer> root = constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder, n - 1, 0, n - 1, inorderMap);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> constructBinarySearchTreeFromPreorderArray_Helper(int[] preorder, int preStart, int preEnd) {

        if (preStart > preEnd) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(preorder[preStart]);

        int index = preStart + 1;
        while (index <= preEnd && preorder[index] < preorder[preStart]) {
            index++;
        }

        root.setLeft(constructBinarySearchTreeFromPreorderArray_Helper(preorder, preStart + 1, index - 1));
        root.setRight(constructBinarySearchTreeFromPreorderArray_Helper(preorder, index, preEnd));

        return root;
    }

    public void constructBinarySearchTreeFromPreorderArray(int[] preorder) {

        int n = preorder.length;
        TreeNode<Integer> root = constructBinarySearchTreeFromPreorderArray_Helper(preorder, 0, n - 1);

        //output:
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> constructBinarySearchTreeFromPostorderArray_Helper(
            int[] postorder, int postStart, int postEnd) {

        if (postEnd > postStart) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(postorder[postStart]);

        int index = postStart - 1;
        while (index >= postEnd && postorder[index] > postorder[postStart]) {
            index--;
        }

        root.setLeft(constructBinarySearchTreeFromPostorderArray_Helper(postorder, index, postEnd));
        root.setRight(constructBinarySearchTreeFromPostorderArray_Helper(postorder, postStart - 1, index + 1));

        return root;
    }

    public void constructBinarySearchTreeFromPostorderArray(int[] postorder) {

        int n = postorder.length;
        TreeNode<Integer> root = constructBinarySearchTreeFromPostorderArray_Helper(postorder, n - 1, 0);

        //output:
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL;
    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev;

    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return null;
        }

        TreeNode<Integer> leftChild = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root.getLeft());
        TreeNode<Integer> rightChild = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root.getRight());

        //isLeaf condition
        if (root.getLeft() == null && root.getRight() == null) {

            //left most leaf node
            if (leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL == null) {
                leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL = root;
            }

            if (leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev != null) {
                leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev.setRight(root);
                root.setLeft(leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev);
            }

            leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev = root;

            return null; //to delete leaf, return null to its parent
        }

        //setting current root's left and right child below the isLeaf condition
        //because if we add these child before that condition, current root can become
        //a leaf node itself just before the isLeaf check and in that condition
        //that root will be considered as leaf
        /*
         treeBFS = 2,3,4;
         3 & 4 are leaf;
         inside isLeaf cond it will return null to its parent (i.e, 2);
         now if 2.left = null & 2.right = null is before isLeaf the 2 will be
         a leaf itself, which should never be the checked;
         thats why root.left = leftChild & root.right = rightChild should be below
         isLeaf cond to save the parent/intermediate node;
         */
        root.setLeft(leftChild);
        root.setRight(rightChild);

        return root;
    }

    public void leavesOfTreeToDoublyLinkedListAndRemoveLeaves(TreeNode<Integer> root) {

        //actual
        System.out.println("Actual tree");
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();

        leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL = null;
        leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev = null;

        //in case if root node is single node,that must be head of DLL and should be deleted(set to null)
        //otherwise it will just return root itselt
        root = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root);

        //output;
        System.out.println("Leaf of tree are now DLL");
        treeToDoublyLinkedList_Print(leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL);
        System.out.println("Tree after deleting leaf");
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private void checkIfTwoNAryTreeAreMirror_PushStack(List<List<Integer>> tree1, Stack<Integer> stack, int root) {

        if (tree1.size() == 0) {
            return;
        }

        stack.push(root);
        List<Integer> childs = tree1.get(root);
        for (int childNodes : childs) {
            checkIfTwoNAryTreeAreMirror_PushStack(tree1, stack, childNodes);
        }
    }

    private void checkIfTwoNAryTreeAreMirror_PushQueue(List<List<Integer>> tree2, Queue<Integer> queue, int root) {

        if (tree2.size() == 0) {
            return;
        }

        List<Integer> childs = tree2.get(root);
        for (int childNodes : childs) {
            checkIfTwoNAryTreeAreMirror_PushQueue(tree2, queue, childNodes);
        }
        queue.add(root);
    }

    public boolean checkIfTwoNAryTreeAreMirror(List<List<Integer>> tree1, List<List<Integer>> tree2) {

        //Explanation: https://youtu.be/UGzXSDZv-SY
        Stack<Integer> stack = new Stack<>();
        checkIfTwoNAryTreeAreMirror_PushStack(tree1, stack, 0);

        Queue<Integer> queue = new LinkedList<>();
        checkIfTwoNAryTreeAreMirror_PushQueue(tree2, queue, 0);

//        System.out.println(stack+"---"+queue);
        if (stack.size() != queue.size()) {
            System.out.println("Not a mirror images");
            return false;
        }

        while (!stack.isEmpty() && !queue.isEmpty()) {
            if (stack.pop() != queue.poll()) {
                return false;
            }
        }
        return true;
    }

    public void deepestLeavesSumOfTree_Iterative(TreeNode<Integer> root) {

//        base edge case
//        if(root == null){
//            return 0;
//        }
        //do level order traversal
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        int sum = 0;
        while (!q.isEmpty()) {

            sum = 0;

            //size of queue at a particular level is required beforehand
            //because we putting the child of curr node in the queue
            //we don't want those nodes to be consumed in the for() loop
            int size = q.size();
            for (int i = 0; i < size; i++) {

                //add up all the nodes at a particular level in the sum variable
                //and at the same time add the chiild nodes of curr node into queue
                TreeNode<Integer> curr = q.poll();

                sum += curr.getData();
                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
        }

        //output:
        System.out.println("Deepest leaves sum: " + sum);
    }

    private void smallestStringInTreeFromLeafToRoot_Helper(TreeNode<Integer> root, StringBuilder sb,
                                                           PriorityQueue<String> strs) {

        if (root == null) {
            return;
        }

        sb.insert(0, (char) (root.getData() + 'a'));

        smallestStringInTreeFromLeafToRoot_Helper(root.getLeft(), sb, strs);
        smallestStringInTreeFromLeafToRoot_Helper(root.getRight(), sb, strs);

        if (root.getLeft() == null && root.getRight() == null) {
            strs.add(sb.toString());
            //we only need 1 string as answer
            if (strs.size() > 1) {
                strs.poll();
            }
        }

        sb.deleteCharAt(0);
    }

    public void smallestStringInTreeFromLeafToRoot(TreeNode<Integer> root) {

        //each nodes contains value 0 - 25 representing alphabets a - z
        //find the lexicographically smallest string (leaf to root) in the tree
        StringBuilder sb = new StringBuilder();
        //making maxHeap to store smallest string in the last of heap
        PriorityQueue<String> strs = new PriorityQueue<>((a, b) -> b.compareTo(a));
        smallestStringInTreeFromLeafToRoot_Helper(root, sb, strs);

        //output
        System.out.println("Smallest string: " + strs.peek());
    }

    private void printSumWhereRootToLeafPathIsANumber_createNumberHelper(TreeNode<Integer> root, int num, List<Integer> nums) {

        if (root == null) {
            return;
        }

        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root.getLeft(), num * 10 + root.getData(), nums);
        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root.getRight(), num * 10 + root.getData(), nums);

        if (root.getLeft() == null && root.getRight() == null) {
            nums.add(num * 10 + root.getData());
        }
    }

    public void printSumWhereRootToLeafPathIsANumber(TreeNode<Integer> root) {

        //ex:
        /* root:
         1
         2       3
         */
        //num1 = 12 (as 1->2 is a path)
        //num2 = 13 (as 1->3 is a path)
        //each path from root to leaf is a separate num
        //print sum of all such number
        List<Integer> nums = new ArrayList<>();
        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root, 0, nums);

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        //output:
        System.out.println("Sum of path of tree representing as a number: " + sum);
    }

    private void fixTwoSwappedNodesInBST_Helper_IsBST(TreeNode<Integer> root) {
        if (root == null) {
            return;
        }

        fixTwoSwappedNodesInBST_Helper_IsBST(root.getLeft());

        if (fixTwoSwappedNodesInBST_Prev != null && fixTwoSwappedNodesInBST_Prev.getData() > root.getData()) {

            if (fixTwoSwappedNodesInBST_First == null) {
                fixTwoSwappedNodesInBST_First = fixTwoSwappedNodesInBST_Prev;
                fixTwoSwappedNodesInBST_Middle = root;
            } else {
                fixTwoSwappedNodesInBST_Last = root;
            }
        }

        fixTwoSwappedNodesInBST_Prev = root;

        fixTwoSwappedNodesInBST_Helper_IsBST(root.getRight());
    }

    private void fixTwoSwappedNodesInBST_Helper(TreeNode<Integer> root) {

        fixTwoSwappedNodesInBST_First = null;
        fixTwoSwappedNodesInBST_Middle = null;
        fixTwoSwappedNodesInBST_Last = null;
        fixTwoSwappedNodesInBST_Prev = null;

        fixTwoSwappedNodesInBST_Helper_IsBST(root);

        if (fixTwoSwappedNodesInBST_First != null && fixTwoSwappedNodesInBST_Last != null) {
            int temp = fixTwoSwappedNodesInBST_First.getData();
            fixTwoSwappedNodesInBST_First.setData(fixTwoSwappedNodesInBST_Last.getData());
            fixTwoSwappedNodesInBST_Last.setData(temp);
        } else if (fixTwoSwappedNodesInBST_First != null && fixTwoSwappedNodesInBST_Middle != null) {
            int temp = fixTwoSwappedNodesInBST_First.getData();
            fixTwoSwappedNodesInBST_First.setData(fixTwoSwappedNodesInBST_Middle.getData());
            fixTwoSwappedNodesInBST_Middle.setData(temp);
        }
    }

    TreeNode<Integer> fixTwoSwappedNodesInBST_First;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Middle;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Last;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Prev;

    public void fixTwoSwappedNodesInBST(TreeNode<Integer> root) {

        //https://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/
        //actual
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();

        fixTwoSwappedNodesInBST_Helper(root);

        //output
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> mergeTwoBinaryTree_Heleper(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        if (root1 == null) {
            return root2;
        }

        if (root2 == null) {
            return root1;
        }

        root1.setData(root1.getData() + root2.getData());

        root1.setLeft(mergeTwoBinaryTree_Heleper(root1.getLeft(), root2.getLeft()));
        root1.setRight(mergeTwoBinaryTree_Heleper(root1.getRight(), root2.getRight()));

        return root1;
    }

    public void mergeTwoBinaryTree(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        //actual
        System.out.println("Actual trees");
        new BinaryTree<Integer>(root1).treeBFS();
        System.out.println();
        new BinaryTree<Integer>(root2).treeBFS();
        System.out.println();

        mergeTwoBinaryTree_Heleper(root1, root2);

        //output
        System.out.println("Merged both trees in tree1");
        new BinaryTree<Integer>(root1).treeBFS();
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_Factorial(long N) {
        long result = 1;
        for (long i = 1; i <= N; i++) {
            result *= i;
        }

        return result;
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_BinomialCoeff(long N, long K) {
        long result = 1;

        if (K > N - K) {
            K = N - K;
        }

        for (long i = 0; i < K; i++) {
            result *= (N - i);
            result /= (i + 1);
        }

        return result;
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(long N) {

        //Catalan number series:
        //https://www.youtube.com/watch?j=CMaZ69P1bAc
        //https://www.geeksforgeeks.org/program-nth-catalan-number/
        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
        long cat = numberOfWaysToCreateBSTAndBTWithGivenN_BinomialCoeff(2 * N, N);
        return cat / (N + 1);
    }

    public void numberOfWaysToCreateBSTAndBTWithGivenN(long N) {

        //problem: https://leetcode.com/problems/unique-binary-search-trees
        //Explanation :
        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
        //ways to create BST
        //find the catalan number of given Nth number
        System.out.println("Number of ways to create a binary search tree with given N nodes: "
                + numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(N));

        //ways to create BT
        //find the catalan number of given Nth number * factorial(N)
        System.out.println("Number of ways to create a binary tree with given N nodes: "
                + (numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(N)
                * numberOfWaysToCreateBSTAndBTWithGivenN_Factorial(N)));
    }

    public boolean checkIfBinaryTreeIsCompleteOrNot(TreeNode<Integer> root) {

        //explanation: https://youtu.be/j16cwbLEf9w
        //complete binary tree:
        /*
         In a complete binary tree, every level, except possibly the last,
         is completely filled, and all nodes in the last level are as far left
         as possible. It can have between 1 and 2^h nodes inclusive at the
         last level h.
         */
        //all the nodes at last level should be left-most alinged
        //if any null is present before the very last node at the level
        //that means tree is not complete binary tree
        boolean isNullBeforeLastNode = false;

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            TreeNode<Integer> curr = q.poll();

            if (curr == null) {
                isNullBeforeLastNode = true;
            } else {
                if (isNullBeforeLastNode) {
                    return false;
                }
                //put all the left and right child nodes as it is
                //without checking for null
                q.add(curr.getLeft());
                q.add(curr.getRight());
            }
        }
        return true;
    }

    private void maximumWidthOfBinaryTree_Helper(TreeNode<Integer> root, int level,
                                                 int position, Map<Integer, Integer> map) {
        if (root == null) {
            return;
        }

        map.putIfAbsent(level, position);
        maximumWidthOfBinaryTree_MaxWidth = Math.max(maximumWidthOfBinaryTree_MaxWidth,
                position - map.get(level) + 1);

        maximumWidthOfBinaryTree_Helper(root.getLeft(), level + 1, 2 * position, map);
        maximumWidthOfBinaryTree_Helper(root.getRight(), level + 1, 2 * position + 1, map);
    }

    int maximumWidthOfBinaryTree_MaxWidth;

    public void maximumWidthOfBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-width-of-binary-tree/description/
        //explanation: https://youtu.be/FPzLE2L7uHs | https://youtu.be/sm4UdCO2868
        maximumWidthOfBinaryTree_MaxWidth = 0;
        Map<Integer, Integer> map = new HashMap<>();
        maximumWidthOfBinaryTree_Helper(root, 0, 1, map);

        //output
        System.out.println("Max Width of binary tree: " + maximumWidthOfBinaryTree_MaxWidth);
    }

    private int distributeCoinsInBinaryTree_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return 0;
        }

        int leftDistributionMove = distributeCoinsInBinaryTree_Helper(root.getLeft());
        int rightDistributionMove = distributeCoinsInBinaryTree_Helper(root.getRight());

        distributeCoinsInBinaryTree_Moves += (Math.abs(leftDistributionMove) + Math.abs(rightDistributionMove));

        return root.getData() + leftDistributionMove + rightDistributionMove - 1;
    }

    int distributeCoinsInBinaryTree_Moves;

    public void distributeCoinsInBinaryTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/distribute-coins-in-binary-tree/
        //explanation: https://youtu.be/MfXxic8IhkI
        //coins = root.data, distribution rule: parent to child OR child to parent
        distributeCoinsInBinaryTree_Moves = 0;
        distributeCoinsInBinaryTree_Helper(root);

        //output:
        System.out.println("Number of moves to distribute coins equally in whole tree: " + distributeCoinsInBinaryTree_Moves);
    }

    public boolean checkIfBinaryTreeIsOddEvenTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/even-odd-tree
        int level = 0;
        TreeNode<Integer> prev = null;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            prev = null; //reset
            int size = q.size();

            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();
                if (level % 2 == 0) {
                    //level = EVEN then nodes at this level should have
                    //all odd data and nodes at this level should be in strictly incr order
                    if (curr.getData() % 2 == 0 || (prev != null && prev.getData() >= curr.getData())) {
                        return false;
                    }
                } else {
                    //level = ODD then nodes at this level should have
                    //all even data and nodes at this level should be in strictly decr order
                    if (curr.getData() % 2 == 1 || (prev != null && prev.getData() <= curr.getData())) {
                        return false;
                    }
                }

                prev = curr;

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }

            level++;
        }
        return true;
    }

    private int maxSumInAnyPathOfTree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int leftSum = Math.max(0, maxSumInAnyPathOfTree_Helper(root.getLeft()));
        int rightSum = Math.max(0, maxSumInAnyPathOfTree_Helper(root.getRight()));

        maxSumInAnyPathOfTree_MaxPathSum = Math.max(maxSumInAnyPathOfTree_MaxPathSum,
                leftSum + rightSum + root.getData());

        return Math.max(leftSum, rightSum) + root.getData();
    }

    int maxSumInAnyPathOfTree_MaxPathSum;

    public void maxSumInAnyPathOfTree(TreeNode<Integer> root) {

        //SIMILAR to diameter of tree approach
        //https://leetcode.com/problems/binary-tree-maximum-path-sum/
        //explanation: https://youtu.be/mOdetMWwtoI
        maxSumInAnyPathOfTree_MaxPathSum = Integer.MIN_VALUE;
        maxSumInAnyPathOfTree_Helper(root);

        //output
        System.out.println("Max path sum in any path of tree: " + maxSumInAnyPathOfTree_MaxPathSum);
    }

    private int longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return 0;
        }

        int left = longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root.getLeft());
        int right = longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root.getRight());

        int leftEdge = 0;
        if (root.getLeft() != null && root.getLeft().getData() == root.getData()) {
            leftEdge += left + 1;
        }

        int rightEdge = 0;
        if (root.getRight() != null && root.getRight().getData() == root.getData()) {
            rightEdge += right + 1;
        }

        longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge = Math.max(longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge,
                leftEdge + rightEdge);

        return Math.max(leftEdge, rightEdge);
    }

    int longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge;

    public void longestEdgeLengthBetweenTreeNodesWithSameValue(TreeNode<Integer> root) {

        //https://leetcode.com/problems/longest-univalue-path/
        longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge = 0;
        longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root);

        //output
        System.out.println("Longest edge between the nodes having same values: " + longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge);
    }

    private int countNodesInCompleteBinaryTree_LeftTreeHeight(TreeNode<Integer> root) {
        int height = 0;
        while (root != null) {
            height++;
            root = root.getLeft();
        }
        return height;
    }

    private int countNodesInCompleteBinaryTree_RightTreeHeight(TreeNode<Integer> root) {
        int height = 0;
        while (root != null) {
            height++;
            root = root.getRight();
        }
        return height;
    }

    public int countNodesInCompleteBinaryTree(TreeNode<Integer> root) {

        //brute force do levelorder and count++ for all the nodes T: O(N)
        //OPTIMISED
        //https://leetcode.com/problems/count-complete-tree-nodes/
        if (root == null) {
            return 0;
        }

        int leftSubtreeHeight = countNodesInCompleteBinaryTree_LeftTreeHeight(root);
        int rightSubtreeHeight = countNodesInCompleteBinaryTree_RightTreeHeight(root);

        if (leftSubtreeHeight == rightSubtreeHeight) {
            //number of node in complete binary tree = (2^H) - 1
            return (int) Math.pow(2, leftSubtreeHeight) - 1;
        }

        return countNodesInCompleteBinaryTree(root.getLeft())
                + countNodesInCompleteBinaryTree(root.getRight()) + 1;
    }

    public int countGoodNodesInBinaryTree_1(TreeNode<Integer> root, int max) {

        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
        /*
         Given a binary tree root, a node X in the tree is named good if in the
         path from root to X there are no nodes with a value greater than X.
         */
        if (root == null) {
            return 0;
        }

        int left = countGoodNodesInBinaryTree_1(root.getLeft(), Math.max(max, root.getData()));
        int right = countGoodNodesInBinaryTree_1(root.getRight(), Math.max(max, root.getData()));

        if (root.getData() < max) {
            //curr node is not a goodNode but it can have
            //max (curr goodNode(i.e 0), left sub tree gootNodes + right sub tree gooNodes)
            return Math.max(0, left + right);
        }

        //left sub tree goodNodes + right sub tree goodNodes + curr root goodNode(i.e 1)
        return left + right + 1;
    }

    private void countGoodNodesInBinaryTree_2_Helper(TreeNode<Integer> root, int max) {

        if (root == null) {
            return;
        }

        countGoodNodesInBinaryTree_2_Helper(root.getLeft(), Math.max(max, root.getData()));
        countGoodNodesInBinaryTree_2_Helper(root.getRight(), Math.max(max, root.getData()));

        if (root.getData() >= max) {
            countGoodNodesInBinaryTree_2_GoodNodes++;
        }
    }

    int countGoodNodesInBinaryTree_2_GoodNodes = 0;

    public void countGoodNodesInBinaryTree_2(TreeNode<Integer> root) {

        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
        /*
         Given a binary tree root, a node X in the tree is named good if in the
         path from root to X there are no nodes with a value greater than X.
         */
        //EASIER APPROACH
        countGoodNodesInBinaryTree_2_GoodNodes = 0;
        countGoodNodesInBinaryTree_2_Helper(root, Integer.MIN_VALUE);

        //output
        System.out.println("Good nodes counts in tree approach 2: " + countGoodNodesInBinaryTree_2_GoodNodes);
    }

    private int minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(TreeNode<Integer> root, int N, int level) {

        if (root == null) {
            return -1;
        }

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();

                if (curr.getData() == N) {
                    return level;
                }

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
            level++;
        }
        return -1;
    }

    public void minDistanceBetweenGivenTwoNodesInBinaryTree(TreeNode<Integer> root, int N1, int N2) {

        //https://www.geeksforgeeks.org/find-distance-between-two-nodes-of-a-binary-tree/
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, N1, N2);

        int levelN1 = minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(lca, N1, 0);
        int levelN2 = minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(lca, N2, 0);

        System.out.println("Min dstance between two given nodes: " + (levelN1 + levelN2));
    }

    private void maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(TreeNode<Integer> root) {
        if (root == null) {
            return;
        }

        maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum += root.getData();

        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root.getLeft());
        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root.getRight());
    }

    private int maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int leftSubTreeSum = maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root.getLeft());
        int rightSubTreeSum = maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root.getRight());

        int leftSplitProduct = (maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum - leftSubTreeSum) * leftSubTreeSum;
        int rightSplitProduct = (maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum - rightSubTreeSum) * rightSubTreeSum;

        maxProductIfBinaryTreeIsSplitIntoTwo_Product = Math.max(maxProductIfBinaryTreeIsSplitIntoTwo_Product,
                Math.max(leftSplitProduct, rightSplitProduct));

        return leftSubTreeSum + rightSubTreeSum + root.getData(); //sub-tree sum from bottom
    }

    int maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum = 0;
    int maxProductIfBinaryTreeIsSplitIntoTwo_Product = 0;

    public void maxProductIfBinaryTreeIsSplitIntoTwo(TreeNode<Integer> root) {

        //https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
        /*

         treeBFS = [1,2,3,4,5,6,NULL]
         split tree as t1 = [2,4,5], t2 = [1,3,6] link-break-between 1.left = 2 break this
         product = sum{t1} * sum(t2) should be maximum
         trace all such break-point where, product of two subtrees max (prod1, prod2)
         */
        maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum = 0;
        maxProductIfBinaryTreeIsSplitIntoTwo_Product = 0;

        //find the total sum of all tree nodes
        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root);

        //find max product by imitating splits
        maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root);

        //output
        System.out.println("Max product of sum of trees by splitting into two: "
                + maxProductIfBinaryTreeIsSplitIntoTwo_Product);

    }

    private List<TreeNode<Integer>> deleteTreeNodeFromBinarySearchTree_FindInorderSuccessor(
            TreeNode<Integer> root) {

        if (root == null) {
            return Collections.emptyList();
        }

        TreeNode<Integer> succ = null;
        TreeNode<Integer> succPrev = null;
        if (root.getRight() != null) {
            succPrev = root;
            succ = root.getRight(); //succ is left most node in the right sub tree
            while (succ.getLeft() != null) {
                succPrev = succ;
                succ = succ.getLeft();
            }
        }
        return Arrays.asList(succPrev, succ);
    }

    private TreeNode<Integer> deleteTreeNodeFromBinarySearchTree_Delete(TreeNode<Integer> rootToDelete) {

        //https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
        if (rootToDelete == null) {
            return null;
        }

        if (rootToDelete.getLeft() == null && rootToDelete.getRight() == null) { // node is leaf
            return null;
        } else if (rootToDelete.getLeft() == null) { //node has one child
            return rootToDelete.getRight();
        } else if (rootToDelete.getRight() == null) { //node has one child
            return rootToDelete.getLeft();
        } else { //node has two child
            List<TreeNode<Integer>> succList = deleteTreeNodeFromBinarySearchTree_FindInorderSuccessor(rootToDelete);

            if (!succList.isEmpty()) {
                TreeNode<Integer> succPrev = succList.get(0);
                TreeNode<Integer> succ = succList.get(1);
                //replace root's data with inorder successor (succ)
                rootToDelete.setData(succ.getData());
                //delete the inorder successor node from its actual place
                if (succPrev != rootToDelete) {
                    succPrev.setLeft(deleteTreeNodeFromBinarySearchTree_Delete(succ));
                } else {
                    succPrev.setRight(deleteTreeNodeFromBinarySearchTree_Delete(succ));
                }
            }

            return rootToDelete;
        }
    }

    public TreeNode<Integer> deleteTreeNodeFromBinarySearchTree(TreeNode<Integer> root, int findToDelete) {

        //https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
        if (root == null) {
            return null;
        }

        if (root.getData() == findToDelete) {
            return deleteTreeNodeFromBinarySearchTree_Delete(root);
        } else if (findToDelete < root.getData()) {
            root.setLeft(deleteTreeNodeFromBinarySearchTree(root.getLeft(), findToDelete));
        } else {
            root.setRight(deleteTreeNodeFromBinarySearchTree(root.getRight(), findToDelete));
        }
        return root;
    }

    private TreeNode<Integer> deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(TreeNode<Integer> root,
                                                                                  int low, int high) {

        if (root == null) {
            return null;
        }

        root.setLeft(deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root.getLeft(),
                low, high));
        root.setRight(deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root.getRight(),
                low, high));

        //not in range
        if (!(root.getData() >= low && root.getData() <= high)) {
            return deleteTreeNodeFromBinarySearchTree_Delete(root);
        }

        return root;
    }

    public void deleteTreeNodeFromBinarySearchTreeNotInRange(TreeNode<Integer> root,
                                                             int low, int high) {
        TreeNode<Integer> node = deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root, low, high);
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    public void checkIfTwoTreeNodesAreCousin(TreeNode<Integer> root, int x, int y) {

        //https://leetcode.com/problems/cousins-in-binary-tree/
        /*
         Two nodes are cousins when they both lie on same level (levelX == levelY) but also
         their parent should not be same (parentX != parentY)
         */
        int levelX = -1;
        int levelY = -1;

        TreeNode<Integer> parentX = null;
        TreeNode<Integer> parentY = null;

        int level = 0;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());

                    //x or col can be in left sub tree
                    if ((int) curr.getLeft().getData() == x) {
                        levelX = level;
                        parentX = curr;
                    }

                    if ((int) curr.getLeft().getData() == y) {
                        levelY = level;
                        parentY = curr;
                    }
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());

                    //x or col can be in right sub tree
                    if ((int) curr.getRight().getData() == x) {
                        levelX = level;
                        parentX = curr;
                    }

                    if ((int) curr.getRight().getData() == y) {
                        levelY = level;
                        parentY = curr;
                    }
                }
            }

            //if both nodes are found, their parents will not be null
            //and we will not be required to traverse further
            if (parentX != null && parentY != null) {
                break;
            }
            level++;
        }

        if (levelX == levelY && parentX != parentY) {
            System.out.println("Cousins");
        } else {
            System.out.println("Not cousins");
        }
    }

    public void cousinsInBinaryTreeTwo(TreeNode<Integer> root) {
        //https://leetcode.com/problems/cousins-in-binary-tree-ii/description/

        //actual
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();

        Map<Integer, Set<TreeNode<Integer>>> levelToParents = new HashMap<>();
        Map<Integer, Integer> levelWiseNodeSum = new HashMap<>();

        int maxLevel = 0;

        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> currRoot = queue.poll();

                //curr level == maxLevel, child level below is maxLevel + 1
                //so the parent of nodes in child level is 'currRoot'
                levelToParents.putIfAbsent(maxLevel + 1, new HashSet<>());
                levelToParents.get(maxLevel + 1).add(currRoot);

                //curr level == maxLevel, in this map we will store the sum of nodes
                //in the curr level only
                levelWiseNodeSum.put(maxLevel, levelWiseNodeSum.getOrDefault(maxLevel, 0) + currRoot.getData());

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }
            maxLevel++;
        }

        //process tree now
        for (int level = 0; level < maxLevel; level++) {
            if (level == 0) {
                root.setData(0);
            } else {

                //total sum of nodes per level
                int levelWiseTotalSum = levelWiseNodeSum.get(level);

                //iterate over the all the parent nodes above this 'level'
                for (TreeNode<Integer> parent : levelToParents.get(level)) {

                    //curr parent can have atmost 2 childs, find the possible sum
                    //from these 2 childs of curr 'parent'
                    int childSum = 0;
                    childSum += parent.getLeft() == null ? 0 : parent.getLeft().getData();
                    childSum += parent.getRight() == null ? 0 : parent.getRight().getData();

                    //possible child value to be updated with
                    //total_level_wise_sum - sum_of_childs_of_curr_parent
                    int updateChildNodes = levelWiseTotalSum - childSum;

                    //update both the child of curr 'parent'
                    if (parent.getLeft() != null) {
                        parent.getLeft().setData(updateChildNodes);
                    }

                    if (parent.getRight() != null) {
                        parent.getRight().setData(updateChildNodes);
                    }
                }
            }
        }
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private void printConnectedNodesAtSameLevelByRandomPointer(TreeNode<Integer> root) {

        int level = 0;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = q.poll();
                TreeNode<Integer> ptrRandom = curr;
                System.out.print(level + ": ");
                while (ptrRandom != null) {
                    //print the nodes connected by random pointers
                    System.out.print(ptrRandom.getData() + " ");
                    ptrRandom = ptrRandom.getRandom();
                }

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }

                System.out.println();
            }
            level++;
        }
    }

    private void connectTreeNodesAtSameLevel_Recursive_Helper(TreeNode<Integer> root,
                                                              int level, Map<Integer, TreeNode<Integer>> map) {

        if (root == null) {
            return;
        }

        if (map.containsKey(level)) {
            //this will have a previous node to current root
            map.get(level).setRandom(root);
        }

        //update previous node with current root in that level
        map.put(level, root);
        root.setRandom(null); //default random value if there is no next node in that level

        connectTreeNodesAtSameLevel_Recursive_Helper(root.getLeft(), level + 1, map);
        connectTreeNodesAtSameLevel_Recursive_Helper(root.getRight(), level + 1, map);
    }

    public void connectTreeNodesAtSameLevel_Recursive(TreeNode<Integer> root) {
        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
        Map<Integer, TreeNode<Integer>> map = new HashMap<>();
        connectTreeNodesAtSameLevel_Recursive_Helper(root, 0, map);

        //output
        printConnectedNodesAtSameLevelByRandomPointer(root);
    }

    public void connectTreeNodesAtSameLevel_Iterative(TreeNode<Integer> root) {
        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);
        TreeNode<Integer> prev;
        while (!queue.isEmpty()) {

            int size = queue.size();
            prev = null;

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = queue.poll();
                if (i > 0) {
                    prev.setRandom(curr);
                }
                curr.setRandom(null);
                prev = curr;

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }
        }

        //output
        printConnectedNodesAtSameLevelByRandomPointer(root);
    }

    private void binarySearchTreeToGreaterSumTree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return;
        }

        //go to right most leaf node in right sub tree
        //output starts from there only (otherwise you could choose as per the output demands)
        binarySearchTreeToGreaterSumTree_Helper(root.getRight());

        binarySearchTreeToGreaterSumTree_Sum += root.getData();

        root.setData(binarySearchTreeToGreaterSumTree_Sum);

        //now go to left sub tree as per output
        binarySearchTreeToGreaterSumTree_Helper(root.getLeft());
    }

    int binarySearchTreeToGreaterSumTree_Sum;

    public void binarySearchTreeToGreaterSumTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/convert-bst-to-greater-tree/
        //actual
        new BinarySearchTree<Integer>(root).treeBFS();
        System.out.println();

        binarySearchTreeToGreaterSumTree_Sum = 0;
        binarySearchTreeToGreaterSumTree_Helper(root);

        //output
        new BinarySearchTree<Integer>(root).treeBFS();
        System.out.println();
    }

    public void subtreeWithAllDeepestNodes(TreeNode<Integer> root) {

        //https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
        //https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
        //Actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //levelorder to find the deepest leaf nodes
        List<Integer> deepLeaf = new ArrayList<>();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            //clear all previous levels, in the end, we will have last level,
            //which will never be cleared
            deepLeaf.clear();
            int size = q.size();
            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = q.poll();
                deepLeaf.add(curr.getData());

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
        }

        //get leftMost & rightMost leaf nodes in the deepLeaf level
        int n1 = -1;
        int n2 = -1;
        if (!deepLeaf.isEmpty()) {
            n1 = deepLeaf.get(0);
            n2 = deepLeaf.get(deepLeaf.size() - 1);
        }

        //find lca for n1 & n2
        //lca for two deepest leaf nodes will hold subtree, that conatins the deepest leaf nodes
        TreeNode<Integer> lcaForDeepLeafNodes = null;
        if (n1 != -1 && n2 != -1) {
            lcaForDeepLeafNodes = lowestCommonAncestorOfTree_Helper(root, n1, n2);
        }

        //output
        new BinaryTree<>(lcaForDeepLeafNodes).treeBFS();
        System.out.println();
    }

    private void pseudoPallindromicPathInBinaryTree_Helper(TreeNode<Integer> root,
                                                           Map<Integer, Integer> map) {

        if (root == null) {
            return;
        }

        //freq of nodes in the path
        map.put(root.getData(), map.getOrDefault(root.getData(), 0) + 1);

        pseudoPallindromicPathInBinaryTree_Helper(root.getLeft(), map);
        pseudoPallindromicPathInBinaryTree_Helper(root.getRight(), map);

        if (root.getLeft() == null && root.getRight() == null) {
            //for a path to be pseudo pallindromic, the freq of nodes in the paths can have
            //either even freq(nodeHasOddFreq == 0) OR atmost 1 node can have odd freq(nodeHasOddFreq == 1)
            int nodeHasOddFreq = 0;
            for (int key : map.keySet()) {
                if (map.get(key) % 2 == 1) {
                    nodeHasOddFreq++;
                }
            }

            //atmost 1 node should have odd freq
            if (nodeHasOddFreq <= 1) {
                pseudoPallindromicPathInBinaryTree_Count++;
            }
        }

        //remove the freq of the last node added once they are processed
        map.put(root.getData(), map.get(root.getData()) - 1);
        if (map.get(root.getData()) <= 0) {
            map.remove(root.getData());
        }
    }

    int pseudoPallindromicPathInBinaryTree_Count;

    public void pseudoPallindromicPathInBinaryTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
        /*paths are [2,3,3] & [2,1,1] these paths are
         pseudo pallindromic as they can be represented as pallindrome [3,2,3] & [1,2,1]*/
        pseudoPallindromicPathInBinaryTree_Count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        pseudoPallindromicPathInBinaryTree_Helper(root, map);

        //output
        System.out.println("Pseudo pallindromic paths count: " + pseudoPallindromicPathInBinaryTree_Count);
    }

    int countNumberOfTurnsBetweenRootToGivenKey_CountTurns = 0;

    public boolean countNumberOfTurnsBetweenRootToGivenKey(TreeNode<Integer> root,
                                                           int key, boolean goingLeft) {

        if (root == null) {
            return false;
        }

        if (root.getData() == key) {
            return true;
        }

        if (goingLeft) {
            //as we are goingLeft == true so turn will not be counted
            //going deeper to left subtrees
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getLeft(),
                    key, goingLeft)) {
                return true;
            }
            //each time we make a move to right subtree that means we are making
            //a turn to find the key
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getRight(), key, !goingLeft)) {
                countNumberOfTurnsBetweenRootToGivenKey_CountTurns += 1;
                return true;
            }
        } else { //goingLeft == false
            //as we are goingLeft == false(going to right) so turn will not be counted
            //going deeper to right subtrees
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getRight(), key, goingLeft)) {
                return true;
            }
            //each time we make a move to left subtree that means we are making
            //a turn to find the key
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getLeft(), key, !goingLeft)) {
                countNumberOfTurnsBetweenRootToGivenKey_CountTurns += 1;
                return true;
            }
        }
        return false;
    }

    public int countNumberOfTurnsBetweenTwoNodesOfTree(TreeNode<Integer> root, int n1, int n2) {

        //https://www.geeksforgeeks.org/number-turns-reach-one-node-binary-tree/
        //find lca of two nodes
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, n1, n2);

        if (lca == null) {
            return -1;
        }

        countNumberOfTurnsBetweenRootToGivenKey_CountTurns = 0;

        boolean n1FoundInLeftSubtree = false;
        boolean n2FoundInLeftSubtree = false;

        //if lca is not any of the nodes, neither n1 AND n2
        if (lca.getData() != n1 && lca.getData() != n2) {

            //count turns  in finding n1 in both left OR right sub tree of lca
            n1FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n1, true); //goingLeft == true
            if (!n1FoundInLeftSubtree) {
                //if n1 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n1, false); //goingLeft == false
            }

            //count turns  in finding n2 in both left OR right sub tree of lca
            n2FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n2, true); //goingLeft == true
            if (!n2FoundInLeftSubtree) {
                //if n2 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n2, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns + 1; //1 turn also made at lca node
        } else if (lca.getData() == n1) { //lca node is one of the given node

            //count turns of the other node from the lca
            n2FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n2, true); //goingLeft == true
            if (!n2FoundInLeftSubtree) {
                //if n2 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n2, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns;
        } else { //lca.getData() == n2
            //count turns of the other node from the lca
            n1FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n1, true); //goingLeft == true
            if (!n1FoundInLeftSubtree) {
                //if n1 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n1, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns;
        }
    }

    class LongestZigZagPathInTreePair {

        int leftZigZagPath;
        int rightZigZagPath;

        public LongestZigZagPathInTreePair(int leftZigZagPath, int rightZigZagPath) {
            this.leftZigZagPath = leftZigZagPath;
            this.rightZigZagPath = rightZigZagPath;
        }
    }

    private void longestZigZagPathInTree_Helper(TreeNode<Integer> root,
                                                Map<TreeNode<Integer>, LongestZigZagPathInTreePair> map) {

        if (root == null) {
            return;
        }

        map.putIfAbsent(root, new LongestZigZagPathInTreePair(0, 0));

        longestZigZagPathInTree_Helper(root.getLeft(), map);
        longestZigZagPathInTree_Helper(root.getRight(), map);

        //calculate zig zag path for curr root for its both
        //leftZigZagPath i.e, path from root.left and its rightZigZagPath
        //rightZigZagPath i.e, path from root.right and its leftZigZagPath
        map.get(root).leftZigZagPath = 1 + map.get(root.getLeft()).rightZigZagPath;
        map.get(root).rightZigZagPath = 1 + map.get(root.getRight()).leftZigZagPath;

        longestZigZagPathInTree_Length = Math.max(
                longestZigZagPathInTree_Length,
                Math.max(map.get(root).leftZigZagPath,
                        map.get(root).rightZigZagPath));
    }

    int longestZigZagPathInTree_Length;

    public void longestZigZagPathInTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
        longestZigZagPathInTree_Length = 0;
        Map<TreeNode<Integer>, LongestZigZagPathInTreePair> map = new HashMap<>();
        map.put(null, new LongestZigZagPathInTreePair(0, 0));
        longestZigZagPathInTree_Helper(root, map);

        //output
        System.out.println("Longest zig zag path in tree approach1: " + (longestZigZagPathInTree_Length - 1));
    }

    private int longestZigZagPathInTree2_Helper(
            TreeNode<Integer> root, boolean isComingFromLeft, boolean isComingFromRight, int pathLength) {
        if (root == null) {
            return pathLength;
        }
        int leftPathLength = longestZigZagPathInTree2_Helper(root.getLeft(),
                true, //from curr root going to its left
                false,
                //if previously coming from right
                //and now going to left that means its a zig zag path
                //so pathLen + 1
                //otherwise not coming from right and going to left
                //consider it starting of some new zig zag path
                isComingFromRight ? pathLength + 1 : 1);
        int rightPathLength = longestZigZagPathInTree2_Helper(root.getRight(),
                false,
                true, //from curr root going to its right
                //if previously coming from left
                //and now going to right that means its a zig zag path
                //so pathLen + 1
                //otherwise not coming from left and going to right
                //consider it starting of some new zig zag path
                isComingFromLeft ? pathLength + 1 : 1);
        return Math.max(leftPathLength, rightPathLength);
    }

    public void longestZigZagPathInTree2(TreeNode<Integer> root) {
        //FASTER than above approach 1
        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/discuss/2225080/Java-Solution
        int longestZigZagPath = longestZigZagPathInTree2_Helper(root, false, false, 1) - 1;
        //output
        System.out.println("Longest zig zag path in tree approach2: " + longestZigZagPath);
    }

    private int longestPathArithemeticProgressionInBinaryTree_MaxLength;

    private void longestPathArithemeticProgressionInBinaryTree_DFS(
            TreeNode<Integer> root, int difference, int currMaxLengthAP) {

        if (root.getLeft() != null) {
            int currDifference = root.getLeft().getData() - root.getData();
            if (currDifference == difference) {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getLeft(), currDifference, currMaxLengthAP + 1);

                longestPathArithemeticProgressionInBinaryTree_MaxLength = Math.max(
                        longestPathArithemeticProgressionInBinaryTree_MaxLength,
                        currMaxLengthAP + 1);
            } else {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getLeft(), currDifference, currMaxLengthAP);
            }
        }

        if (root.getRight() != null) {
            int currDifference = root.getRight().getData() - root.getData();
            if (currDifference == difference) {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getRight(), currDifference, currMaxLengthAP + 1);

                longestPathArithemeticProgressionInBinaryTree_MaxLength = Math.max(
                        longestPathArithemeticProgressionInBinaryTree_MaxLength,
                        currMaxLengthAP + 1);
            } else {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getRight(), currDifference, currMaxLengthAP);
            }
        }
    }

    public void longestPathArithemeticProgressionInBinaryTree(TreeNode<Integer> root) {

        //https://www.geeksforgeeks.org/arithmetic-progression/
        //https://www.geeksforgeeks.org/longest-path-to-the-bottom-of-a-binary-tree-forming-an-arithmetic-progression/
        longestPathArithemeticProgressionInBinaryTree_MaxLength = 2;

        if (root == null) {
            longestPathArithemeticProgressionInBinaryTree_MaxLength = 0;
        }

        if (root.getLeft() == null && root.getRight() == null) {
            longestPathArithemeticProgressionInBinaryTree_MaxLength = 1;
        }

        //root & root.left OR root & root.right
        int currMaxLengthAP = 2;
        if (root.getLeft() != null) {
            int difference = root.getLeft().getData() - root.getData();
            longestPathArithemeticProgressionInBinaryTree_DFS(root.getLeft(), difference, currMaxLengthAP);
        }

        if (root.getRight() != null) {
            int difference = root.getRight().getData() - root.getData();
            longestPathArithemeticProgressionInBinaryTree_DFS(root.getRight(), difference, currMaxLengthAP);
        }
        //output
        System.out.println("Max length AP in binary tree: "
                + longestPathArithemeticProgressionInBinaryTree_MaxLength);
    }

    public void timeNeededToInformAllEmployee_NAryTreeDFS(int managerNode,
                                                          Map<Integer, List<Integer>> managerToEmployees,
                                                          int[] informTime,
                                                          PriorityQueue<Integer> minHeap,
                                                          int currTime) {

        if (!managerToEmployees.containsKey(managerNode)) {
            minHeap.add(currTime);
            if (minHeap.size() > 1) {
                minHeap.poll();
            }
        }

        List<Integer> directReportee = managerToEmployees.getOrDefault(managerNode, new ArrayList<>());
        for (int employee : directReportee) {
            timeNeededToInformAllEmployee_NAryTreeDFS(employee,
                    managerToEmployees,
                    informTime,
                    minHeap,
                    currTime + informTime[managerNode]);
        }
    }

    public void timeNeededToInformAllEmployee_NAryTree(int employees, int headManagerID,
                                                       int[] manager, int[] informTime) {
        //Working but little time taking
        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
        //minHeap to store max time taken from headManager to last subordinate
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        //manager[i] => [i]
        Map<Integer, List<Integer>> managerToEmployees = new HashMap<>();
        for (int i = 0; i < employees; i++) {
            managerToEmployees.putIfAbsent(manager[i], new ArrayList<>());
            managerToEmployees.get(manager[i]).add(i);
        }
        timeNeededToInformAllEmployee_NAryTreeDFS(headManagerID, managerToEmployees, informTime, minHeap, 0);
        System.out.println("Max time required to inform all employee from head manager to subordinate(N-Ary tree DFS): "
                + (minHeap.isEmpty() ? 0 : minHeap.peek()));
    }

    private int timeNeededToInformAllEmployee_DFS_Helper(int employeeNode, int[] manager, int[] informTime) {
        if (manager[employeeNode] == -1) {
            return informTime[employeeNode];
        }

        informTime[employeeNode] += timeNeededToInformAllEmployee_DFS_Helper(
                manager[employeeNode], manager, informTime);

        manager[employeeNode] = -1;

        return informTime[employeeNode];
    }

    public void timeNeededToInformAllEmployee_DFS(int employees, int headManagerID,
                                                  int[] manager, int[] informTime) {
        //Little more optimized than above solution
        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
        //https://www.geeksforgeeks.org/google-interview-experience-sde-1-off-campus-2022/
        int maxTime = 0;
        //Loop trying to check the max time taken from any node, headMaangerID is not directly used here
        for (int employee = 0; employee < employees; employee++) {
            maxTime = Math.max(maxTime, timeNeededToInformAllEmployee_DFS_Helper(employee, manager, informTime));
        }
        System.out.println("Max time required to inform all employee from head manager to subordinate(Direct DFS): "
                + maxTime);
    }

    private enum BinaryTreeCameraState {

        hasCamera, needCamera, covered
    }
    int binaryTreeCameras_ReqCamera;

    private BinaryTreeCameraState binaryTreeCameras_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return BinaryTreeCameraState.covered;
        }

        BinaryTreeCameraState leftState = binaryTreeCameras_Helper(root.getLeft());
        BinaryTreeCameraState rightState = binaryTreeCameras_Helper(root.getRight());

        if (leftState == BinaryTreeCameraState.needCamera
                || rightState == BinaryTreeCameraState.needCamera) {
            binaryTreeCameras_ReqCamera++;
            return BinaryTreeCameraState.hasCamera;
        }

        if (leftState == BinaryTreeCameraState.hasCamera
                || rightState == BinaryTreeCameraState.hasCamera) {
            return BinaryTreeCameraState.covered;
        }
        return BinaryTreeCameraState.needCamera;
    }

    public void binaryTreeCameras(TreeNode<Integer> root) {
        //https://leetcode.com/problems/binary-tree-cameras/
        //https://leetcode.com/problems/binary-tree-cameras/solution/
        binaryTreeCameras_ReqCamera = 0;
        int output = binaryTreeCameras_Helper(root) == BinaryTreeCameraState.needCamera
                ? binaryTreeCameras_ReqCamera++
                : binaryTreeCameras_ReqCamera;
        System.out.println("Binary tree cameras : " + output);
    }

    private TreeNode<Integer> convertSortedArrayToHeightBalancedBinarySearchTree_Helper(
            int[] arr, int start, int end) {
        if (start > end) {
            return null;
        }

        int mid = start + (end - start) / 2;
        TreeNode<Integer> root = new TreeNode<>(arr[mid]);
        root.setLeft(
                convertSortedArrayToHeightBalancedBinarySearchTree_Helper(arr, start, mid - 1)
        );
        root.setRight(
                convertSortedArrayToHeightBalancedBinarySearchTree_Helper(arr, mid + 1, end)
        );

        return root;
    }

    public void convertSortedArrayToHeightBalancedBinarySearchTree(int[] arr) {
        //https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
        //explanation: https://youtu.be/0K0uCMYq5ng
        TreeNode<Integer> root = convertSortedArrayToHeightBalancedBinarySearchTree_Helper(
                arr, 0, arr.length - 1);
        //output
        new BinarySearchTree<>(root).treeInorder();
        System.out.println();
    }

    public void binarySearchTreeIterator(TreeNode<Integer> root) {
        //..............T: O(H), at most using addNodes() we are just travelling
        //tree upto the height of tree and not the complete N nodes of tree
        //https://leetcode.com/problems/binary-search-tree-iterator
        BinarySearchTreeIterator<Integer> iterator = new BinarySearchTreeIterator<>(root);
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    private boolean linkedListInBinaryTree_MatchCheck(Node<Integer> head, TreeNode<Integer> root) {
        if (head == null) {
            return true;
        }

        if (root == null) {
            return false;
        }

        return (root.getData() == head.getData())
                && (linkedListInBinaryTree_MatchCheck(head.getNext(), root.getLeft())
                || linkedListInBinaryTree_MatchCheck(head.getNext(), root.getRight()));

    }

    private boolean linkedListInBinaryTree_DFS(Node<Integer> head, TreeNode<Integer> root) {

        if (root == null) {
            return false;
        }

        if (linkedListInBinaryTree_MatchCheck(head, root)) {
            return true;
        }

        return linkedListInBinaryTree_DFS(head, root.getLeft())
                || linkedListInBinaryTree_DFS(head, root.getRight());

    }

    public void linkedListInBinaryTree(Node<Integer> head, TreeNode<Integer> root) {
        //https://leetcode.com/problems/linked-list-in-binary-tree/
        boolean output = linkedListInBinaryTree_DFS(head, root);
        //output
        System.out.println("Is linked list present in binary tree: " + output);
    }

    private void printBinaryTreeInStringMatrixFormat_Helper(
            TreeNode<Integer> root, int currRow, int currCol, int height, List<List<String>> treeMatrix) {

        if (root == null) {
            return;
        }

        treeMatrix.get(currRow).set(currCol, root.getData() + "");

        printBinaryTreeInStringMatrixFormat_Helper(root.getLeft(),
                currRow + 1,
                currCol - (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);

        printBinaryTreeInStringMatrixFormat_Helper(root.getRight(),
                currRow + 1,
                currCol + (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);
    }

    public void printBinaryTreeInStringMatrixFormat(TreeNode<Integer> root) {
        //https://leetcode.com/problems/print-binary-tree/
        /*
            1. The height of the tree is height and the number of rows m should be equal to height + 1.
            2. The number of columns n should be equal to 2height+1 - 1.
            3. Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]).
            4. For each node that has been placed in the matrix at position res[r][c],
                place its left child at res[r+1][c-2height-r-1] and its right child at res[r+1][c+2height-r-1].
            5. Continue this process until all the nodes in the tree have been placed.
            6. Any empty cells should contain the empty string "".
         */
        int height = heightOfTree(root);
        int m = height + 1;
        int n = (int) Math.pow(2, height + 1) - 1;

        //preparing empty matrix
        String EMPTY_SPOT = ".";
        List<List<String>> treeMatrix = new ArrayList<>();
        for (int r = 0; r < m; r++) {
            treeMatrix.add(new ArrayList<>());
            for (int c = 0; c < n; c++) {
                treeMatrix.get(r).add(EMPTY_SPOT);
            }
        }

        int currRow = 0;
        int currCol = (n - 1) / 2;

        treeMatrix.get(currRow).set(currCol, root.getData() + "");

        printBinaryTreeInStringMatrixFormat_Helper(root.getLeft(),
                currRow + 1,
                currCol - (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);

        printBinaryTreeInStringMatrixFormat_Helper(root.getRight(),
                currRow + 1,
                currCol + (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);
        //output
        System.out.println("Print binary tree in string matrix format: ");
        for (List<String> level : treeMatrix) {
            System.out.println(level);
        }
    }

    private TreeNode<Integer> insufficientNodesInRootToLeafPath_Helper(
            TreeNode<Integer> root, int limit, int currPathSum) {

        if (root == null) {
            return null;
        }

        //if any path from root-to-(curr leaf) has path sum strictly less than
        //limit then this leaf node should be trimmed off from its parent root hence
        //return null
        //otherwise return the actaul curr leaf(==> here root) node as it is back to
        //its parent root(==> this return of NON-NULL root node validates that there
        //exists a path sum >= limit)
        if (root.getLeft() == null && root.getRight() == null) {
            return (currPathSum + root.getData() < limit) ? null : root;
        }

        //any root-to-leaf path sum going via root.left, if the path sum is less
        //than the given 'limit' then we must be trimming that path from leaf and
        //moving up-above to parent by pass 'null' to its parent root otherwise
        //pass the actual left node back to parent root and it will reassigned as
        //left child
        root.setLeft(insufficientNodesInRootToLeafPath_Helper(
                root.getLeft(), limit, currPathSum + root.getData()));

        //any root-to-leaf path sum going via root.right, if the path sum is less
        //than the given 'limit' then we must be trimming that path from leaf and
        //moving up-above to parent by pass 'null' to its parent root otherwise
        //pass the actual right node back to parent root and it will reassigned as
        //right child
        root.setRight(insufficientNodesInRootToLeafPath_Helper(
                root.getRight(), limit, currPathSum + root.getData()));

        //this case here checks, if from curr root, the path sum extending via
        //root.left or root.right didn't have sum greater or equal to 'limit' then
        //surely this root have been assigned 'null' for both its left and right child
        //simply meaning curr root's left and right subtree is now trimmed off, in that
        //case this curr root should also be trimmed off as curr root also didn't add
        //up to path sum >= limit hence return null to delete this curr root from its
        //parent recursive call
        if (root.getLeft() == null && root.getRight() == null) {
            return null;
        }
        return root;
    }

    public void insufficientNodesInRootToLeafPath(TreeNode<Integer> root, int limit) {
        //https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
        //actual:
        new BinaryTree(root).treeBFS();
        System.out.println();

        TreeNode<Integer> output = insufficientNodesInRootToLeafPath_Helper(root, limit, 0);
        //output
        System.out.println("Tree after removing insufficient sum path: ");
        new BinaryTree(output).treeBFS();
        System.out.println();
    }

    private int sticklerThiefThree_DP_Memoization_DFSHelper(
            TreeNode<Integer> root, Map<TreeNode<Integer>, Integer> memo) {
        if (root == null) {
            return 0;
        }

        if (memo.containsKey(root)) {
            return memo.get(root);
        }

        int currPick = 0;

        //1. decide to pick the curr root house
        currPick += root.getData();
        //since we have picked the curr root house, we can't pick its direct
        //childrens(left or right) but we can surely pick its grand children
        //i.e, left & right child of curr root.left
        if (root.getLeft() != null) {
            int maxPickGrandLeftChildOfLeft = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getLeft().getLeft(), memo);

            int maxPickGrandRightChildOfLeft = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getLeft().getRight(), memo);

            currPick += maxPickGrandLeftChildOfLeft + maxPickGrandRightChildOfLeft;

        }
        //i.e, left & right child of curr root.right
        if (root.getRight() != null) {
            int maxPickGrandLeftChildOfRight = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getRight().getLeft(), memo);

            int maxPickGrandRightChildOfRight = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getRight().getRight(), memo);

            currPick += maxPickGrandLeftChildOfRight + maxPickGrandRightChildOfRight;
        }

        //2. decide to not pick curr root, in that case we can directly move to
        //its direct children i.e, root.left & root.right
        int maxPickDirectLeftChild = sticklerThiefThree_DP_Memoization_DFSHelper(
                root.getLeft(), memo);

        int maxPickDirectRightChild = sticklerThiefThree_DP_Memoization_DFSHelper(
                root.getRight(), memo);

        //choosing which option has get us the max currPick for the curr root house
        currPick = Math.max(currPick, maxPickDirectLeftChild + maxPickDirectRightChild);

        memo.put(root, currPick);
        return currPick;
    }

    public void sticklerThiefThree_DP_Memoization(TreeNode<Integer> rootHouse) {
        //https://leetcode.com/problems/house-robber-iii/
        Map<TreeNode<Integer>, Integer> memo = new HashMap<>();
        int maxRob = sticklerThiefThree_DP_Memoization_DFSHelper(rootHouse, memo);
        System.out.println("The maximum amount stickler thief can pick from alternate binary tree house: " + maxRob);
    }

    private void stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(
            TreeNode<Integer> root, int startNode, StringBuilder curr) {
        if (root == null) {
            return;
        }

        if (root.getData() == startNode) {
            stepByStepDirection_Path += curr;
            return;
        }
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(root.getLeft(), startNode, curr.append("U"));
        //remove the last added direction before moving to right subtree
        curr.deleteCharAt(curr.length() - 1);

        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(root.getRight(), startNode, curr.append("U"));
        //remove the last added direction before moving to prev call stack
        curr.deleteCharAt(curr.length() - 1);
    }

    private void stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(
            TreeNode<Integer> root, int destNode, StringBuilder curr) {
        if (root == null) {
            return;
        }

        if (root.getData() == destNode) {
            stepByStepDirection_Path += curr;
            return;
        }
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(root.getLeft(), destNode, curr.append("L"));
        //remove the last added direction before moving to right subtree
        curr.deleteCharAt(curr.length() - 1);

        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(root.getRight(), destNode, curr.append("R"));
        //remove the last added direction before moving to prev call stack
        curr.deleteCharAt(curr.length() - 1);
    }

    private String stepByStepDirection_Path;

    public String stepByStepDirectionsBetweenTwoNodesInBinaryTree(TreeNode<Integer> root, int startNode, int destNode) {
        //https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
        stepByStepDirection_Path = "";
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, startNode, destNode);
        //using StringBuilder here for below DFS is trivial, otherwise it may cause memory limit exceed
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(lca, startNode, new StringBuilder());
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(lca, destNode, new StringBuilder());
        //output
        return stepByStepDirection_Path;
    }

    public int findDistanceInBinaryTree(TreeNode<Integer> root, int node1, int node2) {
        //https://leetcode.com/problems/find-distance-in-a-binary-tree/description/
        //https://leetcode.ca/all/1740.html#:~:text=1740.-,Find%20Distance%20in%20a%20Binary%20Tree,from%20one%20to%20the%20other.
        //based exactly on stepByStepDirectionsBetweenTwoNodesInBinaryTree()
        if (node1 == node2) {
            return 0;
        }
        String edgePath = stepByStepDirectionsBetweenTwoNodesInBinaryTree(root, node1, node2);
        //output
        //in above question we are simply printing the path, in this question that
        //path itself is the dist between two given nodes
        return edgePath.length();
    }

    private void addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(
            TreeNode<Integer> root, int level, int maxLevel, Map<Integer, List<TreeNode<Integer>>> levelOrder) {
        //level > maxLevel this cond is added because we only need the nodes at
        //depth - 1 parent level to perform our logic, we don't really need to
        //traverse each and every node falling below the given depth, this might
        //save some extra time on traversing the whole tree
        if (root == null || level > maxLevel) {
            return;
        }

        levelOrder.putIfAbsent(level, new ArrayList<>());
        levelOrder.get(level).add(root);

        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root.getLeft(), level + 1, maxLevel, levelOrder);
        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root.getRight(), level + 1, maxLevel, levelOrder);
    }

    public void addExtraRowWithGivenValueAtGivenDepth(TreeNode<Integer> root, int val, int depth) {
        //https://leetcode.com/problems/add-one-row-to-tree/
        System.out.println("Add row in tree with given value at given depth using BFS recursive approach");
        //actual
        System.out.println("Actual tree:");
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //simple level order traversal using recursion and hashmap
        Map<Integer, List<TreeNode<Integer>>> levelOrder = new HashMap<>();
        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root, 1, depth, levelOrder);
        //update functionality
        //edge condition when we want to add the new row at the root level( == 1)
        //simply create a newRoot with given val and add the actual tree(root) as
        //left child of it
        if (depth == 1) {
            //depth == 1 is root level
            TreeNode<Integer> newRoot = new TreeNode<>(val);
            newRoot.setLeft(root);
            new BinaryTree<>(newRoot).treeBFS();
            System.out.println();
            return;
        }

        List<TreeNode<Integer>> nodesAboveCurrDepth = levelOrder.getOrDefault(depth - 1, new ArrayList<>());
        //since we want to create the new row at given depth that means if we have
        //all the nodes at the level above, we can do our logic
        //1. save actual left & right subtree of curr parent
        //2. create a new row with given value and make it a child of curr parent
        //3. then adjust the actual left subtree to left part of new row node and
        //actual right subtree to right part of new row node
        for (TreeNode<Integer> parent : nodesAboveCurrDepth) {

            TreeNode<Integer> actualLeftSubtree = parent.getLeft();
            TreeNode<Integer> actualRightSubtree = parent.getRight();

            //adding the new row right below the parent level as its child
            parent.setLeft(new TreeNode<>(val));
            parent.setRight(new TreeNode<>(val));

            //putting parents left subtree & right substree in
            //exactly left & right part of the newly created row
            parent.getLeft().setLeft(actualLeftSubtree);
            parent.getRight().setRight(actualRightSubtree);
        }
        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    public void addExtraRowWithGivenValueAtGivenDepth_BFSIterative(TreeNode<Integer> root, int val, int depth) {
        //https://leetcode.com/problems/add-one-row-to-tree/
        //same approach as addExtraRowWithGivenValueAtGivenDepth(), but little
        //OPTIMIZED as no extra hashmap used and in single BFS pass we are targetting
        //the row above curr depth
        System.out.println("Add row in tree with given value at given depth using BFS iterative approach");
        //actual
        System.out.println("Actual tree:");
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //update functionality
        //edge condition when we want to add the new row at the root level( == 1)
        //simply create a newRoot with given val and add the actual tree(root) as
        //left child of it
        if (depth == 1) {
            //depth == 1 is root level
            TreeNode<Integer> newRoot = new TreeNode<>(val);
            newRoot.setLeft(root);
            new BinaryTree<>(newRoot).treeBFS();
            System.out.println();
            return;
        }

        int level = 1;
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> parent = queue.poll();

                //since we want to create the new row at given depth that means if we have
                //all the nodes at the level above given depth, we can do our logic
                //1. save actual left & right subtree of curr parent
                //2. create a new row with given value and make it a child of curr parent
                //3. then adjust the actual left subtree to left part of new row node and
                //actual right subtree to right part of new row node
                if (level == depth - 1) {
                    TreeNode<Integer> actualLeftSubtree = parent.getLeft();
                    TreeNode<Integer> actualRightSubtree = parent.getRight();

                    //adding the new row right below the parent level as its child
                    parent.setLeft(new TreeNode<>(val));
                    parent.setRight(new TreeNode<>(val));

                    //putting parents left subtree & right substree in
                    //exactly left & right part of the newly created row
                    parent.getLeft().setLeft(actualLeftSubtree);
                    parent.getRight().setRight(actualRightSubtree);
                } else {
                    if (parent.getLeft() != null) {
                        queue.add(parent.getLeft());
                    }

                    if (parent.getRight() != null) {
                        queue.add(parent.getRight());
                    }
                }
            }
            level++;
            if (level == depth) {
                break;
            }
        }

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    public void findElementsInContaminatedBinaryTree(TreeNode<Integer> contaminatedRoot, List<Integer> find) {
        //https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
        class FindElements {

            Set<Integer> nodes;

            public FindElements(TreeNode<Integer> root) {
                nodes = new HashSet<>();
                nodes.add(0);
                root.setData(0);
                fixTree(root);
            }

            private void fixTree(TreeNode<Integer> root) {
                //pre-order traversal
                if (root == null) {
                    return;
                }

                //if root.left is valid
                if (root.getLeft() != null) {
                    //root.left.val = 2 * root.val + 1
                    root.getLeft().setData(2 * root.getData() + 1);
                    nodes.add(root.getLeft().getData());
                }

                //if root.right is valid
                if (root.getRight() != null) {
                    //root.right.val = 2 * root.val + 2
                    root.getRight().setData(2 * root.getData() + 2);
                    nodes.add(root.getRight().getData());
                }

                fixTree(root.getLeft());
                fixTree(root.getRight());
            }

            public boolean find(int val) {
                return nodes.contains(val);
            }
        }

        FindElements findElements = new FindElements(contaminatedRoot);
        for (int val : find) {
            System.out.println(val + " is present in contaminated tree : " + findElements.find(val));
        }
    }

    public void reverseOddLevelsOfPerfectBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
        /*
        A binary tree is perfect if all parent nodes have two children and all
        leaves are on the same level.
         */
        //actual:
        new BinaryTree(root).treeBFS();
        System.out.println();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        int level = 0;

        List<TreeNode<Integer>> oddLevelNodes = new ArrayList<>();

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> currNode = queue.poll();

                if (currNode.getLeft() != null) {
                    queue.add(currNode.getLeft());
                }

                if (currNode.getRight() != null) {
                    queue.add(currNode.getRight());
                }

                //hold all the nodes at odd level
                if (level % 2 == 1) {
                    oddLevelNodes.add(currNode);
                }

            }

            //reversing the odd levels
            if (level % 2 == 1) {

                int oddLevelSize = oddLevelNodes.size();

                for (int i = 0; i < oddLevelSize / 2; i++) {

                    TreeNode<Integer> firstNode = oddLevelNodes.get(i);
                    TreeNode<Integer> lastNode = oddLevelNodes.get(oddLevelSize - i - 1);

                    //swap nodes in the odd level
                    int temp = firstNode.getData();
                    firstNode.setData(lastNode.getData());
                    lastNode.setData(temp);
                }
                //reset odd level nodes;
                oddLevelNodes.clear();
            }

            level++;
        }

        //output
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    public void closestNodesQueriesInBinarySearchTree(TreeNode<Integer> root, List<Integer> queries) {
        //https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/
        List<List<Integer>> closestNodesForQueries = new ArrayList<>();
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        TreeSet<Integer> treeSet = new TreeSet<>();
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> currRoot = queue.poll();

                treeSet.add(currRoot.getData());

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }
        }

        for (int query : queries) {
            if (treeSet.contains(query)) {
                closestNodesForQueries.add(Arrays.asList(query, query));
            } else {
                Integer min = treeSet.lower(query);
                Integer max = treeSet.higher(query);
                closestNodesForQueries.add(Arrays.asList(min == null ? -1 : min,
                        max == null ? -1 : max));
            }
        }
        //output
        System.out.println("Closest nodes queries: " + closestNodesForQueries);
    }

    private TreeNode<Integer> deleteLeavesWithGiveValue_Helper(TreeNode<Integer> root, int target) {
        if (root == null) {
            return null;
        }

        root.setLeft(deleteLeavesWithGiveValue_Helper(root.getLeft(), target));
        root.setRight(deleteLeavesWithGiveValue_Helper(root.getRight(), target));

        //if curr root is leaf and root's value is target, return null to its
        //parent root node
        if (root.getLeft() == null && root.getRight() == null && root.getData() == target) {
            return null;
        }
        //if above condition is not matching return curr root back to its parent root
        return root;
    }

    public void deleteLeavesWithGiveValue(TreeNode<Integer> root, int target) {
        //https://leetcode.com/problems/delete-leaves-with-a-given-value/description/
        //actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        root = deleteLeavesWithGiveValue_Helper(root, target);
        //outout
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private int maxDiffBetweenNodesAndAncestor_Helper(TreeNode<Integer> root, int currMax, int currMin) {
        if (root == null) {
            return currMax - currMin;
        }
        int leftDiff = maxDiffBetweenNodesAndAncestor_Helper(root.getLeft(),
                Math.max(currMax, root.getData()),
                Math.min(currMin, root.getData()));

        int rightDiff = maxDiffBetweenNodesAndAncestor_Helper(root.getRight(),
                Math.max(currMax, root.getData()),
                Math.min(currMin, root.getData()));

        return Math.max(leftDiff, rightDiff);
    }

    public void maxDiffBetweenNodesAndAncestor(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/
        if (root == null) {
            System.out.println("Max diff between node and ancestor is: 0");
            return;
        }

        int maxDiffBetweenNodeAndAncestor = maxDiffBetweenNodesAndAncestor_Helper(root, root.getData(), root.getData());
        //output
        System.out.println("Max diff between node and ancestor is: " + maxDiffBetweenNodeAndAncestor);
    }

    private void timeRequiredToInfectBinaryTree_TreeToGraph(
            TreeNode<Integer> root, TreeNode<Integer> parent, Map<Integer, List<Integer>> graph) {
        if (root == null) {
            return;
        }

        graph.putIfAbsent(root.getData(), new ArrayList<>());

        if (parent != null) {
            graph.get(root.getData()).add(parent.getData());
        }

        if (root.getLeft() != null) {
            graph.get(root.getData()).add(root.getLeft().getData());
        }

        if (root.getRight() != null) {
            graph.get(root.getData()).add(root.getRight().getData());
        }

        timeRequiredToInfectBinaryTree_TreeToGraph(root.getLeft(), root, graph);
        timeRequiredToInfectBinaryTree_TreeToGraph(root.getRight(), root, graph);
    }

    public void timeRequiredToInfectBinaryTree(TreeNode<Integer> root, int startNode) {
        //https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/
        //based on BFS, Graph
        Map<Integer, List<Integer>> graph = new HashMap<>();
        //this creates an adjlist map for curr tree in graph form
        //where a curr root will have connections to atmost 3 nodes
        //curr root's parent & curr root's child(left & right child)
        /*
        Tree:
        ...............parent
        .................\
        ...............currRoot
        ............../........\
        .......leftChild.....rightChild
        Graph:
        {currRoot = [parent, leftChild, rightChild]}
         */
        timeRequiredToInfectBinaryTree_TreeToGraph(root, null, graph);

        //perform BFS on graph
        int infect = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(startNode);

        Set<Integer> visited = new HashSet<>();
        visited.add(startNode);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int currRoot = queue.poll();
                for (int childRoot : graph.getOrDefault(currRoot, new ArrayList<>())) {
                    if (visited.contains(childRoot)) {
                        continue;
                    }
                    visited.add(childRoot);
                    queue.add(childRoot);
                }
            }
            infect++;
        }
        //output
        System.out.println("Amount of time required to infect the binary tree: " + (infect - 1));
    }

    private TreeNode<Integer> maxBinaryTree_Helper(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }

        int maxVal = Integer.MIN_VALUE;
        int maxValIndex = -1;
        int index = start;
        for (; index <= end; index++) {
            if (nums[index] > maxVal) {
                maxVal = nums[index];
                maxValIndex = index;
            }
        }

        TreeNode<Integer> root = new TreeNode<>(nums[maxValIndex]);
        root.setLeft(maxBinaryTree_Helper(nums, start, maxValIndex - 1));
        root.setRight(maxBinaryTree_Helper(nums, maxValIndex + 1, end));

        return root;
    }

    public void maxBinaryTree(int[] nums) {
        //https://leetcode.com/problems/maximum-binary-tree/description/
        TreeNode<Integer> root = maxBinaryTree_Helper(nums, 0, nums.length - 1);
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> maxBinaryTreeTwo_Helper(TreeNode<Integer> root, int val) {
        //if the 'val' is the smallest of all the nodes present in tree
        if (root == null) {
            return new TreeNode<>(val);
        }
        //if the curr 'root' is smaller than the 'val', means the subtree starting
        //from this 'root' be below this 'val', so create newNode of 'val'
        //fill the left node of this newNode curr 'root', return newNode to its
        //parent node
        if (root.getData() < val) {
            TreeNode<Integer> newNode = new TreeNode<>(val);
            newNode.setLeft(root);
            return newNode;
        }

        root.setRight(maxBinaryTreeTwo_Helper(root.getRight(), val));
        return root;
    }

    public void maxBinaryTreeTwo(TreeNode<Integer> root, int val) {
        //https://leetcode.com/problems/maximum-binary-tree-ii/description/
        //actual:
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        TreeNode<Integer> result = maxBinaryTreeTwo_Helper(root, val);

        //output
        new BinaryTree<>(result).treeBFS();
        System.out.println();
    }

    private boolean univaluedBinaryTree_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return true;
        }

        boolean isLeftSubtreeUnivalued = univaluedBinaryTree_Helper(root.getLeft());

        if (univaluedBinaryTree_Prev != null && univaluedBinaryTree_Prev.getData() != root.getData()) {
            return false;
        }

        univaluedBinaryTree_Prev = root;

        boolean isRightSubtreeUnivalued = univaluedBinaryTree_Helper(root.getRight());

        return isLeftSubtreeUnivalued && isRightSubtreeUnivalued;
    }

    private boolean univaluedBinaryTree_Helper2(TreeNode<Integer> root) {

        if (root == null) {
            return true;
        }

        boolean isLeftSubtreeUnivalued = univaluedBinaryTree_Helper2(root.getLeft());

        boolean isRightSubtreeUnivalued = univaluedBinaryTree_Helper2(root.getRight());

        if (root.getLeft() != null && root.getLeft().getData() != root.getData()) {
            return false;
        }

        if (root.getRight() != null && root.getRight().getData() != root.getData()) {
            return false;
        }

        return isLeftSubtreeUnivalued && isRightSubtreeUnivalued;
    }

    private TreeNode<Integer> univaluedBinaryTree_Prev;

    public void univaluedBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/univalued-binary-tree/description/
        univaluedBinaryTree_Prev = null;
        boolean isTreeUnivalued = univaluedBinaryTree_Helper(root);
        boolean isTreeUnivalued2 = univaluedBinaryTree_Helper2(root);
        //output
        System.out.println("Is tree univalued (approach similar to check isBST): " + isTreeUnivalued);
        System.out.println("Is tree univalued: " + isTreeUnivalued2);
    }

    private boolean countSingleValuedSubtreeInATree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return true;
        }

        boolean isLeftTreeSingleValued = countSingleValuedSubtreeInATree_Helper(root.getLeft());

        boolean isRightTreeSingleValued = countSingleValuedSubtreeInATree_Helper(root.getRight());

        //check if this curr root node value is also same as its both child's node
        //values.
        //curr root left node is valid but its value is not same as curr root's value
        //hence not a single valued tree, return false
        if (root.getLeft() != null && root.getLeft().getData() != root.getData()) {
            return false;
        }

        //curr root right node is valid but its value is not same as curr root's value
        //hence not a single valued tree, return false
        if (root.getRight() != null && root.getRight().getData() != root.getData()) {
            return false;
        }

        if (isLeftTreeSingleValued && isRightTreeSingleValued) {
            countSingleValuedSubtreeInATree_CountSubtree++;
        }

        //a tree is said to be single valued if all of its internal subtrees are
        //also single valued, henec both left & right subtrees should be single
        //valued
        return isLeftTreeSingleValued && isRightTreeSingleValued;
    }

    private int countSingleValuedSubtreeInATree_CountSubtree;

    public void countSingleValuedSubtreeInATree(TreeNode<Integer> root) {
        //https://practice.geeksforgeeks.org/problems/single-valued-subtree/1
        //actual:
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        countSingleValuedSubtreeInATree_CountSubtree = 0;
        countSingleValuedSubtreeInATree_Helper(root);
        //output
        System.out.println("Single values subtrees: " + countSingleValuedSubtreeInATree_CountSubtree);
    }

    public void sumOfNodesWithEvenValuedGrandparent(TreeNode<Integer> root) {
        //https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description/
        class Relation {

            TreeNode<Integer> grandparent;
            TreeNode<Integer> parent;
            TreeNode<Integer> root;

            public Relation(TreeNode<Integer> grandparent, TreeNode<Integer> parent, TreeNode<Integer> root) {
                this.grandparent = grandparent;
                this.parent = parent;
                this.root = root;
            }

        }

        int nodeSumWithEvenValuedGrandparent = 0;

        if (root == null) {
            System.out.println("Nodes sum have even valued grandparent: " + nodeSumWithEvenValuedGrandparent);
            return;
        }

        Queue<Relation> queue = new LinkedList<>();
        //root's grandparent is null, root's parent is null, root itself
        queue.add(new Relation(null, null, root));

        while (!queue.isEmpty()) {

            Relation currRelation = queue.poll();

            //if the curr root's grandparent is not null and also this grandparent
            //is even-valued then we must add the curr root's value to our sum
            if (currRelation.grandparent != null && currRelation.grandparent.getData() % 2 == 0) {
                nodeSumWithEvenValuedGrandparent += currRelation.root.getData();
            }

            //for next left child from the curr root node
            //curr root's parent will become grandparent of root's left child
            //curr root itself become parent of root's left child
            //grandparent, parent, root ==> root's parent, root, root.left
            if (currRelation.root.getLeft() != null) {
                queue.add(new Relation(
                        currRelation.parent,
                        currRelation.root,
                        currRelation.root.getLeft()
                ));
            }

            //for next right child from the curr root node
            //curr root's parent will become grandparent of root's right child
            //curr root itself become parent of root's right child
            //grandparent, parent, root ==> root's parent, root, root.right
            if (currRelation.root.getRight() != null) {
                queue.add(new Relation(
                        currRelation.parent,
                        currRelation.root,
                        currRelation.root.getRight()
                ));
            }

        }
        //output
        System.out.println("Nodes sum have even valued grandparent: " + nodeSumWithEvenValuedGrandparent);
    }

    private boolean printAllAncestorOfTagetNodeInBinaryTree_Helper(
            TreeNode<Integer> root, int target, List<Integer> ancestors) {
        if (root == null) {
            return false;
        }

        if (root.getData() == target) {
            return true;
        }

        //first try to find the target node in left subtree
        boolean isTragetInLeft = printAllAncestorOfTagetNodeInBinaryTree_Helper(root.getLeft(), target, ancestors);
        boolean isTragetInRight = false;

        //if the target node is not found in the left sub tree then only go searching
        //in the right sub tree. This will help in reducing the time complexity of
        //searching a node. Because if we have already found our target ndoe in left
        //sub tree then there is no sense to go search the same in right sub tree
        if (!isTragetInLeft) {
            isTragetInRight = printAllAncestorOfTagetNodeInBinaryTree_Helper(root.getRight(), target, ancestors);
        }

        //if the target node is found in either of its left or right sub trees
        //then that means the curr root node is its ancestor (target node lies
        //in the either child sub trees(left or right))
        if (isTragetInLeft || isTragetInRight) {
            ancestors.add(root.getData());
        }

        //return true only if the target node is there in any of the subtrees
        //of this curr root node
        return isTragetInLeft || isTragetInRight;
    }

    public void printAllAncestorOfTagetNodeInBinaryTree(TreeNode<Integer> root, int target) {
        //https://youtu.be/2VZHLtHM_6w
        List<Integer> ancestors = new ArrayList<>();
        printAllAncestorOfTagetNodeInBinaryTree_Helper(root, target, ancestors);
        //output
        System.out.println("Print all the ancestors of the given target node: " + ancestors);
    }

    public void kthLargestLevelSumInBinaryTree(TreeNode<Integer> root, int k) {
        //https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description/
        //based on BFS
        PriorityQueue<Long> minHeap = new PriorityQueue<>((a, b) -> a.compareTo(b));
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);
        long levelSum = 0;
        int level = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            levelSum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = queue.poll();
                levelSum += curr.getData();

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }

            level++;
            minHeap.add(levelSum);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        long kThLargestLevelSum = level < k ? -1 : minHeap.peek();
        //output
        System.out.println("Kth largest level sum in binary tree: " + kThLargestLevelSum);
    }

    public int numberOfGoodLeafNodesPairsOFBinaryTree(TreeNode<Integer> root, int distance) {
        //https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/
        /*
        Intuition behind this is
        convert the tree into graph representation and while converting save all
        the leaf nodes in a list

        now that we have all leaf ndoes and a tree-as-graph we will be able to
        directly start a DFS call from leaf nodes via this graph

        using this DFS from a leaf node on this graph calculate distance with
        currDist. any currDist above the given distance should be discarded.
        in order to calculate pair, currDist <= distance and this path should
        start and end with a leaf node.
        starting leaf node is via the loop on leafNodes and ending leaf node is
        checked in DFS calls

         */
        //saving graph as TreeNodes beacuses tree node's values may be duplicate
        //here we will convert the given tree to a graph representation
        //this will helps us do dfs from leaf nodes directly
        Map<TreeNode<Integer>, List<TreeNode<Integer>>> graph = new HashMap<>();
        //to hold only leaf nodes of tree
        List<TreeNode<Integer>> leafNodes = new ArrayList<>();

        class Helper {

            int pairs = 0;

            void convertTreeToGraph(TreeNode<Integer> root, TreeNode<Integer> parent) {
                if (root == null) {
                    return;
                }

                //leaf nodes here, so save all the leaf nodes in a list
                if (root.getLeft() == null && root.getRight() == null) {
                    leafNodes.add(root);
                }

                //create a graph
                if (root != null && parent != null) {

                    graph.putIfAbsent(root, new ArrayList<>());
                    graph.get(root).add(parent);

                    graph.putIfAbsent(parent, new ArrayList<>());
                    graph.get(parent).add(root);
                }

                convertTreeToGraph(root.getLeft(), root);
                convertTreeToGraph(root.getRight(), root);
            }

            void calculatePairsWithinDistance(
                    TreeNode<Integer> root, TreeNode<Integer> parent, int distance, int currDist) {

                //the shortest path from starting leaf node to any other leaf node
                //should not be more than given distance
                if (currDist > distance) {
                    return;
                }

                //shortest path should end with another leaf node
                if (root.getLeft() == null && root.getRight() == null) {
                    //currDist > 0 ensures that we dont update pairs for the same
                    //leaf node we started the DFS call with
                    if (currDist > 0) {
                        pairs++;
                    }
                }

                for (TreeNode<Integer> childRoot : graph.getOrDefault(root, new ArrayList<>())) {

                    if (childRoot == parent) {
                        continue;
                    }

                    calculatePairsWithinDistance(childRoot, root, distance, currDist + 1);
                }
            }
        }

        Helper helper = new Helper();

        helper.convertTreeToGraph(root, null);

        //in case of skewed trees there will be only one leaf node, then no pairs
        //can be possible hence return 0
        if (leafNodes.size() == 1) {
            return 0;
        }

        for (TreeNode<Integer> leaf : leafNodes) {
            helper.calculatePairsWithinDistance(leaf, null, distance, 0);
        }
        //since we are looping over leafNodes then we are calculating pairs twice
        //that why we need to divide 2
        //ex: leafNodes: [4, 5, 6, 7] then shortest path is calculated with all
        //leaf nodes. So if 4 has shortest path with 5 == pair == 1
        //then in the loop itself 5 will be calculated again with 4 == pair == 2
        //we checked 4 and 5 pairs twice that why divide by 2
        return helper.pairs / 2;
    }

    public void maxSumBSTInBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/
        //https://leetcode.com/problems/largest-bst-subtree/description/
        /*

        The helper class below solves 2 different questions, having exactly same logic

        1. it finds the max sum of the BST if present in the given tree
        2. it finds the largest of the BST(BST with more number of nodes in it)
        if present in the given tree

        So don't confuse with the 2 outputs and what they means,
        A possible BST with max sum might not be the same largest BST and vice versa
        those 2 outputs can be of two distinctive BST(s)

         */
        class NodeInfo {

            boolean isBST;
            int maxInLeftSubtree;
            int minInRightSubtree;
            int sum;
            int nodesCount;

            public NodeInfo() {
                isBST = false;
                maxInLeftSubtree = Integer.MIN_VALUE;
                minInRightSubtree = Integer.MAX_VALUE;
                sum = 0;
                nodesCount = 0;
            }
        }

        class Helper {

            int maxBSTSubtreeSum = Integer.MIN_VALUE;
            int largestBSTSubtree = 0;

            void helperDFS(TreeNode<Integer> root, NodeInfo currRootInfo) {

                if (root == null) {
                    currRootInfo.isBST = true;
                    return;
                }

                //curr root's left subtree info will be collected in this in DFS calls
                NodeInfo leftTreeInfo = new NodeInfo();
                //curr root's right subtree info will be collected in this in DFS calls
                NodeInfo rightTreeInfo = new NodeInfo();

                helperDFS(root.getLeft(), leftTreeInfo);
                helperDFS(root.getRight(), rightTreeInfo);

                //nodes count i.e,
                //number of nodes in left-subtree
                //+ 1 for the curr root node count
                //+ number of nodes in right-subtree
                //with this, we can count the number of nodes in the BST hence
                //we can find the largestBST in the given tree
                currRootInfo.nodesCount = leftTreeInfo.nodesCount + 1 + rightTreeInfo.nodesCount;

                //node sum i.e,
                //sum of nodes in left-subtree
                //+ curr root value
                //+ sum of nodes in right-subtree
                currRootInfo.sum = leftTreeInfo.sum + root.getData() + rightTreeInfo.sum;

                //Here we will calculate the max node value among all the nodes
                //from curr root's left subtree and right subtree and including
                //curr root node value as well, this info will also be propagated
                //back to curr root's parent
                currRootInfo.maxInLeftSubtree = Math.max(root.getData(),
                        Math.max(leftTreeInfo.maxInLeftSubtree, rightTreeInfo.maxInLeftSubtree));

                //Here we will calculate the min node value among all the nodes
                //from curr root's left subtree and right subtree and including
                //curr root node value as well, this info will also be propagated
                //back to curr root's parent
                currRootInfo.minInRightSubtree = Math.min(root.getData(),
                        Math.min(leftTreeInfo.minInRightSubtree, rightTreeInfo.minInRightSubtree));

                //a subtree having this curr root node as 'root' is BST only if
                //1. this root's left subtree is also a BST
                //2. this root's right subtree is also a BST
                //3. this root's value is greater than the max value in its left
                //subtree AND less than the min value in its right subtree
                //i.e property of BST:
                //root node's left tree will have all nodes lesser than curr root node
                //AND
                //root node's right tree will have all nodes greater than curr root node
                currRootInfo.isBST
                        = //left subtree should be BST in itself
                        leftTreeInfo.isBST
                                && //right subtree should be BST in itself
                                rightTreeInfo.isBST
                                && //curr root node should be greater than the max node
                                //value in its left subtree i.e leftTreeInfo.maxInLeftSubtree
                                //also
                                //curr root node should be less than the min node
                                //value in its right subtree i.e rightTreeInfo.minInRightSubtree
                                (root.getData() > leftTreeInfo.maxInLeftSubtree
                                        && root.getData() < rightTreeInfo.minInRightSubtree);

                //now, that if the curr subtree rooted at this curr root node
                //is a BST then we will compare the max BST subtree sum
                if (currRootInfo.isBST) {
                    //to find the max sum of the BST in the given tree
                    maxBSTSubtreeSum = Math.max(maxBSTSubtreeSum, currRootInfo.sum);
                    //to find the largest BST(BST with more number of nodes in it)
                    //in the given tree
                    largestBSTSubtree = Math.max(largestBSTSubtree, currRootInfo.nodesCount);
                }
            }
        }

        Helper helper = new Helper();

        helper.helperDFS(root, new NodeInfo());
        //output
        //-ve max value are default to 0, acc to quest
        System.out.println("Max BST sum in binary tree : "
                + (helper.maxBSTSubtreeSum < 0 ? 0 : helper.maxBSTSubtreeSum));

        System.out.println("Largest BST in binary tree : " + helper.largestBSTSubtree);
    }

    private void findAllLonelyNodesInBinaryTree_Helper(
            TreeNode<Integer> root, TreeNode<Integer> parent, List<Integer> lonelyNodes) {

        if (root == null) {
            return;
        }

        findAllLonelyNodesInBinaryTree_Helper(root.getLeft(), root, lonelyNodes);

        findAllLonelyNodesInBinaryTree_Helper(root.getRight(), root, lonelyNodes);

        //if the parent is valid(==> not null)
        //curr 'root' will be called lonely, ONLY IF this curr 'root' is the single
        //child of it's 'parent' that means either of parent's left or right child
        //is null
        if (parent != null && (parent.getLeft() == null || parent.getRight() == null)) {
            lonelyNodes.add(root.getData());
        }
    }

    public void findAllLonelyNodesInBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/find-all-the-lonely-nodes/
        //https://leetcode.ca/all/1469.html
        List<Integer> lonelyNodes = new ArrayList<>();

        //edge case: if root is the only node, but this root can't be called lonely
        //as it don't have any parent so lonelyNodes = []
        findAllLonelyNodesInBinaryTree_Helper(root, null, lonelyNodes);

        //output
        System.out.println("Find all lonely node : " + lonelyNodes);
    }

    public void binaryTreeUpSideDown(TreeNode<Integer> root) {
        //https://leetcode.com/problems/binary-tree-upside-down/description/
        /*

        As per question, The mentioned steps are done level by level. It is
        guaranteed that every right node has a sibling (a left node with the
        same parent) and has no children.

        To understand this logic, try to understand just the 3-node tree and the
        pattern will be applied to larger trees as well

        tree:
        .....................1
        .................../...\
        .................2.......3

        now according to question,

        You can turn a binary tree upside down with the following steps:

        1. The original left child becomes the new root.
        2. The original root becomes the new right child.
        3. The original right child becomes the new left child.

        upside-down

        tree: newRoot = 2
        .....................2
        .................../...\
        .................3.......1

        Logic:

        it is based on simple DFS call which basically traverse the left subtree
        first and then right substree and meanwhile it will retrun the same node
        back to its parent hence its based on postorder traversal

        now the modification to above dfs call is,

        at a curr root, where we have its left-child as leftNode & right-child as
        rightNode and hence forming the 3-node tree in that call stack, we can apply
        the mentioned steps to make it upside-down

        **simulating DFS call stacks**

        tree:
        ........................1
        ....................../...\
        ....................2.......3
        ................../...\
        ................4.......5

        newRoot = null

        main: call(root) ==> call(1)

        #1 call(1)
        ==> if(root == null) FAILED
        ==> if(isLeaf(1)) FAILED
        ==> leftNode = call(1.left) ==> call(2) ==> #2

        #2 call(2)
        ==> if(root == null) FAILED
        ==> if(isLeaf(2)) FAILED
        ==> leftNode = call(2.left) ==> call(4) ==> #3

        #3 call(4)
        ==> if(root == null) FAILED
        ==> if(isLeaf(4)) TRUE
        ====> if(newRoot == null) newRoot = root = 4
        //extreme left-leaf-node will be the new root node, one time initialization
        ====> return root ==> 4 ==> #2

        #2 call(2)
        ==> if(root == null) FAILED
        ==> if(isLeaf(2)) FAILED
        ==> leftNode = call(2.left) ==> call(4) ==> #3
        ==> leftNode = 4 ret from #3
        ==> rightNode call(2.right) ==> call(5) ==> #5

        #5 call(5)
        ==> if(root == null) FAILED
        ==> if(isLeaf(5)) TRUE
        ====> if(newRoot == null) FAILED
        ====> return root ==> 5 ==> #2

        #2 call(2)
        ==> if(root == null) FAILED
        ==> if(isLeaf(2)) FAILED
        ==> leftNode = call(2.left) ==> call(4) ==> #3
        ==> leftNode = 4 ret from #3
        ==> rightNode call(2.right) ==> call(5) ==> #5
        ==> rightNode = 5 ret from #5

        //here we have 3-node in curr call stack
        //{root = 2, leftNode = 4, rightNode = 5}

        currNewRoot = leftNode ==> 4
        currNewRoot.left = rightNode
        ==> 4.left = 5
        currNewRoot.right = root
        ==> 4.right = 2

        //remove all ref
        root.left = root.right = null

        ==> return root ==> 2 ==> #1


        //stucture modified for these 3-node tree
        //newRoot = 4, 4.left = 5, 4.right = 2


        #1 call(1)
        ==> if(root == null) FAILED
        ==> if(isLeaf(1)) FAILED
        ==> leftNode = call(1.left) ==> call(2) ==> #2
        ==> leftNode = 2 ret from #2
        ==> rightNode = call(1.right) ==> call(3) ==> #6

        #5 call(3)
        ==> if(root == null) FAILED
        ==> if(isLeaf(3)) TRUE
        ====> if(newRoot == null) FAILED
        ====> return root ==> 3 ==> #1

        #1 call(1)
        ==> if(root == null) FAILED
        ==> if(isLeaf(1)) FAILED
        ==> leftNode = call(1.left) ==> call(2) ==> #2
        ==> leftNode = 2 ret from #2
        ==> rightNode = call(1.right) ==> call(3) ==> #6
        ==> rightNode = 3 ret from #6

        //here we have 3-node in curr call stack
        //{root = 1, leftNode = 2, rightNode = 3}

        currNewRoot = leftNode ==> 2
        currNewRoot.left = rightNode
        ==> 2.left = 3
        currNewRoot.right = root
        ==> 2.right = 1

        //remove all ref
        root.left = root.right = null

        ==> return root ==> 1 ==> main

        //stucture modified for these 3-node tree
        //newRoot = 4, 4.left = 5, 4.right = 2, 2.left = 3, 2.right = 1

        tree:
        ........................4
        ....................../...\
        ....................5.......2
        ........................../...\
        ........................3.......1

         */
        //actual
        System.out.println("Original tree: ");
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        class Helper {

            TreeNode<Integer> newRoot;

            public TreeNode<Integer> makeBinaryTreeUpSideDownHelper(TreeNode<Integer> root) {

                if (root == null) {
                    return null;
                }

                if (root.getLeft() == null && root.getRight() == null) {

                    //extreme left-leaf-node will be the new root for the
                    //upside-down tree, out of all the leaf nodes, here we will
                    //have one-time initialization for newRoot
                    if (newRoot == null) {
                        newRoot = root;
                    }

                    //return leaf node as well
                    return root;
                }

                TreeNode<Integer> leftNode = makeBinaryTreeUpSideDownHelper(root.getLeft());
                TreeNode<Integer> rightNode = makeBinaryTreeUpSideDownHelper(root.getRight());

                //the upside-down logic
                //left-child-node will be new root
                TreeNode<Integer> currNewRoot = leftNode;
                //right-child-node will be new root's left-child
                currNewRoot.setLeft(rightNode);
                //curr root will be new root's right-child
                currNewRoot.setRight(root);

                //remove the existing references from the curr root as it is going
                //to be changed in the upside-down logic
                root.setLeft(null);
                root.setRight(null);

                return root;
            }
        }

        Helper helper = new Helper();

        helper.makeBinaryTreeUpSideDownHelper(root);

        //output
        System.out.println("Upsided-down tree: ");
        new BinaryTree<>(helper.newRoot).treeBFS();
        System.out.println();
    }

    private int findLeavesOfBinaryTree_Helper(TreeNode<Integer> root, List<List<Integer>> leaves) {

        //same as calculating height of binary tree
        if (root == null) {
            return -1;
        }

        int leftSubtreeHeight = findLeavesOfBinaryTree_Helper(root.getLeft(), leaves);

        int rightSubtreeHeight = findLeavesOfBinaryTree_Helper(root.getRight(), leaves);

        int currRootHeight = Math.max(leftSubtreeHeight, rightSubtreeHeight) + 1;

        if (leaves.size() <= currRootHeight) {
            leaves.add(new ArrayList<>());
        }

        leaves.get(currRootHeight).add(root.getData());

        return currRootHeight;
    }

    public void findLeavesOfBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/find-leaves-of-binary-tree/description/
        /*

        Intuition to solve this question is,

        height of the tree and notion is that each node in the tree has a different
        height. All the leaf nodes are the nodes that will have 0 height then their
        parent node's height will be derived from their child nodes and in the end root's
        height will be calculated as the max(leftSubtreeHeight, rightSubtreeHeight) + 1

        tree:
        .....................1
        .................../...\
        .................2.......3
        .............../..\
        ..............4....5

        height of leaf root(4), root(5).................
        4 ==> max(leftSubtreeHeight, rightSubtreeHeight) + 1 ==> max(-1, -1) + 1 ==> 0
        currRootHeight = root(4) = 0
        leaves.size() at this point is 0

        if(leaves.size() <= currRootHeight) TRUE
        ===> leaves.add(new ArrayList<>()) ==> [[]]
        leaves.get(currRootHeight).add(root.val) ==> leaves.get(0).add(root.val) ==> [[4]]

        return currRootHeight = 0 ==> back to root(2)

        5 ==> max(leftSubtreeHeight, rightSubtreeHeight) + 1 ==> max(-1, -1) + 1 ==> 0
        currRootHeight = root(5) = 0
        leaves.size() at this point is 1

        if(leaves.size() <= currRootHeight) FAIL
        leaves.get(currRootHeight).add(root.val) ==> leaves.get(0).add(root.val) ==> [[4, 5]]

        return currRootHeight = 0 ==> back to root(2)

        height of root(2).................

        2 ==> max(leftSubtreeHeight, rightSubtreeHeight) + 1 ==> max(0, 0) + 1 ==> 1
        currRootHeight = root(2) = 1
        leaves.size() at this point is 1

        if(leaves.size() <= currRootHeight) TRUE
        ===> leaves.add(new ArrayList<>()) ==> [[4,5], []]
        leaves.get(currRootHeight).add(root.val) ==> leaves.get(1).add(root.val) ==> [[4,5], [2]]

        return currRootHeight = 1 ==> back to root(1)

        height of leaf root(3)....................

        3 ==> max(leftSubtreeHeight, rightSubtreeHeight) + 1 ==> max(-1, -1) + 1 ==> 0
        currRootHeight = root(3) = 0
        leaves.size() at this point is 2

        if(leaves.size() <= currRootHeight) FAIL
        leaves.get(currRootHeight).add(root.val) ==> leaves.get(0).add(root.val) ==> [[4, 5, 3], [2]]

        return currRootHeight = 0 ==> back to root(1)

        height of leaf root(1)....................

        1 ==> max(leftSubtreeHeight, rightSubtreeHeight) + 1 ==> max(1, 0) + 1 ==> 2
        currRootHeight = root(1) = 2
        leaves.size() at this point is 2

        if(leaves.size() <= currRootHeight) TRUE
        ===> leaves.add(new ArrayList<>()) ==> [[4,5], [2], []]
        leaves.get(currRootHeight).add(root.val) ==> leaves.get(2).add(root.val) ==> [[4, 5, 3], [2], [1]]

         */
        List<List<Integer>> leaves = new ArrayList<>();
        findLeavesOfBinaryTree_Helper(root, leaves);
        //output
        System.out.println("Find leaves of binary tree : " + leaves);
    }

    public void minOprnsToSortBinaryTreeByLevels(TreeNode<Integer> root) {
        //https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/

        class Helper {

            int findIndex(int[] levelVals, int actualVal) {
                for (int i = 0; i < levelVals.length; i++) {
                    if (levelVals[i] == actualVal) {
                        return i;
                    }
                }
                return 0;
            }

            void swap(int[] levelVals, int index1, int index2) {
                int temp = levelVals[index1];
                levelVals[index1] = levelVals[index2];
                levelVals[index2] = temp;
            }

            int countSwapsRequiredHelper(int[] levelVals) {

                int n = levelVals.length;

                //sorting the levelVals.clone, will tell the actual order
                //of each node that should be in the levelVals
                int[] sorted = levelVals.clone();

                Arrays.sort(sorted);

                int countSwaps = 0;

                for (int i = 0; i < n; i++) {

                    //if the curr position of node is not matching with the
                    //ideal/sorted position of the node at curr i-th index
                    //we must swap these nodes so that levelVals should have
                    //the actual node (==> sorted[i]) at the i-th index
                    if (levelVals[i] != sorted[i]) {
                        //since we are making the positions right by swaping
                        //count this oprn
                        countSwaps++;

                        //swap the curr node value at i-th index with j-th index
                        //of the actual node(==> sorted[i])
                        swap(levelVals, i, findIndex(levelVals, sorted[i]));
                    }
                }
                return countSwaps;
            }

        }

        Helper helper = new Helper();

        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        int swaps = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> currRoot = queue.poll();

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }

            int index = 0;

            //levelVals is the curr order of the nodes occuring in the curr level
            //of the binary tree
            int[] levelVals = new int[queue.size()];

            for (TreeNode<Integer> levelNode : queue) {
                levelVals[index++] = levelNode.getData();
            }

            swaps += helper.countSwapsRequiredHelper(levelVals);
        }

        //output
        System.out.println("Min oprns to sort binary tree by levels : " + swaps);
    }

    public TreeNode<Integer> findNearestRightNodeInBinaryTree(TreeNode<Integer> root, int target) {
        //https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/description/
        //based on BFS, LEVEL-ORDER TRAVERSAL

        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        TreeNode<Integer> targetNode = null;

        while (!queue.isEmpty()) {

            int size = queue.size();

            //finding the 'target' node in each level
            for (int i = 0; i < size; i++) {

                TreeNode<Integer> currRoot = queue.poll();

                //if we have previously found the target node in the 'level'
                //meaning the currRoot is coming in the right of the target node
                if (targetNode != null) {
                    return currRoot;
                }

                //if we have located the given 'target' node in the 'level'
                //we will save it in targetNode and next currRoot coming
                //after this, will be the 'nearest right node'
                if (currRoot.getData() == target) {
                    targetNode = currRoot;
                }

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }

            //above a 'level' is ended, and after the level has ended and
            //targetNode is not null means we found the 'target' which was
            //the very last node in that level hence no right node exist
            //to the very last node
            //ex: target = 5, level above: [2, 3, 5] we found target at a
            //last node and no right node exists for 'target' in that level
            //hence as per question, return null
            if (targetNode != null) {
                return null;
            }
        }

        return null;
    }

    // STACK
    int middleElementInStack_Element = Integer.MIN_VALUE;

    private void middleElementInStack_Helper(Stack<Integer> s, int n, int index) {

        if (n == index || s.isEmpty()) {
            return;
        }

        int ele = s.pop();
        middleElementInStack_Helper(s, n, index + 1);
        if (index == n / 2) {
            middleElementInStack_Element = ele;
        }
        s.push(ele);
    }

    public void middleElementInStack(Stack<Integer> stack) {
        int n = stack.size();
        int index = 0;
        //just reseting
        middleElementInStack_Element = Integer.MIN_VALUE;
        middleElementInStack_Helper(stack, n, index);
        //outputs
        System.out.println("Middle eleement of the stack: " + middleElementInStack_Element);
    }

    public void nextSmallerElementToRightInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() > val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next smaller element to the right in array: " + Arrays.toString(result));
    }

    public void nextSmallerElementToLeftInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() > val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next smaller element to the left in array: " + Arrays.toString(result));
    }

    public void nextGreaterElementToRightInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() < val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next greater element to the right in the array: " + Arrays.toString(result));
    }

    public void nextGreaterElementToLeftInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() < arr[i]) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next greater element to the left in the array: " + Arrays.toString(result));
    }

    private void reserveStack_Recursion_Insert(Stack<Integer> stack, int element) {

        if (stack.isEmpty()) {
            stack.push(element);
            return;
        }

        int popped = stack.pop();
        reserveStack_Recursion_Insert(stack, element);
        stack.push(popped);
    }

    private void reserveStack_Recursion(Stack<Integer> stack) {

        if (stack.isEmpty()) {
            return;
        }

        int popped = stack.pop();
        reserveStack_Recursion(stack);
        reserveStack_Recursion_Insert(stack, popped);
    }

    public void reverseStack(Stack<Integer> stack) {
        System.out.println("actual: " + stack);
        reserveStack_Recursion(stack);
        System.out.println("output: " + stack);
    }

    public void largestAreaInHistogram(int[] heights) {
        //https://leetcode.com/problems/largest-rectangle-in-histogram/
        // Create an empty stack. The stack holds indexes of hist[] array
        // The bars stored in stack are always in increasing order of their
        // heights.
        Stack<Integer> stack = new Stack<>();
        int n = heights.length;
        int maxArea = 0; // Initialize max area
        int top;  // To store top of stack
        int areaWithTop; // To store area with top bar as the smallest bar

        // Run through all bars of given histogram
        int index = 0;
        while (index < n) {
            // If this bar is higher than the bar on top stack, push it to stack
            if (stack.isEmpty() || heights[stack.peek()] <= heights[index]) {
                stack.push(index++);

                // If this bar is lower than top of stack, then calculate area of rectangle
                // with stack top as the smallest (or minimum height) bar. 'i' is
                // 'right index' for the top and element before top in stack is 'left index'
            } else {

                top = stack.pop();  // store the top index
                // Calculate the area with hist[tp] stack as smallest bar
                areaWithTop = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
                // update max area, if needed
                maxArea = Math.max(maxArea, areaWithTop);
            }
        }

        // Now pop the remaining bars from stack and calculate area with every
        // popped bar as the smallest bar
        while (!stack.isEmpty()) {
            top = stack.pop();
            areaWithTop = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
            maxArea = Math.max(maxArea, areaWithTop);
        }

        //output:
        System.out.println("Max area of histogram: " + maxArea);
    }

    public void postfixExpressionEvaluation_SingleDigit(String expr) {
        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < expr.length(); i++) {

            char ch = expr.charAt(i);
            if (Character.isDigit(ch)) {
                stack.push(ch - '0');
            } else {
                int num1 = stack.pop();
                int num2 = stack.pop();

                switch (ch) {
                    case '+':
                        stack.push(num2 + num1);
                        break;
                    case '-':
                        stack.push(num2 - num1);
                        break;
                    case '*':
                        stack.push(num2 * num1);
                        break;
                    case '/':
                        stack.push(num2 / num1);
                        break;
                }
            }
        }

        //output:
        System.out.println("Evaluation single digit expression: " + stack.pop());
    }

    public void postfixExpressionEvaluation_MultipleDigit(String expr) {
        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < expr.length(); i++) {

            char ch = expr.charAt(i);

            //space is needed in expr to distinguish b/w 2 different multiple digit
            if (ch == ' ') {
                continue;
            }

            //if we found atleat one digit
            //try to iterate i until we found a char chr which is not a digit
            if (Character.isDigit(ch)) {
                int createNum = 0;
                while (Character.isDigit(expr.charAt(i))) {
                    createNum = createNum * 10 + (expr.charAt(i) - '0');
                    i++; //this to further iterate i and find digit char
                }
//                i--; //just to balance to one iter back
                stack.push(createNum);
            } else {
                int num1 = stack.pop();
                int num2 = stack.pop();

                switch (ch) {
                    case '+':
                        stack.push(num2 + num1);
                        break;
                    case '-':
                        stack.push(num2 - num1);
                        break;
                    case '*':
                        stack.push(num2 * num1);
                        break;
                    case '/':
                        stack.push(num2 / num1);
                        break;
                }
            }
        }

        //output:
        System.out.println("Evaluation multiple digit expression: " + stack.pop());
    }

    public void removeKDigitsToCreateSmallestNumber(String num, int K) {

        //explanation: https://youtu.be/vbM41Zql228
        if (K == num.length()) {
            System.out.println("Number formed: 0");
            return;
        }

        StringBuilder sb = new StringBuilder();
        Stack<Integer> stack = new Stack<>();

        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            //Greedily take the smaller digit than stack's peek digit
            //ex: "1432219"
            //stack [1]
            //stack [1, 4] as not 1 > 4
            //stack [1, 3] as 4 > 3
            //becasue if number has to be formed in that case 14 > 13 smaller num req 13 and so on.
            while (!stack.isEmpty() && stack.peek() > digit && K != 0) {
                stack.pop();
                K--;
            }
            stack.push(digit);
        }

        //case when all the digits in the stack are same
        //ex: 1111
        while (!stack.isEmpty() && K != 0) {
            stack.pop();
            K--;
        }

        //form the number
        //ex: "1432219"
        //stack would be having [1, 2, 1, 9] <- peek
        //pop element and add then at 0th index so sb = "1219"
        while (!stack.isEmpty()) {
            sb.insert(0, stack.pop());
        }

        //case when there are leading zeros in num
        //ex: 000234 => 234
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }

        //output
        System.out.println("Number formed: " + sb.toString());
    }

    public void findTheMostCompetetiveSubsequenceOfSizeKFromArray(int[] nums, int K) {

        //problem: https://leetcode.com/problems/find-the-most-competitive-subsequence/
        //explanation: https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/1113429/Java-Brute-Force-Stack
        int n = nums.length;
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            int val = nums[i];

            while (stack.size() > 0 && stack.size() + n - (i + 1) >= K
                    && stack.peek() > val) {
                stack.pop();
            }
            stack.push(val);
        }

        while (!stack.isEmpty() && stack.size() > K) {
            stack.pop();
        }
        //output
        int[] result = stack.stream().mapToInt(val -> val).toArray();
        for (int x : result) {
            System.out.print(x + " ");
        }

        System.out.println();
    }

    public void nextWarmerDayInTheGivenWeatherRecordings(int[] recordings) {

        //SIMILAR TO NEXT GREATER ELEMENT TO RIGHT
        //problem statement: https://youtu.be/0mcAy91rPzE
        //https://leetcode.com/problems/daily-temperatures/
        int n = recordings.length;
        int[] warnDaysAfter = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {

            while (!stack.isEmpty() && recordings[stack.peek()] < recordings[i]) {
                stack.pop();
            }

            warnDaysAfter[i] = stack.isEmpty() ? 0 : stack.peek() - i;
            stack.push(i);
        }

        //output:
        System.out.println("For each recording next warm day occur after:");
        for (int i = 0; i < n; i++) {
            if (warnDaysAfter[i] == 0) {
                System.out.println(recordings[i] + ": after " + warnDaysAfter[i] + " day, there is no warm day after this recrding");
                continue;
            }
            System.out.println(recordings[i] + ": after " + warnDaysAfter[i] + " day, there is a warm day i,e: " + recordings[i + warnDaysAfter[i]]);
        }
    }

    private void rotAllAdjacent(int[][] basket,
                                int x, int y,
                                boolean[][] visited,
                                int row, int col) {

        //all aadjacent coordinate
        //check new coordinates are in bounds
        //check new coordinates are not previously visited
        //maake the adjacent rot and mark them visited
        int x1 = -1;
        int y1 = -1;

        //left coordinate to row,col = row, col-1
        x1 = x;
        y1 = y - 1;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //right coordinate to row,col = row, col+1
        x1 = x;
        y1 = y + 1;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //top coordinate to row,col = row-1, col
        x1 = x - 1;
        y1 = y;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //bottom coordinate to row,col = row+1, col
        x1 = x + 1;
        y1 = y;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

    }

    public void rottenOranges_DFS(int[][] basket) {

        int rottenTime = 0;
        int row = basket.length;
        int col = basket[0].length;

        boolean[][] visited = new boolean[row][col];

        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (visited[x][y] != true && basket[x][y] == 2) {
                    //rotten oranges == 2
                    visited[x][y] = true;
                    rottenTime++;
                    rotAllAdjacent(basket, x, y, visited, row, col);
                }
            }
        }

        //check if any one is left unrotten(1)
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (basket[x][y] == 1) {
                    //rotten oranges == 2
                    rottenTime = -1;
                }
            }
        }

        System.out.println("rotten time " + rottenTime);

    }

    public int rottenOranges_HashBased(int[][] grid) {
        //https://leetcode.com/problems/rotting-oranges/
        Set<String> fresh = new HashSet<>();
        Set<String> rotten = new HashSet<>();
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {

                if (grid[i][j] == 1) {
                    fresh.add(i + "" + j);
                }

                if (grid[i][j] == 2) {
                    rotten.add(i + "" + j);
                }
            }
        }

        int minTime = 0;
        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };
        Set<String> infected = new HashSet<>();
        while (fresh.size() > 0) {
            //loop over all the rotten oranges
            for (String rottenPoint : rotten) {
                //get coord of all the curr rotten orange
                int x = rottenPoint.charAt(0) - '0';
                int y = rottenPoint.charAt(1) - '0';
                //find all the adjacent 4-directions from the
                //curr rotten orange
                for (int[] dir : dirs) {
                    int newX = x + dir[0];
                    int newY = y + dir[1];
                    //if any adjacent 4-directions contains a fresh orange
                    //that means the curr rotten orange has infected it(in 1 unit time)
                    if (fresh.contains(newX + "" + newY)) {
                        //fresh is now infected by curr rotten orange
                        //so remove from fresh coords
                        fresh.remove(newX + "" + newY);
                        //move this newly infected orange into infected coord
                        infected.add(newX + "" + newY);
                    }
                }
            }

            //if at any point, we are unable to infect any fresh oranges
            //out infected coord will remain empty, so return -1
            if (infected.isEmpty()) {
                return -1;
            }

            //put all the infected oranges into rotten coords and clear infected
            //for next time
            rotten.addAll(infected);
            infected.clear();
            minTime++;
        }

        return minTime;
    }

    public void validSudoku(String[][] grid) {
        //https://leetcode.com/problems/valid-sudoku/
        //https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/
        //Explanantion: https://youtu.be/Pl7mMcBm2b8
        HashSet<String> vis = new HashSet<>();

        for (int x = 0; x < grid.length; x++) {
            for (int y = 0; y < grid[x].length; y++) {

                String curr = grid[x][y];
                if (!curr.equals(".")) {

                    if (!vis.add(curr + " at row: " + x)
                            || !vis.add(curr + " at col: " + y)
                            || !vis.add(curr + " in cell: " + (x / 3) + "-" + (y / 3))) {
                        System.out.println("Invalid sudoku grid");
                        return;
                    }
                }
            }
        }

        System.out.println("Valid sudoku grid");
    }

    public void minCostOfRope(int[] ropes) {

        //GREEDY ALGO
        //HEAP based approach
        PriorityQueue<Integer> minHeapRopes = new PriorityQueue<>();
        for (int rope : ropes) {
            minHeapRopes.add(rope);
        }

        //calculations
        int cost = 0;
        while (minHeapRopes.size() >= 2) {

            int rope1 = minHeapRopes.poll();
            int rope2 = minHeapRopes.poll();

            cost += rope1 + rope2;
            int newRope = rope1 + rope2;
            minHeapRopes.add(newRope);
        }
        //output
        System.out.println("Min cost to combine all rpes into one rope: " + cost);
    }

    public void kLargestElementInArray(int[] arr, int K) {

        PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1, o2) -> o1.compareTo(o2));
        for (int x : arr) {
            minHeap.add(x);
            if (minHeap.size() > K) {
                minHeap.poll();
            }
        }

        int[] result = new int[minHeap.size()];
        int index = minHeap.size() - 1;
        while (!minHeap.isEmpty()) {

            result[index--] = minHeap.poll();
        }

        //output
        System.out.println("K largest elements: " + Arrays.toString(result));
    }

    public void kLargestElementInStringNumsArray(String[] nums, int k) {
        //https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/description/

        PriorityQueue<String> minHeapStringNums = new PriorityQueue<>((a, b) -> {
            //**custom comparator as min heap**
            //if "80" length < "3000" length put "80" first
            //despite having a comparision on chars '8' & '3'
            if (a.length() < b.length()) {
                return -1;
            } else if (b.length() < a.length()) {
                return 1;
            }
            //here we are having same length for both a and b string nums
            //so decide which numeric char is smaller out of the two
            return a.compareTo(b) <= 0 ? -1 : 1;
        });

        for (String num : nums) {
            minHeapStringNums.add(num);
            if (minHeapStringNums.size() > k) {
                minHeapStringNums.poll();
            }
        }

        //output
        System.out.println("K-th largest element in string nums array: " + minHeapStringNums.peek());
    }

    public void mergeKSortedArrays_1(int[][] arr) {
        //......................T: O(M*N*Log(M*N)), where M = row & N = col
        //......................S: O(M*N)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int[] row : arr) {
            for (int cell : row) {
                minHeap.add(cell);
            }
        }

        List<Integer> sortedList = new ArrayList<>();
        while (!minHeap.isEmpty()) {
            sortedList.add(minHeap.poll());
        }

        //output:
        System.out.println("K sorted array into a list: " + sortedList);
    }

    public void mergeKSortedArrays_2(int[][] arr) {

        class Input {

            final int row;
            int col;
            final int colLength;

            public Input(int row, int col, int colLength) {
                this.row = row;
                this.col = col;
                this.colLength = colLength;
            }
        }

        //OPTIMISED
        //........................T: O(N*K*LogK)
        //........................S: O(K)
        PriorityQueue<Input> minHeap = new PriorityQueue<>((a, b) -> arr[a.row][a.col] - arr[b.row][b.col]);
        //minHeap will hold start coordinate(row, col) for all the elements in each row not the total R*C elements directly
        for (int r = 0; r < arr.length; r++) {
            if (arr[r].length > 0) {
                minHeap.add(new Input(r, 0, arr[r].length));
            }
        }
        //after this loop minHeap will have K instance of Input() holding (row, col)  for each row
        //minHeap.size() == K

        List<Integer> sortedList = new ArrayList<>();
        while (!minHeap.isEmpty()) {

            //At any point of time we poll Input from minHeap
            Input in = minHeap.poll();
            //we put the element at that row, col
            sortedList.add(arr[in.row][in.col]);
            //if new col is less than its col length
            //we update col and put that updated input(in) in minHeap back
            if (in.col + 1 < in.colLength) {
                in.col++;
                minHeap.add(in);
            }
        }

        //output:
        System.out.println("K sorted array into a list: " + sortedList);
    }

    public void kThLargestSumFromContigousSubarray(int[] arr, int K) {
        //................................T: O(N^2 * LogK)
        //................................S: O(K), only K elements are stored at a time in heap
        //https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/
        //arr[]: [20, -5, -1]
        //contSumSubarry: [20, 15, 14, -5, -6, -1]
        //20, 20+(-5), 20+(-5)+(-1), -5, -5+(-1), -1
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        //generating subarrays
        for (int i = 0; i < arr.length; i++) {
            int contSum = 0;
            for (int j = i; j < arr.length; j++) {
                contSum += arr[j];
                minHeap.add(contSum);
                if (minHeap.size() > K) {
                    minHeap.poll();
                }
            }
        }
        System.out.println("kth largest sum from contigous subarray: " + minHeap.peek());
    }

    public void majorityElement_1(int[] a) {
        //.............T: O(N)
        //.............S: O(Unique ele in a)
        //https://leetcode.com/problems/majority-element/
        //https://leetcode.com/problems/majority-element-ii/
        int maj = a.length / 2;

        Map<Integer, Integer> map = new HashMap<>();
        for (int x : a) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> e : map.entrySet()) {
            if (e.getValue() > maj) {
                System.out.println("Majority element: " + e.getKey());
                return;
            }
        }

        System.out.println("Majority element: -1");
    }

    public void majorityElement_2(int[] nums) {
        //Moores Voting Algorithm
        //https://leetcode.com/problems/majority-element/
        //https://www.geeksforgeeks.org/majority-element/
        //..........T: O(N)
        //..........S: O(1)
        //finding candidate
        int majorityElementCandidate = nums[0];
        int count = 1;

        for (int val : nums) {

            if (val == majorityElementCandidate) {
                count++;
            } else {
                count--;
            }

            if (count == 0) {
                majorityElementCandidate = val;
                count = 1;
            }
        }

        //verifying 'majorityElementCandidate'
        count = 0;
        for (int val : nums) {
            if (val == majorityElementCandidate) {
                count++;
            }
        }

        int majorityElement = count > nums.length / 2 ? majorityElementCandidate : -1;

        System.out.println("Majority element: " + majorityElement);
    }

    public void mergeTwoSortedArraysWithoutExtraSpace(int[] arr1, int[] arr2) {
        //https://practice.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1
        //https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/
        //explanation: https://youtu.be/n7uwj04E0I4
        /*

        since both the given arrays are sorted increasingly, then we are left
        with just one possibilty that is any starting side values of arr2[j]
        is lesser than the ending side values of arr1[i] making it that
        arr1[i] > arr2[j] that would mean, these lesser values of arr2[j]
        should be somewhere arranged in arr1[] only

        ex: arr1[] = [1 3 5 7], arr2[] = [0 2 6 8 9], m = 4, n = 5

        ideally the merge should be, which is final output as well
        arr1[] = [0, 1, 2, 3], arr2[] = [5, 6, 7, 8, 9]

        as per this logic,

        i = m - 1 = 4 - 1 = 3
        j = 0

        (arr1[i] > arr2[j]) ==> (arr1[3] > arr2[0])
        ==> (7 > 0)
        ==> this basically tells that arr2 has value 0 and arr1 has value 7 but
        in ideal case 0 should belongs to arr1[] in a merged arr1[] & arr2[]
        If this case is seen in loop we must swap these values to put them in
        their right arrays. At a point when this comparision is no more possible
        break;

        and since in above loop, we just swapped values in their rightful arrays
        we now need to arrange then in sorted order, for that we can sort them
        separately

         */

        int m = arr1.length;
        int n = arr2.length;

        //i-th index represent the last values from arr1[]
        int i = m - 1;
        //j-th index represent the starting values from arr2[]
        int j = 0;

        while (i >= 0 && j < n) {

            if (arr1[i] > arr2[j]) {
                //swap
                int temp = arr1[i];
                arr1[i] = arr2[j];
                arr2[j] = temp;
                i--;
                j++;
            } else {
                //break, when arr1[i] <= arr2[j]
                break;
            }
        }

        //now that we have put all the possible smaller values from arr2[] to arr1[]
        //and simultaneously larger values from arr1[] to arr2[], we can then
        //separately sort these two arrays
        Arrays.sort(arr1);
        Arrays.sort(arr2);

        //output
        System.out.println("Merge sorted arrays without extra space : "
                + (Arrays.toString(arr1) + ":" + Arrays.toString(arr2)));
    }

    private int findFirstOccurenceTargetInSortedArray(int[] nums, int target) {

        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            if ((mid == 0 || nums[mid - 1] < target) && nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }

    private int findLastOccurenceTargetInSortedArray(int[] nums, int target) {

        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            if ((mid == n - 1 || target < nums[mid + 1]) && nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return -1;
    }

    public void findFirstAndLastOccurenceOfTargetInSortedArray(int[] nums, int target) {
        //https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
        //https://leetcode.com/problems/find-target-indices-after-sorting-array/
        int first = findFirstOccurenceTargetInSortedArray(nums, target);
        int last = findLastOccurenceTargetInSortedArray(nums, target);

        System.out.println(target + " first and last occurence: " + first + " " + last);
    }

    private int longestSubsequenceWithLimitedSum_BinarySearchHelper(int[] nums, int target) {

        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            if ((mid == n - 1 || target < nums[mid + 1]) && nums[mid] <= target) {
                return mid;
            } else if (target < nums[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return -1;
    }

    public void longestSubsequenceWithLimitedSum(int[] nums, int[] queries) {
        //https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/
        //based on PREFIX SUM, BINARY SEARCH
        int n = nums.length;
        int m = queries.length;

        int[] longestSubseq = new int[m];

        Arrays.sort(nums);

        int prefixSum = 0;

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            nums[i] = prefixSum;
        }

        for (int i = 0; i < m; i++) {

            int target = queries[i];
            int index = longestSubsequenceWithLimitedSum_BinarySearchHelper(nums, target);
            longestSubseq[i] = index == -1 ? 0 : index + 1;
        }

        System.out.println("Longest subseq with limited sum : " + Arrays.toString(longestSubseq));
    }

    public int searchInRotatedSortedArray(int[] nums, int K) {
        //https://leetcode.com/problems/search-in-rotated-sorted-array
        //explanation: https://youtu.be/oTfPJKGEHcc
        /*
        normal sorted nums[]: [0, 1, 2, 3, 4, 5, 6, 7, 8]
        rotated sorted nums[]: [5, 6, 7, 8, 0, 1, 2, 3, 4]
        left sorted sec = [5, 6, 7, 8] strictly increasing
        right sorted sec = [0, 1, 2, 3, 4] strictly increasing
         */
        int start = 0;
        int end = nums.length - 1;
        int N = nums.length;

        while (end >= start) {

            int mid = start + (end - start) / 2;
            if (nums[mid] == K) {
                return mid;
            }
            //left sorted section
            //if nums[mid] lies in left sorted sec then it is obvious that
            //nums[start] will be nums[start] <= nums[mid]
            //else if nums[mid] lies in right sorted sec then each values of
            //left sorted sec is greater than each values of right sorted sec
            //means this if cond (nums[start] <= nums[mid]) will fail
            if (nums[start] <= nums[mid]) {
                //we are in left sorted sec and also if target lies in
                //left sorted sec range then move end to left sorted sec
                //(reducing search window to left sorted sec only)
                //otherwise move start to right sorted sec
                if (K >= nums[start] && K < nums[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }

            } else {
                //right sorted section
                //we are in right sorted sec and also if target lies in
                //right sorted sec range then mode start to right sorted sec
                //(reducing search window to right sorted sec only)
                //otherwise move end to left-sec
                if (K > nums[mid] && K <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        return -1;
    }

    public int searchInRotatedSortedArrayWithDuplicateArrayElement(int[] arr, int K) {

        int start = 0;
        int end = arr.length - 1;
        int N = arr.length;
        int mid = -1;

        while (end >= start) {

            //shift front till arr[f] is same as arr[f+1]
            //when f and f+1 elements are diff loop will end
            while (start < end && arr[start] == arr[start + 1]) {
                start++;
            }
            //shift last till arr[l] is same as arr[l-1]
            //when l and l-1 elements are diff loop will end
            while (start < end && arr[end] == arr[end - 1]) {
                end--;
            }

            mid = start + (end - start) / 2;
            if (arr[mid] == K) {
                return mid;
            }

            if (arr[start] <= arr[mid]) {

                if (K >= arr[start] && K < arr[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }

            } else {
                if (K > arr[mid] && K <= arr[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        return -1;
    }

    public void findRepeatingAndMissingInUnsortedArray_1(int[] arr) {
        //https://leetcode.com/problems/set-mismatch/
        //problem statement: https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
        //arr: will be of size N and elements in arr[] will be [1..N]
        //.......................T: O(N)
        //.......................S: O(N)
        System.out.println("Approach 1");
        int[] count = new int[arr.length + 1];
        //get the occurence of arr element in count[] where count[i] i: elements in arr
        for (int i = 0; i < arr.length; i++) {
            count[arr[i]]++;
        }

        for (int i = 1; i < count.length; i++) {
            //first ith index that has count[i] = 0 is the element in arr which is supposed to be missing
            //count[i] == 0 => i = element in arr is supposed to be missing
            if (count[i] == 0) {
                System.out.println("Missing: " + i);
                break;
            }
        }

        for (int i = 1; i < count.length; i++) {
            //first ith index which has count[i] > 1 (occuring more that 1)
            //is the element which is repeating
            //count[i] > 1 => i = element in arr which is repeating
            if (count[i] > 1) {
                System.out.println("Repeating: " + i);
                break;
            }
        }
    }

    public void findRepeatingAndMissingInUnsortedArray_2(int[] arr) {
        //https://leetcode.com/problems/set-mismatch/
        //problem statement: https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
        //explanation: https://youtu.be/aMsSF1Il3IY
        //OPTIMISED
        //.......................T: O(N)
        //.......................S: O(1)
        System.out.println("Approach 2");
        System.out.println("Repeating element: ");
        for (int val : arr) {
            int absVal = Math.abs(val);
            if (arr[absVal - 1] > 0) {
                arr[absVal - 1] = -arr[absVal - 1];
            } else {
                System.out.println(absVal);
            }
        }

        System.out.println("Missing element: ");
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0) {
                System.out.println(i + 1);
            }
        }
    }

    public boolean checkIfPairPossibleInArrayHavingGivenDiff(int[] arr, int diff) {

        //..................T; O(N)
        //..................S: O(N)
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            //arr[row] - arr[col] = diff
            //arr[row] = diff + arr[col]
            //if set.contains(arr[col]) then pair is possible
            if (set.contains(arr[i])) {
                return true;
            }

            //arr[row] = arr[col] +diff
            set.add(arr[i] + diff);
        }

        return false;
    }

    private double squareRootOfANumber_PreciseDoubleValue_BinarySearch(double n, double start, double end) {

        if (end >= start) {

            double mid = start + (end - start) / 2.0;
            double sqr = mid * mid;

            if (sqr == n || Math.abs(n - sqr) < 0.00001) {
                return mid;
            } else if (sqr < n) {
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, mid, end);
            } else {
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, start, mid);
            }
        }

        return 1.0;
    }

    public double squareRootOfANumber_PreciseDoubleValue(double n) {

        //https://leetcode.com/problems/sqrtx/
        if (n == 0.0 || n == 1.0) {
            return n;
        }

        double i = 1;
        while (true) {
            double sqr = i * i;
            if (sqr == n) {
                return i;
            } else if (sqr > n) {
                //at this point where sqr of i is > n then that means sqr root for n lies b/w
                // i-1 and i
                //ex sqrt(3) == 1.73 (lie b/w 1 and 2)
                // i = 1 sqr = 1*1 = 1
                //i = 2 sqr = 2*2 = 4
                //4 > n i.e 4 > 3 that means sqrt(3) lie in b/w 1 and 2
                //so we will do binary search i-1, i (1, 2)
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, i - 1, i);
            }
            i++;
        }
    }

    public int squareRootOfANumber_RoundedIntValue(int x) {

        //https://leetcode.com/problems/sqrtx/
        long start = 0;
        long end = (x / 2) + 1;

        while (end > start) {

            long mid = start + (end - start) / 2 + 1;
            long sqr = mid * mid;
            if (sqr == x) {
                return (int) mid;
            } else if (x < sqr) {
                end = mid - 1;
            } else {
                start = mid;
            }
        }
        return (int) start;
    }

    public void kThElementInTwoSortedArrays_1(int[] a, int[] b, int K) {

        //HEAP SORTING AND MERGING
        //...........................T: O((N+M).Log(N+M))
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int a_ : a) {
            minHeap.add(a_);
        }

        for (int b_ : b) {
            minHeap.add(b_);
        }

        //pop out K element from heap
        int kthElement = -1;
        while (K-- != 0 && !minHeap.isEmpty()) {
            kthElement = minHeap.poll();
        }

        //output:
        System.out.println("Kth element in two sorted arrays: " + kthElement);
    }

    public void kThElementInTwoSortedArrays_2(int[] a, int[] b, int K) {

        //Two arrays are already sorted
        //...........................T: O(K)
        int iK = 0;
        int m = a.length;
        int n = b.length;
        int i = 0;
        int j = 0;
        int kthElement = -1;

        while (i < m && j < n) {

            if (a[i] < b[j]) {
                iK++;
                if (iK == K) {
                    kthElement = a[i];
                    break;
                }
                i++;
            } else {
                iK++;
                if (iK == K) {
                    kthElement = b[j];
                    break;
                }
                j++;
            }
        }

        //if loop ends beacuse we run out of one array element
        while (i < m) {
            iK++;
            if (iK == K) {
                kthElement = a[i];
            }
            i++;
        }

        while (j < n) {
            iK++;
            if (iK == K) {
                kthElement = b[j];
            }
            j++;
        }

        //output:
        System.out.println("Kth element in two sorted arrays: " + kthElement);
    }

    public int findMinimumInRotatedSortedArray(int[] nums) {
        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
        //explanation: https://youtu.be/IzHR_U8Ly6c
        /*
        lets take an expample of sorted array[]
        nums[] = [1,2,3,4,5]

        in sorted incr array(non rotated), there is always a single upward slope

        ..................................5
        ................................./
        ................................4
        .............................../
        ..............................3
        ............................./
        ............................2
        .........................../
        ..........................1


        now rotate this nums[] = [3,4,5,1,2]

        ...................................5...2
        ................................./..\./
        ................................4....1
        .............................../
        ..............................3

        now after the rotation, we can see there are two upward slope(3 -> 5) & (1 -> 2)
        and one dip/falling slope (5 -> 1)

        in our binary search, we need to find a 'mid' which is the bottom point
        of the falling slope and our min-in-rotated-rotated-array here that bottom
        point is '1' on mid == 3 since its falling slope, just before this point
        there will be peek value that is '5' always on (mid - 1)

        hence this cond is there ==> (mid > 0 && nums[mid - 1] > nums[mid]), since
        we are considering (mid - 1) so it can go out of bounds so check for (mid > 0)

        now in order to move the start or end ptr, we need to keep track of this
        peek point
        ==>
        ..................nums[mid]
        ................../.......\
        ................./.........\
        .........nums[start].......nums[end]

        some movement for example

        ==>
        start = 0, mid == 0, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ................3............2
        ==>
        start = 0, mid == 1, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ......................4
        ................../.......\
        ................./.........\
        ................3............2
        ==>
        start = 0, mid == 2, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ......................5
        ................../.......\
        ................./.........\
        ................3............2

        as long as we are seeing (nums[start] <= nums[mid] && nums[mid] > nums[end])
        we are following a peek value and we continue to find a peek value by moving
        start = mid + 1 why? as we said, right after a top peek, there will be a fall.
        our mid should point to this fall point

         */
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {
            int mid = start + (end - start) / 2;

            if (mid > 0 && nums[mid - 1] > nums[mid]) {
                return nums[mid];
            } else if (nums[start] <= nums[mid] && nums[mid] > nums[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return nums[start];
    }

    public int findMinimumInRotatedSortedArrayTwo(int[] nums) {
        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/
        //based exactly on findMinimumInRotatedSortedArray()
        //handle duplicated values
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            //keep lopp on start ptr, until we skip all the duplicates of nums[start]
            while (start + 1 < n && nums[start] == nums[start + 1]) {
                start++;
            }

            //keep lopp on end ptr, until we skip all the duplicates of nums[end]
            while (end - 1 >= 0 && nums[end - 1] == nums[end]) {
                end--;
            }

            //if from above loops, we ever reach an invalid start & end ptr, break
            if (start > end) {
                break;
            }

            int mid = start + (end - start) / 2;
            if (mid > 0 && nums[mid - 1] > nums[mid]) {
                return nums[mid];
            } else if (nums[start] <= nums[mid] && nums[mid] > nums[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return nums[start];
    }

    public void findLocalMinima(int[] arr) {

        int start = 0;
        int end = arr.length - 1;
        int mid = 0;
        while (end >= start) {

            mid = start + (end - start) / 2;

            if ((mid == 0 || arr[mid - 1] > arr[mid])
                    && (mid == arr.length - 1 || arr[mid + 1] > arr[mid])) {
                break;
            } else if (mid > 0 && arr[mid - 1] < arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        //output
        System.out.println("Local minima at index: " + mid + " element: " + arr[mid]);
    }

    public void findLocalMaxima(int[] arr) {
        //LOCAL MAXIMA OR PEAK ELEMENT
        //https://leetcode.com/problems/find-peak-element/
        //https://leetcode.com/problems/peak-index-in-a-mountain-array/description/
        //explanation: https://youtu.be/kMzJy9es7Hc
        int n = arr.length;
        int start = 0;
        int end = n - 1;
        int mid = 0;
        while (end >= start) {

            mid = start + (end - start) / 2;

            if ((mid == 0 || arr[mid - 1] < arr[mid]) && (mid == n - 1 || arr[mid] > arr[mid + 1])) {
                break;
            } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        //output
        System.out.println("Local maxima at index: " + mid + " element: " + arr[mid]);
    }

    private int findInMountainArray_MountainPeek(int[] arr) {
        //based on findLocalMaxima()
        int n = arr.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //as per question, to have min calls to 'MountainArray' API, store
            //the min value one time and use the value after instead of making
            //new calls as arr[mid]
            int midVal = arr[mid];

            if ((mid == 0 || arr[mid - 1] < midVal) && (mid == n - 1 || midVal > arr[mid + 1])) {
                return mid;
            } else if (mid > 0 && arr[mid - 1] > midVal) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return start;
    }

    private int findInMountainArray_FindInUpHill(int[] arr, int start, int end, int target) {

        //the up hill part of the mountain array i.e, [0 to peekIndex] will be
        //seen as an increasingly sorted array, hence we will apply BINARY SEARCH
        //accordingly
        while (end >= start) {

            int mid = start + (end - start) / 2;

            //as per question, to have min calls to 'MountainArray' API, store
            //the min value one time and use the value after instead of making
            //new calls as arr[mid
            int midVal = arr[mid];

            //if the target is found
            if (target == midVal) {
                return mid;
            } else if (target < midVal) {
                //if target is smaller than the curr midVal, means we need to
                //shift search space to left side of up-hill array
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return -1;
    }

    private int findInMountainArray_FindInDownHill(int[] arr, int start, int end, int target) {

        //the down hill part of the mountain array i.e, [peekIndex to n - 1]
        //will be seen as an decreasingly sorted array, hence we will apply
        //BINARY SEARCH accordingly
        while (end >= start) {

            int mid = start + (end - start) / 2;

            //as per question, to have min calls to 'MountainArray' API, store
            //the min value one time and use the value after instead of making
            //new calls as arr[mid
            int midVal = arr[mid];

            //if target is found
            if (target == midVal) {
                return mid;
            } else if (target < midVal) {
                //if target is smaller than the curr midVal, means we need to
                //shift search space to right side of down-hill array
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }

    public int findInMountainArray(int[] mountainArr, int target) {
        //https://leetcode.com/problems/find-in-mountain-array/description/
        //based on BINARY SEARCH
        /*

        Question statement:

        Given a mountain array mountainArr, return the minimum index such that
        mountainArr.get(index) == target. If such an index does not exist,
        return -1.

        You cannot access the mountain array directly. You may only access the
        array using a MountainArray interface:

        MountainArray.get(k) returns the element of the array at index k (0-indexed).
        MountainArray.length() returns the length of the array.
        Submissions making more than 100 calls to MountainArray.get will be
        judged Wrong Answer

         */
        int n = mountainArr.length;

        //same as finding local maxima/ peek element as given array is already
        //a mountain array hence there must exist a 'mountain peek'
        int mountainPeekIndex = findInMountainArray_MountainPeek(mountainArr);
        int mountainPeekValue = mountainArr[mountainPeekIndex];

        if (target == mountainPeekValue) {
            return mountainPeekIndex;
        }

        int upHillIndex = findInMountainArray_FindInUpHill(mountainArr, 0, mountainPeekIndex, target);
        int downHillIndex = findInMountainArray_FindInDownHill(mountainArr, mountainPeekIndex, n - 1, target);

        //if target is not found in up-hill part(upHillIndex == -1) then we must
        //return downHillIndex, which also can be -1 that would mean that, target
        //don't exist at all in given mountainArray
        //otherwise
        //if unHillIndex != -1 means we found a target in up-hill part hence this
        //index will the min index as required in question
        //(see above question statemnet)
        return upHillIndex == -1 ? downHillIndex : upHillIndex;
    }

    private int countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
            int[] arr, int x, int start, int end) {

        //MODIFIED BINARY SERACH FOR THIS QUESTION
        //SIMILAR TO findLastOccurenecOfKInSortedArray()
        if (end >= start) {

            int mid = start + (end - start) / 2;

            if ((mid == arr.length - 1 || x < arr[mid + 1]) && arr[mid] == x) {
                return mid;
            } else if (x < arr[mid]) {
                return countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                        arr, x, start, mid - 1);
            } else {
                return countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                        arr, x, mid + 1, end);
            }
        }
        return end;
    }

    public void countElementsFromSecondArrayLessOrEqualToElementInFirstArray(int[] first, int[] second) {

        /*
         Brute force : T: O(N^2)
         `1. Use 2 for loop:
         -> i for first[]
         ---> count = 0
         ---> j for second[]
         ------> if second[j] <= first[i]: count++
         ---> print: count
         */
        //............................T: O((M + N) * LogN) where M = first.length, N = second.length
        //............................S: O(1)
        //https://www.geeksforgeeks.org/element-1st-array-count-elements-less-equal-2nd-array/
        Arrays.sort(second);
        List<Integer> result = new ArrayList<>();
        for (int x : first) {
            int index = countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                    second, x, 0, second.length - 1);
            result.add(index + 1);
        }

        //output
        System.out.println("Count: " + result);
    }

    private int[] KMP_PatternMatching_Algorithm_LPSArray(String pattern, int size) {

        int[] lps = new int[size];
        lps[0] = 0; //always 0th index is 0
        int suffixIndex = 1;
        int prefixIndex = 0;
        while (suffixIndex < size) {

            if (pattern.charAt(prefixIndex) == pattern.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex; // prefixIndex == 0
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }

        return lps;
    }

    public void KMP_PatternMatching_Algorithm(String text, String pattern) {
        //https://leetcode.com/problems/implement-strstr/
        //explanation: https://youtu.be/JoF0Z7nVSrA
        //explanation: https://youtu.be/ziteu2FpYsA
        int textLen = text.length();
        int patternLen = pattern.length();

        //create LPS array for pattern
        int[] lps = KMP_PatternMatching_Algorithm_LPSArray(pattern, patternLen);

        boolean atleastOneMatchFound = false;
        //text and pattern matching
        int textIndex = 0; // index for text
        int patternIndex = 0; // index for pattern
        while (textIndex < textLen) {

            if (textIndex < textLen && patternIndex < patternLen
                    && text.charAt(textIndex) == pattern.charAt(patternIndex)) {
                textIndex++;
                patternIndex++;
            } else if (patternIndex == 0) {
                textIndex++;
            } else {
                patternIndex = lps[patternIndex - 1];
            }

            if (patternIndex == patternLen) {
                //if atleast one match is found and want to stop matching further then simply do
                //return textIndex - patternLen;

                //this below logic will allow to find all matches in text
                System.out.println("Pattern matched at: " + (textIndex - patternLen));
                atleastOneMatchFound = true;
            }
        }
        if (!atleastOneMatchFound) {
            System.out.println("Pattern not matched");
        }
        //if pattern is not found
        //return -1;
    }

    public int editDistance_Recursion(String s1, String s2, int m, int n) {
        //https://leetcode.com/problems/edit-distance/description/
        //https://www.geeksforgeeks.org/edit-distance-dp-5/
        //explanation: https://youtu.be/XYi2-LPrwm4
        //https://youtu.be/MiqoA-yF-0M
        //if s1 is empty then whole s2 is to be inserted to convert s1 to s2
        if (m == 0) {
            return n;
        }

        //if s2 is empty then whole s1 is to be deleted to convert s1 to s2
        if (n == 0) {
            return m;
        }

        //if last char of two strings matches then just move ahead one char in both
        if (s1.charAt(m - 1) == s2.charAt(n - 1)) {
            return editDistance_Recursion(s1, s2, m - 1, n - 1);
        }

        //if the char doesn't matches then take the min of below 3
        int minOprn = Integer.MAX_VALUE;
        //insert
        //simulation, at m-th pos in s1 we have added a char from s2[n-th]
        //and move to next char in s2 by n - 1 but m-th char s1 is still need to
        //be matched with rest of chars in s2 so m remains on m-th char in s1
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m, n - 1));
        //delete
        //simulation, at m-th pos in s1 we have deleted a char from s1[m-th]
        //and move to next char in s1 by m - 1 but since we haven't matched n-th char
        //in s2 so n remains on n-th char in s2 to match with rest of chars in s1
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m - 1, n));
        //replace
        //simulation, char at n-th pos of s2 is put on m-th char of s1 that means
        //replacing m-th char of s1 with n-th char from s2. with this oprn we have
        //made m-th and n-th chars same as that of s2 so we can move to next indexes
        //m - 1 & n - 1 to check further
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m - 1, n - 1));
        return minOprn + 1;
    }

    public int editDistance_DP_Memoization(String s1, String s2) {
        //https://leetcode.com/problems/edit-distance/description/
        //https://www.geeksforgeeks.org/edit-distance-dp-5/
        //explanation: https://youtu.be/XYi2-LPrwm4
        //https://youtu.be/MiqoA-yF-0M
        int m = s1.length();
        int n = s2.length();
        int[][] memo = new int[m + 1][n + 1];

        //base cond
        //in order to convert s1 to s2
        //if s1 is "" (row == 0) and s2 is valid then we need to INSERT char in s1 to be s2
        //if s1 is valid but s2 is "" (col == 0) then we need to DELETE char in s1 to be s2
        for (int x = 0; x < m + 1; x++) {
            for (int y = 0; y < n + 1; y++) {
                if (x == 0) {
                    //insert each y-th char in string s1 that matches s2
                    memo[x][y] = y;
                } else if (y == 0) {
                    //delete each x-th char in string s1 to match s2 as "" string
                    memo[x][y] = x;
                }
            }
        }

        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (s1.charAt(x - 1) == s2.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1];
                } else {
                    //if the char doesn't matches then take the min of below 3
                    int minOprn = Integer.MAX_VALUE;
                    //insert
                    //simulation, at m-th pos in s1 we have added a char from s2[n-th]
                    //and move to next char in s2 by n - 1 but m-th char s1 is still need to
                    //be matched with rest of chars in s2 so m remains on m-th char in s1
                    minOprn = Math.min(minOprn, memo[x][y - 1]);
                    //delete
                    //simulation, at m-th pos in s1 we have deleted a char from s1[m-th]
                    //and move to next char in s1 by m - 1 but since we haven't matched n-th char
                    //in s2 so n remains on n-th char in s2 to match with rest of chars in s1
                    minOprn = Math.min(minOprn, memo[x - 1][y]);
                    //replace
                    //simulation, char at n-th pos of s2 is put on m-th char of s1 that means
                    //replacing m-th char of s1 with n-th char from s2. with this oprn we have
                    //made m-th and n-th chars same as that of s2 so we can move to next indexes
                    //m - 1 & n - 1 to check further
                    minOprn = Math.min(minOprn, memo[x - 1][y - 1]);
                    memo[x][y] = minOprn + 1;
                }
            }
        }
        return memo[m][n];
    }

    public void minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(int[] coins, int change) {
        //Explanation ; SomePracticeQuestion.minNoOfCoinsUsedForChange()
        int N = coins.length;
        int[][] memo = new int[N + 1][change + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < change + 1; y++) {

                //if no coins are available, we might need infinite-coins to make that change
                if (x == 0) {
                    memo[x][y] = Integer.MAX_VALUE - 1;
                }

                //if coins are available, but change we need to make is 0,
                //we need 0 coins
                if (y == 0) {
                    memo[x][y] = 0;
                }

                if (x == 1 && y >= 1) {
                    if (y % coins[x - 1] == 0) {
                        memo[x][y] = 1;
                    } else {
                        memo[x][y] = Integer.MAX_VALUE - 1;
                    }
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < change + 1; y++) {
                //if the amount of coins is greater than the change(col) we are making
                //then just leave that coin, and move from that without making any change in col
                if (coins[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    //two choices
                    //1. take that coin and adjust the change col with the amount of that coin
                    //and add 1 as picking up 1 coins in min
                    //2. don't take that coins and move to next coin, without making any adjustment in change col
                    memo[x][y] = Math.min(memo[x][y - coins[x - 1]] + 1,
                            memo[x - 1][y]);
                }
            }
        }

        //output
        System.out.println("Minimum coins required to make change: " + memo[N][change]);
    }

    public void coinChange_DP_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change/description/
        //https://leetcode.com/problems/coin-change/editorial/
        //1-D memory optimization on minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization()
        int n = coins.length;
        int[] memo = new int[amount + 1];
        Arrays.fill(memo, amount + 1);
        //change required for amount 0 is 0
        memo[0] = 0;
        for (int coinIndex = 0; coinIndex < n; coinIndex++) {
            for (int currAmount = 1; currAmount < amount + 1; currAmount++) {
                if (coins[coinIndex] <= currAmount) {
                    memo[currAmount] = Math.min(memo[currAmount], 1 + memo[currAmount - coins[coinIndex]]);
                }
            }
        }
        //output
        System.out.println("Minimum number of coins to make change for amount: "
                + (memo[amount] > amount ? -1 : memo[amount]));
    }

    private int coinChangeTwo_Recursive_Memoization_Helper(int[] coins, int index, int amount, Integer[][] memo) {

        //if the amount for change is already 0 or it has reached 0(by making change),
        //then there is 1 way we can make this change
        if (amount == 0) {
            return 1;
        }

        //if no coins available there, no way we can make any change
        //possibilities when amount for change is > 0 (thats why above if-block didn't work)
        //1. no coins are available to make change(== empty coins[])
        //so in the starting itself empty coins[] ==> index == coins.length == 0
        //2. we reached the index == coins.length meaning we ran out of coins to use
        //but amount is yet not 0 so we can't make any change further
        if (index == coins.length) {
            return 0;
        }

        if (memo[index][amount] != null) {
            return memo[index][amount];
        }

        //now we have two choices,
        //1. don't take the coin and don't adjust amount just move ahead for a new coin(== index + 1)
        int dontPick = coinChangeTwo_Recursive_Memoization_Helper(coins, index + 1, amount, memo);

        //2. take the coin (if coin value is less than or equal to amount we need to make change for)
        //and adjust the amount by this coin value but since coins are in infinte supply
        //then we can keep picking the same coins so keep index as it is
        int pick = 0;
        if (coins[index] <= amount) {
            pick = coinChangeTwo_Recursive_Memoization_Helper(coins, index, amount - coins[index], memo);
        }

        //total ways we can make change is ways if pick or dontPick the curr coin
        return memo[index][amount] = pick + dontPick;
    }

    public void coinChangeTwo_Recursive_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change-2/
        int n = coins.length;
        Integer[][] memo = new Integer[n + 1][amount + 1];
        int waysToMakeChange = coinChangeTwo_Recursive_Memoization_Helper(coins, 0, amount, memo);
        //output
        System.out.println("Ways to make change for given amount with infinite supply of coins: " + waysToMakeChange);
    }

    public void coinChangeTwo_DP_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change-2/
        int N = coins.length;
        int[][] memo = new int[N + 1][amount + 1];

        //base
        //if no coins are given coins[] is empty (==> N == 0)
        for (int col = 0; col < amount + 1; col++) {
            memo[0][col] = 0;
        }
        //if amount to make change for is already 0 (==> K == 0)
        for (int row = 0; row < N + 1; row++) {
            memo[row][0] = 1;
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < amount + 1; y++) {

                if (coins[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x][y - coins[x - 1]] + memo[x - 1][y];
                }
            }
        }

        System.out.println("Ways to make change for given amount with infinite supply of coins: " + memo[N][amount]);
    }

    public int knapSack01_Recursive_Memoization_Helper(
            int[] weight, int[] value, int W, int index, Integer[][] memo) {

        //if the knapsack capacity is already 0 or it has reached 0 or less
        //(by picking product of some weight[index])
        if (W <= 0) {
            return 0;
        }

        //if no products available there, no way we can pick anything in our knapsack
        //possibilities when knapsack has some capacity left > 0 (thats why above if-block didn't work)
        //1. no products are available to put in knapsack(== empty weight[] & value[])
        //so in the starting itself empty weight[] & value[] ==> index == value.length == 0
        //2. we reached the index == value.length meaning we ran out of products to pick
        if (index == value.length) {
            return 0;
        }

        if (memo[index][W] != null) {
            return memo[index][W];
        }

        //we have 2 choices to make if we want to get max value in given knapsack
        //of weight W
        //1. dont pick the curr value[index] of some weight[index] then its value
        //will not be considered and we move to next value(== index + 1)
        int dontPick = knapSack01_Recursive_Memoization_Helper(
                weight, value, W, index + 1, memo);

        //2. we choose to pick the curr value[index] of some weight[index] only
        //if the our curr knapsack have the capacity to hold this weight[index]
        //inside W(== weight[index] <= W, because if the weight of this product
        //is more than the knapSack capacity(W) then we must ignore it)
        //now we are picking this value[index] here means we have to consider its
        //value to be added and since we are adding that means knapsack capacity
        //must be reduced by this weight[index](== W - weight[index])
        int pick = 0;
        if (weight[index] <= W) {
            pick = value[index] + knapSack01_Recursive_Memoization_Helper(
                    weight, value, W - weight[index], index + 1, memo);
        }

        //we now have to take max of these 2 descision
        return Math.max(dontPick, pick);
    }

    public void knapSack01_Recursive_Memoization(int[] weight, int[] value, int W) {
        int n = weight.length;
        Integer[][] memo = new Integer[n + 1][W + 1];
        int maxValueInKnapsack = knapSack01_Recursive_Memoization_Helper(weight, value, W, 0, memo);
        //output
        System.out.println("The maximum profit with given knap sack: " + maxValueInKnapsack);
    }

    public void knapSack01_DP_Memoization(int[] weight, int[] value, int W) {

        int N = value.length;
        int[][] memo = new int[N + 1][W + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < W + 1; y++) {
                //No product row == N == 0
                //No knapSack capacity col == W == 0
                if (x == 0 || y == 0) {
                    memo[x][y] = 0;
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < W + 1; y++) {
                if (weight[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = Math.max(
                            value[x - 1] + memo[x - 1][y - weight[x - 1]],
                            memo[x - 1][y]);
                }
            }
        }

        System.out.println("The maximum profit with given knap sack: " + memo[N][W]);
    }

    public boolean subsetSum_Recursive_Memoization_Helper(int[] arr, int sum, int index, Boolean[][] memo) {

        //if the sum given is already 0 then we always have a subset from arr[]
        //whoose sum will be 0 i.e, empty subset {} subset sum == sum == 0
        //OR our sum has reached 0 by picking some values from arr[]
        //return true in both cases
        if (sum == 0) {
            return true;
        }

        //if no arr values available there, no way we add any value to our subset
        //possibilities when given sum is > 0 (thats why above if-block didn't work)
        //1. no arr values are available to put in subset(== empty arr[])
        //so in the starting itself empty arr[] ==> index == arr.length == 0
        //2. we reached the index == arr.length meaning we ran out of arr values
        //to pick and further we can't pick any value so we have to return false
        //because our sum didn't reach 0 but index reached its limit
        if (index == arr.length) {
            return false;
        }

        if (memo[index][sum] != null) {
            return memo[index][sum];
        }

        //here we have 2 choices to make
        //1. dont pick the curr arr value at index and move to next index(== index + 1)
        //and hence the sum will also not change
        boolean dontPick = subsetSum_Recursive_Memoization_Helper(arr, sum, index + 1, memo);

        //2. we pick the curr arr value at index, only if the curr arr value is
        //less than equals to the 'sum' we want to make and then move to next
        //index(== index + 1) and since we taking this curr arr value we must
        //reduce our sum by this arr value
        boolean pick = false;
        if (arr[index] <= sum) {
            pick = subsetSum_Recursive_Memoization_Helper(arr, sum - arr[index], index + 1, memo);
        }

        //from our 2 choices, if it possible to have some subset from arr[] that
        //sum upto given 'sum', we return that (OR any of the choice gives true
        //then return true)
        return memo[index][sum] = dontPick || pick;

    }

    public void subsetSum_Recursive_Memoization(int[] arr, int sum) {
        int n = arr.length;
        Boolean[][] memo = new Boolean[n + 1][sum + 1];
        boolean subsetSumPossible = subsetSum_Recursive_Memoization_Helper(arr, sum, 0, memo);
        //output
        System.out.println("Subset of array equal to given sum is possible: " + subsetSumPossible);
    }

    public void subsetSum_DP_Memoization(int[] arr, int sum) {

        int N = arr.length;
        boolean[][] memo = new boolean[N + 1][sum + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < sum + 1; y++) {
                //if array is empty then any given sum is not possible (except sum == 0)
                if (x == 0) {
                    memo[x][y] = false;
                }

                //if the given sum is just 0 then it can be prove even if the arrays is empty or full
                if (y == 0) {
                    memo[x][y] = true;
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < sum + 1; y++) {
                if (arr[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x - 1][y - arr[x - 1]] || memo[x - 1][y];
                }
            }
        }

        System.out.println("Subset of array equal to given sum is possible: " + memo[N][sum]);
    }

    public void equalsSumPartition_SubsetSum(int[] arr) {

        int arrSum = 0;
        for (int ele : arr) {
            arrSum += ele;
        }

        if (arrSum % 2 == 1) {
            //if odd no equal partition is possble for the given sum
            //arr = {1,5,5,11} arrSum = 22 == even can be divided into 2 half as {11}, {1,5,5}
            //if arrSum = 23 == odd no equal partition possible
            System.out.println("The equal sum partition for the given sum is not possible as sum of array is odd");
            return;
        }

        System.out.println("The equal sum partition for the given array is possible: ");
        //if arrSum == even then if we can prove the sum = arrSum/2 is possible
        //then other half of the sub set is by default will be equal to arrSum/2
        //arrSum = 22 == sum = arrSum/2 = 11 prove {11} then other half will be {1,5,5}
        subsetSum_DP_Memoization(arr, arrSum / 2);
    }

    private int longestCommonSubsequence_Recursive_Memoization_Helper(
            String s1, String s2, int index1, int index2, Integer[][] memo) {

        int n = s1.length();
        int m = s2.length();

        //return 0, incase if the given string s1 was already empty "" in that
        //case index1 == 0 == s1.length OR we have reached the end of s1 and no
        //chars are left and hence from here, LCS can't be possible with s2
        if (index1 >= n) {
            return 0;
        }

        //return 0, incase if the given string s2 was already empty "" in that
        //case index2 == 0 == s2.length OR we have reached the end of s2 and no
        //chars are left and hence from here, LCS can't be possible with s1
        if (index2 >= m) {
            return 0;
        }

        if (memo[index1][index2] != null) {
            return memo[index1][index2];
        }

        //here, chars at index1 & index2 of their respect string s1 & s2 are same
        //meaning there is one common subseq char that is present in both and currently
        //its length is '1' and further we move in boh the strings to check further
        if (s1.charAt(index1) == s2.charAt(index2)) {
            return memo[index1][index2] = 1 + longestCommonSubsequence_Recursive_Memoization_Helper(
                    s1, s2, index1 + 1, index2 + 1, memo);
        }

        //if above, chars at index1 & index2 don't match, we have 2 choices to
        //find any possible LCS, we can check the subseq of curr string s1 but
        //s2 is reduced by 1 char i.e, starting from next char at (index2 + 1)
        //OR
        //we can check the subseq of curr string s2 but s1 is reduced by 1 char
        //i.e, starting from next char at (index1 + 1)
        //choose the max LCS provided from any of the choices
        return memo[index1][index2] = Math.max(
                longestCommonSubsequence_Recursive_Memoization_Helper(
                        s1, s2, index1, index2 + 1, memo),
                longestCommonSubsequence_Recursive_Memoization_Helper(
                        s1, s2, index1 + 1, index2, memo));
    }

    public void longestCommonSubsequence_Recursive_Memoization(String s1, String s2) {

        int n = s1.length();
        int m = s2.length();

        Integer[][] memo = new Integer[n + 1][m + 1];

        int longestCommonSubseq = longestCommonSubsequence_Recursive_Memoization_Helper(
                s1, s2, 0, 0, memo);

        //output
        System.out.println("Longest common subseq (approach Recursive Memoization) : " + longestCommonSubseq);
    }

    public int longestCommonSubsequence_DP_Memoization(String s1, String s2, int m, int n) {
        //https://leetcode.com/problems/longest-common-subsequence
        int[][] memo = new int[m + 1][n + 1];

        //base cond
        //if s1 is empty and s2 is non-empty String no subseq length is possible
        //if s2 is empty and s1 is non-empty Strng no subseq length is possible
        for (int[] r : memo) {
            Arrays.fill(r, 0);
        }

        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (s1.charAt(x - 1) == s2.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x][y - 1], memo[x - 1][y]);
                }
            }
        }

        System.out.println("The longest common subsequence length for the given two string is: " + memo[m][n]);
        return memo[m][n];
    }

    public void uncrossedLines_DP_Memoization(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/uncrossed-lines/
        //this questions is also longestCommonSubsequence between two int arrays
        //completely based on longestCommonSubsequence_DP_Memoization
        int n = nums1.length;
        int m = nums2.length;

        int[][] memo = new int[n + 1][m + 1];
        //base cond is if there are no elements in nums1 then
        //there is no lines possible with nums2 similarly if there
        //no elements in nums2 there is no lines possible with nums1
        //so memo[r == 0][c] = 0 and memo[r][c == 0] = 0
        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < m + 1; y++) {
                if (nums1[x - 1] == nums2[y - 1]) {
                    //here adding 1 represents that one line between two arrays is made
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    //here we need to choose the max uncrossed lines possible
                    //out of all the combinations
                    memo[x][y] = Math.max(memo[x - 1][y], memo[x][y - 1]);
                }
            }
        }
        //output
        System.out.println("Max uncrossed lines possible with given two num arrays: " + memo[n][m]);
    }

    private int longestPallindromicSubsequence_Recursive_Memoization_Helper(
            String str, int startIndex, int endIndex, Integer[][] memo) {

        //if the both the ptrs startIndex & endIndex referreing to same char
        //for ex: 'a' then any single char is by default pallindrome, hence return 1
        if (startIndex == endIndex) {
            return 1;
        }

        //since both the ptrs, checks the char from start and end indexes and if
        //at any point in time endIndex goes below startIndex OR startIndex goes
        //ahead of endIndex return 0, as this is not a valid ptrs position
        if (endIndex < startIndex) {
            return 0;
        }

        if (memo[startIndex][endIndex] != null) {
            return memo[startIndex][endIndex];
        }

        //as with any basic pallindrome logic, we check if the starting char of string
        //matches with the ending char of the same str, then those 2 chars are considered
        //to be pallindrome and we move both ptrs repectively to check further
        //here also, if the char at startIndex matches with endIndex then 2 char
        //matches hence adding '2' and move ahead to next chars from both the ptrs
        //means (startIndex + 1) & (endIndex - 1)
        if (str.charAt(startIndex) == str.charAt(endIndex)) {
            return memo[startIndex][endIndex]
                    = 2 + longestPallindromicSubsequence_Recursive_Memoization_Helper(
                    str, startIndex + 1, endIndex - 1, memo);
        }

        //if the chars at startIndex & endIndex don't match, then we have to check the
        //subeq if we ignore the startIndex-th char and move to next (startIndex + 1)
        //while keeping endIndex same
        //AND vice verse condition
        //any of the options give the max value will be considere in longest subseq
        return memo[startIndex][endIndex] = Math.max(
                longestPallindromicSubsequence_Recursive_Memoization_Helper(
                        str, startIndex + 1, endIndex, memo),
                longestPallindromicSubsequence_Recursive_Memoization_Helper(
                        str, startIndex, endIndex - 1, memo));
    }

    public void longestPallindromicSubsequence_Recursive_Memoization(String s) {
        //https://leetcode.com/problems/longest-palindromic-subsequence/
        //explanation: https://youtu.be/M4pfB3G-YQc
        //based on recursive approach
        int n = s.length();
        Integer[][] memo = new Integer[n + 1][n + 1];
        int longestPallindromicSubseq = longestPallindromicSubsequence_Recursive_Memoization_Helper(
                s, 0, n - 1, memo);
        //output
        System.out.println("Longest pallindromic subsequence (approach Recursive Memoization) : "
                + longestPallindromicSubseq);
    }

    public void longestPallindromicSubsequence_DP_Memoization(String s) {
        //https://leetcode.com/problems/longest-palindromic-subsequence/
        //based on LONGEST COMMON SUBSEQUENCE, longestCommonSubsequence_DP_Memoization()
        int len = s.length();
        String rev = new StringBuilder(s).reverse().toString();
        int longestPallindromicSubseq = longestCommonSubsequence_DP_Memoization(s, rev, len, len);
        System.out.println("Longest pallindromic subsequences (approach based on LCS) : "
                + longestPallindromicSubseq);
    }

    public void maximizePallindromLengthFromSubsequence_DP_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/description/
        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/solutions/2193811/simple-java-dp-solution/
        //based on longestPallindromicSubsequence_DP_Memoization() & longestCommonSubsequence_DP_Memoization()
        int m = str1.length();
        int n = str2.length();

        int minStart = Integer.MAX_VALUE;
        int maxEnd = Integer.MIN_VALUE;

        //find the minStart index (==> starting index) of a char from str1
        //that also occurs in str2 as near as possible in i-th loop
        //find the maxEnd index (==> ending index) of a char from str2
        //that also occurs in str1 as far as possible in j-th loop
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (str1.charAt(i) == str2.charAt(j)) {
                    minStart = Math.min(minStart, i);
                    maxEnd = Math.max(maxEnd, j);
                }
            }
        }

        //when no char is common in str1 and str2
        if (minStart == Integer.MAX_VALUE) {
            System.out.println("Maximize pallindromic length from subsequences (based on LPS & LCS) : 0");
            return;
        }

        //from here it will same as LPS
        String word1 = str1.substring(minStart) + str2.substring(0, maxEnd + 1);
        String word2 = new StringBuilder(word1).reverse().toString();
        int len = word1.length();

        int longestPallindromicSubseq = longestCommonSubsequence_DP_Memoization(word1, word2, len, len);
        //output
        System.out.println("Maximize pallindromic length from subsequences (based on LPS & LCS) : "
                + longestPallindromicSubseq);
    }

    public void deleteOperationOfTwoStrings_DP_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/delete-operation-for-two-strings/
        /*
         how many char we need to delete or insert to make str1 transformed to str2
         //ex: str1 = "sea", str2 = "eat"
         longest common subseq = 2 ==> (ea)
         if both strings are combined = str1 + str2 = sea + eat ==> seaeat
         you can see in merged form of both strings the lcs come 2 times and if we
         remove these 2 occurences of lcs we will left with those chars
         that we either need to delete or insert
         seaeat - 2 * (ea) ==> st ==> delete(s) and insert(t)
         that's why len1 + len2 - 2 * lcs
         */
        int len1 = str1.length();
        int len2 = str2.length();
        int longestCommonSubseq = longestCommonSubsequence_DP_Memoization(str1, str2, len1, len2);
        int deleteOprn = len1 + len2 - 2 * longestCommonSubseq;
        System.out.println("Delete operation of two strings: "
                + deleteOprn);
    }

    private int longestRepeatingSubsequence_Recursion_Helper(String a, String b, int m, int n) {

        if (m == 0 || n == 0) {
            return 0;
        }

        if (a.charAt(m - 1) == b.charAt(n - 1) && m != n) {
            return longestRepeatingSubsequence_Recursion_Helper(a, b, m - 1, n - 1) + 1;
        }

        return Math.max(longestRepeatingSubsequence_Recursion_Helper(a, b, m, n - 1),
                longestRepeatingSubsequence_Recursion_Helper(a, b, m - 1, n));
    }

    public int longestRepeatingSubsequence_Recursion(String str, int N) {
        return longestRepeatingSubsequence_Recursion_Helper(str, str, N, N);
    }

    public void longestRepeatingSubsequence_DP_Memoization(String str) {

        int N = str.length();
        int[][] memo = new int[N + 1][N + 1];

        //base cond
        //if string length is 0 then no subseq is possible
        //here there is only one string so mem[row][col] where row == 0 OR col == 0 memo[row][col] = 0
        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < N + 1; y++) {
                if (str.charAt(x - 1) == str.charAt(y - 1) && x != y) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x][y - 1], memo[x - 1][y]);
                }
            }
        }

        //output:
        System.out.println("Longest repeating subsequence: " + memo[N][N]);
    }

    public void longestCommonSubstring_DP_Memoization(String a, String b) {
        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
        int m = a.length();
        int n = b.length();

        int[][] memo = new int[m + 1][n + 1];

        //base cond: if any of the string is empty then common subtring is not possible
        //x == 0 OR col == 0 : memo[0][0] = 0
        int maxLenSubstring = 0;
        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (a.charAt(x - 1) == b.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                    maxLenSubstring = Math.max(maxLenSubstring, memo[x][y]);
                } else {
                    memo[x][y] = 0;
                }
            }
        }

        //output:
        System.out.println("Longest common substring: " + maxLenSubstring);
    }

    public int maximumLengthOfPairChain_DP_Approach(int[][] pairs) {

        //https://leetcode.com/problems/maximum-length-of-pair-chain/solution/
        //.......................T: O(N^2)
        //.......................S: O(N)
        Arrays.sort(pairs, (a, b) -> a[0] - b[0]); //T: O(N.LogN)
        int N = pairs.length;
        int[] dp = new int[N];
        Arrays.fill(dp, 1);

        //T: O(N^2)
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[j][1] < pairs[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        int ans = 0;
        for (int x : dp) {
            ans = Math.max(ans, x);
        }

        //overall T: O(N^2) as, N^2 > N.LogN
        return ans;
    }

    public int maximumLengthOfPairChain_Greedy_Approach(int[][] pairs) {

        //OPTIMISED
        //https://leetcode.com/problems/maximum-length-of-pair-chain/solution/
        //........................T: O(N.LogN)
        //........................S: O(1)
        Arrays.sort(pairs, (a, b) -> a[1] - b[1]); //T: O(N.LogN)
        int prevEnd = Integer.MIN_VALUE;
        int chain = 0;
        for (int[] currPair : pairs) { //T: O(N)

            int currStart = currPair[0];
            int currEnd = currPair[1];

            if (prevEnd < currStart) {
                prevEnd = currEnd;
                chain++;
            }
        }

        //overall T: O(N.LogN) as, N.LogN > N
        return chain;
    }

    public int findBinomialCoefficient_Recursion(int n, int r) {

        //https://www.geeksforgeeks.org/binomial-coefficient-dp-9/
        //this approach have overlapping subproblems
        //Binomial coefficient : nCr formula = n!/r!(n - r)!
        //if r = 0 OR r = n, ans: 1 as,
        //r == 0: n!/0!.(n - 0)! => n!/n! => 1
        //r == n: n!/n!.(n - n)! => n!/n! => 1
        //0! = 1
        if (r > n) {
            return 0;
        }

        if (r == 0 || r == n) {
            return 1;
        }

        return findBinomialCoefficient_Recursion(n - 1, r - 1) + findBinomialCoefficient_Recursion(n - 1, r);
    }

    public void findBinomialCoefficient_DP_Memoization(int n, int r) {

        int[][] memo = new int[n + 1][r + 1];
        //base cond
        for (int x = 0; x < n + 1; x++) {
            for (int y = 0; y < r + 1; y++) {

                if (y > x) {
                    memo[x][y] = 0;
                } else if (y == 0 || y == x) {
                    memo[x][y] = 1;
                }
            }
        }

        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < r + 1; y++) {
                memo[x][y] = memo[x - 1][y - 1] + memo[x - 1][y];
            }
        }

        //output:
        System.out.println("Binomial coefficient (nCr) DP way: " + memo[n][r]);
    }

    public int friendsPairingProblem_Recursion(int n) {

        //https://www.geeksforgeeks.org/friends-pairing-problem/
        //if no friend is there nothing is possible
        if (n == 0) {
            return 0;
        }

        //if 1 friend is avaialbe he can only remain single
        if (n == 1) {
            return 1;
        }

        //if 2 friends are available there can be two ways
        //friend can remain single: {2} Or can be be paired as {1,2}
        if (n == 2) {
            return 2;
        }

        //if above cond doesn't fulfil we have two choices
        //1. ether we can remain single fun(n-1)
        //2. Or we can keep ourself and check others for pair: (n-1)*fun(n-2)
        return friendsPairingProblem_Recursion(n - 1) + (n - 1) * friendsPairingProblem_Recursion(n - 2);

    }

    public void friendsPairingProblem_DP_Memoization(int n) {

        //.............................T: O(N)
        //.............................S: O(N)
        //https://www.geeksforgeeks.org/friends-pairing-problem/
        int[] memo = new int[n + 1];
        //base cond
        memo[0] = 0;
        memo[1] = 1;
        memo[2] = 2;

        for (int i = 3; i < n + 1; i++) {
            memo[i] = memo[i - 1] + (i - 1) * memo[i - 2];
        }

        //output
        System.out.println("No. ways freinds can be paired: " + memo[n]);
    }

    public void friendsPairingProblem(int n) {

        //.............................T: O(N)
        //.............................S: O(1)
        //OPTIMISED
        //https://www.geeksforgeeks.org/friends-pairing-problem/
        if (n <= 2) {
            System.out.println("No. ways freinds can be paired: " + n);
            return;
        }

        int a = 1;
        int b = 2;
        int c = 0;

        for (int i = 3; i <= n; i++) {

            c = b + (i - 1) * a;
            a = b;
            b = c;
        }

        //output
        System.out.println("No. ways freinds can be paired: " + c);
    }

    public int sticklerThief_Recursive_Memoization_Helper(int[] houses, int index, Integer[] memo) {

        int n = houses.length;

        //return 0 as profit because the index reached the end of houses[] and
        //thief don't have any more houses left to steal from
        if (index >= n) {
            return 0;
        }

        if (memo[index] != null) {
            return memo[index];
        }

        //2 choices we can make here
        //1. don't pick the house @index to steal and move to next house(==> index + 1)
        int maxProfit = sticklerThief_Recursive_Memoization_Helper(
                houses, index + 1, memo);

        //2. pick the house @index to steal from and the amount it has will also
        //be considered into maxProfit BUT as restricted once we steal from a house
        //we can't steal from its next adjacent house but alternate house (==> index + 2)
        maxProfit = Math.max(maxProfit,
                houses[index] + sticklerThief_Recursive_Memoization_Helper(houses, index + 2, memo));

        return memo[index] = maxProfit;
    }

    public void sticklerThief_Recursive_Memoization(int[] houses) {
        //https://leetcode.com/problems/house-robber
        int n = houses.length;
        Integer[] memo = new Integer[n + 1];
        int maxProfit = sticklerThief_Recursive_Memoization_Helper(houses, 0, memo);
        //output
        System.out.println("Maximum profit thief can pick from alternate houses (approach Recursive Memoization): "
                + maxProfit);
    }

    public int sticklerThief_DP_Memoization(int[] houses) {
        //https://leetcode.com/problems/house-robber
        int n = houses.length;
        int[] memo = new int[n + 1];

        //base cond
        memo[0] = 0; //if no house is available
        memo[1] = houses[0]; //if only one house is available

        for (int i = 2; i < memo.length; i++) {
            memo[i] = Math.max(memo[i - 1], houses[i - 1] + memo[i - 2]);
        }

        //output;
        return memo[n];
    }

    public void sticklerThiefTwo_DP_Memoization(int[] houses) {
        //https://leetcode.com/problems/house-robber-ii/
        int n = houses.length;
        int result = Integer.MIN_VALUE;

        int[] currHouses = new int[n - 1];
        //house[0] to house[n - 2] in which last house (n - 1)-th will not be covered
        for (int i = 0; i < n - 1; i++) {
            currHouses[i] = houses[i];
        }

        result = Math.max(result, sticklerThief_DP_Memoization(currHouses));

        currHouses = new int[n];
        //house[1] to house[n - 1] in which first house(0-th) will not be covered
        for (int i = 1; i < n; i++) {
            currHouses[i] = houses[i];
        }

        result = Math.max(result, sticklerThief_DP_Memoization(currHouses));

        //output;
        System.out.println("The maximum amount stickler thief can pick from alternate but circular houses: "
                + result);
    }

    int longestIncreasingSubsequence_LongestSeqLength;

    private int longestIncreasingSubsequence_Recursion_Helper(int[] arr, int n) {

        //if there is one element in arr then the longest seq length is just one
        if (n == 1) {
            return 1;
        }

        int res = 0;
        int maxLengthHere = 1;

        for (int i = 1; i < n; i++) {

            res = longestIncreasingSubsequence_Recursion_Helper(arr, i);
            if (arr[i - 1] < arr[n - 1] && res + 1 > maxLengthHere) {
                maxLengthHere = res + 1;
            }
        }

        longestIncreasingSubsequence_LongestSeqLength = Math.max(
                longestIncreasingSubsequence_LongestSeqLength,
                maxLengthHere);

        return maxLengthHere;
    }

    public int longestIncreasingSubsequence_Recursion(int[] arr, int n) {
        //if array is empty no longest incr seq is possible hence -1,
        //otherwise atleast element will be considered as incr seq hence 1
        longestIncreasingSubsequence_LongestSeqLength = n == 0 ? -1 : 1;
        longestIncreasingSubsequence_Recursion_Helper(arr, n);
        return longestIncreasingSubsequence_LongestSeqLength;
    }

    public void longestIncreasingSubsequence_DP_Memoization(int[] arr, int n) {
        //https://leetcode.com/problems/longest-increasing-subsequence
        //https://leetcode.com/problems/number-of-longest-increasing-subsequence
        //if array is empty, no longest incr seq is possible hence -1,
        //otherwise atleast one element will be considered as incr seq hence 1
        int maxLengthLongestIncSubseq = n == 0 ? -1 : 1;
        //memo[i] will hold the longest incr subseq for ith arr[i] calculated
        int[] memo = new int[n];
        //base cond
        //a single num is also an increasing seq, that's why 1
        Arrays.fill(memo, 1);

        for (int i = 1; i < n; i++) {
            //we iterate over subarray [0 to i]
            for (int j = 0; j < i; j++) {
                //j loop will run over the above subarray
                //while looping in j will check what all
                //arr[j] are lesser than arr[i] (i.e arr[i] > arr[j])
                //also need to have a check like, at any subarray if memo[i]
                //already have a longest incr length memo[j] should not modify that
                //only when memo[i] <= memo[j]
                if (arr[i] > arr[j] && memo[i] <= memo[j]) {
                    memo[i] = memo[j] + 1;
                }
            }
            maxLengthLongestIncSubseq = Math.max(maxLengthLongestIncSubseq, memo[i]);
        }

        //output:
        System.out.println("DP Longest inc subseq of the given array is: " + maxLengthLongestIncSubseq);
    }

    private int longestIncreasingSubsequence2_DP_Memoization_BinarySearchHelper(
            int[] memoLISAsIndex, int val) {

        //with this binary search we try to find a mid-index whose value is
        //STRICTLY SMALLER than given val
        int n = memoLISAsIndex.length;

        int start = 0;
        int end = n - 1;

        //initial value, if there is no smaller value in memoLISAsIndex which is
        //STRICTLY SMALLER than 'val'
        int indexOfSmallerVal = -1;

        while (end >= start) {

            //mid represents a index, where we are assuming that value at this
            //'mid' index is STRICTLY SMALLER than 'val'
            int mid = start + (end - start) / 2;

            //here, if the value at 'mid' ==> memoLISAsIndex[mid] is STRICTLY
            //SMALLER than 'val' then this 'mid' is a valid index hence we store
            //it in 'indexOfSmallerVal' from here, we know that 'mid' is valid
            //but we will also try to check if any higher 'mid' index also have
            //value smaller than 'val' beacuse as we know index of memoLISAsIndex[]
            //represents LIS so higher 'mid' index satisfying the cond below will
            //give a LONGEST INCR SUBSEQ so for that we move search space to right-side
            if (memoLISAsIndex[mid] < val) {

                indexOfSmallerVal = mid;
                start = mid + 1;
            } else {
                //here, we know the 'mid' index is not valid yet, we still need to
                //find a 'mid' value that has value STRICTLY SMALLER than 'val'
                //but see here if this curr 'mid' is failing cond
                //(==> memoLISAsIndex[mid] < val) means any higher 'mid' index
                //will also fail, so we move search space to left-side
                end = mid - 1;
            }
        }

        return indexOfSmallerVal;
    }

    public void longestIncreasingSubsequence2_DP_Memoization(int[] arr, int n) {
        //https://leetcode.com/problems/longest-increasing-subsequence
        //https://leetcode.com/problems/number-of-longest-increasing-subsequence
        //based on BINARY SEARCH
        int maxLengthLongestIncSubseq = n == 0 ? 0 : 1;

        //here, memo[] will store the previous smaller value
        //such that val1 < val2 < val3 < prevVal4 < ... < currValn
        //index of memo[] will represent the length of the LIS and its associated
        //value tells us the prev smaller value so that any curr val should be
        //STRICTLY GREATER than memoLISAsIndex[i] < currVal
        int[] memoLISAsIndex = new int[n + 1];

        //initially, each memo[] index/LIS have a MAX smaller value associated
        Arrays.fill(memoLISAsIndex, Integer.MAX_VALUE);

        //except the memo[] index/ LIS ==> 0, this means that a longest incr subseq
        //of length 0 which basically means empty arr[], will have the MIN value
        //as prev smaller val such that MIN < currVal
        memoLISAsIndex[0] = Integer.MIN_VALUE;

        for (int val : arr) {

            //indexOfSmallerVal represents the index of a value in memoLISAsIndex[]
            //where memoLISAsIndex[indexOfSmallerVal] < val
            int indexOfSmallerVal = longestIncreasingSubsequence2_DP_Memoization_BinarySearchHelper(
                    memoLISAsIndex, val);

            //now, if this curr val is actually of STRICTLY INCREASING seq then
            //the length of LIS will increase by +1 from prev length denoted as
            //index ==> indexOfSmallerVal
            //ex: curr val = 7
            //and, indexOfSmallerVal returned as 5
            //which means there must have been this TRUE cond: memoLISAsIndex[indexOfSmallerVal] < val
            //let say, memoLISAsIndex[indexOfSmallerVal] < val ==> 6 < 7
            //indexOfSmallerVal = 5 tells that there is LIS of length '5' whose prev/last val is '6'
            //now if the subeq is added with val = 7 the length of LIS should increase to '5' +1
            //==> indexOfSmallerVal + 1
            //also, this curr val will now be treated as the prev/last val of the LIS of
            //length (indexOfSmallerVal + 1) hence at index ==> (indexOfSmallerVal + 1)
            if (indexOfSmallerVal != -1) {

                maxLengthLongestIncSubseq = Math.max(maxLengthLongestIncSubseq, indexOfSmallerVal + 1);
                memoLISAsIndex[indexOfSmallerVal + 1] = val;
            }
        }

        //output:
        System.out.println("Longest incr subseq of the given array is (approach Binary Search): " + maxLengthLongestIncSubseq);
    }

    public void maxSumIncreasingSubsequence_DP_Memoization(int[] arr) {
        //...............................T: O(N ^ 2), checking all subseq
        //...............................T: O(N), memo[] space
        //https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/
        //https://practice.geeksforgeeks.org/problems/maximum-sum-increasing-subsequence4749/1/
        //approach similar to longestIncreasingSubsequence_DP_Memoization()
        int n = arr.length;
        //if array is empty no longest incr seq is possible hence -1,
        //otherwise atleast one element will be considered as incr seq hence 1
        int maxSumIncSubseq = n == 0 ? -1 : 1;
        //memo[i] will hold the max sum incr subseq for ith arr[i] calculated
        int[] memoSum = new int[n];
        //base cond
        //a single num can be a max sum incr seq, that's why arr[i]
        for (int i = 0; i < n; i++) {
            memoSum[i] = arr[i];
        }

        for (int i = 1; i < n; i++) {
            //we iterate over subarray [0 to i]
            for (int j = 0; j < i; j++) {
                //j loop will run over the above subarray
                //while looping in j will check what all
                //arr[j] are lesser than arr[i] (i.e arr[i] > arr[j])
                //also need to have a check like, at any subarray if memo[i]
                //already have a max sum, memo[j] should not modify that
                //only when memo[i] <= memo[j] + arr[i] that means max sum till
                //memo[j] plus value of arr[i] makes the max sum curr max sum at memo[i]
                if (arr[i] > arr[j] && memoSum[i] <= memoSum[j] + arr[i]) {
                    memoSum[i] = memoSum[j] + arr[i];
                }
            }
            maxSumIncSubseq = Math.max(maxSumIncSubseq, memoSum[i]);
        }

        //output:
        System.out.println("DP Max sum incr subseq of the given array is: " + maxSumIncSubseq);
    }

    public void maximumLengthOfRepeatedSubarray_DP_Memoization(int[] arr1, int[] arr2) {

        //Approach is similar to longest common substring
        int m = arr1.length;
        int n = arr2.length;
        int[][] memo = new int[m + 1][n + 1];

        //base cond:
        //arr1 is empty no repeated values can be checked arr2
        //similarly arr2 is empty no repeated values can be checked with arr1
        //x == 0, col == 0 will 0
        int maxLen = 0;
        for (int x = 1; x < m + 1; x++) {

            for (int y = 1; y < n + 1; y++) {

                if (arr1[x - 1] == arr2[y - 1]) {

                    memo[x][y] = memo[x - 1][y - 1] + 1;
                    maxLen = Math.max(maxLen, memo[x][y]);

                } else {

                    memo[x][y] = 0;
                }
            }
        }

        //output
        System.out.println("Maximum length of repeated subarray: " + maxLen);
    }

    public int minInsertsToMakeStringPallindrome_DP_Memoization(String str) {
        //https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome
        //ref: SomePracticeQuestion.minNoOfInsertionInStringToMakeItPallindrome()
        String revString = new StringBuilder(str).reverse().toString();
        int len = str.length();
        int longestCommonSubseq = longestCommonSubsequence_DP_Memoization(str, revString, len, len);
        int inserts = len - longestCommonSubseq;
        //output
        System.out.println("Min inserts to make the string pallindrome: " + inserts);
        return inserts;
    }

    public void minDeletesToMakeStringPallindrome_DP_Memoization(String str) {
        //ref: SomePracticeQuestion.minNoOfDeletionInStringToMakeItPallindrome_LPSBasedApproach()
        int deletes = minInsertsToMakeStringPallindrome_DP_Memoization(str);
        //output
        System.out.println("Min deletes to make the string pallindrome: " + deletes);
    }

    public void paintFence_DP_Memoization(int fence, int paints) {
        //https://leetcode.com/problems/paint-fence/description/
        //https://www.geeksforgeeks.org/painting-fence-algorithm/
        //explanation: https://youtu.be/ju8vrEAsa3Q
        long ways = paints;
        int mod = 1000000007;

        int paintSame = 0;
        int paintDifferent = paints;

        for (int i = 2; i <= fence; i++) {
            paintSame = paintDifferent;

            paintDifferent = (int) ways * (paints - 1);
            paintDifferent %= mod;

            ways = (paintSame + paintDifferent) % mod;
        }
        //output
        System.out.println("No of ways to paint fences such that adjacent fence are painted with same color: "
                + ways);
    }

    private boolean frogJump_Recursive_Memoization_Helper(
            int[] stones, Map<Integer, Integer> stonesPositionToIndex,
            int index, int prevJump, Boolean[][] memo) {

        int n = stones.length;

        //as we started from index = 0 where the frog started at stone-position
        //of stones[index] == 0, now here we have reached to index = n - 1 to a
        //stone-position of stones[n - 1] means there is a possible path hence
        //return true
        if (index >= n - 1) {
            return true;
        }

        if (memo[index][prevJump] != null) {
            return memo[index][prevJump];
        }

        //initially, we are assuming that we don't have any path
        boolean isPossibleToReachEnd = false;

        //jump made from prev stone to reach the curr stone, we can make the
        //next jump to reach next stone-position based on the prev jump, i.e,
        //1. prevJump - 1
        //2. prevJump
        //3. prevJump + 1
        for (int nextJump = prevJump - 1; nextJump <= prevJump + 1; nextJump++) {

            //skip, if nextJump is -ve, that actually means to go backwards,
            //which is not allowed
            //skip, if the nextJump is 0, that actually means staying at same
            //position
            if (nextJump <= 0) {
                continue;
            }

            //frog is currently standing on a stone at stone-position
            //@stones[index] from here frog needs to move forward by
            //making some jump(==> nextJump) BUT the next position should
            //be a valid stone-position
            int nextStonePosition = stones[index] + nextJump;

            //skip, if the frog jumping to next position is not valid stone-position
            if (!stonesPositionToIndex.containsKey(nextStonePosition)) {
                continue;
            }

            isPossibleToReachEnd |= frogJump_Recursive_Memoization_Helper(
                    stones, stonesPositionToIndex,
                    //frog can now make jump to stone at stone-position
                    //'nextStonePosition' so moving to that stone index
                    //at stonesPositionToIndex.get(nextStonePosition)
                    stonesPositionToIndex.get(nextStonePosition),
                    //jump we make here will be the prevJump next call
                    //for calculating frog's next jump
                    nextJump,
                    memo);

        }

        return memo[index][prevJump] = isPossibleToReachEnd;
    }

    public void frogJump_Recursive_Memoization(int[] stones) {
        //https://leetcode.com/problems/frog-jump/description/
        int n = stones.length;
        Map<Integer, Integer> stonesPositionToIndex = new HashMap<>();

        for (int i = 0; i < n; i++) {
            stonesPositionToIndex.put(stones[i], i);
        }

        Boolean[][] memo = new Boolean[n + 1][n + 1];

        boolean isPossibleToReachEnd = frogJump_Recursive_Memoization_Helper(
                stones, stonesPositionToIndex, 0, 0, memo);

        //output
        System.out.println("Frog can reach the end of river (approach Recursive Memoization) : "
                + isPossibleToReachEnd);
    }

    private int decodeWays_Recursive_Memoization_Helper(
            int index, String str, Integer[] memo) {

        int n = str.length();
        //if we have successfully crossed the string
        if (index >= n) {
            return 1;
        }

        //if we already cached the values previously retunn that
        if (memo[index] != null) {
            return memo[index];
        }

        int ways = 0;

        //form a single-digit number mapped to [A == 1 to I == 9]
        int singleDigitNum = str.charAt(index) - '0';

        //form a two-digit number mapped to [J == 10 to Z == 26]
        int twoDigitNum = 0;
        //we can form two digit num only when we are allowed to take (index + 1)th char
        //it should be less than n
        if (index + 1 < n) {
            //this two digit num should be formed with the index-th char which is singleDigitNum
            twoDigitNum = singleDigitNum * 10 + (str.charAt(index + 1) - '0');
        }

        //we have two decision to make to decode our nums in str
        //1. we can take the first single digit that is mapped to char[A == 1 to I == 9]
        if (singleDigitNum > 0) {
            //if we are considering just a single digit, then we simply move to
            //next index val(index + 1)
            ways += decodeWays_Recursive_Memoization_Helper(index + 1, str, memo);
        }

        //2. we can take first two digit num that is mapped to char[J == 10 to Z == 26]
        //this will also handle cases like "06" because "06" as int is not two-digit
        //it will be number = 6
        if (twoDigitNum >= 10 && twoDigitNum <= 26) {
            //if we are considering first two digit, that means we took index-th
            //& (index + 1)-th char then we simply move to (index + 2)
            ways += decodeWays_Recursive_Memoization_Helper(index + 2, str, memo);
        }

        //cache the values
        return memo[index] = ways;
    }

    public void decodeWays_Recursive_Memoization(String str) {
        //https://leetcode.com/problems/decode-ways/
        //explanation: https://youtu.be/N5i7ySYQcgM
        int n = str.length();
        Integer[] memo = new Integer[n];
        int ways = decodeWays_Recursive_Memoization_Helper(0, str, memo);
        //output
        System.out.println("Ways to decode string into alphabets(Recursive-Memoization): " + ways);
    }

    public void decodeWays_DP_Memoization(String str) {
        //https://leetcode.com/problems/decode-ways/
        //explanation: https://youtu.be/N5i7ySYQcgM
        int n = str.length();
        Map<Integer, Integer> cache = new HashMap<>();
        cache.put(n, 1);

        for (int index = n - 1; index >= 0; index--) {
            int singleDigitNum = str.charAt(index) - '0';
            int twoDigitNum = 0;
            //we can form two digit num only when we are allowed to take (index + 1)th char
            //it should be less than n
            if (index + 1 < n) {
                //this two digit num should be formed with the index-th char which is singleDigitNum
                twoDigitNum = singleDigitNum * 10 + (str.charAt(index + 1) - '0');
            }

            int ways = 0;

            if (singleDigitNum > 0) {
                ways = cache.getOrDefault(index, 0) + cache.getOrDefault(index + 1, 0);
            }

            if (twoDigitNum >= 10 && twoDigitNum <= 26) {
                ways = cache.getOrDefault(index, 0) + cache.getOrDefault(index + 2, 0);
            }

            cache.put(index, ways);
        }
        //output
        System.out.println("Ways to decode string into alphabets(DP): " + cache.getOrDefault(0, 0));
    }

    private int fillingBooksInShelves_DP_Recusrive_Memoization_Helper(
            int[][] books, int shelfWidth, int index, Integer[] memo) {

        if (index >= books.length) {
            return 0;
        }

        if (memo[index] != null) {
            return memo[index];
        }

        int currWidth = 0;
        int maxHeight = 0;
        int minHeight = Integer.MAX_VALUE;

        //this approach tries to put a single book in its own shelf. as the loop
        //increases it tries to include more books in one shelf (as long as its
        //under shelfWidth) and while trying to put more books in some shelfs
        //we minimize the height
        //ex [[1,1],[3,1]], shelfWidth = 4
        //index  = 0 it will try to put book[1,1] in its own shelf
        //maxHeight = 1, currWidth = 1 since its under shelfWidth
        //we can move to i + 1 book to put it in another shelf
        //index = 1, it will try to put book[3,1] in its own shelf
        //maxHeight = 1, currWidth = 3 since its under shelfWidth
        //by going to another i + 1 index it will go to base cond(>= n) that will ret 0
        //maxHeight + 0 = 1 + 0 = 1 so minHeight for book[3,1] = 1 now this one
        //recurse back to previous shelf
        //back to book[1,1] maxHeight = 1 + minHeight[3,1] == 1 ==> 2
        //this states that if we try to put each book in its own shelf that would take
        //the max height of our book selves.
        //form here, we will try to add more books in curr shelf here we already have
        //in 1st shelf[1,1] now we put book[3,1] in this shelve
        //currWidth += [3,1] ==> 1 + 3 = 4 which is still equal to shelfWidth(OK!!)
        //maxHeight = max(book[1,1], book[3,1]) = 1 only. This states that
        //now single shelf has book [1,1][3,1] having width <= shelfWidth and maxHeight = 1
        for (int i = index; i < books.length; i++) {
            currWidth += books[i][0];
            maxHeight = Math.max(maxHeight, books[i][1]);

            if (currWidth > shelfWidth) {
                break;
            }

            minHeight = Math.min(minHeight,
                    maxHeight + fillingBooksInShelves_DP_Recusrive_Memoization_Helper(
                            books, shelfWidth, i + 1, memo));

        }
        return memo[index] = minHeight;
    }

    public void fillingBooksInShelves_DP_Recusrive_Memoization(int[][] books, int shelfWidth) {
        //https://leetcode.com/problems/filling-bookcase-shelves/
        //https://leetcode.com/problems/filling-bookcase-shelves/discuss/2278530/Split-and-CHILL
        Integer[] memo = new Integer[books.length + 1];
        int minHeight = fillingBooksInShelves_DP_Recusrive_Memoization_Helper(books, shelfWidth, 0, memo);
        //output
        System.out.println("Min possible height: " + minHeight);
    }

    private int perfectSquares_DP_Recursive_Memoization_Helper(int n, Integer[] memo) {
        //if n == 0, there are 0 perfect squares that sums upto 0
        if (n == 0) {
            return n; // n == 0
        }

        if (memo[n] != null) {
            return memo[n];
        }

        int ways = Integer.MAX_VALUE;

        //this is the branching factor.
        //let say n == 12, sqrt(n) = 3.4.. roundOff = 3
        //Now this 3 * 3 == 9 and if we go one more like for 4 ==> 4 * 4 = 16
        //that means this 16 > n, we can't use 4 as perfect sqaures sums because
        //it always be greater than n
        int sqrRootN = (int) Math.sqrt(n);

        for (int branch = 1; branch <= sqrRootN; branch++) {
            int currPerfectSqr = branch * branch;
            ways = Math.min(ways,
                    1 + perfectSquares_DP_Recursive_Memoization_Helper(n - currPerfectSqr, memo));
        }

        return memo[n] = ways;
    }

    public void perfectSquares_DP_Recursive_Memoization(int n) {
        //........................T: O(n * sqrt(n)), sqrt(n) is the branching factor for
        //each n in the decision tree
        //https://leetcode.com/problems/perfect-squares/submissions/
        //explanation: https://youtu.be/HLZLwjzIVGo
        /*
        intuition
        n = 12
        output = 4 + 4 + 4 = 12 (4 is perfect sqr of 2)

        val     perfect sqrs
        1           1 * 1 = 1
        2           2 * 2 = 4
        3           3 * 3 = 9
        4           4 * 4 = 16

        here for n = 12, we can only consider perfect sqr till val = 3 because
        perfect sqr of val = 4 is 16 which is more than n itself and we need those
        perfect sqrs that sums up to 'n' thats why we need to take sqrt(n) to pick
        vals for our perfect sqr

        here we will pick vals whoose perfect sqr should be reduced from curr 'n'
        and same process will be done in each recursion until we reach n == 0

         */
        Integer[] memo = new Integer[n + 1];
        int perfectSquaresCount = perfectSquares_DP_Recursive_Memoization_Helper(n, memo);
        //output
        System.out.println("Count of perfect squares that will sum up to n: " + perfectSquaresCount);
    }

    public void perfectSquares_DP_Memoization(int n) {
        //........................T: O(n * sqrt(n)), sqrt(n) is the branching factor for
        //each n in the decision tree
        //https://leetcode.com/problems/perfect-squares/submissions/
        //explanation: https://youtu.be/HLZLwjzIVGo
        //<n, currPerfectSquaresWays>
        Map<Integer, Integer> cache = new HashMap<>();
        //if n == 0, 0 are the ways to have sum of perfect squares
        cache.put(0, 0);

        for (int nth = 1; nth <= n; nth++) {
            for (int i = 1; i <= nth; i++) {
                int currPerfectSqr = i * i;
                if (nth - currPerfectSqr < 0) {
                    break;
                }
                int currPerfectSquaresWaysToN = Math.min(
                        cache.getOrDefault(nth, Integer.MAX_VALUE),
                        1 + cache.getOrDefault(nth - currPerfectSqr, Integer.MAX_VALUE));
                cache.put(nth, currPerfectSquaresWaysToN);
            }
        }
        //output
        System.out.println("Count of perfect squares that will sum up to n: " + cache.get(n));
    }

    private int outOfBoundaryPaths_DP_Recursive_Memoization_Helper(
            int m, int n, int maxMoves, int row, int col, Integer[][][] memo) {

        int mod = 1000000007;

        //return 1, as we need to count out-of-boundary-paths and here our curr
        //row & col 'isOutOfBounds'
        if (row < 0 || row >= m || col < 0 || col >= n) {
            return 1;
        }

        //return 0, as above if() cond didn't meet, means we haven't gone out-of-boundary
        //yet but our 'maxMoves' to move in the grid is now 0 hence no movement
        if (maxMoves <= 0) {
            return 0;
        }

        if (memo[row][col][maxMoves] != null) {
            return memo[row][col][maxMoves];
        }

        int outOfBoundaryPathCount = 0;

        //UP
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row - 1, col, memo)) % mod;
        //DOWN
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row + 1, col, memo)) % mod;
        //LEFT
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row, col - 1, memo)) % mod;
        //RIGHT
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row, col + 1, memo)) % mod;

        return memo[row][col][maxMoves] = outOfBoundaryPathCount;
    }

    public void outOfBoundaryPaths_DP_Recursive_Memoization(int m, int n, int maxMoves, int startRow, int startCol) {
        //https://leetcode.com/problems/out-of-boundary-paths/
        Integer[][][] memo = new Integer[m][n][maxMoves + 1];
        int paths = outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves, startRow, startCol, memo);
        //output:
        System.out.println("Out of boundary paths:  " + paths);
    }

    private int frogJump_Recursive_Helper(int[] heights, int index) {

        //if no heights is given the energy consumed for the frog
        //from jumping nth height to n-1th or n-2th height becomes 0
        //because there is no such heights
        //also we are coming back from nth step to 0th step
        if (index <= 0) {
            return 0;
        }

        //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
        int oneStepBack = Math.abs(heights[index] - heights[index - 1])
                + frogJump_Recursive_Helper(heights, index - 1);

        //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
        //default value is Int.MAX because this time frog has to jump 2 steps back
        //and possibly n - 2 steps doesn't exist
        int twoStepBack = Integer.MAX_VALUE;
        //if it is possible to go n - 2 steps back then only calculate the energy consumed
        if (index - 2 >= 0) {
            twoStepBack = Math.abs(heights[index] - heights[index - 2])
                    + frogJump_Recursive_Helper(heights, index - 2);
        }

        //return the min energy consumed from both the steps
        return Math.min(oneStepBack, twoStepBack);
    }

    private int frogJump_Recursive_Memoization(int[] heights, int index, Map<Integer, Integer> cache) {

        //if no heights is given the energy consumed for the frog
        //from jumping nth height to n-1th or n-2th height becomes 0
        //because there is no such heights
        //also we are coming back from nth step to 0th step
        if (index <= 0) {
            return 0;
        }

        if (cache.containsKey(index)) {
            return cache.get(index);
        }

        //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
        int oneStepBack = Math.abs(heights[index] - heights[index - 1])
                + frogJump_Recursive_Helper(heights, index - 1);

        //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
        //default value is Int.MAX because this time frog has to jump 2 steps back
        //and possibly n - 2 steps doesn't exist
        int twoStepBack = Integer.MAX_VALUE;
        //if it is possible to go n - 2 steps back then only calculate the energy consumed
        if (index - 2 >= 0) {
            twoStepBack = Math.abs(heights[index] - heights[index - 2])
                    + frogJump_Recursive_Helper(heights, index - 2);
        }

        cache.put(index, Math.min(oneStepBack, twoStepBack));
        //return the min energy consumed from both the steps
        return Math.min(oneStepBack, twoStepBack);
    }

    public void frogJump_Recursive_And_Memoization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int recursiveFrogJump = frogJump_Recursive_Helper(heights, n - 1);

        Map<Integer, Integer> cache = new HashMap<>();
        int recursiveMemoFrogJump = frogJump_Recursive_Memoization(heights, n - 1, cache);

        System.out.println("Frog jump min energy consumed(Recusrive): " + recursiveFrogJump);
        System.out.println("Frog jump min energy consumed(Recusrive Memoization): " + recursiveMemoFrogJump);
    }

    public void frogJump_DP_Memoization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int[] memo = new int[n];
        memo[0] = 0;
        for (int i = 1; i < n; i++) {
            //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
            int oneStepBack = Math.abs(heights[i] - heights[i - 1])
                    + memo[i - 1];

            //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
            //default value is Int.MAX because this time frog has to jump 2 steps back
            //and possibly n - 2 steps doesn't exist
            int twoStepBack = Integer.MAX_VALUE;
            //if it is possible to go n - 2 steps back then only calculate the energy consumed
            if (i - 2 >= 0) {
                twoStepBack = Math.abs(heights[i] - heights[i - 2])
                        + memo[i - 2];
            }

            //return the min energy consumed from both the steps
            memo[i] = Math.min(oneStepBack, twoStepBack);
        }
        //output
        System.out.println("Frog jump min energy consumed(DP Memoization): " + memo[n - 1]);
    }

    public void frogJump_DP_Memoization_SpaceOptimization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int prevStep = 0;
        int secondPrevStep = 0;
        for (int i = 1; i < n; i++) {
            //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
            int oneStepBack = Math.abs(heights[i] - heights[i - 1])
                    + prevStep;

            //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
            //default value is Int.MAX because this time frog has to jump 2 steps back
            //and possibly n - 2 steps doesn't exist
            int twoStepBack = Integer.MAX_VALUE;
            //if it is possible to go n - 2 steps back then only calculate the energy consumed
            if (i - 2 >= 0) {
                twoStepBack = Math.abs(heights[i] - heights[i - 2])
                        + secondPrevStep;
            }
            secondPrevStep = prevStep;
            //return the min energy consumed from both the steps
            prevStep = Math.min(oneStepBack, twoStepBack);
        }
        //output
        System.out.println("Frog jump min energy consumed(DP Memoization Space Optimization): " + prevStep);
    }

    public int ninjaTraining_Recursive_Helper(int[][] points, int day, int skipTask) {

        //base condition
        //we have started from the last day to day 0, at day 0
        //we can only pick a point which is max on day 0 but we will skip
        //that task which was was performed on day0 + 1 == day1
        if (day == 0) {
            int maxPointsAtDay0 = 0;
            for (int task = 0; task < 3; task++) {
                //skiping the task performed before this curr day
                if (skipTask == task) {
                    continue;
                }
                maxPointsAtDay0 = Math.max(maxPointsAtDay0, points[day][task]);
            }
            return maxPointsAtDay0;
        }

        //out of all the given tasks we will try to maximize out points
        //by trying all the task trainings but skiping the task which
        //was performed on its previous day
        int maxPoints = 0;
        for (int task = 0; task < 3; task++) {
            if (skipTask == task) {
                continue;
            }
            //we are perfroming task 'task' on curr day 'day' now we will move to next day
            //day == 'day - 1' but we are also saying that on the next day we must skip this curr 'task'
            int currMax = points[day][task] + ninjaTraining_Recursive_Helper(points, day - 1, task);
            //from the possible attempts to maximizing our points, keep the maxPoints
            maxPoints = Math.max(maxPoints, currMax);
        }
        return maxPoints;
    }

    public int ninjaTraining_Recursive_Memoization_Helper(
            int[][] points, int day, int skipTask, Map<String, Integer> cache) {

        //base condition
        //we have started from the last day to day 0, at day 0
        //we can only pick a point which is max on day 0 but we will skip
        //that task which was was performed on day0 + 1 == day1
        if (day == 0) {
            int maxPointsAtDay0 = 0;
            for (int task = 0; task < 3; task++) {
                //skiping the task performed before this curr day
                if (skipTask == task) {
                    continue;
                }
                maxPointsAtDay0 = Math.max(maxPointsAtDay0, points[day][task]);
            }
            return maxPointsAtDay0;
        }

        String key = day + "," + skipTask;
        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        //out of all the given tasks we will try to maximize out points
        //by trying all the task trainings but skiping the task which
        //was performed on its previous day
        int maxPoints = 0;
        for (int task = 0; task < 3; task++) {
            if (skipTask == task) {
                continue;
            }
            //we are perfroming task 'task' on curr day 'day' now we will move to next day
            //day == 'day - 1' but we are also saying that on the next day we must skip this curr 'task'
            int currMax = points[day][task] + ninjaTraining_Recursive_Memoization_Helper(points, day - 1, task, cache);
            //from the possible attempts to maximizing our points, keep the maxPoints
            maxPoints = Math.max(maxPoints, currMax);
        }

        cache.put(key, maxPoints);
        return maxPoints;
    }

    public void ninjaTraining_Recursive_And_Memoization(int[][] points) {
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int skipTask = 3;

        //.............................T: O(~ 2 ^ N), because at each level of descion tree
        //we are left with 2 task to try because one is skipped from previous day, so branching factor is reduced 2
        //..............................S: O(N), function call stack
        int recursiveMaxPoints = ninjaTraining_Recursive_Helper(points, n - 1, skipTask);

        //.............................T: O(N), Overlapping subproblems handled by cache
        //..............................S: O(N + N), function call stack + cache
        //<day+","+skipTaks, maxPoints>
        Map<String, Integer> cache = new HashMap<>();
        int recursiveMemoMaxPoints = ninjaTraining_Recursive_Memoization_Helper(points, n - 1, skipTask, cache);
        //output:
        System.out.println("Ninja Training max points on trainings(Recusrive): " + recursiveMaxPoints);
        System.out.println("Ninja Training max points on trainings(Recusrive Memoization): " + recursiveMemoMaxPoints);
    }

    public void ninjaTraining_DP_Memoization(int[][] points) {
        //...............................T: O(N * 4 * 3), N for all the days,
        //4 = (skipTask (0 = skipTask 0, 1 = skipTask 1, 2 = skipTask 2, 3 = skipTask None means try all tasks))
        //3 = tasks to try per day
        //...............................S: O(N * 4), for all N days we are havings points as per skipTasks
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int[][] memo = new int[n][4];
        //base condition
        //on day [0] and by skipping i-th task[i] the max points we can get is
        //the points from other 2 tasks
        //ex skipping task 0 we can pick max points from task 1 or task 2, same for others
        memo[0][0] = Math.max(points[0][1], points[0][2]);
        memo[0][1] = Math.max(points[0][0], points[0][2]);
        memo[0][2] = Math.max(points[0][0], points[0][1]);
        //task 3 actually represents here we didn't skip any task
        //for nth starting day, we won't be haing any skipTask from previous day because
        //that is our starting day, so on that we will try all the task to get our max points
        //from that day to any next day after that, we will some skipTask
        memo[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));

        for (int day = 1; day < n; day++) {
            for (int skipTask = 0; skipTask < 4; skipTask++) {

                memo[day][skipTask] = 0;
                for (int task = 0; task < 3; task++) {
                    if (skipTask == task) {
                        continue;
                    }
                    memo[day][skipTask] = Math.max(memo[day][skipTask],
                            points[day][task] + memo[day - 1][task]);
                }
            }
        }
        //output
        int dpMemoMaxPoints = memo[n - 1][3];
        System.out.println("Ninja Training max points on trainings(DP Memoization): " + dpMemoMaxPoints);
    }

    public void ninjaTraining_DP_Memoization_SpaceOptimization(int[][] points) {
        //...............................T: O(N * 4 * 3), N for all the days,
        //4 = (skipTask (0 = skipTask 0, 1 = skipTask 1, 2 = skipTask 2, 3 = skipTask None means try all tasks))
        //3 = tasks to try per day
        //...............................S: O(4), we will need just a prev day points to calculate our curr day points
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int[] prevDayPoints = new int[4];
        //base condition
        //on day [0] and by skipping i-th task[i] the max points we can get is
        //the points from other 2 tasks
        //ex skipping task 0 we can pick max points from task 1 or task 2, same for others
        prevDayPoints[0] = Math.max(points[0][1], points[0][2]);
        prevDayPoints[1] = Math.max(points[0][0], points[0][2]);
        prevDayPoints[2] = Math.max(points[0][0], points[0][1]);
        //task 3 actually represents here we didn't skip any task
        //for nth starting day, we won't be haing any skipTask from previous day because
        //that is our starting day, so on that we will try all the task to get our max points
        //from that day to any next day after that, we will some skipTask
        prevDayPoints[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));

        for (int day = 1; day < n; day++) {
            int[] currDayPoints = new int[4];
            for (int skipTask = 0; skipTask < 4; skipTask++) {
                currDayPoints[skipTask] = 0;
                for (int task = 0; task < 3; task++) {
                    if (skipTask == task) {
                        continue;
                    }
                    currDayPoints[skipTask] = Math.max(currDayPoints[skipTask],
                            points[day][task] + prevDayPoints[task]);
                }
            }
            prevDayPoints = currDayPoints;
        }
        //output
        int dpMemoSapceOptMaxPoints = prevDayPoints[3];
        System.out.println("Ninja Training max points on trainings(DP Memoization Space Optimization): " + dpMemoSapceOptMaxPoints);
    }

    public void minRemovalToMakeArrayMountain_DP_Memoization(int[] arr) {
        //https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/
        //completely based on Longest increasing subseq, longestIncreasingSubsequence_DP_Memoization()
        int n = arr.length;
        //find longest incr subseq from left to right
        int[] leftLIS = new int[n];
        Arrays.fill(leftLIS, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] > arr[j] && leftLIS[i] <= leftLIS[j]) {
                    leftLIS[i] = 1 + leftLIS[j];
                }
            }
        }

        //find longest incr subseq from right to left
        int[] rightLIS = new int[n];
        Arrays.fill(rightLIS, 1);

        for (int i = n - 2; i >= 0; i--) {
            for (int j = n - 1; j > i; j--) {
                if (arr[i] > arr[j] && rightLIS[i] <= rightLIS[j]) {
                    rightLIS[i] = 1 + rightLIS[j];
                }
            }
        }

        //maximize the length of the mountain so that total elements - maxMountainLength
        //results to minRemovals
        //minRemoval = n - maxMountainLength
        int maxMountainLength = 0;
        //why choosing loop from 1 to n - 1?
        //because a mountain-peek index can only lie in range [1 to n - 1] because
        //in order it to be a valid mountain array 'peek' should have lesser uphill
        //elements to left of peek and should have lesser downhill elements to right
        //of the peek
        //in cases where peek exists at index = 0 OR index = n - 1
        //ex: [1,2,3,4] OR [4,3,2,1] there are no respective uphill elements to
        //left of peek(index = 0) OR no downhill elements to right of peek(index = n - 1)
        for (int i = 1; i < n - 1; i++) {
            if (leftLIS[i] > 1 && rightLIS[i] > 1) {
                /*
                longest incr length from [left to i] = leftLIS[i]
                longest incr length from [right to i] = rightLIS[i]
                in both the lengths, length including i-th element is added twice
                thats why -1

                ex: [2,1,4,6,5,5,1], n = 7
                ....................6
                .................4
                ..............2
                ..............|___L__| leftLIS = 3 (2 < 4 < 6)

                ....................6
                .......................5
                ...........................1
                ....................|___R__| rightLIS = 3 (6 > 5 > 1)

                index = 3 is peek for both leftLIS & rightLIS
                leftLIS[i] + rightLIS[i] = 3 + 3 but length of element 6(==> 1) is
                added twice so 3 + 3 - 1 = 5
                hence maxMountainLength = 5 (2 < 4 < 6 > 5 > 1)
                minRemovals = n - maxMountainLength ==> 7 - 5 = 2
                that means remove index = 1 & either of index 4 or 5 as they are '5'

                 */
                maxMountainLength = Math.max(maxMountainLength, leftLIS[i] + rightLIS[i] - 1);
            }
        }
        //output
        int minRemovals = (n - maxMountainLength);
        System.out.println("Min removal to make array mountain: " + minRemovals);
    }

    public void lastStoneWeightTwo_DP_Memoization(int[] stones) {
        //https://leetcode.com/problems/last-stone-weight-ii/
        //ref: SomePracticeQuestion.minDiffInEqualSubset()
        int n = stones.length;
        int totalStoneSum = 0;
        for (int stone : stones) {
            totalStoneSum += stone;
        }

        boolean[][] memo = new boolean[n + 1][totalStoneSum + 1];

        //if no stones given where n == 0, any sum of stones will not be possible
        for (int col = 0; col < totalStoneSum + 1; col++) {
            memo[0][col] = false;
        }

        //if stones are given but stone sum to prove == 0, then only stone with 0
        //value is possible
        for (int row = 0; row < n + 1; row++) {
            memo[row][0] = true;
        }

        for (int stoneIndex = 1; stoneIndex < n + 1; stoneIndex++) {
            for (int stoneSum = 1; stoneSum < totalStoneSum + 1; stoneSum++) {
                if (stones[stoneIndex - 1] > stoneSum) {
                    memo[stoneIndex][stoneSum] = memo[stoneIndex - 1][stoneSum];
                } else {
                    memo[stoneIndex][stoneSum] = memo[stoneIndex - 1][stoneSum]
                            || memo[stoneIndex - 1][stoneSum - stones[stoneIndex - 1]];
                }
            }
        }

        int minDiff = Integer.MAX_VALUE;
        for (int stoneSum = totalStoneSum / 2; stoneSum >= 0; stoneSum--) {
            if (memo[n][stoneSum]) {
                minDiff = Math.min(minDiff, totalStoneSum - 2 * stoneSum);
            }
        }
        //output
        System.out.println("Min stone diff: " + minDiff);
    }

    private int numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(
            int n, int k, int target, Integer[][] memo) {

        int mod = 1000000007;

        //atmost dice given is n == 1 so that is our base cond
        //now with this 1 dice, can we reduce our target to 0 by taking any
        //face-value number on the dice, if yes return 1 for a possible way
        //otherwise return 0
        if (n == 1) {
            return 1 <= target && target <= k ? 1 : 0;
        }

        //if we have already cache the changing parameters before, get that to
        //save time complexity
        if (memo[n][target] != null) {
            return memo[n][target];
        }

        int currWays = 0;

        //the given k value are the max face-value number the n-th dice can have
        //but just like a knapsack or subset sum with target problem, there is no
        //point in considering a 'face' value that is already greater than our curr
        //target that why, Math.min(target, k) we will take the min of what is required
        //inside the loop we will just add up all the possible ways
        for (int face = 1; face <= Math.min(target, k); face++) {

            currWays = (currWays
                    + numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(
                    n - 1, k, target - face, memo)) % mod;
        }

        //since the changing parameters are n and target, they are causing the
        //subproblem in this DP question so just cache the ways against these
        //changing parameters
        return memo[n][target] = currWays;
    }

    public void numberOfDiceRollWithTargetSum_Recursive_Memoization(int n, int k, int target) {
        //https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
        //somewhat similar to subset sum with given target
        Integer[][] memo = new Integer[n + 1][target + 1];
        int ways = numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(n, k, target, memo);
        //output
        System.out.println("Number of ways to dice roll with target sum: " + ways);
    }

    private void maxNumberOfPointsWithCost_Recursive_Helper(
            int[][] points, int row, int prevCol, int currSum, int ROW, int COL) {

        if (row == ROW) {
            maxNumberOfPointsWithCost_Recursive_MaxCost = Math.max(
                    maxNumberOfPointsWithCost_Recursive_MaxCost,
                    currSum);
            return;
        }

        int currCost = 0;
        for (int col = 0; col < COL; col++) {
            currCost = points[row][col] - Math.abs(col - prevCol);
            maxNumberOfPointsWithCost_Recursive_Helper(points, row + 1, col, currSum + currCost, ROW, COL);
        }
    }

    private int maxNumberOfPointsWithCost_Recursive_MaxCost;

    public void maxNumberOfPointsWithCost_Recursive(int[][] points) {
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
        //this is giving TLE
        int ROW = points.length;
        int COL = points[0].length;
        maxNumberOfPointsWithCost_Recursive_MaxCost = 0;
        for (int col = 0; col < COL; col++) {
            maxNumberOfPointsWithCost_Recursive_Helper(points, 1, col, points[0][col], ROW, COL);
        }
        //output
        System.out.println("Max number of points with cost(Recursive): " + maxNumberOfPointsWithCost_Recursive_MaxCost);
    }

    public void maxNumberOfPointsWithCost_DP_Memoization(int[][] points) {
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1344870/Java-DP
        int ROW = points.length;
        int COL = points[0].length;
        long[] memo = new long[COL];

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                memo[col] += points[row][col];
            }

            for (int col = 1; col < COL; col++) {
                memo[col] = Math.max(memo[col], memo[col - 1] - 1);
            }

            for (int col = COL - 2; col >= 0; col--) {
                memo[col] = Math.max(memo[col], memo[col + 1] - 1);
            }
        }

        long maxCost = 0L;
        for (long cost : memo) {
            maxCost = Math.max(maxCost, cost);
        }
        //output
        System.out.println("Max number of points with cost(DP Memoization): " + maxCost);
    }

    private int minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
            int[][] grid, int target, int row, int currSum, Integer[][] memo) {

        if (row == grid.length) {
            int absDiff = Math.abs(target - currSum);
            return absDiff;
        }

        if (memo[row][currSum] != null) {
            return memo[row][currSum];
        }

        int minAbsDiff = Integer.MAX_VALUE;

        for (int c = 0; c < grid[0].length; c++) {
            int currMinAbsDiff = minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
                    grid, target, row + 1, currSum + grid[row][c], memo);

            minAbsDiff = Math.min(minAbsDiff, currMinAbsDiff);
            if (minAbsDiff == 0) {
                break;
            }
        }

        memo[row][currSum] = minAbsDiff;
        return minAbsDiff;
    }

    public void minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(int[][] grid, int target) {
        //https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
        int ROW = grid.length;
        int COL = grid[0].length;
        //for this question hashmap based cache/memo object was not working and giving TLE
        //using 2D memo matrix solved the problen, using Integer wrapper instead
        //of primitive int helps directly checking with null rather than providing
        //default values to memo[][] as -1
        Integer[][] memo = new Integer[ROW][5001];
        int minAbsDiff = 0;
        for (int col = 0; col < COL; col++) {
            minAbsDiff = minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
                    grid, target, 0, 0, memo);
        }
        //output
        System.out.println("Min abs diff between target and choosen elements: " + minAbsDiff);
    }

    private int minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
            int[] jobs, int days, int index, Integer[][] memo) {

        int n = jobs.length;

        //base case, if we have just 1 day then we have to finish all the jobs
        //in that single day 1, hence we will find the maxDiffJob on this days
        if (days == 1) {
            int maxDiffJob = Integer.MIN_VALUE;
            for (int i = index; i < n; i++) {
                maxDiffJob = Math.max(maxDiffJob, jobs[i]);
            }
            return maxDiffJob;
        }

        if (memo[index][days] != null) {
            return memo[index][days];
        }

        int currMaxDiffJob = Integer.MIN_VALUE;
        int minDiffJobSchedule = Integer.MAX_VALUE;

        //if we have more than 1 day to do jobs then n - days insures that we
        //don't do all the jobs in the same day itself and jobs are left for rest
        //other days as well because as per question we need to do some jobs on
        //each 'days' given
        for (int i = index; i <= n - days; i++) {

            currMaxDiffJob = Math.max(currMaxDiffJob, jobs[i]);

            minDiffJobSchedule = Math.min(minDiffJobSchedule,
                    currMaxDiffJob + minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
                            jobs, days - 1, i + 1, memo));
        }
        return memo[index][days] = minDiffJobSchedule;
    }

    public void minDifficultyOfAJobSchedule_Recursive_Memoization(int[] jobs, int days) {
        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/
        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/2708329/C%2B%2B-Memoized-Solution-oror-Runtime-130-ms-Beats-34.93-Memory-7.3-MB-Beats-93.10
        //explanation: https://youtu.be/smTnSl6UKi0
        /*
        for ex jobs[] = [6, 5, 4, 3, 2, 1], days = 2
        we need to create 'days' non-empty subarrays
        1. [6] | [5, 4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 5 = minDifficulty = 6 + 5 = 11
        2. [6, 5] | [4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 4 = minDifficulty = 6 + 4 = 10
        3. [6, 5, 4] | [4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 3 = minDifficulty = 6 + 3 = 9
        4. [6, 5, 4, 3] | [2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 2 = minDifficulty = 6 + 2 = 8
        5. [6, 5, 4, 3, 2] | [1] = maxDay1 schedule = 6, maxDay2 schedule = 1 = minDifficulty = 6 + 1 = 7

        minDifficulty of all the possible 'days' wise schedule is 7
        where day1 schedule [6, 5, 4, 3, 2]
        and day2 schedule [1]

         */

        int n = jobs.length;

        if (n < days) {
            System.out.println("Min difficulty of a job schedule: -1");
            return;
        }

        Integer[][] memo = new Integer[n + 1][days + 1];
        int minDifficulty = minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
                jobs, days, 0, memo);
        //output
        System.out.println("Min difficulty of a job schedule: " + minDifficulty);
    }

    public void longestArithmeticSubseqOfGivenDiff_DP_Memoization(int[] arr, int diff) {
        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/
        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/discuss/2717595/C%2B%2B-Solution
        //based on LONGEST INCR SUBSEQ but original O(n^2) approach will give TLE
        //here we are using modified approach ths longest increasing subseq using
        //Map
        /*
        ex: arr[7,5,3,1], diff = -2
        length is 4 because 7 - 5 - 3 - 1 has arithmetic diff of -2
        here in the logic
        1. val = 7, map[7 - diff, 0] ==> 0 +1 = 1 because val - diff ==> 7 - -2 = 9 doesn't exists
        map[7=1]
        2. val = 5, map[5 - diff, 0] ==> 0 +1 = 2 because val - diff ==> 5 - -2 = 7 exists with length 1
        (so do +1 to prev seq(7))
        map[7=1, 5=2]
        3. val = 3, map[3 - diff, 0] ==> 0 +1 = 3 because val - diff ==> 3 - -2 = 5 exists with length 2
        (so do +1 to prev seq(5))
        map[7=1, 5=2, 3=3]
        4. val = 1, map[1 - diff, 0] ==> 0 +1 = 4 because val - diff ==> 1 - -2 = 3 exists with length 2
        (so do +1 to prev seq(5))
        map[7=1, 5=2, 3=3, 1=4]
         */
        //a single element will also be considered as of length 1 even if there
        //is no arithmetic seq with given diff
        int maxLen = 1;
        Map<Integer, Integer> memo = new HashMap<>();
        for (int val : arr) {
            //calculate the subseq length for the curr val if there exists a previous
            //subseq as (val - diff), get its length or default is 0 and add 1 to
            //it, because this curr val new addition to already existing subseq hence
            //length increased by 1
            memo.put(val, memo.getOrDefault(val - diff, 0) + 1);
            maxLen = Math.max(maxLen, memo.get(val));
        }
        //output
        System.out.println("Longest arithmetic subseq with given diff: " + maxLen);
    }

    private int distinctSubsequences_Recursive_Memoization_Helper(
            String main, String curr, int mainIndex, int currIndex, Integer[][] memo) {
        //as we need to find all the distinct subseq of curr string that can be formed
        //from main string, but if the curr string is empty("") then it really
        //doesn't matter if the main string is empty("") or some valid long string
        //because there will exist one empty subseq in main string that will match
        //the given empty("") curr string, so return 1
        if (curr.length() == 0 || currIndex == curr.length()) {
            return 1;
        }

        //just opposite to above note, need to find all the distinct subseq of
        //curr string that can be formed from main string, but if the main string
        //is empty("") and curr string is some valid long string then it will never
        //be possible to form the subseq of curr string from main string because
        //there are no chars in main string to choose from to create curr string
        //so return 0
        if (main.length() == 0 || mainIndex >= main.length()) {
            return 0;
        }

        //if something is already cached
        if (memo[mainIndex][currIndex] != null) {
            return memo[mainIndex][currIndex];
        }

        //if two chars from main and curr string are matches, there will be two
        //possibilities to form the subseq from main string that have same chars
        //as curr string
        if (main.charAt(mainIndex) == curr.charAt(currIndex)) {
            return memo[mainIndex][currIndex]
                    //1. possibility, since two chars already matched, then move both indexes
                    //of main and curr string ahead (ex: main: rabbbit, curr: rabbit)
                    //r, a, b will match but you decide to move both index
                    //mainIndex + 1, currIndex + 1
                    //so next main: rab[b]bit, curr: rab[b]it
                    = distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex + 1, memo)
                    //2. possibility, since two chars already matched, then move only
                    //the index of main string ahead
                    //r, a, b will match but you decide to move only mainIndex + 1
                    //so next main: rab[b]bit, curr: ra[b]bit
                    + distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex, memo);
        }
        //if the two chars don't match, we can only move mainIndex because, we want to
        //form subseq that is exactly the curr string, so currIndex remains at that position
        //so that any next (mainIndex + 1)-th char can match with currIndex
        return memo[mainIndex][currIndex]
                = distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex, memo);
    }

    public void distinctSubsequences_Recursive_Memoization(String main, String curr) {
        //https://leetcode.com/problems/distinct-subsequences/
        //explanation: https://youtu.be/-RDzMJ33nx8
        int n = main.length();
        int m = curr.length();
        Integer[][] memo = new Integer[n][m];
        int distinctSubseq = distinctSubsequences_Recursive_Memoization_Helper(main, curr, 0, 0, memo);
        //output
        System.out.println("Distinct subsequences (approach Recursive Memoization): " + distinctSubseq);
    }

    public void distinctSubsequences_DP_Memoization(String main, String curr) {
        //https://leetcode.com/problems/distinct-subsequences/
        //explanation: https://youtu.be/-RDzMJ33nx8
        //based on above recursive memoization approach
        int n = main.length();
        int m = curr.length();
        int[][] memo = new int[n + 1][m + 1];

        //base cond:
        //in case where, string 'curr' is empty and string 'main' is having some
        //chars in it where the length of string 'main' can be [0 to mainIndex]
        //then we can have 1 empty subset from string 'main' that matches string
        //'curr', memo memo[mainIndex][0] will be 1 for empty string 'curr'
        //of length = m = 0 == currIndex
        for (int mainIndex = 0; mainIndex < n + 1; mainIndex++) {
            memo[mainIndex][0] = 1;
        }

        for (int mainIndex = 1; mainIndex < n + 1; mainIndex++) {

            for (int currIndex = 1; currIndex < m + 1; currIndex++) {

                if (main.charAt(mainIndex - 1) == curr.charAt(currIndex - 1)) {
                    memo[mainIndex][currIndex]
                            = memo[mainIndex - 1][currIndex - 1] + memo[mainIndex - 1][currIndex];
                } else {
                    memo[mainIndex][currIndex] = memo[mainIndex - 1][currIndex];
                }
            }
        }

        //output
        System.out.println("Distinct subsequences (approach DP Memoization): " + memo[n][m]);
    }

    private int arrayRemovals_Recursive_Memoization_Helper(
            int[] nums, int k, int minIndex, int maxIndex, int currRemovals, Integer[][] memo) {

        //as we are considering min vals on left side (minIndex) and max vals on
        //right side (maxIndex) of nums[], if we ever reach a cond where
        //minIndex > maxIndex then minIndex starts to point max vals and maxIndex
        //starts to point minIndex which is wrong, hence return Int.MAX as we need
        //to minimize the removals
        if (minIndex > maxIndex) {
            return Integer.MAX_VALUE;
        }

        //as we have sorted nums[] and min and max vals are on left & right side
        //repect. so if we ever see a valid cond where max(nums) - min(nums) <= k
        //we will return the removed elements 'currRemovals' as a result
        //because further moving to minIndex to right side and maxIndex to left
        //side will simulate as more element removals which needs to be minimized
        if (nums[maxIndex] - nums[minIndex] <= k) {
            return currRemovals;
        }

        //if already cached, return those removals
        if (memo[minIndex][maxIndex] != null) {
            return memo[minIndex][maxIndex];
        }

        //currently we have max(nums) - min(nums) > k (why? because above
        //if (nums[maxIndex] - nums[minIndex] <= k) statement didn't get called)
        //2 choices we can make here
        //1. move to next minEle(==> minIndex + 1) and keeping the maxEle same
        //in this case we consider that we have removed the curr element @minIndex,
        //so that should be counted as currRemoval + 1
        int minRemovals = arrayRemovals_Recursive_Memoization_Helper(
                nums, k, minIndex + 1, maxIndex, currRemovals + 1, memo);

        //2. move to next maxEle(==> maxIndex - 1) and keeping the minEle same
        //in this case we consider that we have removed the curr element @maxIndex,
        //so that should be counted as currRemoval + 1
        minRemovals = Math.min(minRemovals,
                arrayRemovals_Recursive_Memoization_Helper(
                        nums, k, minIndex, maxIndex - 1, currRemovals + 1, memo));

        return memo[minIndex][maxIndex] = minRemovals;
    }

    public void arrayRemovals_Recursive_Memoization(int[] arr, int k) {
        //https://practice.geeksforgeeks.org/problems/array-removals/1
        int n = arr.length;
        Integer[][] memo = new Integer[n + 1][n + 1];
        //by sorting we will get minEle at minIndex(i.e, 0) and maxEle at maxIndex(i.e, n - 1)
        Arrays.sort(arr);
        int minRemovals = arrayRemovals_Recursive_Memoization_Helper(
                arr, k, 0, n - 1, 0, memo);
        //output
        System.out.println("Min array element removal: " + minRemovals);
    }

    private int deleteAndEarn_Recursive_Memoization_Helper(
            int val, int maxNumsVal, int[] valFreq, Integer[] memo) {

        //as we have reached a value 'val' which is greater than the max value
        //of the nums[] array 'maxNumsVal' means further we can't consider any
        //value from nums[] as there will be no value left beyond its own max
        //val, hence return 0 as earnings
        if (val > maxNumsVal) {
            return 0;
        }

        if (memo[val] != null) {
            return memo[val];
        }

        //2 choices we can make here
        //1. don't pick the curr val so it will not be taken into earnings and move
        //to next val (val + 1)
        int maxEarnings = deleteAndEarn_Recursive_Memoization_Helper(
                val + 1, maxNumsVal, valFreq, memo);

        //2. pick the curr val so it will be taken into earnings as we will
        //consider this 'val' and all of its freq (==> val * freq[val]) as
        //earnings and move to next val (==> val + 2) why val + 2? because as
        //per questions if we pick a value in our earnings then we should reject
        //all the (val - 1) & (val + 1) values for this pourpose we sorted nums[]
        //so now we don't need to care about prev val (==> val - 1) and also we
        //skip the next val (val + 1) by moving to val + 2
        maxEarnings = Math.max(maxEarnings,
                (val * valFreq[val]) + deleteAndEarn_Recursive_Memoization_Helper(
                        val + 2, maxNumsVal, valFreq, memo));

        return memo[val] = maxEarnings;
    }

    public void deleteAndEarn_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/delete-and-earn/
        //https://leetcode.com/problems/delete-and-earn/discuss/2767347/Javaoror1msoror-90-MEMOIZATIONDP
        //based on sticklerThief()
        int n = nums.length;
        /*
        Pick any nums[i] and delete it to earn nums[i] points. Afterwards,
        you must delete every element equal to nums[i] - 1 and every element
        equal to nums[i] + 1.

        sorting the nums[] will help to skip nums[i] - 1 & nums[i] + 1
         */
        Arrays.sort(nums);
        //find the max value in nums[], upto that (maxVal + 1) all are values in
        //nums[] will be covered.
        int maxVal = nums[n - 1];
        //to calculate freq of each value including any val in nums[] till its
        //maxVal
        int[] valFreq = new int[maxVal + 1];
        for (int val : nums) {
            valFreq[val]++;
        }

        Integer[] memo = new Integer[maxVal + 1];
        //now that nums[] is sorted in incr order the min value is at index 0 so
        //we start our earnings calculations from that value and we can only
        //consider the values 'val' atmost 'maxNumsVal'
        //as each 'val' lies in the range of [nums[0] to maxNumsVal]
        int maxEarnings = deleteAndEarn_Recursive_Memoization_Helper(nums[0], maxVal, valFreq, memo);
        //output
        System.out.println("Delete and earn: " + maxEarnings);
    }

    public void deleteAndEarn_DP_Memoization(int[] nums) {
        //https://leetcode.com/problems/delete-and-earn/
        //https://leetcode.com/problems/delete-and-earn/discuss/2767347/Javaoror1msoror-90-MEMOIZATIONDP
        //based on sticklerThief()
        int n = nums.length;
        /*
        Pick any nums[i] and delete it to earn nums[i] points. Afterwards,
        you must delete every element equal to nums[i] - 1 and every element
        equal to nums[i] + 1.

        sorting the nums[] will help to skip nums[i] - 1 & nums[i] + 1
         */
        Arrays.sort(nums);
        //find the max value in nums[], upto that (maxVal + 1) all are values in
        //nums[] will be covered.
        int maxVal = nums[n - 1];
        //to calculate freq of each value including any val in nums[] till its
        //maxVal
        int[] valFreq = new int[maxVal + 1];
        for (int val : nums) {
            valFreq[val]++;
        }

        //why + 2? because in question if you pick any nums[i] then you we must
        //not use nums[i] + 1 that why +2 is used so that we don't out of bounds.
        Integer[] memo = new Integer[maxVal + 2];

        memo[0] = 0;
        memo[1] = 0;

        for (int val = 2; val < maxVal + 2; val++) {
            memo[val] = Math.max((valFreq[val - 1] * (val - 1)) + memo[val - 2], memo[val - 1]);
        }

        int maxEarnings = memo[maxVal + 1];
        //output
        System.out.println("Delete and earn: " + maxEarnings);
    }

    private void uniquePartitions_Recursive_Helper(int[] nums, int index, int target,
                                                   List<Integer> currList, List<List<Integer>> partitions) {
        if (target == 0) {
            partitions.add(new ArrayList<>(currList));
            return;
        }
        if (index < 0) {
            return;
        }

        //PICK the nums[index], only if this nums[index] is reducing our target
        //not less than 0 (means upto >= 0)
        if (target - nums[index] >= 0) {
            currList.add(nums[index]);
            //if we pick curr nums[index] we can pick this num again and again
            //that why we are keeping index as index only (not index - 1)
            uniquePartitions_Recursive_Helper(nums, index, target - nums[index], currList, partitions);
            currList.remove(currList.size() - 1);
        }

        //DON'T PICK, we are not picking the curr nums[index], that means we have
        //to move to next index i.e, index - 1 and target will also remain as it is
        uniquePartitions_Recursive_Helper(nums, index - 1, target, currList, partitions);
    }

    public void uniquePartitions_Recursive(int n) {
        //https://practice.geeksforgeeks.org/problems/unique-partitions1041/1
        List<List<Integer>> partitions = new ArrayList<>();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        uniquePartitions_Recursive_Helper(nums, n - 1, n, new ArrayList<>(), partitions);
        //output
        System.out.println("Unique partitions: " + partitions);
    }

    public void largestOneBorderedSquare_DP_Memoization(int[][] grid) {
        //https://leetcode.com/problems/largest-1-bordered-square/
        //https://leetcode.com/problems/largest-1-bordered-square/discuss/2770491/Java-%3A-Easy-to-understand(with-explanation)
        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] verticalOneCount = new int[ROW][COL];
        int[][] horizontalOneCount = new int[ROW][COL];

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 0) {
                    continue;
                }
                verticalOneCount[r][c] = r == 0 ? 1 : verticalOneCount[r - 1][c] + 1;
                horizontalOneCount[r][c] = c == 0 ? 1 : horizontalOneCount[r][c - 1] + 1;
            }
        }

        int max = 0;
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                int min = Math.min(verticalOneCount[r][c], horizontalOneCount[r][c]);
                while (min > max) {
                    if (horizontalOneCount[r - min + 1][c] >= min
                            && verticalOneCount[r][c - min + 1] >= min) {
                        max = min;
                    }
                    min--;
                }
            }
        }

        System.out.println("Largest 1 bordered square: " + (max * max));
    }

    private void lexicographicalNumbers_Recursion_DFS(int n, int currNum, List<Integer> lexicographicalNumbers) {
        if (currNum > n) {
            return;
        }
        lexicographicalNumbers.add(currNum);
        for (int nextDigit = 0; nextDigit <= 9; nextDigit++) {
            lexicographicalNumbers_Recursion_DFS(n, currNum * 10 + nextDigit, lexicographicalNumbers);
        }
    }

    public void lexicographicalNumbers_Recursion(int n) {
        //https://leetcode.com/problems/lexicographical-numbers/
        //based on DFS RECURSION
        List<Integer> lexicographicalNumbers = new ArrayList<>();
        //because we want to generate nums in range of [1, n], thats why our curr
        //digit will start from 1
        for (int digit = 1; digit <= 9; digit++) {
            lexicographicalNumbers_Recursion_DFS(n, digit, lexicographicalNumbers);
        }
        //output
        System.out.println("Lexicographically sorted numbers from [1, " + n + "]: " + lexicographicalNumbers);
    }

    private int minFallingPathSum_Recursive_Memoization_Helper(
            int[][] grid, int row, int col, Integer[][] memo) {
        //if we have reached the row limit of the grid, that means we have covered
        //a path from row == 0 to row >= ROW
        if (row >= grid.length) {
            return 0;
        }
        //if already in cache
        if (memo[row][col] != null) {
            return memo[row][col];
        }

        int currMinFallingPathSum = Integer.MAX_VALUE;
        //from the curr col location we can make 3 moves in the next row from
        //this curr col, i.e, newCol will be diagonal-left(-1), down(0), diagonal-right(+1)
        //if this newCol is going out of bounds, skip that iteration
        for (int newCol = col - 1; newCol <= col + 1; newCol++) {
            //out of bounds
            if (newCol < 0 || newCol >= grid[0].length) {
                continue;
            }

            currMinFallingPathSum = Math.min(currMinFallingPathSum,
                    //picking the value at curr row & col and moving to next row
                    //with new col until we reach the path end we will add them
                    //find the currMinFallingPathSum of all the possible paths
                    grid[row][col] + minFallingPathSum_Recursive_Memoization_Helper(grid, row + 1, newCol, memo));
        }

        return memo[row][col] = currMinFallingPathSum;
    }

    public void minFallingPathSum_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/minimum-falling-path-sum/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        Integer[][] memo = new Integer[ROW][COL];
        int minFallingPathSum = Integer.MAX_VALUE;
        for (int col = 0; col < COL; col++) {
            minFallingPathSum = Math.min(minFallingPathSum,
                    minFallingPathSum_Recursive_Memoization_Helper(grid, 0, col, memo));
        }
        //output
        System.out.println("Min falling path sum: " + minFallingPathSum);
    }

    private int minFallingPathSumTwo_Recursive_Memoization_Helper(
            int[][] grid, int row, int skipCol, Integer[][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;

        if (row >= ROW) {
            return 0;
        }

        if (memo[row][skipCol] != null) {
            return memo[row][skipCol];
        }

        int currMinFallingPathSum = Integer.MAX_VALUE;

        for (int col = 0; col < COL; col++) {

            if (col == skipCol) {
                continue;
            }

            currMinFallingPathSum = Math.min(
                    currMinFallingPathSum,
                    grid[row][col] + minFallingPathSumTwo_Recursive_Memoization_Helper(grid, row + 1, col, memo));
        }
        return memo[row][skipCol] = currMinFallingPathSum;
    }

    public void minFallingPathSumTwo_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/minimum-falling-path-sum-ii/
        //https://leetcode.com/problems/paint-house/description/
        //https://leetcode.com/problems/paint-house-ii/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        Integer[][] memo = new Integer[ROW][COL];

        int minFallingPathSum = Integer.MAX_VALUE;

        int row = 0;

        for (int col = 0; col < COL; col++) {
            minFallingPathSum = Math.min(
                    minFallingPathSum,
                    grid[row][col] + minFallingPathSumTwo_Recursive_Memoization_Helper(
                            grid, row + 1, col, memo));
        }
        //output
        System.out.println("Min falling path sum two: " + minFallingPathSum);
    }

    private int minPathCostInGrid_Recursive_Memoization_Helper(
            int[][] grid, int[][] moveCost, int row, int prevCellVal, Integer[][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //return 0 as cost, as we reached end of the grid and hence we can't move
        //to any cell
        if (row >= ROW) {
            return 0;
        }

        if (memo[row][prevCellVal] != null) {
            return memo[row][prevCellVal];
        }

        int currMinPathCost = Integer.MAX_VALUE;

        for (int col = 0; col < COL; col++) {

            int currCellVal = grid[row][col];

            currMinPathCost = Math.min(currMinPathCost,
                    //we moved to this curr 'row' from some prev row from a prev
                    //call stack, for this movement we need to add the movement
                    //cost 'moveCost' that should be prevCellVal-index from where
                    //we started (==> moveCost[prevCellVal]) and currently we moved
                    //to this 'col' hence the movement cost is 'moveCost[prevCellVal][col]'
                    moveCost[prevCellVal][col]
                            //also to the curr cell value in that path cost
                            + currCellVal
                            //move to next row (==> row + 1) and also take this
                            //currCellVal, which will act as prevCellVal for that
                            //next row hence we can calulate the movement cost
                            + minPathCostInGrid_Recursive_Memoization_Helper(
                            grid, moveCost, row + 1, currCellVal, memo));

        }

        return memo[row][prevCellVal] = currMinPathCost;
    }

    public void minPathCostInGrid_Recursive_Memoization(int[][] grid, int[][] moveCost) {
        //https://leetcode.com/problems/minimum-path-cost-in-a-grid/description/
        //based o minFallingPathSumTwo_Recursive_Memoization()
        int ROW = grid.length;
        int COL = grid[0].length;

        int totalDistinctNumbers = ROW * COL;

        Integer[][] memo = new Integer[ROW + 1][totalDistinctNumbers];

        int minPathCost = Integer.MAX_VALUE;

        int movementCostToReachAnyCellInFirstRow = 0;
        int row = 0;

        for (int col = 0; col < COL; col++) {

            int currCellVal = grid[row][col];

            minPathCost = Math.min(minPathCost,
                    //added 0 means, cost of movement 'moveCost' to any cell in
                    //the first row == 0 is 0
                    movementCostToReachAnyCellInFirstRow
                            //also to the curr cell value in that path cost
                            + currCellVal
                            //move to next row (==> row + 1) and also take this
                            //currCellVal, which will act as prevCellVal for that
                            //next row hence we can calulate the movement cost from this
                            //curr cell to any col in next row using moveCost[cellVal-index][col]
                            + minPathCostInGrid_Recursive_Memoization_Helper(
                            grid, moveCost, row + 1, currCellVal, memo));

        }

        //output
        System.out.println("Min path cost in grid : " + minPathCost);
    }

    private int cherryPickupTwo_Recursive_Memoization_Helper(
            int[][] grid, int currRoboRow, int roboCol1, int roboCol2, Integer[][][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //as we have reached the bottom of the grid[][], & further from this 'row'
        //we don't have any more cherries to pick hence return 0
        if (currRoboRow >= ROW) {
            return 0;
        }

        //if robot1 is going out of bounds i.e, going out of left or right edges
        if (roboCol1 < 0 || roboCol1 >= COL) {
            return 0;
        }

        //if robot2 is going out of bounds i.e, going out of left or right edges
        if (roboCol2 < 0 || roboCol2 >= COL) {
            return 0;
        }

        if (memo[currRoboRow][roboCol1][roboCol2] != null) {
            return memo[currRoboRow][roboCol1][roboCol2];
        }

        //firstly we add the cherry picked by robot1
        int currCherryPicks = grid[currRoboRow][roboCol1];
        //secondly we will add the cherry picked by robot2 but if robot2 is already
        //at the same location of robot1 then robot2 can't pick from there as already
        //picked by robot1 so cherry becomes 0
        currCherryPicks += (roboCol1 == roboCol2) ? 0 : grid[currRoboRow][roboCol2];

        //now we will try check which next positions for both the robots will give
        //max cherry pick ups
        int maxCherryPicks = 0;
        //since both the robots can make 3 moves in the next row from their curr
        //cols respec, i.e, diagonal-left(-1), down(0), diagonal-right(+1)
        //suppose our robot1 makes a move to next-row and diagonal-left col, there
        //are 3 movement possibilities for robot2. so for 3 movements for robot1
        //there are 3 movements for robot2
        //robot1(diagonal-left, down, diagonal-right) * robot2(diagonal-left, down, diagonal-right)
        //below nested for loop is for the same 3 * 3 == 9 movements possibilities
        for (int newRoboCol1 = roboCol1 - 1; newRoboCol1 <= roboCol1 + 1; newRoboCol1++) {

            for (int newRoboCol2 = roboCol2 - 1; newRoboCol2 <= roboCol2 + 1; newRoboCol2++) {

                maxCherryPicks = Math.max(
                        maxCherryPicks,
                        currCherryPicks + cherryPickupTwo_Recursive_Memoization_Helper(
                                grid, currRoboRow + 1, newRoboCol1, newRoboCol2, memo));
            }
        }

        return memo[currRoboRow][roboCol1][roboCol2] = maxCherryPicks;
    }

    public void cherryPickupTwo_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/cherry-pickup-ii/
        //https://leetcode.com/problems/cherry-pickup-ii/solutions/880135/cherry-pickup-ii/
        int ROW = grid.length;
        int COL = grid[0].length;
        //rows remain same for both the robots but col locations may be diff
        //for robot1 and robot2
        Integer[][][] memo = new Integer[ROW][COL][COL];
        //both robot iniatlly at row = 0;
        int currRoboRow = 0;
        //first robot is at top-left(currRoboRow, 0)
        int roboCol1 = 0;
        //second robot is at top-right(currRoboRow, COL - 1)
        int roboCol2 = COL - 1;

        int maxCherryPicks = cherryPickupTwo_Recursive_Memoization_Helper(grid, currRoboRow, roboCol1, roboCol2, memo);
        //output
        System.out.println("Max cherry pickups by two robots: " + maxCherryPicks);
    }

    private int dungeonGame_Recursive_Memoization_Helper(int[][] dungeon, int row, int col, Integer[][] memo) {
        int ROW = dungeon.length;
        int COL = dungeon[0].length;

        //if either row or col going out of bounds
        if (row >= ROW || col >= COL) {
            return Integer.MIN_VALUE;
        }

        //if we reached the bottom-right corner of dungeon
        if (row == ROW - 1 && col == COL - 1) {
            return dungeon[row][col];
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        int healthRemaining1 = dungeonGame_Recursive_Memoization_Helper(dungeon, row + 1, col, memo);
        int healthRemaining2 = dungeonGame_Recursive_Memoization_Helper(dungeon, row, col + 1, memo);

        int currMinHealthReq = Math.min(dungeon[row][col],
                dungeon[row][col] + Math.max(healthRemaining1, healthRemaining2));

        return memo[row][col] = currMinHealthReq;
    }

    public void dungeonGame_Recursive_Memoization(int[][] dungeon) {
        //https://leetcode.com/problems/dungeon-game/description/
        //https://leetcode.com/problems/dungeon-game/solutions/52777/dfs-with-memoization/
        int ROW = dungeon.length;
        int COL = dungeon[0].length;
        Integer[][] memo = new Integer[ROW][COL];
        int minHealthReq = dungeonGame_Recursive_Memoization_Helper(dungeon, 0, 0, memo);
        minHealthReq = minHealthReq <= 0 ? -minHealthReq + 1 : 1;
        //output
        System.out.println("Dungeon game: " + minHealthReq);
    }

    private int buySellStocksWithCooldown_Recursive_Memoization_Helper(
            int[] prices, int day, boolean needToBuy, Integer[][] memo) {

        int maxDays = prices.length;

        if (day >= maxDays) {
            return 0;
        }

        if (memo[day][needToBuy ? 1 : 0] != null) {
            return memo[day][needToBuy ? 1 : 0];
        }

        //when we are allowed to buy
        if (needToBuy) {
            //2 options,
            //1. we will buy stock at curr 'day' by paying the price of prices[day]
            //if we are buying at curr 'day', then we 'need to buy' == false because we
            //need to sell then, we will move to next day (==> day + 1) possibly
            //we can sell on that day
            int buyStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(
                    prices, day + 1, false, memo) - prices[day];

            //2. we will still not buy the stock at curr 'day' and possibly move to
            //next day (==> day + 1) to buy a stock at that day, and 'need to buy' == true
            int dontBuyStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, day + 1, true, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(buyStock, dontBuyStock);

        } //when we are allowed to sell
        else {
            //2 options,
            //1. we will sell stock at curr 'day' and receive the price of prices[day]
            //if we are selling at curr 'day', then we 'need to buy' == true but we also
            //need to maintain a 'cooldown' period of 1 day, mean we are not going to buy
            //the next stock on just next day (==> day + 1) but day after tomorrow (==> day + 2)
            int sellStock = prices[day] + buySellStocksWithCooldown_Recursive_Memoization_Helper(
                    prices, day + 2, true, memo);

            //2. we will still not sell the stock at curr 'day' and possibly move to
            //next day (==> day + 1) to sell the stock at that day, and 'need to buy' == false
            //as we are already holding a stock
            int dontSellStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, day + 1, false, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(sellStock, dontSellStock);
        }
    }

    public void buySellStocksWithCooldown_Recursive_Memoization(int[] prices) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
        //Explanation: https://youtu.be/iTvEXpOAyHY | https://www.youtube.com/watch?j=IGIe46xw3YY
        int n = prices.length;
        Integer[][] memo = new Integer[n + 1][2];
        int maxProfit = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, 0, true, memo);
        //output
        System.out.println("Max profit on buying & selling stock with cooldown: " + maxProfit);
    }

    private int buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(int[] prices,
                                                                                   int fee, int day, boolean needToBuy, Integer[][] memo) {

        int maxDays = prices.length;

        if (day >= maxDays) {
            return 0;
        }

        if (memo[day][needToBuy ? 1 : 0] != null) {
            return memo[day][needToBuy ? 1 : 0];
        }

        //when we are allowed to buy
        if (needToBuy) {
            //2 options,
            //1. we will buy stock at curr 'day' by paying the price of prices[day]
            //if we are buying at curr 'day', then we 'need to buy' == false because we
            //need to sell then, we will move to next day (==> day + 1) possibly
            //we can sell on that day
            int buyStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, false, memo) - prices[day];

            //2. we will still not buy the stock at curr 'day' and possibly move to
            //next day (==> day + 1) to buy a stock at that day, and 'need to buy' == true
            int dontBuyStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, true, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(buyStock, dontBuyStock);

        } //when we are allowed to sell
        else {
            //2 options,
            //1. we will sell stock at curr 'day' and receive the price of prices[day]
            //if we are selling at curr 'day', then we 'need to buy' == true and we move
            //to next day (==> day + 1) to buy the next stock of that day, also to note
            //here, we made a 'sell' transaction so each time we complete transaction
            //buy-then-sell, we will have to pay 'fee' on the transaction made
            int sellStock = prices[day] + buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, true, memo) - fee;

            //2. we will still not sell the stock at curr 'day' and possibly move to
            //next day (==> day + 1) to sell the stock at that day, and 'need to buy' == false
            //as we are already holding a stock
            int dontSellStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, false, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(sellStock, dontSellStock);
        }
    }

    public void buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(int[] prices, int fee) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
        //based on buySellStocksWithCooldown_Recursive_Memoization() with minor change
        int n = prices.length;
        Integer[][] memo = new Integer[n + 1][2];
        int maxProfit = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                prices, fee, 0, true, memo);
        //output
        System.out.println("Max profit on buying & selling stock with buy paying transaction fee (Recursive Memoization): "
                + maxProfit);
    }

    public void buySellStocksWithTransactionFeeOnSell_DP_Memoization(int[] prices, int fee) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
        //space OPTIMIZED DP
        int n = prices.length;
        int sell = 0;
        int buy = -prices[0];

        for (int i = 1; i < n; i++) {
            int tempBuy = buy;
            buy = Math.max(buy, sell - prices[i]);
            sell = Math.max(sell, tempBuy + prices[i] - fee);
        }
        //output
        System.out.println("Max profit on buying & selling stock with buy paying transaction fee (SPACE OPTIMIZED DP): "
                + sell);
    }

    public void dominoTrominoTiling_DP_Memoization(int n) {
        //https://leetcode.com/problems/domino-and-tromino-tiling/description/
        //Explanation: https://youtu.be/Iwmn-gFL3c0
        /*
        ref this quest about the shape of domino or tromino
        2 * n board will look like board[2][n]
        if n == 1, board[2][1]
        this shape of board will hold only 1 domino in its vertical form
        ==> Num of ways = 1

        if n == 2, board[2][2]
        1. this shape of board will hold 2 domino in its vertical form
        in board[][] col 0 and 1
        2. this shape of board will hold 2 domino in its horizontal form
        in board[][] row 0 and 1
        ==> Num of ways = 2

        if n == 3, board[2][3]
        will have 5 ways to arrange domino and tromino, see ex in quest
        ==> Num of ways = 5

        **the pattern to solve this quest**

        n    =  1   2   3   4
        ways =  1   2   5   11

        how when n == 4 ways is 11, its the quest of mathematical sequence
        if n == 4 then 11 = 5 * 2 + 1
        that means ==> 11 = (ways[n - 1]) * 2 + (ways[n - 3])
        similarly
        if n == 5, (ways[n - 1]) * 2 + (ways[n - 3])
        ==> (ways[5 - 1] * 2) + ways[5 - 3]
        ==> (ways[4] * 2) + ways[2]
        ==> 11 * 2 + 2
        ==> 24

         */
        if (n == 1 || n == 2) {
            System.out.println("Number of ways to tile an 2 x n board: " + n);
            return;
        }
        int mod = 100000007;
        Integer[] memo = new Integer[n + 1];
        memo[1] = 1;
        memo[2] = 2;
        memo[3] = 5;
        for (int i = 4; i < n + 1; i++) {
            memo[i] = ((memo[i - 1] * 2) % mod + memo[i - 3] % mod) % mod;
        }
        //output
        System.out.println("Number of ways to tile an 2 x n board: " + (memo[n] % mod));
    }

    private int pallindromePartitioningTwo_Recursive_Memoization_Helper(
            String str, int startIndex, int length, Integer[] memo) {
        if (startIndex == length) {
            return 0;
        }

        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int minPartition = Integer.MAX_VALUE;

        for (int endIndex = startIndex; endIndex < length; endIndex++) {
            //if the prefix part of str (i.e, str, startIndex, endIndex) is
            //pallindrome, that means 1 partition can be made here and we can divide the
            //the problem into sub problem to check if substring[i + 1, length]
            //can also be partitioned as pallindrome and choose the min partitions
            if (isStringPallindrome(str, startIndex, endIndex)) {
                minPartition = Math.min(minPartition,
                        1 + pallindromePartitioningTwo_Recursive_Memoization_Helper(
                                str, endIndex + 1, length, memo));
            }
        }

        return memo[startIndex] = minPartition;
    }

    public void pallindromePartitioningTwo_Recursive_Memoization(String str) {
        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
        //Explanation: https://youtu.be/_H8V5hJUGd0
        //based on pallindromePartitioning_Backtracking()
        int n = str.length();
        Integer[] memo = new Integer[n];
        int minPartition = pallindromePartitioningTwo_Recursive_Memoization_Helper(str, 0, n, memo) - 1;
        //output
        System.out.println("Pallindrome partitioning two Recursive Memoization: " + minPartition);
    }

    public void pallindromePartitioningTwo_DP_Memoization(String str) {
        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
        //Explanation: https://youtu.be/_H8V5hJUGd0
        //based on bottom-up DP
        int n = str.length();
        Integer[] memo = new Integer[n + 1];
        memo[n] = 0;
        for (int startIndex = n - 1; startIndex >= 0; startIndex--) {
            int minPartition = Integer.MAX_VALUE;
            for (int endIndex = startIndex; endIndex < n; endIndex++) {
                if (isStringPallindrome(str, startIndex, endIndex)) {
                    minPartition = Math.min(minPartition, 1 + memo[endIndex + 1]);
                }
            }
            memo[startIndex] = minPartition;
        }

        //output
        System.out.println("Pallindrome partitioning two DP Memoization: " + (memo[0] - 1));
    }

    private boolean wildCardMatching_Recursive_Memoization_Helper(
            String str, String pattern, int strIndex, int patternIndex, Boolean[][] memo) {

        int m = str.length();
        int n = pattern.length();

        //return true, if both my strings str and pattern reaches the end,
        //meaning in the process whole pattern matched with str
        //ex: str = "abcd", pattern = "ab?d" ==> a == a, b == b, c == ?, d == d
        if (strIndex >= m && patternIndex >= n) {
            return true;
        }

        //return false, if patten only reached the end before the str reaches end,
        //meaning there are not enough chars(letter, ?, *) to match with chars in str
        //ex: str = "abcd", pattern = "ab?" ==> a == a, b == b, c == ?, d but pattern == pat.len
        //so pattern can't be matched with str fully
        if (patternIndex >= n) {
            return false;
        }

        //third cond has two possibilities, suppose our main string has reached its end
        //but pattern string is still left
        if (strIndex >= m && patternIndex < n) {

            //1. return false, if pattern[patternIndex to pat.length] are not * char, in that case
            //we don't have any chars left in str (because already at strIndex >= str.length)
            //so any char which is not *, can't be compared
            //ex: str = "abcd", pattern = "ab?d*e"
            //==> a == a, b == b, c == ?, d == d, '' == *, strIndex == str.length but pattern has 'e' left
            for (int remainingChar = patternIndex; remainingChar < n; remainingChar++) {
                if (pattern.charAt(remainingChar) != '*') {
                    return false;
                }
            }

            //2. return true, if pattern[patternIndex to pat.length] all are * char, in that case
            //each of this * char in pattern string can be considered as empty seq of chars ''
            //so if the remaining chars in pattern are all * char, we will consider all those
            //* chars as empty seq and hence at the end of pattern it will still match with str
            //ex: str = "abcd", pattern = "ab?d**"
            //==> a == a, b == b, c == ?, d == d, '' == *, '' == *
            return true;
        }

        if (memo[strIndex][patternIndex] != null) {
            return memo[strIndex][patternIndex];
        }

        //str[i] == pat[j] || pat[j] == '?'
        //ex: str = "abcd", pattern = "ab?d" now at strIndex == patternIndex == 2
        //either str[2] == pattern[2] == c OR pattern[2] == '?' because '?' means any char
        //then move to next indexes in both strings to check further
        if (str.charAt(strIndex) == pattern.charAt(patternIndex) || pattern.charAt(patternIndex) == '?') {

            return memo[strIndex][patternIndex]
                    = wildCardMatching_Recursive_Memoization_Helper(
                    str, pattern, strIndex + 1, patternIndex + 1, memo);

        }

        if (pattern.charAt(patternIndex) == '*') {

            return memo[strIndex][patternIndex] = /*
            now '*' char means it can match with any seq chars in string str
            //ex: str = "abxyzef", pattern = "ab*ef"
            //here a == a, b == b
            //but any of this can be true: '' == * OR x == * OR xy == * OR xyz == * OR xyze == * OR xyzef == *
            //so from above xyz == *, * matches seq of chars xyz
            //then e == e, f == f hence MATCHED
            //str: a | b | xyz | e | f
            //pat: a | b | *   | e | f
            //this includes call: (strIndex + 1, patternIndex) why?
            //because patternIndex remained at * char but strIndex moved to strIndex + 1 in dfs calls
            //this simulates picking up char as seq that can be matched with same * char
            //str: a | b | xyz | e | f
            //pat: a | b | *   | e | f
            //str[strIndex] = 'x',
            //str[strIndex + 1] = 'xy',
            //str[strIndex + 1] = 'xyz',
            //str[strIndex + 1] = 'xyze',
            //str[strIndex + 1] = 'xyzef',
            //pattern[patternIndex] = '*' */ wildCardMatching_Recursive_Memoization_Helper(
                    str, pattern, strIndex + 1, patternIndex, memo)
                    || /* also
            //ex: str = "abef", pattern = "ab*ef"
            //here a == a, b == b
            //but any of this can be true: '' == * OR e == * OR ef == *
            //so from above '' == *, * matches seq of chars '' i.e, empty seq
            //then e == e, f == f hence MATCHED
            //str: a | b | '' | e | f
            //pat: a | b | *  | e | f
            //this includes call: (strIndex, patternIndex + 1) why?
            //because strIndex remained same char but patternIndex moved to patternIndex + 1 in dfs calls
            //this simulates considering the * char as empty seq
            //str: a | b | '' | e | f
            //pat: a | b | *  | e | f
            //str[strIndex] = 'e',
            //pattern[patternIndex] = '*',
            //pattern[patternIndex + 1] = 'e' */ wildCardMatching_Recursive_Memoization_Helper(
                    str, pattern, strIndex, patternIndex + 1, memo);

        }

        //where nothing matches
        //neither it is ? nor * and both str & pattern chars also didn't match
        return memo[strIndex][patternIndex] = false;
    }

    public void wildCardMatching_Recursive_Memoization(String str, String pattern) {
        //https://leetcode.com/problems/wildcard-matching/description/
        //Explanation: https://youtu.be/ZmlQ3vgAOMo
        int m = str.length();
        int n = pattern.length();
        Boolean[][] memo = new Boolean[m + 1][n + 1];
        boolean wildCardPatternMatched = wildCardMatching_Recursive_Memoization_Helper(str, pattern, 0, 0, memo);
        //output
        System.out.println(str + ": string wildcard matching with pattern: " + pattern + " : " + wildCardPatternMatched);
    }

    private int maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
            int[][] piles, int pileIndex, int k, Integer[][] memo) {

        int n = piles.length;

        //as we picked all the k coins mean k == 0 picks available hence no more
        //coins can be picked now hence the value of coins is returned 0
        if (k <= 0) {
            return 0;
        }

        //as we have reached the limits of piles we have given, beyond this we
        //don't have any piles left to pick coins from hence the value of coins
        //is returned 0
        if (pileIndex >= n) {
            return 0;
        }

        //return value of coins, if cached this state earlier
        if (memo[pileIndex][k] != null) {
            return memo[pileIndex][k];
        }

        //max value of coins we can get by picking k coins from n piles, that we
        //need to maximize
        int maxValueOfCoinsPicked = 0;

        //2 choices we can mak here,
        //1. pick coins from curr pile @pileIndex then we have further possibilities
        //As we have to pick k coins in total,
        //1. chooses all the k coins from same pile @pileIndex
        //2. choose some coins from same pile @pileIndex but remaining coins
        //from other piles @(pileIndex + 1)
        int currValueOfCoinsPicked = 0;

        for (int i = 0; i < piles[pileIndex].length; i++) {

            //1. possibility is to pick all the k coins from same pile, pick some
            //coins(i + 1) add its value in currValueOfCoinsPicked
            //if we pick any i-th coins in sequence that means in total we picked
            //(i + 1) number of coins 'numberOfCoinsPicked'
            currValueOfCoinsPicked += piles[pileIndex][i];

            //as we can pick only k coins, what if all the k coins are from same pile
            //i.e, from any single pile @pileIndex, coins picked should be [1 to curr 'k']
            //coins, if i is i-th coin picked and added in currValueOfCoinsPicked that
            //means we in total picked 'numberOfCoinsPicked' from curr pile, that should
            //not exceed the curr 'k' (==> numberOfCoinsPicked > k : break)
            int numberOfCoinsPicked = i + 1;
            if (numberOfCoinsPicked > k) {
                break;
            }

            //2. here we picked some coins(==> numberOfCoinsPicked) from the curr
            //pile @pileIndex which gives the coins sum total as 'currValueOfCoinsPicked'
            //and remaining(== k - numberOfCoinsPicked) coins we will be picking from next
            //piles (== pileIndex + 1)
            int valueOfCoinsPickedFromRemaingPiles = maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
                    piles, pileIndex + 1, k - numberOfCoinsPicked, memo);

            //choose the max coins value we get from this combinations
            maxValueOfCoinsPicked = Math.max(
                    maxValueOfCoinsPicked,
                    currValueOfCoinsPicked + valueOfCoinsPickedFromRemaingPiles);
        }

        //2. don't pick the coin from curr pile but move to next pile(==> pileIndex + 1)
        //since we have not picked any coins from curr pile @pileIndex so the k remains same
        maxValueOfCoinsPicked = Math.max(
                maxValueOfCoinsPicked,
                maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
                        piles, pileIndex + 1, k, memo));

        return memo[pileIndex][k] = maxValueOfCoinsPicked;
    }

    public void maxValueFromKCoinsFromPiles_Recursive_Memoization(int[][] piles, int k) {
        //https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/
        Integer[][] memo = new Integer[piles.length + 1][k + 1];
        int maxValueFromKCoinsPicks = maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(piles, 0, k, memo);
        //output
        System.out.println("Max value from k coins picks from given piles: " + maxValueFromKCoinsPicks);
    }

    public void bestTeamWithNoConflict_DP_Memoization(int[] scores, int[] ages) {
        //https://leetcode.com/problems/best-team-with-no-conflicts/description/
        //based on LONGEST INCREASING SUBSEQ, longestIncreasingSubsequence_DP_Memoization()
        /*

        Here we need to find the longest non-decreasing subseq that can look like
        longest non-decreasing subseq ==> 5 <= 5 <= 6

        ex : scores = [4,5,6,5], ages = [2,1,2,1]

        as per question, we need to find the max score BUT without any conflict
        that is,
        A conflict exists if a younger player has a strictly higher score than
        an older player. A conflict does not occur between players of the same age.

        so for this reason, we will create a pair[][] ==> ageToScore and sort the
        pair in incr order their ages, if two ages are same then sort in incr
        order of their scores

        ageToScore[] =  [[2,4], [1,5], [2,6], [1,5]]
        sort(ageToScore) = [[1,5], [1,5], [2,4], [2,6]]
        ==> score = 5 5 4 6
        ==> age =   1 1 2 2

        now ages are already in incr order, as per question to avoid conflict
        we must choose those scores that are in non-decreasing order

        that 5 <= 5 <= 6

         */
        int n = scores.length;
        int[][] agesToScore = new int[n][2];
        for (int i = 0; i < n; i++) {
            agesToScore[i] = new int[]{ages[i], scores[i]};
        }

        //sort the given input according to their ages
        //if the ages are same, sort them incr order of their scores else incr
        //order of ages
        Arrays.sort(agesToScore, (a, b) -> a[0] == b[0]
                ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));

        int[] longestIncrMaxScores = new int[n];
        int maxScores = 0;
        //for each i-th index the max scores is their respec i-th scores[i]
        for (int i = 0; i < n; i++) {
            longestIncrMaxScores[i] = agesToScore[i][1];
            maxScores = Math.max(maxScores, agesToScore[i][1]);
        }

        //based on longest incr subseq, here we are finding longest non-decreasing
        //max scores
        for (int i = 1; i < n; i++) {

            for (int j = 0; j < i; j++) {

                if (agesToScore[i][1] >= agesToScore[j][1]
                        && longestIncrMaxScores[i] <= longestIncrMaxScores[j] + agesToScore[i][1]) {

                    longestIncrMaxScores[i] = longestIncrMaxScores[j] + agesToScore[i][1];
                }
            }
            maxScores = Math.max(maxScores, longestIncrMaxScores[i]);
        }
        //output
        System.out.println("Best team with no conflict: " + maxScores);
    }

    public void greatestSumDivisibleByThree_DP_Memoization(int[] nums) {
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/description/
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/solutions/431077/java-c-python-one-pass-o-1-space/
        /*

        As asked by question, we need max sum that is divisble by 3

        now, observe that if we divide any number X with 3, we get either or
        these three remainders i.e, 0, 1, 2
        ex:
        0 % 3 = 0
        1 % 3 = 1
        2 % 3 = 2
        3 % 3 = 0
        4 % 3 = 1
        5 % 3 = 2

        and so on...

        that what memo of size 3 is for, each index of memo represent a remainder
        now since we want 'max sum that is exactly divisible by 3' that means
        whatever this sum be when we mod it with 3 ==> sum % 3 should be 0
        meaning remainder = 0 ==> memo[0] is where max sum will be stored
        memo[0] will be updated with possible max sum in between divisble by 3

        iterations:

        ex: nums[] = [3,6,5,1,8]
        memo = [0, 0, 0]

        val = 3
        ==> 1. remainder = 0 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 3) % 3] = max(memo[(0 + 3) % 3], 0 + 3)
        ===> memo[0] = max(memo[0], 3) ==> max(0, 3) ==> 3

        ==> 2. remainder = 1 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 3) % 3] = max(memo[(0 + 3) % 3], 0 + 3)
        ===> memo[0] = max(memo[0], 3) ==> max(0, 3) ==> 3

        ==> 3. remainder = 2 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 3) % 3] = max(memo[(0 + 3) % 3], 0 + 3)
        ===> memo[0] = max(memo[0], 3) ==> max(0, 3) ==> 3

        //val = 3 sum = 3 which is divisible by 3 sum % 3 ==> memo[0] = 3
        memo[] ==> [3, 0, 0]

        val = 6
        ==> 1. remainder = 0 & sum ==> prevState = 3
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(3 + 6) % 3] = max(memo[(3 + 6) % 3], 3 + 6)
        ===> memo[0] = max(memo[0], 9) ==> max(3, 9) ==> 9

        ==> 2. remainder = 1 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(3 + 6) % 3] = max(memo[(3 + 6) % 3], 3 + 6)
        ===> memo[0] = max(memo[0], 9) ==> max(3, 9) ==> 9

        ==> 3. remainder = 2 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(3 + 6) % 3] = max(memo[(3 + 6) % 3], 3 + 6)
        ===> memo[0] = max(memo[0], 9) ==> max(3, 9) ==> 9

        //val = 6 sum = 3 + 6 = 9 which is divisible by 3 sum % 3 ==> memo[0] = 9
        memo[] ==> [9, 0, 0]

        val = 5
        ==> 1. remainder = 0 & sum ==> prevState = 9
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(9 + 5) % 3] = max(memo[(9 + 5) % 3], 9 + 5)
        ===> memo[2] = max(memo[2], 9) ==> max(0, 14) ==> 14

        ==> 2. remainder = 1 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 5) % 3] = max(memo[(0 + 5) % 3], 0 + 5)
        ===> memo[2] = max(memo[2], 9) ==> max(0, 5) ==> 5

        ==> 3. remainder = 2 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 5) % 3] = max(memo[(0 + 5) % 3], 0 + 5)
        ===> memo[2] = max(memo[2], 9) ==> max(5, 14) ==> 14

        //val = 5 but this won't be summed for remainder  = 0, but for remainder = 2
        memo[] ==> [9, 0, 14]

        val = 1
        ==> 1. remainder = 0 & sum ==> prevState = 9
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(9 + 1) % 3] = max(memo[(9 + 1) % 3], 9 + 1)
        ===> memo[1] = max(memo[1], 9) ==> max(0, 10) ==> 10

        ==> 2. remainder = 1 & sum ==> prevState = 0
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(0 + 1) % 3] = max(memo[(0 + 1) % 3], 0 + 1)
        ===> memo[1] = max(memo[1], 1) ==> max(10, 1) ==> 10

        ==> 3. remainder = 2 & sum ==> prevState = 14
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(14 + 1) % 3] = max(memo[(14 + 1) % 3], 14 + 1)
        ===> memo[0] = max(memo[0], 9) ==> max(9, 15) ==> 15

        //val = 1 sum = 3 + 6 + 5 + 1 = 15 which is divisible by 3 sum % 3 ==> memo[0] = 15
        memo[] ==> [15, 10, 14]

        val = 8
        ==> 1. remainder = 0 & sum ==> prevState = 15
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(15 + 8) % 3] = max(memo[(15 + 8) % 3], 15 + 8)
        ===> memo[2] = max(memo[2], 9) ==> max(14, 23) ==> 23

        ==> 2. remainder = 1 & sum ==> prevState = 10
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(10 + 8) % 3] = max(memo[(10 + 8) % 3], 10 + 8)
        ===> memo[0] = max(memo[0], 9) ==> max(15, 18) ==> 18

        ==> 3. remainder = 2 & sum ==> prevState = 14
        ==> memo[(prevState + val) % 3] = max(memo[(prevState + val) % 3], prevState + val);
        ===> memo[(14 + 8) % 3] = max(memo[(14 + 8) % 3], 14 + 8)
        ===> memo[1] = max(memo[1], 22) ==> max(10, 22) ==> 22

        //val = 1 sum = 3 + 6 + 1 + 8 = 18 which is divisible by 3 sum % 3 ==> memo[0] = 18
        memo[] ==> [18, 22, 23]

        max sum divisible by 3 = memo[0] = 18

         */
        int[] memo = new int[3];
        for (int val : nums) {
            //Array.copyOf() creates the prevMemo array of memo while changing
            //memo at the same time
            for (int prevState : Arrays.copyOf(memo, memo.length)) {
                memo[(prevState + val) % 3] = Math.max(memo[(prevState + val) % 3], prevState + val);
            }
        }
        //output
        System.out.println("Greatest sum divisible by three: " + memo[0]);
    }

    private int minCostForTickets_Recursive_Memoization_Helper(
            int[] days, int[] costs, int index, int passExpiryDay, Integer[] memo) {

        //if we have reached the end of the days[] means further we need not to
        //buy tickets/ pass, so cost becomes 0
        if (index >= days.length) {
            return 0;
        }

        //previously, we have bought pass/ tickets that will allow us to travel
        //some days. Assume prev, on day X we bought a pass/ tickets:
        //1-day pass: it would have used for day X only so passExpiryDay == 0
        //7-days pass: it would be used untill (X + 6) days == passExpiryDay
        //30-days pass: it would be used untill (X + 29) days == passExpiryDay
        //so if curr days[index] <= passExpiryDay == allowed no. of days through pass
        //we will move to next day(== index + 1) as long as we are allowed until
        //passExpiryDay
        if (days[index] <= passExpiryDay) {
            return minCostForTickets_Recursive_Memoization_Helper(
                    days, costs, index + 1, passExpiryDay, memo);
        }

        //cached
        if (memo[index] != null) {
            return memo[index];
        }

        //since we have 3 diff passes to choose from, so we will try to get minCost
        //out of 3-passes as available options
        //cost[0] == 1-day pass: already used for curr day @index so this pass can't
        //be used further hence passExpiryDay == 0 and we will just move to next
        //day(== index + 1)
        int minCost = costs[0] + minCostForTickets_Recursive_Memoization_Helper(
                days, costs, index + 1, 0, memo);

        //cost[1] == 7-day pass: already used for curr day @index and can be
        //used for next 6 more days hence passExpiryDay == days[index] + 6
        //and we will just move to next day(== index + 1)
        minCost = Math.min(minCost, costs[1] + minCostForTickets_Recursive_Memoization_Helper(
                days, costs, index + 1, days[index] + 6, memo));

        //cost[2] == 30-day pass: already used for curr day @index and can be
        //used for next 29 more days hence passExpiryDay == days[index] + 29
        //and we will just move to next day(== index + 1)
        minCost = Math.min(minCost, costs[2] + minCostForTickets_Recursive_Memoization_Helper(
                days, costs, index + 1, days[index] + 29, memo));

        return memo[index] = minCost;
    }

    public void minCostForTickets_Recursive_Memoization(int[] days, int[] costs) {
        //https://leetcode.com/problems/minimum-cost-for-tickets/description/
        //explanation: https://youtu.be/4pY1bsBpIY4
        //given days[] is already sorted
        int n = days.length;
        Integer[] memo = new Integer[n];
        int minCost = minCostForTickets_Recursive_Memoization_Helper(days, costs, 0, 0, memo);
        //output
        System.out.println("Min cost for tickets: " + minCost);
    }

    private int reducingDishes_Recursive_Memoization_Helper(
            int[] satisfaction, Integer[][] memo, int index, int currTime) {

        //if we have traversed all the dishes, there will no more dishes to
        //calulate like-time coeff value so return 0
        if (index >= satisfaction.length) {
            return 0;
        }

        if (memo[index][currTime] != null) {
            return memo[index][currTime];
        }

        //two options to decide
        //1. Cook the dish at curr index with the time taken as currTime
        //and move on to the next dish(== index + 1) with time as currTime + 1
        int pick = (satisfaction[index] * currTime) + reducingDishes_Recursive_Memoization_Helper(
                satisfaction, memo, index + 1, currTime + 1);

        // 2. Skip the current dish and move on to the next(== index + 1)
        //dish at the same time
        int dontPick = reducingDishes_Recursive_Memoization_Helper(
                satisfaction, memo, index + 1, currTime);

        //maximize the like-time coeff, so chose the one that gives the max
        return memo[index][currTime] = Math.max(pick, dontPick);
    }

    public void reducingDishes_Recursive_Memoization(int[] satisfaction) {
        //https://leetcode.com/problems/reducing-dishes/description/
        int n = satisfaction.length;
        Integer[][] memo = new Integer[n + 1][n + 1];
        Arrays.sort(satisfaction);
        int likeTimeCoeff = reducingDishes_Recursive_Memoization_Helper(satisfaction, memo, 0, 1);
        //output
        System.out.println("Max like time coefficient: " + likeTimeCoeff);
    }

    private boolean scrambledStrings_Recursive_Memoization_Helper(
            String str1, String str2, Map<String, Boolean> memo) {

        int n = str1.length();

        //if both strings are not equal in size
        if (str2.length() != n) {
            return false;
        }

        //if both strings are equal
        if (str1.equals(str2)) {
            return true;
        }

        //if we have reached to this condition then following are sure:
        //1. size of both string is equal
        //2. string are not equal
        //because above two if cond have failed
        //so size is equal(== 1) and they are not equal then obviously false
        //example 'a' and 'b' string are not equal, size is equal
        if (n == 1) {
            return false;
        }

        //if already cached
        String key = str1 + "," + str2;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        // for every iteration it can two condition
        // 1.we should proceed without swapping
        // 2.we should swap before looking next
        for (int i = 1; i < n; i++) {
            // ex of without swap: gr|eat and rg|eat
            boolean isScrambledWithoutSwap = ( // left part of first and second string
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(0, i), str2.substring(0, i), memo)
                            && // right part of first and second string;
                            scrambledStrings_Recursive_Memoization_Helper(str1.substring(i), str2.substring(i), memo));

            // if without swap give us right answer then we do not need
            // to call the recursion withswap
            if (isScrambledWithoutSwap) {
                memo.put(key, true);
                return true;
            }

            // ex of withswap: gr|eat rge|at
            // here we compare "gr" with "at" and "eat" with "rge"
            boolean isScrambledWithSwap = ( // left part of first and right part of second
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(0, i), str2.substring(n - i), memo)
                            && // right part of first and left part of second
                            scrambledStrings_Recursive_Memoization_Helper(str1.substring(i), str2.substring(0, n - i), memo));

            // if with swap give us right answer then we return true
            // otherwise the for loop do it work
            if (isScrambledWithSwap) {
                memo.put(key, true);
                return true;
            }
            // we are not returning false in else case
            // because we want to check further cases with the for loop
        }

        //if in above for() we have not encountered return true means the
        //curr strings str1 & str2 are not scrambled
        memo.put(key, false);

        return false;
    }

    public void scrambledStrings_Recursive_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/scramble-string/description/
        //https://leetcode.com/problems/scramble-string/solutions/3357439/easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation/
        //explanation: https://youtu.be/Fx96uB9EIDQ
        Map<String, Boolean> memo = new HashMap<>();
        System.out.println("Strings scrambled: "
                + scrambledStrings_Recursive_Memoization_Helper(str1, str2, memo));
    }

    private int numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
            int ROW, int COL, int[][] prefixSum, Integer[][][] memo, int row, int col, int currCut) {

        //if the pizza cut segment with row & col don't have apples, then this
        //can be valid cut return 0
        if (prefixSum[row][col] == 0) {
            return 0;
        }

        //return 1 as possible way, if we have made all the valid-cuts and now
        //our currCut == 0 means we have cut pizza into k pieces
        if (currCut == 0) {
            return 1;
        }

        //cached, since currCut, row, col are the changing parameters
        if (memo[currCut][row][col] != null) {
            return memo[currCut][row][col];
        }

        int mod = 1000000007;
        int ways = 0;

        //below we are making the horizontal cuts(== hCut, row wise cuts)
        //but before we move next hCut we must check the curr cut at
        //horzonatal-index == row should have apples
        //(== prefixSum[row][col] - prefixSum[hCut][col] > 0)
        //if curr cut has apples > 0 we move to sub-problem recursively to make
        //next horizontal cut hCut and since we make cut at curr row so for next
        //currCut - 1
        for (int hCut = row + 1; hCut < ROW; hCut++) {
            if (prefixSum[row][col] - prefixSum[hCut][col] > 0) {
                ways = (ways + numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                        ROW, COL, prefixSum, memo, hCut, col, currCut - 1)) % mod;
            }
        }

        //below we are making the vertical cuts(== vCut, col wise cuts)
        //but before we move next vCut we must check the curr cut at
        //vertical-index == col should have apples
        //(== prefixSum[row][col] - prefixSum[row][vCut] > 0)
        //if curr cut has apples > 0 we move to sub-problem recursively to make
        //next vertical cut vCut and since we make cut at curr col so for next
        //currCut - 1
        for (int vCut = col + 1; vCut < COL; vCut++) {
            if (prefixSum[row][col] - prefixSum[row][vCut] > 0) {
                ways = (ways + numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                        ROW, COL, prefixSum, memo, row, vCut, currCut - 1)) % mod;
            }
        }

        return memo[currCut][row][col] = ways;
    }

    public void numberOfWaysOfCuttingPizza_Recursive_Memoization(String[] pizza, int k) {
        //https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description/
        //Explanation: https://www.youtube.com/watch?j=g2D-HymlQqQ&t=608s
        int ROW = pizza.length;
        int COL = pizza[0].length();
        Integer[][][] memo = new Integer[k][ROW][COL];
        int[][] prefixSum = new int[ROW + 1][COL + 1];

        for (int r = ROW - 1; r >= 0; r--) {

            for (int c = COL - 1; c >= 0; c--) {

                prefixSum[r][c] = prefixSum[r][c + 1]
                        + prefixSum[r + 1][c]
                        - prefixSum[r + 1][c + 1]
                        + (pizza[r].charAt(c) == 'A' ? 1 : 0);
            }
        }

        int waysToCutPizza = numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                ROW, COL, prefixSum, memo, 0, 0, k - 1);
        //output
        System.out.println("Ways to cut pizza: " + waysToCutPizza);
    }

    private int targetSum_Recursive_Memoization_Helper(
            int[] nums, int target, Map<String, Integer> memo, int index, int currSum) {

        //if there are no elements to pick from the array, then we will have to
        //check if our currSum becomes target or not
        if (index >= nums.length) {
            return currSum == target ? 1 : 0;
        }

        String key = index + "," + currSum;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int ways = 0;

        //2 options to choose from, either we will add or subtract the num @index
        //if by adding or subtracting currSum becomes equal to target at the end
        //of the array, we will get 1 way for making sum equal to target otherwise 0
        //1. we will add the curr num @index and we will move to next index
        //(== index + 1) hence our currSum will be currSum + nums[index]
        ways += targetSum_Recursive_Memoization_Helper(
                nums, target, memo, index + 1, currSum + nums[index]);
        //2. we will subtract the curr num @index and we will move to next index
        //(== index + 1) hence our currSum will be currSum - nums[index]
        ways += targetSum_Recursive_Memoization_Helper(
                nums, target, memo, index + 1, currSum - nums[index]);

        memo.put(key, ways);
        return ways;
    }

    public void targetSum_Recursive_Memoization(int[] nums, int target) {
        //https://leetcode.com/problems/target-sum/description/
        //explanation: https://youtu.be/g0npyaQtAQM
        Map<String, Integer> memo = new HashMap<>();
        int ways = targetSum_Recursive_Memoization_Helper(
                nums, target, memo, 0, 0);
        //output
        System.out.println("Target sum : " + ways);
    }

    private long waysToFormStringFromDict_Recursive_Memoization_Helper(
            int wordLen, String target, int[][] charFreqAtEachWordIndex,
            int targetCharIndex, int wordCharIndex, Integer[][] memo) {

        int mod = 1000000007;

        //since we have to make target string from dict words[] so if in making
        //this target string we reached where target-char-index is at end of target
        //string means we have successfully created this target so return 1
        if (targetCharIndex >= target.length()) {
            return 1;
        }

        //if the above if() cond didn't fulfil and at this cond we already exhaust
        //all the word-char-index to travel further means there are no more chars
        //in any of the word in words[] to form target string so return 0;
        if (wordCharIndex >= wordLen) {
            return 0;
        }

        //if already cached
        if (memo[targetCharIndex][wordCharIndex] != null) {
            return memo[targetCharIndex][wordCharIndex];
        }

        //don't pick the char at curr word char index
        //1. since we have to make the target string as a result means we can't
        //skip the char from target string at curr targetCharIndex but we can skip the
        //char of the word at wordCharIndex to be used in target and move to
        //(wordCharIndex + 1)
        long ways = waysToFormStringFromDict_Recursive_Memoization_Helper(
                wordLen, target, charFreqAtEachWordIndex, targetCharIndex, wordCharIndex + 1, memo);

        //pick the char at curr word char index
        //2. here we are picking the char targetChar which will also be there in
        //words of words[], now we are picking this 'targetChar' from wordCharIndex
        //of the word, but the catch here is, there can be many words in words[]
        //that will have same 'targetChar' at wordCharIndex means there will be
        //that many ways to form our target string. That's why we have precomputed
        //the freq of char of all the words at particular word-char-index
        //ex: target = "aba", targetCharIndex = 0,
        //means we will pick targetChar = 'a' to be choosen from the words in word[]
        //lets say words[] = ["abba", "bbbb", "acac"] at wordCharIndex = 0, we
        //have two strings "abba", "acac" so our,
        //charFreqAtEachWordIndex[wordCharIndex][targetChar - 'a'] will have freq
        //charFreqAtEachWordIndex[0]['a'] = 2
        char targetChar = target.charAt(targetCharIndex);
        long pickWordCharIndex = charFreqAtEachWordIndex[wordCharIndex][targetChar - 'a']
                * waysToFormStringFromDict_Recursive_Memoization_Helper(
                wordLen, target, charFreqAtEachWordIndex, targetCharIndex + 1, wordCharIndex + 1, memo);

        ways += pickWordCharIndex;

        return memo[targetCharIndex][wordCharIndex] = (int) (ways % mod);
    }

    public void waysToFormStringFromDict_Recursive_Memoization(String[] words, String target) {
        //https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/
        //explanation: https://youtu.be/_GF-0T-YjW8
        int targetLen = target.length();
        //all the words in given words[] dict is of same length
        int wordLen = words[0].length();

        //let say a word is "abcd", wordLen = 4 then each char-index = [0 to 3]
        //now if there are N words in words[] having same lengths then with
        //charFreqAtEachWordIndex[][] arrays we count freq of chars at curr
        //char-index for all the words
        /*
        words[] = [["acca","bbbb","caca"], wordLen = words[0].length = "acca".length()
        wordLen = 4, charFreqAtEachWordIndex[wordLen][26]

        char-index  |    words[]    | charFreqAtEachWordIndex[wordLen][26]
        0               a   b   c       0 = [a = 1, b = 1, c = 1]
        1               c   b   a       1 = [a = 1, b = 1, c = 1]
        2               c   b   c       2 = [a = 0, b = 1, c = 2]
        3               a   b   a       3 = [a = 2, b = 1, c = 0]

         */
        int[][] charFreqAtEachWordIndex = new int[wordLen][26];
        for (String word : words) {
            for (int index = 0; index < wordLen; index++) {
                char wordChar = word.charAt(index);
                charFreqAtEachWordIndex[index][wordChar - 'a']++;
            }
        }

        Integer[][] memo = new Integer[targetLen][wordLen];
        long ways = waysToFormStringFromDict_Recursive_Memoization_Helper(
                wordLen, target, charFreqAtEachWordIndex, 0, 0, memo);

        //output
        System.out.println("Number of ways to form string from given dictionary : " + ways);
    }

    private int profitableScheme_Recursive_Memoization_Helper(int n, int minProfit, int[] groups, int[] profits,
                                                              int index, int currProfit, int members, Integer[][][] memo) {

        int mod = 1000000007;

        //if we have reached the end of our profits[] means we can't go further
        //to pick anything, from here if our currProfit is 'atleast' minProft
        //return 1
        if (index >= profits.length) {
            return currProfit >= minProfit ? 1 : 0;
        }

        if (memo[index][currProfit][members] != null) {
            return memo[index][currProfit][members];
        }

        int ways = 0;

        //there are 2 choices to make here,
        //1. if we don't pick, the group @index then the members of groups[index]
        //will not be counted and profit from this group as profit[index] will
        //also not be counted, and we move to next index as (index + 1) and
        //skip curr value
        ways = profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                index + 1,
                currProfit,
                members,
                memo);

        //2. if we choose to pick, the group @index then the members of groups[index]
        //will be counted and profit from this group as profit[index] will
        //also be counted, and we move to next index as (index + 1)
        //but here's a catch
        //while picking members from groups[] we can't take members more than
        //given n value, so if adding member from group[index] into our 'members'
        //is still less than n, we will proceed(== members + groups[index] <= n)
        if (members + groups[index] <= n) {
            ways = (ways
                    + profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                    index + 1,
                    //to be in bounds of memo[][][] we are picking min of profits
                    //because in base cond above we only want our currProfit to
                    //be 'atleast' minProfit
                    Math.min(minProfit, currProfit + profits[index]),
                    members + groups[index],
                    memo)) % mod;
        }

        return memo[index][currProfit][members] = ways;
    }

    public void profitableScheme_Recursive_Memoization(int n, int minProfit, int[] groups, int[] profits) {
        /*
        ........................T: O(NMK)
        We have three parameters index, count and profit. The index can vary
        from 0 to M - 1, and the count can again vary from 0 to N - 1 (as we
        consider crime only if it doesn't exceed the limit of N), the last
        param profit can vary largely but since we cap its value to minProfit
        it values can vary from 0 to minProfit. We need to calculate the answer
        to each of these states to solve the original problem; hence the total
        computation would be O(NMK).

        ........................S: O(NMK)
        The size of memo would equal the number of states as (NMK). Although
        we used the maximum value of 101 in the code to simplify things,
        we can also use the original values in the input as the size of memo.
        Also, there would be some space in the recursion as well, the total
        number of active recursion calls could be NNN one for each crime, and
        hence the total recursion space would be O(N).
         */
        //https://leetcode.com/problems/profitable-schemes/description/
        //explanation: https://youtu.be/CcLKQLKvOl8
        /*
        Constraints:

        1 <= n <= 100
        0 <= minProfit <= 100
        1 <= group.length <= 100
        1 <= group[i] <= 100
        profit.length == group.length
        0 <= profit[i] <= 100
         */
        int len = groups.length;
        Integer[][][] memo = new Integer[len + 1][minProfit + 1][n + 1];
        int ways = profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                0, 0, 0, memo);
        //output
        System.out.println("Ways to have profitable scheme : " + ways);
    }

    private int restoreArray_Recursive_Memoization_Helper(String str, int k, int startIndex, Integer[] memo) {

        int mod = 1000000007;
        int n = str.length();

        //return 1, if we have reached the end of the str meaning in the process
        //of restoring the array we have successfully restored it where all the
        //array elements are in the range of [1, k]
        if (startIndex >= n) {
            return 1;
        }

        //return 0, if the starting of possible new array element from this
        //startIndex is having leading 0s ex: 01, 034 no new array element should
        //be formed with a leading 0 in it
        if (str.charAt(startIndex) == '0') {
            return 0;
        }

        //if cached
        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int ways = 0;

        for (int endIndex = startIndex; endIndex < n; endIndex++) {
            //form a new array element between start and end inclusive
            //alternative to use of substring(), we can form number as
            //number = number * 10 + (str.charAt(endIndex) - '0'), declare
            //int number = 0 above this loop
            String arrElement = str.substring(startIndex, endIndex + 1);
            //check if this new array element is bigger than k then we can't go
            //further from here it will always be bigger than k only, so break
            if (Long.parseLong(arrElement) > k) {
                break;
            }

            //if the curr array element formed as 'arrElement' is in the range
            //then we can move further to form new array elements,
            //since we have considered a num from [startIndex, endIndex] so
            //the next num should start from (endIndex + 1)
            ways = (ways
                    + restoreArray_Recursive_Memoization_Helper(str, k, endIndex + 1, memo)) % mod;
        }
        return memo[startIndex] = ways;
    }

    public void restoreArray_Recursive_Memoization(String str, int k) {
        /*
        .........................T: O(n * Logk)
        We create memo of length n + 1 for memory, it takes O(n) steps to update them.
        At each step s[start], we look for all possible ending index end. In the
        worst-case scenario, we will iterate over Logk indexes before currNumber
        is larger than k, because each iteration increases currNumber by a magnitude.
        To sum up, the overall time complexity is O(n * Logk)

        .........................S: O(n)
        We create an array memo of length n + 1.

         */
        //https://leetcode.com/problems/restore-the-array/description/
        int n = str.length();
        Integer[] memo = new Integer[n + 1];
        int ways = restoreArray_Recursive_Memoization_Helper(str, k, 0, memo);
        //output
        System.out.println("Ways to restore the array where elements range between[1, k] : " + ways);
    }

    public void restoreArray_DP_Memoization(String str, int k) {
        /*
        .........................T: O(n * Logk)
        We create memo of length n + 1 for memory, it takes O(n) steps to update them.
        At each step s[start], we look for all possible ending index end. In the
        worst-case scenario, we will iterate over Logk indexes before currNumber
        is larger than k, because each iteration increases currNumber by a magnitude.
        To sum up, the overall time complexity is O(n * Logk)

        .........................S: O(n)
        We create an array memo of length n + 1.

         */
        //https://leetcode.com/problems/restore-the-array/description/
        int mod = 1000000007;
        int n = str.length();
        int[] memo = new int[n + 1];
        memo[0] = 1;

        for (int startIndex = 0; startIndex < n; startIndex++) {
            if (str.charAt(startIndex) == '0') {
                continue;
            }
            for (int endIndex = startIndex; endIndex < n; endIndex++) {

                String arrElement = str.substring(startIndex, endIndex + 1);

                if (Long.parseLong(arrElement) > k) {
                    break;
                }

                memo[endIndex + 1] = (memo[endIndex + 1] + memo[startIndex]) % mod;
            }
        }

        //output
        System.out.println("Ways to restore the array where elements range between[1, k] (DP Memoization): "
                + memo[n]);
    }

    private int waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(
            String nums, int k, int m, int startIndex, int currPartition, Integer[][] memo) {

        int mod = 1000000007;
        int n = nums.length();

        //return 1, only if we have reached the end of our string and no further
        //digit we can pick from nums str also in process till here we should have
        //made currPartiton == k, if currPartition != k return 0
        if (startIndex >= n) {
            return (currPartition == k) ? 1 : 0;
        }

        //one of the requirement is that the partition of string we are making
        //it should start with an even digit, so here if the digit @startIndex
        //of nums str is not even then further in the loop below it will never
        //have first digit as even, return 0 then
        if ((nums.charAt(startIndex) - '0') % 2 != 0) {
            return 0;
        }

        //if cached
        if (memo[startIndex][currPartition] != null) {
            return memo[startIndex][currPartition];
        }

        int ways = 0;

        //generate valid partitons
        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //currNum is the partiton that will be formed from the nums str
            //[startIndex, endIndex] inclusive
            String currNum = nums.substring(startIndex, endIndex + 1);

            //one of the requiremnet is, the partition that we generating here
            //should have 'atleast' m length (means currNum.length >= m), if its
            //less than m(== currNum.length < m) then continue, add more digits to
            //currNum
            if (currNum.length() < m) {
                continue;
            }

            //one of the requirement is, the partition that we generating here
            //should have a last digit as odd, so here we are checking the same
            //if currNum's last digit (== currNum.length - 1) is not odd then
            //continue, add more digits to currNum
            if ((currNum.charAt(currNum.length() - 1) - '0') % 2 != 1) {
                continue;
            }

            //till here we will generate a partition as 'currNum' that will full
            //fill our requirements, then from here we can try to form another
            //partition from the remaining nums str (== endIndex + 1) and we made
            //valid partition here so for next partition we have (currPartition + 1)
            ways = (ways
                    + waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(
                    nums, k, m, endIndex + 1, currPartition + 1, memo)) % mod;
        }

        return memo[startIndex][currPartition] = ways;
    }

    public void waysToMakeKPartitionStringOfMLength_Recursive_Memoization(String nums, int k, int m) {
        //https://leetcode.com/discuss/interview-question/2257966/Google-OA
        /*
        You are given a string S of lenght N of digits 0 - 9. You need to partiton
        strings into K substrings such that

        1. Each substring has a minimum lenght of M
        2. Substring must start with even digit and ends with odd digit number

        Determine the number of ways to partition the strings which satisfy the
        above condition. You should find answer modulo 1e9 + 7

        constraints :
        1 <= n<= 2x10^3
        1<= m<= n
        1<=k<=n
         */
        int n = nums.length();
        Integer[][] memo = new Integer[n + 1][k + 1];
        int ways = waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(nums, k, m, 0, 0, memo);
        //output
        System.out.println("Ways to make K partiton strings each of length M : " + ways);
    }

    private int combinationSumFour_Recursive_Memoization_Helper(
            int[] nums, int target, int index, Integer[][] memo) {

        int n = nums.length;

        //if we have reached the end of the nums[] from where we can't pick any
        //more values, then we check if our target value becomes exactly 0 or not
        //return 1 if target becomes 0 else 0
        if (index >= n) {
            return target == 0 ? 1 : 0;
        }

        if (memo[index][target] != null) {
            return memo[index][target];
        }

        int ways = 0;

        //two choice we have here,
        //1. don't pick the num @index from nums[] then target will remain same
        //and we will move to next index (== index + 1)
        ways += combinationSumFour_Recursive_Memoization_Helper(nums, target, index + 1, memo);

        //2. pick the num @index and then target will be reduced by nums[index]
        //(== target - nums[index]) also that we can pick number multiple times
        //from the starting of nums[] hence index needs to start from 0 again
        //also to keep in mind, we pick any number @index from nums[] should be
        //less than the target itself because if nums[index] > target then (==
        //target - nums[index] becomes negative but we needs to be in bounds of
        //memo[][]), so always check if(nums[index] <= target)
        if (nums[index] <= target) {
            ways += combinationSumFour_Recursive_Memoization_Helper(
                    nums, target - nums[index], 0, memo);
        }
        return memo[index][target] = ways;
    }

    public void combinationSumFour_Recursive_Memoization(int[] nums, int target) {
        //https://leetcode.com/problems/combination-sum-iv/description/
        int n = nums.length;
        Integer[][] memo = new Integer[n + 1][target + 1];
        //sort the nums[] so that we limit our traversal, means if any nums[index]
        //is greater than target itself then subtracting nums[index] from target
        //(== target - nums[index]) will be negative, avoid this case
        Arrays.sort(nums);
        int ways = combinationSumFour_Recursive_Memoization_Helper(nums, target, 0, memo);
        //output
        System.out.println("Combination sum four : " + ways);
    }

    private int waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
            int startPos, int endPos, int k, Map<String, Integer> memo) {

        int mod = 1000000007;

        //return 0, if we have used all our k steps
        if (k < 0) {
            return 0;
        }

        //if we have used exactly k steps(k == 0) then
        //return 1 only if startPos == endPos else return 0
        if (k == 0) {
            return (startPos == endPos) ? 1 : 0;
        }

        //if cached, Map<String, Integer> is used here because startPos could go
        //-ve which will not fall in bounds of memo[startPos][k]
        String key = startPos + "," + k;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int ways = 0;
        //two choices to make here,

        //1. in one steps (k - 1) we can go left from startPos(== startPos - 1)
        ways = (ways + waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos - 1, endPos, k - 1, memo)) % mod;

        //2. in one steps (k - 1) we can go right from startPos(== startPos + 1)
        ways = (ways + waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos + 1, endPos, k - 1, memo)) % mod;

        memo.put(key, ways);
        return ways;

    }

    public void waysToReachAPositionAfterKSteps_Recursive_Memoization(int startPos, int endPos, int k) {
        //https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/
        Map<String, Integer> memo = new HashMap<>();
        int ways = waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos, endPos, k, memo);
        //output
        System.out.println("Ways to reach from start pos to end post in exactly k steps : " + ways);
    }

    private int waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization_Helper(
            int length, int steps, int index, Map<String, Integer> memo) {

        int mod = 1000000007;

        //if 'index' ptr is not in the range of array's length i.e, [0 to length - 1]
        //that means 'index' gone out of the array bounds hence this can't be
        //counted as a way hence return 0
        if (!(0 <= index && index < length)) {
            return 0;
        }

        //here, above if() block didn't execute meaning 'index' is still inside the
        //array's bounds [0 to length - 1] so we check if we have used all the steps
        //then at this moment the 'index' points to 0, if yes return 1 as there
        //we found 1 way 'such that your pointer is still at index 0 after exactly 'steps''
        if (steps == 0) {
            return index == 0 ? 1 : 0;
        }

        String subProblemState = index + "," + steps;

        if (memo.containsKey(subProblemState)) {
            return memo.get(subProblemState);
        }

        int ways = 0;

        //3 choices we have here
        //1. we can choose to stay at same 'index' but also to mention
        //staying at same position will also be counted as a valid step
        //hence (steps - 1)
        ways = (ways + waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization_Helper(
                length, steps - 1, index, memo)) % mod;

        //2. we can choose to move 'index' to 1 position left and this
        //is also valid step (==> steps - 1) and move to left (==> index - 1)
        ways = (ways + waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization_Helper(
                length, steps - 1, index - 1, memo)) % mod;

        //2. we can choose to move 'index' to 1 position right and this
        //is also valid step (==> steps - 1) and move to right (==> index + 1)
        ways = (ways + waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization_Helper(
                length, steps - 1, index + 1, memo)) % mod;

        memo.put(subProblemState, ways);

        return ways;
    }

    public void waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization(int arrLength, int steps) {
        //https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/
        //Here, we can't use Integer[][] memo for changing parameters index & steps
        //because constraints given for arrLen is large : 1 <= arrLen <= 10^6 so
        //creating a 2D memo array of this big size will throw 'Memory Limit Exception'
        //thats why need to use Map<String, Integer> memo where
        //key = subProblemState = index + "," steps
        Map<String, Integer> memo = new HashMap<>();

        int ways = waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization_Helper(
                arrLength, steps, 0, memo);

        //output
        System.out.println("Ways to stay in same place after some steps : " + ways);
    }

    private long solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
            int[][] questions, int index, Long[] memo) {

        int n = questions.length;

        //return 0, if we have solved all the questions from the given array
        if (index >= n) {
            return 0l;
        }

        //if cached
        if (memo[index] != null) {
            return memo[index];
        }

        long maxPoints = 0l;
        //here we have 2 choices to make
        //1. don't pick/ don't solve the curr question @index and simply move to
        //next index (== index + 1) and since we are not solving this curr question
        //then points associated with questions[index][point] will not be considered
        maxPoints = Math.max(maxPoints, solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                questions, index + 1, memo));

        //2. pick/ solve the curr question @index and by solving this curr question,
        //we will consider the points associated with questions[index][point] into
        //our 'maxPoints' and acc to problem statement, we will need to skip the further
        //questions represented as 'brainPower' from questions[index][brainpower]
        //that why, we need to move to index (== index + questions[index][1] + 1)
        //means from curr 'index' skip 'brainPower' number of questions and +1
        //for the next index that needs to be solved from questions[][]
        long point = questions[index][0];
        int brainPower = questions[index][1];

        maxPoints = Math.max(maxPoints,
                point + solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                        questions, index + brainPower + 1, memo));

        return memo[index] = maxPoints;
    }

    public void solvingQuestionsWithBrainPower_Recursive_Memoization(int[][] questions) {
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        int n = questions.length;
        Long[] memo = new Long[n + 1];
        long maxPoints = solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                questions, 0, memo);
        //output
        System.out.println("Max points obtained by solving questions : " + maxPoints);
    }

    public void solvingQuestionsWithBrainPower_DP_Memoization(int[][] questions) {
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        //explanation: https://youtu.be/D7TD_ArkfkA
        //iterative BOTTOM-UP DP approach for recursive memoization
        /*
        the iterative loop has to start from last index (n - 1) why?
        as per the problem if we start from starting index then we need to
        skip next 'brainpower' amount of questions (== i + 'brainPower') an we
        haven't processed points collected at (i + brainPower) index

        benifit of starting from last index and having hashmap is that whenever
        we are calculating (i + 'brainpower' + 1) or (i + 1) for skipped questions
        we can easily do getOrDefault() and save from out-of-bounds on skipped
        questions[][] index
         */
        int n = questions.length;

        Map<Integer, Long> maxPointsMemo = new HashMap<>();

        for (int index = n - 1; index >= 0; index--) {

            Long maxPoints = Math.max(
                    //don't pick /don't solve question at curr @index then we
                    //get the max points calculated at
                    //(index + 1, if this next index is out of bounds then 0)
                    maxPointsMemo.getOrDefault(index + 1, 0l),
                    //pick /solve question at curr @index then we have to consider
                    //the max points given by questions[index][points] and have to
                    //get the max points calculated at index
                    //(index + questions[index][brainpower] + 1, if this next index is out of bounds then 0)
                    questions[index][0] + maxPointsMemo.getOrDefault(index + questions[index][1] + 1, 0l));

            maxPointsMemo.put(index, maxPoints);
        }
        //output
        //after solving questions from (n - 1) back to 0-index, our maxPoints will
        //be stored at 0-th index
        System.out.println("Max points obtained by solving questions (DP Memoization): " + maxPointsMemo.get(0));
    }

    private int countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
            int low, int high, int zero, int one, int currLength, Integer[] memo) {

        int mod = 1000000007;

        //return 0, as we don't want to consider strings with
        //'currLength' greater than high value
        if (currLength > high) {
            return 0;
        }

        if (memo[currLength] != null) {
            return memo[currLength];
        }

        //as per requirement, the ideal good string should have a min length of
        //'low' hence if currLength >= low we must consider the curr string with
        //length as 'currLength'
        int countGoodStrings = currLength >= low ? 1 : 0;

        //add up the string counts if we only append 'zero' in our string with 'currLength'
        countGoodStrings = (countGoodStrings
                + countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                low, high, zero, one, currLength + zero, memo)) % mod;

        //add up the string counts if we only append 'one' in our string with 'currLength'
        countGoodStrings = (countGoodStrings
                + countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                low, high, zero, one, currLength + one, memo)) % mod;

        return memo[currLength] = countGoodStrings;
    }

    public void countWaysToBuildGoodStrings_Recursive_Memoization(int low, int high, int zero, int one) {
        //...................T: O(high)
        //...................S: O(high + 1)
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        //explanation: https://youtu.be/G-i4CveBSYI | https://youtu.be/JKpVHG2mhbk
        /*
        take an example: low = 2, high = 3, zero = 1, one = 2
        acc to question, we must count good strings having lengths in range [low, high]
        inclusive

        ==> starting from empty string "" with len = 0

        ==> each time we decide to either append "1" or "0"
        if we decide to append "1" in curr string, we need to append "1" given 'one' times
        and same if we decide to append "0" to curr string, we need to append "0" given 'zero' times

        ==> every time we append "1" or "0", we are only considering its lengths
        from empty string "" having length = 0, we form two string "11" with length = 2 & "0" with length = 1

        ==> at level 5, see with appending "1" we form a string "1111" with length = 4 that is greater than
        given 'high' value so we won't move further after that (hence our tree can go at max to depth of 'high')
        also to note, in any append operation if our string length becomes greater or equal 'low' that is our
        valid string that should be considered (hence countGoodStrings = currLength >= low ? 1 : 0)

        ==> observe a thing we started of appending "1" or "0" hence each time a string created further in tree
        will be unique string, how? because from starting empty string "" it is the first char itself that will
        make the distinction see:
        "" append("1") ==> "11" first char == 1
        "" append("0") ==> "0" first char == 0
        and further in tree this distinction will make it unique,
        only thing that is common in the tree is the repetition of length 'len'
        see, len = 2 is seen twice in tree & len = 3 also appearing twice hence the length itself is a
        SUB PROBLEM

        ==> if we memoise on the lengths, memo['length'] we will save these repeatitive length calculation
        hence this reduce the time complexity from O(2^high) to just O(high) as we will be checking a length
        atmost once and other time we will just get it from memo['length']


        1........................................."", len = 0
        .................................../.............\
        2..........................."1"(2)/.................\"0"(1)
        .............................../........................\
        3................."11",len = 2........................len = 1, "0"
        .............................../..................................\
        4...................."1"(2)/.......\"0"(1).............."1"(2)/........\"0"(1)
        ......................../.............\..................../..............\
        5..........."1111", len = 4......"110",len = 3........"011",len = 3.........len = 2,"00"

         */
        Integer[] memo = new Integer[high + 1];
        int countGoodString = countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                low, high, zero, one,
                //since we are starting from an empty string("") that will have
                //length == 0
                0, memo);
        //output
        System.out.println("Count ways to build good strings : " + countGoodString);
    }

    public void countWaysToBuildGoodStrings_DP_Memoization(int low, int high, int zero, int one) {
        //...................T: O(high)
        //...................S: O(high + 1)
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        //explanation: https://youtu.be/G-i4CveBSYI | https://youtu.be/JKpVHG2mhbk
        int mod = 1000000007;
        Map<Integer, Integer> memo = new HashMap<>();
        //as per question, a string with length == 0 can be considered as good string
        //so its count is 1
        memo.put(0, 1);

        int countGoodString = 0;

        for (int length = 1; length <= high; length++) {

            int count = 0;
            count = (count + memo.getOrDefault(length - zero, 0)) % mod;
            count = (count + memo.getOrDefault(length - one, 0)) % mod;

            memo.put(length, count);

            if (length >= low && length <= high) {
                countGoodString = (countGoodString + memo.get(length)) % mod;
            }
        }

        //output
        System.out.println("Count ways to build good strings (DP memoization): " + countGoodString);
    }

    private int sortIntegersByPowerValue_Recursive_Memoization_GetPower(
            int num, Map<Integer, Integer> numPowerMemo) {

        if (numPowerMemo.containsKey(num)) {
            return numPowerMemo.get(num);
        }
        //base cond, as we need to reach 1, the power of 1 will remain 0
        //if X = 1 and goal = 1 then acc to question power of X = 0
        if (num == 1) {
            numPowerMemo.put(num, 0);
        } else if (num % 2 == 0) {
            //if curr num is even then add +1 to reach to curr num + steps to cover (num / 2)
            //until this num == 1
            numPowerMemo.put(num, 1 + sortIntegersByPowerValue_Recursive_Memoization_GetPower(
                    num / 2, numPowerMemo));
        } else {
            //if curr num is odd then add +1 to reach to curr num + steps to cover (3 * num + 1)
            //until this num == 1
            numPowerMemo.put(num, 1 + sortIntegersByPowerValue_Recursive_Memoization_GetPower(
                    3 * num + 1, numPowerMemo));
        }

        //return the power calculated in recursive call for our initial num == X
        return numPowerMemo.get(num);
    }

    public void sortIntegersByPowerValue_Recursive_Memoization(int low, int high, int k) {
        //https://leetcode.com/problems/sort-integers-by-the-power-value/description/
        //map is used here because as per the calucations based on even or odd num
        //the 'num' value can go beyond the given constraint (1 <= lo <= hi <= 1000)
        Map<Integer, Integer> numPowerMemo = new HashMap<>();
        List<int[]> saveNumToPower = new ArrayList<>();
        for (int num = low; num <= high; num++) {
            saveNumToPower.add(new int[]{
                    num,
                    sortIntegersByPowerValue_Recursive_Memoization_GetPower(num, numPowerMemo)});
        }

        //sort all the num to power list to get k-th num
        //if the power of the nums are same then sort the nums in incr order else
        //sort the power in incr order
        Collections.sort(saveNumToPower, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        //output
        int numAtK = saveNumToPower.get(k - 1)[0];
        System.out.println("K-th num in sorted integer by power value : " + numAtK);
    }

    private int maxScoreOfNOperations_Recursive_Memoization_GetGCD(int a, int b) {
        //function to calculate GCD of two num
        if (b == 0) {
            return a;
        }
        return maxScoreOfNOperations_Recursive_Memoization_GetGCD(b, a % b);
    }

    private int maxScoreOfNOperations_Recursive_Memoization_Helper(
            int[] nums, int maxOprn, int currOprn, boolean[] picked, Map<String, Integer> memo) {

        int n = nums.length;

        //as the array given is 2 * n but we only need to perform n oprn
        //our maxOprn == n and if currOprn > maxOprn return 0
        if (currOprn > maxOprn) {
            return 0;
        }

        //if cached
        //here our picked[] is itself our key how?
        //as we are picking (i, j) pair and mark it in the picked[], there are
        //sub-problems in recursion tree where the same state of picked[] is seen
        //repeating in diff branches
        String key = Arrays.toString(picked);
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int maxScore = 0;

        //the below nested for loops will generate the possible pairs of n num[]
        //as per the requirement, if we pick a pair let say (nums[i], nums[j]) at
        //index (i, j) these pairs then can't be picked in the further recursions
        //hence we are using the picked[] boolean array, this helps in maintaining
        //marking those indexes both (i, j) as picked == true so that in recursion
        //we can 'continue' if we see the same (i, j) pair in loops
        for (int i = 0; i < n; i++) {

            //skip, the i-th index or nums[i] because it is already picked == true
            //in the previous recursion call
            if (picked[i]) {
                continue;
            }

            //if the i-th index or nums[i], was not picked in previous recursion
            //call stacks, mark it as picked here
            picked[i] = true;

            //now since we are picking nums[i] as first part of our pair (nums[i], 'second')
            //then using j loop, we will generate all possible j-th or nums[j] value as
            //'second' part of our pair
            for (int j = i + 1; j < n; j++) {

                //skip, the j-th index or nums[j] because it is already picked == true
                //in the previous recursion call
                if (picked[j]) {
                    continue;
                }

                //if the j-th index or nums[j], was not picked in previous recursion
                //call stacks, mark it as picked here
                picked[j] = true;

                //calculate the GCD of nums[i] & nums[j]
                int currPairGCD = maxScoreOfNOperations_Recursive_Memoization_GetGCD(nums[i], nums[j]);
                //as per question, need to calculate the curr pair score i.e, (oprn * gcd(nums[i], nums[j]))
                int currPairScore = currOprn * currPairGCD;
                //now, we are currently considering nums[i] & nums[j] as picked pairs
                //then we need to move further in recursion to pick remaining pairs,
                //in 'remainingPairScore' we will get the possible maxScore from their
                //respective recursion call stacks.
                //also, we performed 1 oprn here, further we need to perform (currOprn + 1) oprns
                int remainingPairScore = maxScoreOfNOperations_Recursive_Memoization_Helper(
                        nums, maxOprn, currOprn + 1, picked, memo);

                //calculate the maxScore from currPairScore + remainingPairScore
                maxScore = Math.max(maxScore, currPairScore + remainingPairScore);

                //once we are done j-th or nums[j] value as pair with nums[i], we
                //can move to next j-th index or nums[j] to check the next possible
                //maxScore, but this curr j-th index or nums[j] can be used in
                //remaining so mark as false again
                picked[j] = false;

            }

            //once we are done i-th or nums[i] value, we can move to next i-th
            //index or nums[i] to check the next possible maxScore
            picked[i] = false;
        }

        memo.put(key, maxScore);
        return maxScore;
    }

    public void maxScoreOfNOperations_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/maximize-score-after-n-operations/description/
        //explanation: https://youtu.be/CTYIzzT9agE
        //this algo is highly time costly, commenting its method calls from main()
        int n = nums.length;
        int maxOprn = n / 2;
        boolean[] picked = new boolean[n];
        Map<String, Integer> memo = new HashMap<>();
        int maxScore = maxScoreOfNOperations_Recursive_Memoization_Helper(nums, maxOprn, 1, picked, memo);
        //output
        System.out.println("max score of N oprations : " + maxScore);
    }

    private int numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
            int[][] grid, int k, int row, int col, int currPathSum, Integer[][][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;
        int mod = 1000000007;

        //return 0, if the curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        if (row == ROW - 1 && col == COL - 1) {
            //adding the last grid value (==> grid[ROW - 1][COL - 1]) to our
            //currPathSum (==> remainder to be said) if that is still divisible
            //by k or not
            //return 1, if divisible else 0
            return (currPathSum + grid[row][col]) % k == 0 ? 1 : 0;
        }

        //if cached, here the overlapping subproblem occurs when we reach a particular
        //row & col and we see a same path-sum till that (row, col), keep in mind that
        //if we follow any path in grid, this state (row, col, currPathSum) may be
        //repeating in mutiple branches, so cache this state
        if (memo[row][col][currPathSum] != null) {
            return memo[row][col][currPathSum];
        }

        int ways = 0;

        //as we can only make two movements in the grid[][] that is,
        //move to right ==> col + 1 or move down ==> row + 1
        //each of the path we are going in we must add that grid[row][col] value
        //in our currPathSum BUT this path sum can become very large as we reach
        //our dest position (ROW - 1, COL - 1) so here is the thought, we don't
        //actually care about the curr-path-sum as we reach our dest position
        //we only need one thing from this path sum and that is whether this
        //curr-path-sum is divisible by k or not, so every time we move into a
        //recursive call, we will add the remainder of the currPathSum % k because
        //if we add values to remainders in the path we follow, that also will give
        //the same information at the dest position.
        ways = (ways
                + numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                grid, k, row + 1, col,
                //passing the currPathSum + curr-grid-value remainder with k
                (currPathSum + grid[row][col]) % k, memo)) % mod;

        ways = (ways
                + numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                grid, k, row, col + 1,
                //passing the currPathSum + curr-grid-value remainder with k
                (currPathSum + grid[row][col]) % k, memo)) % mod;

        return memo[row][col][currPathSum] = ways;
    }

    public void numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(int[][] grid, int k) {
        //https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        //in our recursive calls we will be calculating currPathSum remainders
        //(currPathSum % k) and not the path-sum to be exact so our remainder of
        //path-sum becomes third changing parameter by applying mod operation
        //on currPathSum ==> currPathSum % k, it will put the whole currPathSum
        //in range of [0 to k - 1] that's why [k] can be the size in memo
        Integer[][][] memo = new Integer[ROW][COL][k + 1];

        int ways = numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                grid, k, 0, 0, 0, memo);
        //output
        System.out.println("Number of paths in grid whose sum is divisible by k : " + ways);
    }

    private int numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
            int[][] types, int target, int typeIndex, Integer[][] memo) {

        int n = types.length;
        int mod = 1000000007;

        //as we need to earn points which will be equal to the given 'target'
        //here we reduced target with the points earned in between and in that
        //process, target reached <= 0 that means there is 1 ways we can earn
        //'target' points
        if (target <= 0) {
            return 1;
        }

        //we have reached end of types[][] and further we can't choose any more
        //questions, hence return 0 as we can't earn anymore points
        if (typeIndex >= n) {
            return 0;
        }

        //if cached
        if (memo[typeIndex][target] != null) {
            return memo[typeIndex][target];
        }

        int ways = 0;

        //2 choices we have,
        //1. don't pick the questions of the curr type @typeIndex and simply move
        //to next type (==> typeIndex + 1) and since we haven't solved any question
        //of curr type we will not consider a single point from this question type
        ways = (ways
                + numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
                types, target, typeIndex + 1, memo)) % mod;

        //2. pick the questions form the curr type @typeIndex, so if we are picking
        //then we can decide how many questions we can do from the curr 'type', if
        //we do 'x' amount of question from curr 'type' then we can earn x * points
        //from those questions and if we have earned (x * points) then we can reduce
        //our target points by (x * points).
        //Also to note: if we have solved 'x' questions from curr 'type' then we
        //can also move to next type (==> typeIndex + 1) to solve the remaining
        //questions and earn remaining points from those 'type'
        //questionsCount = max amount of questions we can solve of curr 'type'
        int questionsCount = types[typeIndex][0];
        //questionPoint = point earn for each questions solved of 'type'
        int questionPoint = types[typeIndex][1];
        //pointsEarned = points accuired by solving 'x' questions of 'type'
        //==> x * questionPoint
        int pointsEarned = 0;

        for (int question = 1; question <= questionsCount; question++) {
            //pointsEarned = question * questionPoint
            pointsEarned = question * questionPoint;
            //break, if we have earned more points than curr target
            if (pointsEarned > target) {
                break;
            }
            //currently we have solved 'question' out of questionsCount and the
            //remaining questions we choose from next type(==> typeIndex + 1)
            //but we have earned 'pointsEarned' points by solving 'question'
            //so reduce the target with this much pointsEarned
            ways = (ways
                    + numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
                    types, target - pointsEarned, typeIndex + 1, memo)) % mod;
        }

        return memo[typeIndex][target] = ways;
    }

    public void numberOfWaysToEarnPoints_Recursive_Memoization(int[][] types, int target) {
        //https://leetcode.com/problems/number-of-ways-to-earn-points/description/
        //based on pattern of maxValueFromKCoinsFromPiles_Recursive_Memoization()
        int n = types.length;
        Integer[][] memo = new Integer[n + 1][target + 1];
        int ways = numberOfWaysToEarnPoints_Recursive_Memoization_Helper(types, target, 0, memo);
        //output
        System.out.println("Number of ways to earn points : " + ways);
    }

    private int stoneGameTwo_Recursive_Memoization_Helper(
            int[] piles, boolean isAlice, int index, int M, Integer[][][] memo) {

        int n = piles.length;

        //return alice score as 0 because we are at the end of our piles[] and further
        //we can't pick any pile from the piles[]
        if (index >= n) {
            return 0;
        }

        //if cached
        if (memo[isAlice ? 0 : 1][index][M] != null) {
            return memo[isAlice ? 0 : 1][index][M];
        }

        //we are simulating both alice and bob turns as players of this game
        //our main aim is to maximise alice's score, or as bob is playing against
        //alice so will bob try to minimize alice's score in both the cases bob's
        //own score doesn't matter. Only thing matter here is how alice is trying
        //to max her score and how bob is trying to min alice's score(in his turn)
        //here if currently its alice's turn (isAlice == true) then in order to
        //max her score we take a min default value(==> -1) and vice versa if its
        //bob's turn then in order to min alice score it will have max default value
        int aliceScore = isAlice ? -1 : 1000000;
        //each time we decide to pick X-th pile we will add the piles value
        int pilesTakenScore = 0;

        //as per questions, our piles picking range for both alice and bob is bounded
        //1 <= X <= 2 * M
        //here X is starting from 1 to 2 * M, but our piles index starts from 0
        //so we need to offset our index to pick the correct pile value for the
        //current player
        //ex: index = 0, X = 1, then we should pick 0-th index index + X - 1
        //add an offset of -1 == index + X - 1 ==> 0 + 1 - 1 = 0
        for (int X = 1; X <= Math.min(2 * M, n - index); X++) {

            //pick the curr piles, simulating picking X-th piles from our bounded
            //range[1 <= X <= 2 * M]
            pilesTakenScore += piles[index + X - 1];

            //currently its alice's turn, so alice will try to max her score
            if (isAlice) {
                aliceScore = Math.max(aliceScore,
                        pilesTakenScore + stoneGameTwo_Recursive_Memoization_Helper(
                                piles, false, index + X, Math.max(M, X), memo));
            } else {
                //currently its bob's turn, here we don't really need to calculate
                //bob's score but bob will try to minimize alice score, so here
                //we don't need to consider 'pilesTakenScore' for bob
                aliceScore = Math.min(aliceScore,
                        stoneGameTwo_Recursive_Memoization_Helper(
                                piles, true, index + X, Math.max(M, X), memo));
            }
        }
        return memo[isAlice ? 0 : 1][index][M] = aliceScore;
    }

    public void stoneGameTwo_Recursive_Memoization(int[] piles) {
        //https://leetcode.com/problems/stone-game-ii/description/
        //explanation: https://youtu.be/9f1vzDFVnGA | https://youtu.be/I-z-u0zfQtg
        int n = piles.length;
        Integer[][][] memo = new Integer[2][n + 1][n + 1];
        int maxAliceScore = stoneGameTwo_Recursive_Memoization_Helper(piles, true, 0, 1, memo);
        //output
        System.out.println("Stone game two (alice max score) : " + maxAliceScore);
    }

    private int stoneGameThree_Recursive_Memoization_Helper(int[] stoneValue, int index, Integer[] memo) {

        int n = stoneValue.length;

        if (index >= n) {
            return 0;
        }

        if (memo[index] != null) {
            return memo[index];
        }

        int currWinner = Integer.MIN_VALUE;

        int stoneTaken = 0;

        for (int X = 1; X <= Math.min(3, n - index); X++) {
            stoneTaken += stoneValue[index + X - 1];
            currWinner = Math.max(currWinner,
                    stoneTaken - stoneGameThree_Recursive_Memoization_Helper(
                            stoneValue, index + X, memo));
        }

        return currWinner;
    }

    public void stoneGameThree_Recursive_Memoization(int[] stoneValue) {
        //https://leetcode.com/problems/stone-game-iii/description/
        //explanation: https://youtu.be/KI8suf35r38 | https://youtu.be/HsLG5QW9CFQ
        int n = stoneValue.length;
        Integer[] memo = new Integer[n];
        int winner = stoneGameThree_Recursive_Memoization_Helper(stoneValue, 0, memo);
        //output
        System.out.println("Stone game three (winner name) : "
                + (winner == 0 ? "Tie" : (winner > 0 ? "Alice" : "Bob")));
    }

    public void stoneGameThree_DP_Memoization(int[] stoneValue) {
        //https://leetcode.com/problems/stone-game-iii/description/
        //explanation: https://youtu.be/KI8suf35r38 | https://youtu.be/HsLG5QW9CFQ
        int n = stoneValue.length;
        int[] memo = new int[n + 1];
        //same as recursive method's currWinner == INT_MIN
        Arrays.fill(memo, Integer.MIN_VALUE);
        //same as recursive base cond
        memo[n] = 0;

        for (int index = n - 1; index >= 0; index--) {

            int stoneTaken = 0;

            for (int X = 1; X <= Math.min(3, n - index); X++) {

                stoneTaken += stoneValue[index + X - 1];
                memo[index] = Math.max(memo[index], stoneTaken - memo[index + X]);
            }
        }
        //output
        int winner = memo[0];
        System.out.println("Stone game three (winner name) (DP Memoization) : "
                + (winner == 0 ? "Tie" : (winner > 0 ? "Alice" : "Bob")));
    }

    private int predictTheWinner_Recursive_Memoization(
            int[] nums, int firstIndex, int lastIndex, boolean isAliceTurn, Integer[][][] memo) {

        int n = nums.length;

        //since both the players have the choice to pick the val from either left
        //or right end of nums[] denoted with first & last indexes, so if by picking
        //vals we exhaust the range, return 0, meaning no further valid picks can be
        //made and hence score will be 0
        if (firstIndex > lastIndex) {
            return 0;
        }

        //same reason as above, we exhaust the range or reached limit for both the
        //indexes, return 0 as the score
        if (firstIndex >= n || lastIndex < 0) {
            return 0;
        }

        //return stored score, if state if previously cached
        if (memo[firstIndex][lastIndex][isAliceTurn ? 0 : 1] != null) {
            return memo[firstIndex][lastIndex][isAliceTurn ? 0 : 1];
        }

        //as we want to predict, wheather alice will win the game or not, so alice
        //would want to maximize her score in her turn
        int aliceScore = 0;

        //if its alice's turn
        if (isAliceTurn) {

            //2 choices alice can make here,
            //1.choose the element from left(==> firstIndex) side of nums[]
            //and for next bob's isAliceTurn will be false and turn range will be
            //[firstIndex + 1 to lastIndex] from which he can pick
            //to note here: alice picked nums[firstIndex] in hope that it would
            //score her a higher value but also understand it in a way that only
            //nums[firstIndex] is not her score, she must also add up a cummalative
            //score for her from the further recursive calls
            //now those recursive calls, have turns where bob has played and alice
            //has played alternatively, so if bob has optimally maximized his score
            //that would means a reduced score for alice but still alice needs a
            //cummlative scores to add up, hence recursive calls ad added
            int currScore = nums[firstIndex] + predictTheWinner_Recursive_Memoization(
                    nums, firstIndex + 1, lastIndex, false, memo);

            //2. choose the element from right(==> lastIndex) side of nums[]
            //and for next bob's isAliceTurn will be false and turn range will be
            //[firstIndex to lastIndex - 1] from which he can pick
            //to note here: alice picked nums[lastIndex] in hope that it would
            //score her a higher value but also understand it in a way that only
            //nums[lastIndex] is not her score, she must also add up a cummalative
            //score for her from the further recursive calls
            //now those recursive calls, have turns where bob has played and alice
            //has played alternatively, so if bob has optimally maximized his score
            //that would means a reduced score for alice but still alice needs a
            //cummlative scores to add up, hence recursive calls ad added
            currScore = Math.max(currScore,
                    nums[lastIndex] + predictTheWinner_Recursive_Memoization(
                            nums, firstIndex, lastIndex - 1, false, memo));

            aliceScore = currScore;

        } else {

            //here its bob's turn to pick the elements
            //1.choose the element from left(==> firstIndex) side of nums[]
            //and for next alice's isAliceTurn will be true and turn range will
            //be [firstIndex + 1 to lastIndex] from which alice can pick
            //here bob will play optimally and will maxmize his score and further
            //recursive calls will bring the cummalative scores for both alice and
            //bob played in further calls, so understand it in a way bob's higher
            //score will reduce the alice's score hence the recursive calls are
            //subtracted
            int currScore = nums[firstIndex] - predictTheWinner_Recursive_Memoization(
                    nums, firstIndex + 1, lastIndex, true, memo);

            //2.choose the element from right(==> alstIndex) side of nums[]
            //and for next alice's isAliceTurn will be true and turn range will
            //be [firstIndex to lastIndex - 1] from which alice can pick
            //here bob will play optimally and will maxmize his score and further
            //recursive calls will bring the cummalative scores for both alice and
            //bob played in further calls, so understand it in a way bob's higher
            //score will reduce the alice's score hence the recursive calls are
            //subtracted
            currScore = Math.max(currScore,
                    nums[lastIndex] - predictTheWinner_Recursive_Memoization(
                            nums, firstIndex, lastIndex - 1, true, memo));

            aliceScore = -currScore;

        }

        return memo[firstIndex][lastIndex][isAliceTurn ? 0 : 1] = aliceScore;
    }

    public void predictTheWinner_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/predict-the-winner/description/
        int n = nums.length;
        Integer[][][] memo = new Integer[n + 1][n + 1][2];
        //in order for alice to win, should either score higher value (> 0)
        //or even if its a tie (== 0), alice will considered a winner
        boolean isAliceWinner = predictTheWinner_Recursive_Memoization(nums, 0, n - 1, true, memo) >= 0;
        //output
        System.out.println("Predict the winner : " + isAliceWinner);
    }

    private int minCostToCutStick_Recursive_Memoization_Helper(
            int[] cuts, int start, int end, Map<String, Integer> memo) {

        int cutLength = cuts.length;

        //rather having a proper 'length' as a parameter we maintain a range
        //which will tell the length of the segments (end - start)
        int currSegmentLength = (end - start);

        //we can make make profit/reduce cost by making cuts on the
        //given segment having some length as 'length'(==> (end - start))
        //now think it this way, a segment length of 1 can't be further
        //divided so if we can't make cuts then our cost to make cut becomes 0,
        //hence return 0
        if (currSegmentLength == 1) {
            return 0;
        }

        //Map is more memory optimized as compared to 2D memo array
        //due to large 'n' size
        String key = start + "," + end;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        //our aim is to minimize our cost on making cuts, hence
        //the initial value should be a INT_MAX value, but also
        //to keep in mind that we might come accros a situation
        //where a cut is not possible on the curr segment length
        //in that case minCost should then be 0
        int minCost = Integer.MAX_VALUE;

        //any cut can be made in any order, hence to try all possibilties, loop
        //for all the cuts that we have every time for every cut segments but
        //maintain the check that this cuts[i] is valid cut on the cut segment(start, end)
        //where start or end will tell starting or ending of that segment
        //if a cuts[i] is made on segment(start, end) then this cuts[i]
        //will create two different cut segement that might have diff lengths
        //where cuts[i] becomes ending of the first cut segment AND starting
        //of the second cut segment
        //ex: initial segment length = 7 i.e, [start, end] = [0, 7]
        //assume we made a cuts[i] = 3, it will create two segments now
        //first cut segment = [start, cuts[i]] = [0, 3]
        //second cut segment = [cuts[i], end] = [3, 7]
        for (int index = 0; index < cutLength; index++) {

            //any cut of cuts[i] can only be made on a cut segment of length
            //'length' ==> (end - start) if this cuts[i] lie within the range
            //of (start, end) both non-inclusive
            //ex: a cut segment length = 3 ==> (start, end) = (2, 5)
            //and a cuts[i] = 1 then its not possible to make this cut
            //in-between the curr cut segment
            //so we need to check if a cut of cuts[i] falls within the range
            //of the cut segment length
            if (cuts[index] > start && cuts[index] < end) {

                //take the min cost of making cuts
                minCost = Math.min(minCost,
                        //cost as curr cut segment length
                        //+ cost in making further cuts on first cut segment (start, cuts[index])
                        //+ cost in making further cuts on second cut segment (cuts[index], end)
                        currSegmentLength
                                + minCostToCutStick_Recursive_Memoization_Helper(cuts, start, cuts[index], memo)
                                + minCostToCutStick_Recursive_Memoization_Helper(cuts, cuts[index], end, memo));
            }
        }

        //as mentioned, if any cuts is not possible then minCost should be returned 0
        minCost = minCost == Integer.MAX_VALUE ? 0 : minCost;

        memo.put(key, minCost);

        return minCost;
    }

    public void minCostToCutStick_Recursive_Memoization(int segment, int[] cuts) {
        //https://leetcode.com/problems/minimum-cost-to-cut-a-stick/description/
        //explanation: https://youtu.be/EVxTO5I0d7w
        //in this quest, Map is more memory optimized as compared to the use of
        //2D memo[segment + 1][segment + 1] array due to large value of 'segment'
        Map<String, Integer> memo = new HashMap<>();
        int minCost = minCostToCutStick_Recursive_Memoization_Helper(cuts, 0, segment, memo);
        //output
        System.out.println("Min cost to cut stick : " + minCost);
    }

    private boolean maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_CanTakeWord(
            String concatenatedWordSeq, String word) {

        boolean[] hasSeenWordChars = new boolean[26];

        //check 1. the words[index] itself can have duplicate chars in that case
        //such words[index] should be rejected right away
        //ex: words[index] ==> "aa", "bb", "paxoap"
        for (char ch : word.toCharArray()) {
            //if a char ch is seen first time then its hasSeenWordChars[ch] will be
            //marked as true and again if we see same char that will then
            //(hasSeenWordChars[ch] == true) means a duplicate char ch so return false
            if (hasSeenWordChars[ch - 'a']) {
                return false;
            }
            hasSeenWordChars[ch - 'a'] = true;
        }

        //check 2. if we are concatenating words[index] into 'concatenatedWordSeq'
        //then this should not have duplicate chars after concatenation
        //after above loop on 'word', hasSeenWordChars[ch] = true tells that which
        //char of 'word' is present(by this time, we can say 'word' has only unique chars)
        //now check if any char 'seqChr' of 'concatenatedWordSeq' is already there in 'word'
        //and for that we can use same hasSeenWordChars[] array to check if both of
        //them have any common chars then in that case we can't concatenate
        //'word' into 'concatenatedWordSeq'
        for (char seqChr : concatenatedWordSeq.toCharArray()) {
            //if chars are common in 'concatenatedWordSeq' and 'word'
            if (hasSeenWordChars[seqChr - 'a']) {
                return false;
            }
        }
        return true;
    }

    private int maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_Helper(
            String[] words, int index, String concatenatedWordSeq) {

        int n = words.length;

        //return the length so formed of the concatenated words as seq if we have
        //reached the end of words[] as we can't take any more words
        if (index >= n) {
            return concatenatedWordSeq.length();
        }

        //initially, len of concatenated word is 0 assuming an empty string("")
        //we will try to maximize this length with 2 choices on whether to pick
        //index-th word from words[] or not
        int maxLenConcatenatedWords = 0;

        //2 choices we need to make
        //1. don't pick the index-th word from words[] and we will simply move to
        //next word index(==> index + 1) and since we have not picked words[index]
        //so this will also not get concatenated into 'concatenatedWordSeq'
        maxLenConcatenatedWords = Math.max(
                maxLenConcatenatedWords,
                maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_Helper(
                        words, index + 1, concatenatedWordSeq));

        //2. pick the curr index-th word from words[] and concatenate this words[index]
        //into 'concatenatedWordSeq' and then move to next index(==> index + 1) for
        //further word concatenation
        //BUT we also need to have some checks here, as per question
        //check 1. the words[index] itself can have duplicate chars in that case
        //such words[index] should be rejected right away(ex: "aa", "bb")
        //check 2. if we are concatenating words[index] into 'concatenatedWordSeq'
        //then this should not have duplicate chars after concatenation
        if (maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_CanTakeWord(
                concatenatedWordSeq, words[index])) {

            //if the concatenation of words[index] with 'concatenatedWordSeq' is
            //valid then move ahead
            maxLenConcatenatedWords = Math.max(
                    maxLenConcatenatedWords,
                    maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_Helper(
                            words, index + 1, concatenatedWordSeq + words[index]));
        }

        return maxLenConcatenatedWords;
    }

    public void maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(String[] words) {
        //https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/description/
        //explanation: https://youtu.be/MqMvkrkerIY
        //based on RECURSION, BACKTRACKING
        //as per the question, the constraints given is small enough that it can
        //pass with recursion only but if we want to memoize it the we need to take
        //Map<String, Integer> because we have 2 changing parameter
        //1. index, 2. concatenatedWordSeq they together form map = key
        //memoization actually slowed down this solution on leetcode
        int maxLenConcatenatedWords = maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization_Helper(
                words, 0, "");
        //output
        System.out.println("Max lentgh of concatenated string with unique chars : " + maxLenConcatenatedWords);
    }

    private boolean maxScoreOfWordFormedByLetters_Recursive_Memoization_CanTakeWord(
            int[] lettersFreq, String word) {

        //firstly, count the freq[] of curr word, that will tell how many chars
        //we need from the given letters[]
        int[] wordCharFreq = new int[26];
        for (char ch : word.toCharArray()) {
            wordCharFreq[ch - 'a']++;
        }

        //here, we will check if we have enough chars available in the letters[]
        //in the form of lettersFreq[] so that we can pick chars of 'word' from
        //this lettersFreq[]
        for (char ch : word.toCharArray()) {
            //ex: word = "good" ==> [g = 1, o = 2, d = 1] & lettersFreq[] = [g = 1, o = 1, d = 1]
            //here, in order to form word = "good" we need atleast 2 'o' but lettersFreq[]
            //has just 1 'o' so word = "good" can't be taken
            if (wordCharFreq[ch - 'a'] > lettersFreq[ch - 'a']) {
                return false;
            }
        }
        return true;
    }

    private int maxScoreOfWordFormedByLetters_Recursive_Memoization_Helper(
            String[] words, int[] lettersFreq, int[] wordScores, int index) {

        int n = words.length;

        //return 0, as we have reached end of words[] and further we can't pick
        //any other words hence from here our score is 0
        if (index >= n) {
            return 0;
        }

        //initial score is 0 that we need to maximize this score
        int maxScore = 0;

        //2 choices we need to make
        //1. don't pick the word @index from words[index] and move to next index
        //(==> index + 1) and since we are not picking any words[index] here so
        //its wordScores[index] will not be calculated
        maxScore = Math.max(
                maxScore,
                maxScoreOfWordFormedByLetters_Recursive_Memoization_Helper(
                        words, lettersFreq, wordScores, index + 1));

        //2. pick the word @index from words[index] and move to next index
        //(==> index + 1) and since we are picking curr words[index] here so its
        //wordScores[index] will also be added
        //BUT we also need to have a check here
        //check: we are given char letters[] from which we can use some letters
        //and form any word exist in given words[]. Firstly we need to check if
        //the lettersFreq[] have enough chars available so that we can pick chars
        //of curr words[index] from this lettersFreq[]
        if (maxScoreOfWordFormedByLetters_Recursive_Memoization_CanTakeWord(lettersFreq, words[index])) {

            //here comes a backtracking side of this question
            //if the words[index] is a valid word(valid means we can form this words[index]
            //from the letters[] as lettersFreq[]) then we actually have to simulate
            //picking the chars of words[index] from lettersFreq[]
            for (char ch : words[index].toCharArray()) {
                //forming words[index] by picking its same chars from lettersFreq[ch]
                lettersFreq[ch - 'a']--;
            }

            maxScore = Math.max(
                    maxScore,
                    wordScores[index] + maxScoreOfWordFormedByLetters_Recursive_Memoization_Helper(
                            words, lettersFreq, wordScores, index + 1));

            //once we have considered taking words[index] then we have to readjust
            //the lettersFreq[] by putting the chars of words[index] back to it.
            for (char ch : words[index].toCharArray()) {
                //putting back words[index] by giving taken chars from lettersFreq[ch]
                lettersFreq[ch - 'a']++;
            }
        }

        return maxScore;
    }

    public void maxScoreOfWordFormedByLetters_Recursive_Memoization(
            String[] words, char[] letters, int[] scores) {
        //https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/
        //based on RECURSION, BACKTRACKING
        //as per the question, the constraints given is small enough that it can
        //pass with recursion only but if we want to memoize it then we need to
        //take Map<String, Integer> because we have 2 changing parameter
        //1. index, 2. lettersFreq[] they together form map = key
        //for this question, memoization actually slowed down this solution on leetcode

        int n = words.length;
        //pre calculating the scores of each word in words[]
        int[] wordScores = new int[n];
        for (int i = 0; i < n; i++) {
            for (char ch : words[i].toCharArray()) {
                //ex: wordScores[i] ==> words[i] = "good" ==> scores[g] + scores[o] + scores[o] + scores[d]
                wordScores[i] += scores[ch - 'a'];
            }
        }

        //calculate the freq of each letter in letters[]
        int[] lettersFreq = new int[26];
        for (char ch : letters) {
            lettersFreq[ch - 'a']++;
        }

        int maxScore = maxScoreOfWordFormedByLetters_Recursive_Memoization_Helper(
                words, lettersFreq, wordScores, 0);

        //output
        System.out.println("Max score of words formed byt letters : " + maxScore);
    }

    private long numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization_Helper(
            List<Integer> nums, long[][] pascalTriangle) {

        int mod = 1000000007;
        int n = nums.size();

        if (n < 3) {
            return 1;
        }

        int root = nums.get(0);
        List<Integer> leftBSTNodes = new ArrayList<>();
        List<Integer> rightBSTNodes = new ArrayList<>();

        for (int i = 1; i < n; i++) {
            if (nums.get(i) < root) {
                leftBSTNodes.add(nums.get(i));
            } else {
                rightBSTNodes.add(nums.get(i));
            }
        }

        long waysLeftTree = numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization_Helper(
                leftBSTNodes, pascalTriangle) % mod;

        long waysRightTree = numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization_Helper(
                rightBSTNodes, pascalTriangle) % mod;

        return (((waysLeftTree * waysRightTree) % mod) * (pascalTriangle[n - 1][leftBSTNodes.size()])) % mod;
    }

    public void numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/
        //pascal triangle
        //explanations: https://youtu.be/bR7mQgwQ_o8
        //explanation: https://youtu.be/YMe9Q2yZvBo
        int mod = 1000000007;
        int n = nums.length;
        long[][] pascalTriangle = new long[n][n];
        for (int r = 0; r < n; r++) {
            //first col
            pascalTriangle[r][0] = 1;
            //diagonal
            pascalTriangle[r][r] = 1;
        }

        for (int r = 2; r < n; r++) {
            for (int c = 1; c < r; c++) {
                pascalTriangle[r][c] = (pascalTriangle[r - 1][c - 1] + pascalTriangle[r - 1][c]) % mod;
            }
        }

        List<Integer> numList = Arrays.stream(nums).boxed().collect(Collectors.toList());
        int ways = (int) ((numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization_Helper(
                numList, pascalTriangle) - 1) % mod);

        //output
        System.out.println("Ways to reorder array to get same BST : " + ways);
    }

    private int makeArrayStrictlyIncreasing_Recursive_Memoization_Helper(
            int[] nums1, int[] nums2, int index, int prev, Map<String, Integer> memo) {

        int n = nums1.length;

        //return 0, as we have reached the end of nums1[] that means in between
        //we did our process to make nums1[] STRICLTY INCREASING and now we can't
        //make any more replace, so replace operations becomes 0
        if (index >= n) {
            return 0;
        }

        //if cached
        String key = index + "," + prev;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        //initial max replace
        int minReplace = (int) 10e7;

        //2 choices to make, try to replace nums1[index] with nums2[j] and don't
        //based on some cond
        //1. we will not perform replace operation if curr nums1[index] > prev
        //means they are already in STRICTLY INCREASING pattern (prev < nums1[index])
        //if curr nums1[index] value is already STRICTLY GREATER than its prev value
        //then we don't need to make any replace for curr nums1[index] and we can
        //simply move to next index (==> index + 1) and when we move to next index
        //this curr nums1[index] will become the prev value for the next index value
        //of nums1[]
        if (prev < nums1[index]) {
            minReplace = Math.min(
                    minReplace,
                    makeArrayStrictlyIncreasing_Recursive_Memoization_Helper(
                            nums1, nums2, index + 1, nums1[index], memo));
        }

        //2. we will perform replace operation here we will find a
        //value STRICTLY GREATER than curr 'prev' value from nums2 means we will
        //have to perform replace operation means replace this nums1[i] value
        //with nums2[j] value (nums1[i] = nums2[j]) only if that nums2[] j-th
        //index is valid and move to next index (==> index + 1) also keep a note
        //here we did perform a replace oprn on curr nums1[index] hence the prev
        //value for next recursion is (prev = nums1[index] = nums2[j] = nums2[replaceIndex])
        int replaceIndex = findAStrictlyGreaterValueThanPivot_BinarySearch(nums2, prev);
        //if this j-th == replaceIndex is valid(means 0 <= replaceIndex < nums2.length)
        if (replaceIndex < nums2.length) {

            //as the replaceIndex is valid j-th index for nums2[] and we will need
            //to perform a replace operation here so below (+1) is for that and
            //for next recursion (prev = nums1[index] replaced with nums2[j] = nums2[replaceIndex])
            minReplace = Math.min(
                    minReplace,
                    1 + makeArrayStrictlyIncreasing_Recursive_Memoization_Helper(
                            nums1, nums2, index + 1, nums2[replaceIndex], memo));
        }

        memo.put(key, minReplace);
        return minReplace;
    }

    public void makeArrayStrictlyIncreasing_Recursive_Memoization(int[] nums1, int[] nums2) {
        //.........................T: O(M * N * LogN)
        //(M) as our recursion depends on index which is representing nums1[] length
        //(N*LogN) due to sorting nums2[]
        //.........................S: O(M * N)
        //space depends on grid[M][N] as disctinct comb of {index, prev}
        //https://leetcode.com/problems/make-array-strictly-increasing/description/
        /*
        here we need to make nums1[] to be strictly increasing and we can replace
        any nums1[i] value with nums2[j] value for that. Need min replace in which
        we can make nums1[] STRICTLY INCREASING
         */
        int MAX = (int) 10e7;
        //as per constraint:
        //0 <= arr1[i], arr2[i] <= 10^9
        //memo[][] will not be memory optimized hence using Map<String, Integer>
        Map<String, Integer> memo = new HashMap<>();

        //sort the nums2[] so that we can use binary search to find a Strictly
        //greater value than 'pivot' here 'prev' value so that prev < nums2[j]
        Arrays.sort(nums2);

        int minReplace = makeArrayStrictlyIncreasing_Recursive_Memoization_Helper(
                nums1, nums2, 0, -1, memo);

        minReplace = minReplace >= MAX ? -1 : minReplace;
        //output
        System.out.println("Min replace operations to make array strictly increasing : " + minReplace);
    }

    public int paintingTheWalls_Recursive_Memoization_Helper(
            int[] cost, int[] time, int index, int wallsLeft, Integer[][] memo) {

        int n = cost.length;

        //note: do not check this cond
        //==> if(index >= n) return (wallsLeft <= 0) ? 0 : (int) 10e8;
        //because wallsLeft can be negative due to picking recursive
        //choice(==> wallsLeft - time[index] - 1)
        //and if wallsLeft <= 0 is checked inside if(index >= 0) like above
        //then this cache check if(memo[index][wallsLeft] != null) might cause
        //'Runtime Error' due -ve index for wallsLeft
        //return 0, if there are 'no walls at all' or 'no walls left to paint'
        //any more, in that case we are not painting hence 0 is the cost
        if (wallsLeft <= 0) {
            return 0;
        }

        //return MAX value as we reached the end of all the walls
        if (index >= n) {
            return (int) 10e8;
        }

        //if cached
        if (memo[index][wallsLeft] != null) {
            return memo[index][wallsLeft];
        }

        //initial cost that we need to minimize
        int minCost = (int) 10e8;

        //2 choices to make
        //1. we choose not to paint this curr wall @index and move to next wall
        //(==> index + 1) and since we didn't paint the wall wallLeft remain as it is
        minCost = Math.min(minCost, paintingTheWalls_Recursive_Memoization_Helper(
                cost, time, index + 1, wallsLeft, memo));

        //2. we choose to paint this curr wall @index and move to next wall
        //(==> index + 1) and since we are considering to paint this @index wall
        //that means we also need to consider its cost (==> cost[index]) and as
        //painter1 is painting this @index wall for which he will be occupied till
        //time[index] that means by this time period painter2 will paint and painter2
        //will paint time[index] amount of walls hence for painter1 walls left to paint
        //after curr @index wall is (wallsLeft - time[index] - 1), -1 for painting curr @index wall
        int wallPaintedByPainter2 = time[index];
        int wallPaintedByPainter1 = 1;

        minCost = Math.min(
                minCost,
                cost[index] + paintingTheWalls_Recursive_Memoization_Helper(
                        cost, time,
                        index + 1,
                        wallsLeft - wallPaintedByPainter2 - wallPaintedByPainter1, memo));

        return memo[index][wallsLeft] = minCost;
    }

    public void paintingTheWalls_Recursive_Memoization(int[] cost, int[] time) {
        //https://leetcode.com/problems/painting-the-walls/
        //based on 0/1 KNAPSACK
        /*
        how is this 0/1 knapsack problem?
        firstly we need to paint all the walls = n = cost.length or time.length
        which is same as knapsack bag capacity (W)

        secondly, we need to minimize the cost of painting so cost[] is same as
        value[] of knapsack

        thirdly, we need to reduce the no of walls painted so if painter1 takes
        time as time[i] to paint i-th wall that also means painter1 will be occupied
        till time[i] unit of time which means painter2 will paint the same no of walls
        (==> time[i]) each in 1 unit of time at 0 cost
        here time[] is same as weight[] of knapsack

         */
        int walls = cost.length;
        Integer[][] memo = new Integer[walls + 1][walls + 1];
        int minCost = paintingTheWalls_Recursive_Memoization_Helper(cost, time, 0, walls, memo);
        //output
        System.out.println("Min cost to paint the walls : " + minCost);
    }

    private int tallestBillboard_Recursive_Helper(
            int[] rods, int index, int poleLength1, int poleLength2) {
        int n = rods.length;

        //if we have reached the end of our rods[] that means we can't pick anymore
        //rod segment and weld to any of the pole
        if (index >= n) {
            //here at the end of rods[], if we have successfully welded rod segments
            //such that two poles now have same length then return the poleLength
            //otherwise 0
            return poleLength1 == poleLength2 ? poleLength1 : 0;
        }

        int maxLength = 0;

        //3 choices we have to make.
        //1. don't add/weld the rod segement @index to any of the pole
        //and their length remain as it is and we move to next rod segment
        //index (==> index + 1)
        maxLength = Math.max(maxLength,
                tallestBillboard_Recursive_Helper(rods, index + 1, poleLength1, poleLength2));

        //2. add/weld the rod segement @index to the poleLength1 and we move
        //to next rod segment index (==> index + 1)
        maxLength = Math.max(maxLength,
                tallestBillboard_Recursive_Helper(rods, index + 1, poleLength1 + rods[index], poleLength2));

        //3. add/weld the rod segement @index to the poleLength2 and we move
        //to next rod segment index (==> index + 1)
        maxLength = Math.max(maxLength,
                tallestBillboard_Recursive_Helper(rods, index + 1, poleLength1, poleLength2 + rods[index]));

        return maxLength;
    }

    public void tallestBillboard_Recursive(int[] rods) {
        //https://leetcode.com/problems/tallest-billboard/description/
        //explanation: https://youtu.be/Zyzs3AuqPRw
        int n = rods.length;
        /*

        ............------------------------------
        ...........|                             |
        ...........|                             |
        ...........|                             |
        ............------------------------------
        ..............| |...................| |....
        ..............| |...................| |....
        ..............| |...................| |....
        ..............| |...................| |....
        ..............---...................---....
        ...........poleLength1...........poleLength2

        aim is to create two poles from rods[] by welding some subset of rod
        segemnt (==> rods[index]) such that both poles have equal lengths and
        their length is MAXIMIZED

        initially both poles will start from 0 lengths and in the recursion will
        have 3 choices over the rod segments of rods[]
        1. skip curr rod segment of rods[] @index
        2. add/weld curr rod segment of rods[] @index to poleLength1
        ==> poleLength1 + rods[index]
        3. add/weld curr rod segment of rods[] @index to poleLength2
        ==> poleLength2 + rods[index]

        in the base case where index >= rods.length where we don't have any rods
        left to weld to any of the pole there we can check if both the poles
        lengths are equal or not (poleLength1 == poleLength2) if equal return
        the length of the pole otherwise 0, 0 because we need to maximize the
        pole length then 0 is MIN_VALUE we can consider

        ** this version of recursive approach will not be memoized, why?

        we have taken 5001 as max limit for memo[][][] for parameters like
        poleLength1 & poleLength2, why?

        because as per given constarint: sum(rods[i]) <= 5000

        so if by any chance we add up/weld all the rods[i] to either
        poleLength1 or poleLength2 then at max their length can go as long as 5000
        also to note: only recursion approach with one index & two poles parameter
        can't be memoized with with this constraint, as it will throw
        'Memory Limit exceeded'

        Integer[][][] memo = new Integer[n + 1][5001][5001];

         */

        //NOT MEMOIZING THIS VERSION OF RECURSION, SO THIS RECURSIVE APPROACH
        //WILL FAIL ON LARGE INPUTS WITH TLE, IF WE CHOOSE TO MEMOIZE IT WILL
        //GIVE 'Memory Limit exceeded'
        //Integer[][][] memo = new Integer[n + 1][5001][5001];
        //initially we start off with index = 0 and poleLengths as 0, 0 because
        //nothing is welded in the start
        int maxLength = tallestBillboard_Recursive_Helper(rods, 0, 0, 0);
        //output
        System.out.println("Tallest billboard (Recursive Approach): " + maxLength);
    }

    private int tallestBillboard_Recursive_Memoization_Helper(
            int[] rods, int index, int lengthDiff, Integer[][] memo) {

        int n = rods.length;
        int NEGATIVE_OFFSET = 5000;

        if (index >= n) {
            return lengthDiff == 0 ? 0 : Integer.MIN_VALUE;
        }

        if (memo[index][lengthDiff + NEGATIVE_OFFSET] != null) {
            return memo[index][lengthDiff + NEGATIVE_OFFSET];
        }

        int maxLength = Integer.MIN_VALUE;

        //3 choices we have to make.
        //1. don't add/weld the rod segement @index to any of the pole
        //and their lengthDiff remain as it is and we move to next rod segment
        //index (==> index + 1)
        maxLength = Math.max(maxLength,
                tallestBillboard_Recursive_Memoization_Helper(rods, index + 1, lengthDiff, memo));

        //2. add/weld the rod segement @index to the poleLength1 and we move
        //to next rod segment index (==> index + 1)
        maxLength = Math.max(maxLength,
                rods[index] + tallestBillboard_Recursive_Memoization_Helper(
                        rods, index + 1, lengthDiff + rods[index], memo));

        //3. add/weld the rod segement @index to the poleLength2 and we move
        //to next rod segment index (==> index + 1)
        maxLength = Math.max(maxLength,
                rods[index] + tallestBillboard_Recursive_Memoization_Helper(
                        rods, index + 1, lengthDiff - rods[index], memo));

        return memo[index][lengthDiff + NEGATIVE_OFFSET] = maxLength;
    }

    public void tallestBillboard_Recursive_Memoization(int[] rods) {
        //https://leetcode.com/problems/tallest-billboard/description/
        //explanation: https://youtu.be/Zyzs3AuqPRw
        int n = rods.length;
        /*

        ............------------------------------
        ...........|                             |
        ...........|                             |
        ...........|                             |
        ............------------------------------
        ..............| |...................| |....
        ..............| |...................| |....
        ..............| |...................| |....
        ..............| |...................| |....
        ..............---...................---....
        ...........poleLength1...........poleLength2

        aim is to create two poles from rods[] by welding some subset of rod
        segemnt (==> rods[index]) such that both poles have equal lengths and
        their length is MAXIMIZED

        initially both poles will start from 0 lengths and in the recursion will
        have 3 choices over the rod segments of rods[]
        1. skip curr rod segment of rods[] @index
        2. add/weld curr rod segment of rods[] @index to poleLength1
        ==> poleLength1 + rods[index]
        3. add/weld curr rod segment of rods[] @index to poleLength2
        ==> poleLength2 + rods[index]

        in the base case where index >= rods.length where don't have any rods
        left to weld to any of the pole there we can check if both the poles
        lengths are equal or not (poleLength1 == poleLength2) if equal return
        the length of the pole otherwise 0, 0 becuse we need to maximize the
        pole length then 0 is MIN_VALUE we can consider

        extending the concept from tallestBillboard_Recursive()

        as mentioned in the base case, we were comparing the pole lengths
        (poleLength1 == poleLength2)
        ==> (poleLength1 = poleLength2)
        ==> poleLength1 - poleLength2 = 0 ==> lengthDiff

        weld choices we had

        2. add/weld curr rod segment of rods[] @index to poleLength1
        ==> poleLength1 + rods[index]
        ==> (poleLength1 + rods[index]) - poleLength2
        ==> (poleLength1 - poleLength2) + rods[index]
        ==> lengthDiff + rods[index]

        3. add/weld curr rod segment of rods[] @index to poleLength2
        ==> poleLength2 + rods[index]
        ==> poleLength1 - (poleLength2  + rods[index])
        ==> (poleLength1 - poleLength2) - rods[index]
        ==> lengthDiff - rods[index]

        after all the recursion, we will get the answer as maxLength but this time
        this maxLength is sum of both the poles(==> poleLength1 + poleLength2)
        so we need to divide by 2 to get max length of each pole

        ex:
        initially rods[] = [1,2,1]
        l1 = 0, l2 = 0 hence lengthDiff = l1 - l2 = 0

        add rods[0] to l1 ==> l1 + rods[0] ==> 1
        add rods[1] to l2 ==> l2 + rods[1] ==> 2
        add rods[2] to l1 ==> l1 + rods[2] ==> 1 + 1 = 2

        recursive calls to a valid path scene:
        main: maxLength = call(index, diff) ==> call(0, 0)

        1. choice 2 : add rods[0] to poleLength1 = 0 but diff = 0
        ==> rod[0] + call(1, diff + rod[0])
        ==> 1 + call(1, 0 + 1)
        ==> 1 + call(1, 1)

        2. choice 3 : add rods[1] to poleLength2 = 0 but diff = 1
        ==> rod[1] + call(2, diff - rod[1])
        ==> 2 + call(2, 1 - 2)
        ==> 2 + call(2, -1)

        3. choice 2 : add rods[2] to poleLength1 = 1 but diff = -1
        ==> rod[2] + call(3, diff + rod[2])
        ==> 1 + call(3, -1 + 1)
        ==> 1 + call(3, 0)

        4. BASE CASE : index >= n ==> 3 >= 3, with diff = 0
        ==> return diff == 0 ? 0 ==> call-back-3

        3. choice 2 : add rods[2] to poleLength1 = 1 but diff = -1
        ==> rod[2] + call(3, diff + rod[2])
        ==> 1 + call(3, -1 + 1)
        ==> 1 + call(3, 0)
        ==> 1 + 0 (==> recurs 4. return 0)
        ==> 1 ==> call-back-2

        2. choice 2 : add rods[1] to poleLength2 = 0 but diff = 1
        ==> rod[1] + call(2, diff - rod[1])
        ==> 2 + call(2, 1 - 2)
        ==> 2 + call(2, -1)
        ==> 2 + 1 (==> recurs 3. return 0)
        ==> 3 ==> call-back-1

        1. choice 2 : add rods[0] to poleLength1 = 0 but diff = 0
        ==> rod[0] + call(1, diff + rod[0])
        ==> 1 + call(1, 0 + 1)
        ==> 1 + call(1, 1)
        ==> 1 + 3 (==> recurs 2. return 3)
        ==> 4 ==> call-back-main

        main: call(0, 0)
        ==> maxLength = 4 which is sum of poleLength1 + poleLength2
        ==> hence maxLength / 2
        ==> 2

        for memoization we are taking 10001 as max limit for lengthDiff
        because as per given constraint sum(rods[i]) <= 5000
        in some case if we add up all the rods[index] to either of the pole
        like
        poleLength1 = 5000, poleLength2 = 0, lengthDiff = l1 - l2 ==> 5000 - 0 = 5000
        OR
        poleLength1 = 0, poleLength2 = 5000, lengthDiff = l1 - l2 ==> 0 - 5000 = -5000

        then respective lengthDiff will be -5000 <= lengthDiff <= 5000

        so above lengthDiff can be negative and to handle negative lengthDiff
        in memo[][lengthDiff] we need to OFFSET this negative lengthDiff with max
        constraint(==> 5000)

        lengthDiff with offset:

        OFFSET = 5000

        -5000 + OFFSET <= lengthDiff <= 5000 + OFFSET
        ==> 0 <= lengthDiff <= 10000

        thats why 5000 + OFFSET == 10000!!!

         */

        Integer[][] memo = new Integer[n + 1][10001];
        //initially we start off with index = 0 and poleLengths as 0, 0 because nothing
        //is welded in the start
        int maxLength = tallestBillboard_Recursive_Memoization_Helper(rods, 0, 0, memo);
        //output
        System.out.println("Tallest billboard (Recursive Memoization Approach): " + (maxLength / 2));
    }

    private int countAllPossibleRoutes_Recursive_Memoization_Helper(
            int[] locations, int currCityIndex, int finishCityIndex, int remainingFuel, Integer[][] memo) {

        int mod = 1000000007;
        int n = locations.length;

        //as per question, as long as we have fuel (means fuel is not negative)
        //we can move around in different cities at locations[cityIndex] BUT
        //once our fuel < 0 means negative we can't move to any other city hence
        //no routes is possible so return 0
        if (remainingFuel < 0) {
            return 0;
        }

        if (memo[currCityIndex][remainingFuel] != null) {
            return memo[currCityIndex][remainingFuel];
        }

        //as we are just roaming around the cities, so whenever our currCityIndex
        //is same as finishCityIndex, means there is some route between these two
        //cities, hence both cities are same there is 1 possible route otherwise 0
        int routesCount = currCityIndex == finishCityIndex ? 1 : 0;

        //since, we are allowed to roam around from one city to another, meaning
        //we can reach to next city index from our curr city index (only if they
        //are not same) so we will try out all such city routes
        for (int nextCityIndex = 0; nextCityIndex < n; nextCityIndex++) {

            //both, next and curr cities should not be same
            if (nextCityIndex == currCityIndex) {
                continue;
            }

            //try out all the possible routes
            routesCount = (routesCount + countAllPossibleRoutes_Recursive_Memoization_Helper(
                    locations,
                    nextCityIndex,
                    finishCityIndex,
                    //since we are moving from currCityIndex to nextCityIndex
                    //some fuel is also spent on this travel which is
                    //abs(locations[nextCity] - locations[currCity]) so for any
                    //other route, our curr fuel left is
                    //remainingFuel - abs(locations[nextCity] - locations[currCity])
                    remainingFuel - Math.abs(locations[nextCityIndex] - locations[currCityIndex]),
                    memo)) % mod;
        }

        return memo[currCityIndex][remainingFuel] = routesCount;
    }

    public void countAllPossibleRoutes_Recursive_Memoization(
            int[] locations, int startCityIndex, int finishCityIndex, int fuel) {
        //.............................T: O(N^2 * fuel)
        //We iterate over all cities for each currCity, remainingFuel state.
        //Because there are n * fuel states and computing each state requires
        //iterating over all the n cities (except the current one)
        //The recursive function might be called more than once as we saw in the
        //recursion tree. However, due to memoization each state will be computed
        //only once.
        //.............................S: O(N * fuel)
        //space needed for memo[][]
        //https://leetcode.com/problems/count-all-possible-routes/description/
        /*
        given, locations[] where the indexes are cities and locations[city] are
        the positions of each index 'city'

        we are initially at start city index and need to find count of routes to
        finish city index within given fuel that means, as long as we have fuel
        greater or equal to 0(==> fuel >= 0) we are allowed to roam in the city
        here and there

         */
        int n = locations.length;
        Integer[][] memo = new Integer[n + 1][fuel + 1];
        int routesCount = countAllPossibleRoutes_Recursive_Memoization_Helper(
                locations, startCityIndex, finishCityIndex, fuel, memo);

        //output
        System.out.println("Count all possible routes within given fuel : " + routesCount);
    }

    private int findSubstringWithMaxCost_Recursive_Memoization_Helper(
            String str, Map<Character, Integer> charToCost, int strIndex, Integer[] memo) {

        int n = str.length();

        //if we have reached the 'end of string' or 'string given is already empty
        //means(==> "")' in that case our max cost can only be 0 because as per
        //question 'The cost of the substring is the sum of the values of each
        //character in the substring. The cost of an empty string is considered 0'
        if (strIndex >= n) {
            return 0;
        }

        if (memo[strIndex] != null) {
            return memo[strIndex];
        }

        //max cost = 0, denotes for an empty substring because any how there will
        //always exist an empty substring in 'str' that we can be picked by default
        int maxCost = 0;

        //curr cost is the cost considered for the curr substring
        int currCost = 0;

        //generating all possible substrings
        for (int index = strIndex; index < n; index++) {

            char chr = str.charAt(index);

            //for the curr char of 'str' that is 'chr' if any cost value was provided
            //in costs[] we can get that costs value otherwise acc to question by
            //default we can pick is 1-based alphabet positions(ex: a = 1, b = 2, c = 3, ... z = 26)
            currCost += charToCost.getOrDefault(chr, (chr - 'a') + 1);

            //choose the maxCost of all the possibilities of the substrings
            maxCost = Math.max(maxCost,
                    //substring cost from curr substring starting with @strIndex
                    Math.max(currCost,
                            //substrings cost from recursive calls starting from
                            //@(index + 1)
                            findSubstringWithMaxCost_Recursive_Memoization_Helper(
                                    str, charToCost, index + 1, memo)));
        }

        return memo[strIndex] = maxCost;
    }

    public void findSubstringWithMaxCost_Recursive_Memoization(String str, String chars, int[] costs) {
        //https://leetcode.com/problems/find-the-substring-with-maximum-cost/description/
        /*

        The value of the character is defined in the following way:

        1. If the character is not in the string chars, then its value is its
        corresponding position (1-indexed) in the alphabet.
        For example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.

        2. Otherwise, assuming i is the index where the character occurs in the
        string chars, then its value is vals[i].

        ***Though the Recursive Memoization solution is OKAY
        BUT for larger input size, this approach will give 'TLE'

        so this approach will be commented

         */
        int n = str.length();

        Map<Character, Integer> charToCost = new HashMap<>();
        //string 'chars' will contain distinct chars where cost of chars[i] is
        //costs[i]
        //so to easily access the cost of chars[i] create a map for each chars[i]
        //with its cost
        for (int i = 0; i < chars.length(); i++) {
            charToCost.put(chars.charAt(i), costs[i]);
        }

        Integer[] memo = new Integer[n + 1];

        int maxCost = findSubstringWithMaxCost_Recursive_Memoization_Helper(str, charToCost, 0, memo);
        //output
        System.out.println("Find substring with max cost (Recursive Memoization): " + maxCost);
    }

    public void findSubstringWithMaxCost_DP_Memoization(String str, String chars, int[] costs) {
        //https://leetcode.com/problems/find-the-substring-with-maximum-cost/description/
        //based on KADEN'S ALGO
        /*

        The value of the character is defined in the following way:

        1. If the character is not in the string chars, then its value is its
        corresponding position (1-indexed) in the alphabet.
        For example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.

        2. Otherwise, assuming i is the index where the character occurs in the
        string chars, then its value is vals[i].

        ***Since the above Recursive Memoization was OKAY BUT giving TLE on larger
        inputs, here we will use kaden's algo to solve this question

        BUT why we need to apply kaden's algo?

        aim of the question is to 'find a max cost of substring of given string str'
        also given that each char in 'str' have a default value of its 1-based
        positions like a = 1, b = 2, c = 3, ... z = 26

        now for ex: str = "adaa"
        this can be written as array of cost of each char of 'str'
        "adaa" ==> alphabetCost[] = [1, 4, 1, 1] as a = 1, d = 4

        also, in the questions we are given a string chars, which contains some
        distinct alphbet/chars and costs[] which together denotes that for each
        i-th char in chars string, will have corresponding cost as costs[i]

        chars = "d", costs[] = [-1000]
        ==> i = 0, chars[i] = costs[i]
        ==> 'd' = -1000

        hence cost of each char of 'str' is now updated
        ==> alphabetCost[] = [1, -1000, 1, 1] because char 'd' has an updated cost of -1000

        NOW question statment is same as kaden's algo, where we need to
        find max subarray sum from the given array
        ==> 'find a max cost of substring of given string str'

         */
        int n = str.length();

        //since we are only having 26 chars at max(i.e, a to z)
        //we will save each char's actual cost value
        int[] alphabetCost = new int[26];

        //pre-compute score for each char of alphabet
        //for the curr char 'chr' of alphabet, acc to question by default we can
        //pick is 1-based alphabet positions(ex: a = 1, b = 2, c = 3, ... z = 26)
        for (char chr = 'a'; chr <= 'z'; chr++) {

            alphabetCost[chr - 'a'] = (chr - 'a') + 1;
        }

        //string 'chars' will contain distinct chars where cost of chars[i] is
        //costs[i], so if any specific cost value is provided as costs[i] for any
        //char @i-th index in 'chars' then we can update the score for that 'chr'
        //in alphabetCost[chr]
        for (int i = 0; i < chars.length(); i++) {

            char chr = chars.charAt(i);
            int chrCost = costs[i];

            //cost of chr = chrCost
            alphabetCost[chr - 'a'] = chrCost;
        }

        //kaden's algo
        //since, the overall subarrays sum can be negative then its better to use
        //Integer.MIN_VALUE as initial maxCost
        int maxCost = Integer.MIN_VALUE;

        int currCost = 0;

        for (char chr : str.toCharArray()) {

            //cost of curr char 'chr' from given string 'str', since we have pre-computed
            //all the possible cost value for each char in alphabetCost[] we can easily
            //pick that cost
            int cost = alphabetCost[chr - 'a'];

            currCost = Math.max(currCost + cost, cost);
            maxCost = Math.max(maxCost, currCost);
        }

        //for cases like str = "abc", chars = "abc", costs[-1, -1, -1]
        //where cost of chars[i] is costs[i] that means
        //a = -1, b = -1, c = -1
        //hence the maxCost from above kaden's algo will be -3 but we can also
        //consider an empty string from 'str' and hence its cost will be 0 because
        //as per question, 'The cost of an empty string is considered 0'
        maxCost = Math.max(maxCost, "".length());

        //output
        System.out.println("Find substring with max cost (DP Memoization): " + maxCost);
    }

    private int substringWithLargestVariance_Recursive_Memoization_GetVariance(int[] freq) {

        int maxVariance = 0;

        for (char chrI = 'a'; chrI <= 'z'; chrI++) {

            if (freq[chrI - 'a'] == 0) {
                continue;
            }

            for (char chrJ = 'a'; chrJ <= 'z'; chrJ++) {

                if (freq[chrJ - 'a'] == 0) {
                    continue;
                }

                maxVariance = Math.max(maxVariance, Math.abs(freq[chrI - 'a'] - freq[chrJ - 'a']));
            }
        }

        return maxVariance;
    }

    private int substringWithLargestVariance_Recursive_Memoization_Helper(
            String str, int startIndex, Integer[] memo) {

        int n = str.length();

        //as we have reached the end of 'str' or 'str is empty' so we can't pick
        //any more chars to calculate variance hence return 0 as variance
        if (startIndex >= n) {
            return 0;
        }

        //if cached
        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int largestVariance = 0;

        //keep the freq of chars considered in the substring formed from
        //curr [startIndex to n] in this curr recursive call
        int[] charFreq = new int[26];

        //generate the substring of 'str' from curr [startIndex to n]
        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //count the freq of curr char 'chr'
            char chr = str.charAt(endIndex);
            charFreq[chr - 'a']++;

            //calculate the max variance we can have in the curr substring from
            //[startIndex to endIndex]
            int currVariance = substringWithLargestVariance_Recursive_Memoization_GetVariance(charFreq);

            //store the largest variance from all possible substring,
            largestVariance = Math.max(
                    largestVariance,
                    Math.max(
                            //variance for curr substring formed in this recursive
                            //call
                            currVariance,
                            //largest variance we can get from rest of substrings
                            //of 'str'
                            substringWithLargestVariance_Recursive_Memoization_Helper(str, endIndex + 1, memo)));

        }

        return memo[startIndex] = largestVariance;
    }

    public void substringWithLargestVariance_Recursive_Memoization(String str) {
        //https://leetcode.com/problems/substring-with-largest-variance/description/
        //this approach gives TLE even after memoization because we need better
        //way to calculate variance other than getVariance() we have
        //we keep this commented
        int n = str.length();

        Integer[] memo = new Integer[n + 1];

        int largestVariance = substringWithLargestVariance_Recursive_Memoization_Helper(str, 0, memo);
        //output
        System.out.println("Substring with largest variance (approach Recursive Memoization): " + largestVariance);
    }

    public void substringWithLargestVariance_DP_Memoization(String str) {
        //https://leetcode.com/problems/substring-with-largest-variance/description/
        //based on modified KADEN'S ALGO
        int[] charFreq = new int[26];

        for (char ch : str.toCharArray()) {
            charFreq[ch - 'a']++;
        }

        int globalMax = 0;

        for (char chrI = 'a'; chrI <= 'z'; chrI++) {

            //skip, if curr chrI is not in 'str'
            if (charFreq[chrI - 'a'] == 0) {
                continue;
            }

            for (char chrJ = 'a'; chrJ <= 'z'; chrJ++) {

                //skip, if major and minor chars are same
                if (chrI == chrJ) {
                    continue;
                }

                //skip, if curr chrJ is not in 'str'
                if (charFreq[chrJ - 'a'] == 0) {
                    continue;
                }

                //here, we will consider two char at time to calculate the variance
                //majorChar & minorChar
                char majorChr = chrI;
                char minorChr = chrJ;

                //find the maximum variance of majorChrCount - minorChrCount
                int majorChrCount = 0;
                int minorChrCount = 0;

                //the remaining minorChrCount in the rest of s
                int remainingMinorChrCount = charFreq[chrJ - 'a'];

                for (char ch : str.toCharArray()) {

                    if (ch == majorChr) {
                        majorChrCount++;
                    }

                    if (ch == minorChr) {
                        minorChrCount++;
                        remainingMinorChrCount--;
                    }

                    // Only update the variance if there is at least one minor.
                    if (minorChrCount > 0) {
                        globalMax = Math.max(globalMax, majorChrCount - minorChrCount);
                    }

                    // We can discard the previous string if there is at least one remaining minor.
                    if (majorChrCount < minorChrCount && remainingMinorChrCount > 0) {
                        majorChrCount = 0;
                        minorChrCount = 0;
                    }
                }
            }
        }

        //output
        System.out.println("Substring with largest variance (approach DP Memoization): " + globalMax);
    }

    private int maxProfitInJobScheduling_Recursive_Memoization_BinarySearchIncrStartTimeFromEndTime(
            int[][] events, int endTime) {

        int n = events.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //'mid' should represent an event[][] whose start time is STRICTLY
            //GREATER than the end time of the event choosen, now if the curr
            //event at 'mid' is a valid event then its prev event's start time
            //should be less or equal to the 'endTime' OR a valid 'mid' exist
            //at index = mid = 0 in that case (mid - 1) will not exist
            if ((mid == 0 || events[mid - 1][0] <= endTime) && endTime < events[mid][0]) {
                return mid;
            } else if (events[mid][0] <= endTime) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        return start;
    }

    private int maxProfitInJobScheduling_Recursive_Memoization_Helper(
            int[][] events, int index, Integer[] memo) {

        int n = events.length;

        //as we reached the end of the events[][] then if after this we can't
        //pick anymore events hence event value becomes 0, retuen 0
        if (index >= n) {
            return 0;
        }

        //if cached
        if (memo[index] != null) {
            return memo[index];
        }

        //initial max event value that we need to maximize
        int maxProfitValue = 0;

        //2 choices we cn make here,
        //1. don't pick the curr event @index from events[][] and simply move to
        //next index(==> index  + 1) and we will not be considering its profit value
        maxProfitValue = Math.max(maxProfitValue,
                maxProfitInJobScheduling_Recursive_Memoization_Helper(events, index + 1, memo));

        //2. pick the curr event @index from events[][] then we can consider its
        //event value 'currProfitValue', now from here, we need to move to an
        //index value which is acc to question, the next event index can be
        //'If you choose a job that ends at time X you will be able to start
        //another job that starts at time X.'
        //in order to achieve that, we first sorted the events[][] in incr order
        //of the startTime, now using the binary search we need to find an index
        //'nextEventIndex' at which this event's startTime is greater or equal
        //than the curr choosen event's endTime(==> currEndTime)
        //==> events[index].currEndTime <= events[nextEventIndex].startTime
        int currEndTime = events[index][1];
        int currProfitValue = events[index][2];

        int nextEventIndex = maxProfitInJobScheduling_Recursive_Memoization_BinarySearchIncrStartTimeFromEndTime(
                events, currEndTime);

        maxProfitValue = Math.max(
                maxProfitValue,
                //consider the curr event value and move to next valid event index
                //'nextEventIndex'
                currProfitValue + maxProfitInJobScheduling_Recursive_Memoization_Helper(
                        events, nextEventIndex, memo));

        return memo[index] = maxProfitValue;
    }

    public void maxProfitInJobScheduling_Recursive_Memoization(int[] startTime, int[] endTime, int[] profit) {
        //https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/description/
        //based on BINARY SEARCH
        int n = startTime.length;

        int[][] events = new int[n][3];

        //create an 2D array with combined values
        for (int i = 0; i < n; i++) {
            events[i] = new int[]{startTime[i], endTime[i], profit[i]};
        }

        Integer[] memo = new Integer[n + 1];

        //sort the events[][] in incr order of the start time
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));

        int maxProfitValue = maxProfitInJobScheduling_Recursive_Memoization_Helper(events, 0, memo);

        //output
        System.out.println("Max profit in job scheduling : " + maxProfitValue);
    }

    private int maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_BinarySearchStrictlyIncrStartTimeFromEndTime(
            int[][] events, int endTime) {

        int n = events.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //'mid' should represent an event[][] whose start time is STRICTLY
            //GREATER than the end time of the event choosen, now if the curr
            //event at 'mid' is a valid event then its prev event's start time
            //should be less or equal to the 'endTime' OR a valid 'mid' exist
            //at index = mid = 0 in that case (mid - 1) will not exist
            if ((mid == 0 || events[mid - 1][0] <= endTime) && endTime < events[mid][0]) {
                return mid;
            } else if (events[mid][0] <= endTime) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        return start;
    }

    private int maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_Helper(
            int[][] events, int index, int k, Integer[][] memo) {

        int n = events.length;

        //as we can only pick atmost 'k' events from events[][] so if ever 'k'
        //becomes 0, then we can't pick any event and hence its event value
        //becomes 0, return 0
        if (k <= 0) {
            return 0;
        }

        //as we reached the end of the events[][] then if after this we can't
        //pick anymore events hence event value becomes 0, retuen 0
        if (index >= n) {
            return 0;
        }

        //if cached
        if (memo[index][k] != null) {
            return memo[index][k];
        }

        //initial max event value that we need to maximize
        int maxEventValue = 0;

        //2 choices we cn make here,
        //1. don't pick the curr event @index from events[][] and simply move to
        //next index(==> index  + 1) and since we didn't pick this curr event,
        //'k' remain as it is and we will not be considering its event value
        maxEventValue = Math.max(maxEventValue,
                maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_Helper(
                        events, index + 1, k, memo));

        //2. pick the curr event @index from events[][] then we can consider its
        //event value 'currEventValue' and also 'k' must be reduced by 1 as we
        //took one event here. Now from here, we need to move to an index value
        //which is acc to question, the next event should not be overlapping with
        //curr event
        //in order to achieve that, we first sorted the events[][] in incr order
        //of the startTime, now using the binary search we need to find an index
        //'nextEventIndex' at which this event's startTime is STRICTLY INCR than
        //the curr choosen event's endTime(==> currEndTime)
        //==> events[index].currEndTime < events[nextEventIndex].startTime
        int currEndTime = events[index][1];
        int currEventValue = events[index][2];

        int nextEventIndex = maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_BinarySearchStrictlyIncrStartTimeFromEndTime(
                events, currEndTime);

        maxEventValue = Math.max(
                maxEventValue,
                //consider the curr event value and move to next valid event index
                //'nextEventIndex'
                currEventValue + maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_Helper(
                        events, nextEventIndex, k - 1, memo));

        return memo[index][k] = maxEventValue;
    }

    public void maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization(int[][] events, int k) {
        //https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/description/
        //https://leetcode.com/problems/two-best-non-overlapping-events/description/
        //based on BINARY SEARCH and maxProfitInJobScheduling_Recursive_Memoization()
        int n = events.length;
        Integer[][] memo = new Integer[n + 1][k + 1];
        //since we can't pick two events that are overlapping with each other
        //we must sort the events[][] and use binary search to find next event
        //index whoose startTime is STRICTLY INCR than prev choosen event's endTime
        //sort the events in incr order of its startTime
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));

        int maxEventValue = maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization_Helper(events, 0, k, memo);

        //output
        System.out.println("Max number of events value that can be attended two : " + maxEventValue);
    }

    private long maxAlternatingSubseqSum_Recursive_Memoization_Helper(
            int[] nums, int index, boolean toAdd, Long[][] memo) {

        int n = nums.length;

        if (index >= n) {
            return 0L;
        }

        if (memo[index][toAdd ? 0 : 1] != null) {
            return memo[index][toAdd ? 0 : 1];
        }

        long maxSubseqSum = 0L;

        maxSubseqSum = Math.max(maxSubseqSum,
                maxAlternatingSubseqSum_Recursive_Memoization_Helper(
                        nums, index + 1, toAdd, memo));

        int value = toAdd ? nums[index] : -nums[index];

        maxSubseqSum = Math.max(maxSubseqSum,
                value + maxAlternatingSubseqSum_Recursive_Memoization_Helper(
                        nums, index + 1, !toAdd, memo));

        return memo[index][toAdd ? 0 : 1] = maxSubseqSum;
    }

    public void maxAlternatingSubseqSum_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/maximum-alternating-subsequence-sum/description/
        //explanation: https://youtu.be/bRk0n5JyXSc
        int n = nums.length;
        Long[][] memo = new Long[n + 1][2];
        long maxSubseqSum = maxAlternatingSubseqSum_Recursive_Memoization_Helper(nums, 0, true, memo);

        //output
        System.out.println("Max alternating subseq sum : " + maxSubseqSum);
    }

    private int russianDollsEnvelopes_DP_Memoization_HelperBinarySearch(int[] memoIndexAsLIS, int height) {

        int n = memoIndexAsLIS.length;

        int start = 0;
        int end = n - 1;

        int smallestEnvelopeHeightIndex = 0;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            if (memoIndexAsLIS[mid] < height) {
                smallestEnvelopeHeightIndex = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }

        return smallestEnvelopeHeightIndex;
    }

    public void russianDollsEnvelopes_DP_Memoization(int[][] envelopes) {
        //https://leetcode.com/problems/russian-doll-envelopes/description/
        //based on LONGEST INCR SUBSEQ (LIS), BINARY SEARCH
        //but the exact O(n ^ 2) logic will give TLE here, so need to modify
        //it so solve
        int n = envelopes.length;

        //sort the envelopes in increasing order of their width value envelopes[i][0]
        //if widths are same then sort enevlopes in decreasing order of their height
        //value enevelopes[i][1]
        //why are we sorting heights in decr order whenever two widths are same?
        //because
        //ex: envelopes[][] = [[4,5],[4,6],[6,7],[2,3],[1,1]]
        //now if we sort this normally in incr order of widths as well as heights
        //then after sortiing it would be ==> [[1,1],[2,3],[4,5],[4,6],[6,7]]
        //now since width are in incr order then in order to find max doll length
        //we would do LIS calculation on heights only, now look for LIS on heights
        //==> 1 < 3 < 5 < 6 < 7 ==> LIS = 5, height of each envelopes are incr
        //so this gives an idea that LIS is 5
        //BUT
        //using this sorting we missed to check if two widths are equal or not
        //before considering them in LIS of heights, meaning LIS on heights
        //==> 1 < 3 < [5 < 6] < 7, envelopes with height 5 & 6 have width of 4 each
        //which is not allowed as per question
        //this is the reason, we are sorting heights in decr order when two widths
        //are same for envelopes, as out of [4,5] & [4,6] we can consider 'atmost 1'
        //envelope to be part of LIS on heights
        Arrays.sort(envelopes, (a, b) -> a[0] == b[0]
                ? Integer.compare(b[1], a[1])
                : Integer.compare(a[0], b[0]));

        //here the index of this LIS[] will be the longest incr subseq length
        //but the value stored at LIS[i] = 'height' will be the smallest possible
        //height of envelope, why smallest height? because it is easier to find
        //a longest incr subseq if the prev value/height is comparatively smaller
        //than the curr value/height
        //ex:
        //index:    0   1   2   3   5   6
        //height:   h1  h2  h3  h4  h5  h6
        //this states that if we need a longest incr subseq of length let say 5
        //then h4 < h5
        int[] memoIndexAsLIS = new int[n + 1];
        //initially, all LIS[i] will have max height possible
        Arrays.fill(memoIndexAsLIS, Integer.MAX_VALUE);
        //except for LIS[0], a base cond where longest incr subseq with length = 0
        //will actually don't have any envelopes/value (==> n = 0) hence we can
        //consider here a min possible height
        memoIndexAsLIS[0] = Integer.MIN_VALUE;

        int maxDollsLength = 0;

        for (int i = 0; i < n; i++) {

            int height = envelopes[i][1];

            int smallestEnvelopeHeightIndex = russianDollsEnvelopes_DP_Memoization_HelperBinarySearch(
                    memoIndexAsLIS, height);

            if (smallestEnvelopeHeightIndex == -1) {
                continue;
            }

            //since we mentioned above, each index of LIS[] is a possible length
            //so if we found an index 'smallestEnvelopeHeightIndex' where this curr 'height'
            //is greater than some prev height, that would mean this will create
            //a new longest incr subseq
            maxDollsLength = Math.max(maxDollsLength, smallestEnvelopeHeightIndex + 1);

            memoIndexAsLIS[smallestEnvelopeHeightIndex + 1] = height;
        }
        //output
        System.out.println("Russian dolls envelopes  : " + maxDollsLength);
    }

    private double knightProbabiltyInChessBoard_Recursive_Memoization_Helper(
            int n, int row, int col, int k, int[][] knightDirs, Double[][][] memo) {

        //return 0.0, as knight has gone out of the chessboard 'isOutOfBounds'
        if (row < 0 || row >= n || col < 0 || col >= n) {
            return 0.0;
        }

        //return 1.0, as within k moves, knight is still inside the chessboard
        //how we can say till below if(), knight is inside chessboard? because
        //above if() block checks the is-out-of-bounds case and if that if()
        //didn't execute and we reached this statement here where move, k == 0
        //then we can say that within k moves knight stays inside chessboard
        //hence its one way where knight remain in board, out of all 8-dirs it
        //can move to
        if (k == 0) {
            return 1.0;
        }

        //return cached probabililty, if stored any similar state earlier
        if (memo[row][col][k] != null) {
            return memo[row][col][k];
        }

        //ways, that sums up the total possible knight dirs/movement within k
        //moves where knight remain inside board
        double ways = 0.0;

        for (int[] dir : knightDirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];

            //now from curr row & col, we will move to new row & col coord as per
            //knight's movement(two & half movement), since we are making a move
            //then k should be reduced(==> k - 1)
            ways += knightProbabiltyInChessBoard_Recursive_Memoization_Helper(
                    n, newRow, newCol, k - 1, knightDirs, memo);

        }

        //probability, out of all the 8 dirs/movement the knight can make from
        //curr row & col, chances/ways in which this knight stays inside board
        //gives us the probabiltity
        double probability = ways / 8.0;

        return memo[row][col][k] = probability;
    }

    public void knightProbabiltyInChessBoard_Recursive_Memoization(int n, int k, int row, int col) {
        //https://leetcode.com/problems/knight-probability-in-chessboard/description/
        //explanation: https://youtu.be/ETA-5CD0z7Q
        /*

        as knight moves two & half steps from its curr coord(here, row & col)
        so below there are 8 possible(two & half) directions from its curr coord

                                            (two steps up & half step left)         (two steps up & half step right)
                                                        (row - 2, col - 1) _   _ (row - 2, col + 1)
                                                                            | |
              (two steps left & half step up) = (row - 1, col - 2) |        | |         | (row - 1, col + 2) = (two steps right & half step up)
                                                                    - -    knight    - -
                                                                    - -  (row, col)  - -
            (two steps left & half step down) = (row + 1, col - 2) |        | |          | (row + 1, col + 2) = (two steps right & half step down)
                                                                            | |
                                                        (row + 2, col - 1) -   - (row + 2, col - 1)
                                        (two steps down & half step left)        (two steps down & half step right)

         */
        int[][] knightDirs = {
                {-2, -1}, //two steps up & half step left
                {-2, 1}, //two steps up & half step right
                {-1, -2}, //two steps left & half step up
                {-1, 2}, //two steps right & half step up
                {2, -1}, //two steps down & half step left
                {2, 1}, //two steps down & half step right
                {1, -2}, //two steps left & half step down
                {1, 2} //two steps right & half step down
        };

        Double[][][] memo = new Double[n][n][k + 1];

        double knightProbability = knightProbabiltyInChessBoard_Recursive_Memoization_Helper(
                n, row, col, k, knightDirs, memo);

        //output
        System.out.println("Knight probabilty in chessboard : " + knightProbability);
    }

    private List<TreeNode<Integer>> allPossibleFullBinaryTrees_Recursive_Memoization_Helper(
            int n, List<TreeNode<Integer>>[] memo) {

        //return an empty subtree nodes list, because we know that even numbered
        //nodes can't form full binary tree
        if (n % 2 == 0) {
            return new ArrayList<>();
        }

        //as we just have 1 nodes for full binary tree, return a subtree nodes
        //list with that n == 1 node in it
        if (n == 1) {
            return Arrays.asList(new TreeNode<>(0));
        }

        //if cached
        if (memo[n] != null) {
            return memo[n];
        }

        List<TreeNode<Integer>> currFullBinaryTrees = new ArrayList<>();

        //as any left or right subtree we will form, has to be a full binary tree
        //and we know for that we need odd numbered nodes, hence this loop will
        //generate possibilties of forming left & right subtrees by pass oddNodes
        for (int oddNodes = 1; oddNodes < n; oddNodes += 2) {

            //passing curr 'oddNodes' to form full binary leftSubtree(==> oddNodes)
            List<TreeNode<Integer>> leftSubtree = allPossibleFullBinaryTrees_Recursive_Memoization_Helper(
                    oddNodes, memo);

            //passing remaining oddNodes to form full binary rightSubtree(==> n - oddNodes)
            //we have to do -1 as well beacuse we need to consider one node as
            //root, so (==> n - oddNodes - 1)
            List<TreeNode<Integer>> rightSubtree = allPossibleFullBinaryTrees_Recursive_Memoization_Helper(
                    n - oddNodes - 1, memo);

            //from here, we can generate all possible full binary trees
            for (TreeNode<Integer> leftNode : leftSubtree) {

                for (TreeNode<Integer> rightNode : rightSubtree) {

                    TreeNode<Integer> root = new TreeNode<>(0, leftNode, rightNode);

                    currFullBinaryTrees.add(root);
                }
            }
        }

        return memo[n] = currFullBinaryTrees;
    }

    public void allPossibleFullBinaryTrees_Recursive_Memoization(int n) {
        //https://leetcode.com/problems/all-possible-full-binary-trees/description/
        //https://leetcode.com/problems/all-possible-full-binary-trees/editorial/
        /*

        each node in a full binary tree has either 0 or 2 children, because a
        full binary tree will always have an odd number of nodes (root node + even child nodes).

        a basic full binary tree
        1. tree with 0 childrens where n = 1
        ==> ..............root

        2. tree with 2 childrens, where n = 3
        ==> ..............root
            ............./....\
            .........left.....right

        As we just said above a tree can only have either 0 or 2 childrens that
        makes the number of nodes in full binary tree can only be formed
        when n = odd numbered nodes

        so here we get the base case,
        if n % 2 == 0 (==> even nodes) full binary tree not possible hence,
        return new ArrayList<>()

        if n == 1 means only node we can add to make a full binary tree hence,
        return Arrays.asList(new TreeNode<>(0));

        To find all the possible permutations of full binary trees with n nodes,
        we can use one node as the root node and split the other n - 1 nodes
        between the left and right subtrees in all possible ways. Let us say we
        place i nodes in the left subtree and n - i - 1 in the right subtree.

        Now, we create a list of root nodes called left for all possible full
        binary trees that can be formed using i nodes. Similarly, we create a
        list of root nodes called right for all the full binary trees using
        n - i - 1 nodes. We can now create a new full binary tree by choosing
        one element from left to be the left child and one element from right to
        be the right child. To generate all full binary trees, we will iterate
        over all pairs between left, right.

        As we know any full binary tree must have an odd number of nodes, i and
        n - 1 - i should be odd as well to form full binary trees that are being
        used as the left and right subtrees. As a result, we move the value of i
        from i = 1 till n - 1 incrementing i by 2 each time so that we just loop
        on odd numbers of i. Since we have odd n and odd i, n - 1 - i would also
        be an odd number.

         */
        List<TreeNode<Integer>>[] memo = new ArrayList[n + 1];
        List<TreeNode<Integer>> fullBinaryTrees = allPossibleFullBinaryTrees_Recursive_Memoization_Helper(
                n, memo);

        //output
        System.out.println("All possible full binary tree with " + n + " nodes : ");
        for (TreeNode<Integer> root : fullBinaryTrees) {
            System.out.println();
            new BinaryTree<>(root).treeBFS();
        }
        System.out.println();
    }

    List<TreeNode<Integer>> uniqueBinarySearchTreesTwo_Recursive_Memoization_Helper(
            int start, int end, Map<String, List<TreeNode<Integer>>> memo) {

        List<TreeNode<Integer>> bsts = new ArrayList<>();

        if (start > end) {
            bsts.add(null);
            return bsts;
        }

        String key = start + "," + end;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        for (int node = start; node <= end; node++) {

            List<TreeNode<Integer>> leftSubtree = uniqueBinarySearchTreesTwo_Recursive_Memoization_Helper(
                    start, node - 1, memo);

            List<TreeNode<Integer>> rightSubtree = uniqueBinarySearchTreesTwo_Recursive_Memoization_Helper(
                    node + 1, end, memo);

            for (TreeNode<Integer> leftNode : leftSubtree) {

                for (TreeNode<Integer> rightNode : rightSubtree) {

                    TreeNode<Integer> root = new TreeNode(node, leftNode, rightNode);

                    bsts.add(root);
                }
            }
        }

        memo.put(key, bsts);

        return bsts;
    }

    public void uniqueBinarySearchTreesTwo_Recursive_Memoization(int n) {
        //https://leetcode.com/problems/unique-binary-search-trees-ii/description/

        Map<String, List<TreeNode<Integer>>> memo = new HashMap<>();

        List<TreeNode<Integer>> bsts = uniqueBinarySearchTreesTwo_Recursive_Memoization_Helper(1, n, memo);

        //output
        System.out.println("Unique binary search trees two with " + n + " nodes : ");
        for (TreeNode<Integer> root : bsts) {
            System.out.println();
            new BinaryTree<>(root).treeBFS();
        }
        System.out.println();
    }

    public void waysToAddParenthesis_Recursive_Memoization(String expression) {
        //https://leetcode.com/problems/different-ways-to-add-parentheses/description/
        /*

        Intuition to solve this question,

        expression = "22-1"
        split the expression on opeartor

        .............. -
        ............/.....\
        ..........22.......1

        split expression on operator and as sub-problem, solve left-side and right-side
        expressions and compute their results

        with this splitting, we can reach a point where there is no operator in
        their sub-expressions
        ==> "22" ==> containsAnyOperator() ==> false
        hence in such cases, these sub-expressions can't be further splitted and
        hence return the Int("22") as list of sub-expression result

        similarly, for sub-expression "1", it should return as list

        now, when all the left-side & right-side sub-expression is solved with
        possibilities of 'add parenthesis', we will get leftExpressionResults &
        rightExpressionResults for all these possibilities

        and futher using these results, we can compute the curr possibilties of
        result with the curr operator split i.e, here '-'

         */
        //Helper class
        class Helper {

            Map<String, List<Integer>> memo = new HashMap<>();

            private boolean containsAnyOperator(String expression) {

                for (char chr : expression.toCharArray()) {
                    if (chr == '+' || chr == '-' || chr == '*') {
                        return true;
                    }
                }
                return false;
            }

            private int computeExpressionWithOperator(char operator, int leftResult, int rightResult) {
                switch (operator) {
                    case '+':
                        return leftResult + rightResult;
                    case '-':
                        return leftResult - rightResult;
                    case '*':
                        return leftResult * rightResult;
                }
                return 0;
            }

            public List<Integer> waysToAddParenthesis_Recursive_Memoization_Helper(String expression) {

                int n = expression.length();

                if (memo.containsKey(expression)) {
                    return memo.get(expression);
                }

                //a sub-expression, that no more contains any operators, can't
                //be splitted further based on operator, hence this means there
                //is just a numeric expression, simply return that 'int'
                //sub-expression as list
                if (!containsAnyOperator(expression)) {
                    return Arrays.asList(Integer.parseInt(expression));
                }

                List<Integer> expressionResults = new ArrayList<>();

                for (int i = 0; i < n; i++) {

                    //as we are splitting based on the curr i-th 'operator', so
                    //if we see an operator we need to solve sub-expression
                    //that exists on left-side & right-side of this 'operator'
                    if (!Character.isDigit(expression.charAt(i))) {

                        //curr operator
                        char operator = expression.charAt(i);

                        //solve all the 'add parenthesis' possibilities and get
                        //result for left sub-expression
                        List<Integer> leftExpressionResults = waysToAddParenthesis_Recursive_Memoization_Helper(
                                expression.substring(0, i));

                        //solve all the 'add parenthesis' possibilities and get
                        //result for right sub-expression
                        List<Integer> rightExpressionResults = waysToAddParenthesis_Recursive_Memoization_Helper(
                                expression.substring(i + 1));

                        //curr i-th char is an operator i.e, ('+', '-', '*') and
                        //we have all the possible sub-expression results that
                        //exist on left-side & right-side of curr i-th operator
                        //now all these sub-expressions are sub-problems we solved
                        //and hence generated the list of results as:
                        //leftExpressionResults, for this we solved sub-expression
                        //expression[0, i - 1] (==> not including curr 'operator')
                        //rightExpressionResults, for this we solved sub-expression
                        //expression[i + 1, n]
                        //now, all these results will give several different
                        //results with the curr 'operator' is place
                        for (int leftResult : leftExpressionResults) {

                            for (int rightResult : rightExpressionResults) {

                                int currResult = computeExpressionWithOperator(
                                        operator, leftResult, rightResult);

                                expressionResults.add(currResult);

                            }
                        }
                    }
                }

                memo.put(expression, expressionResults);

                return expressionResults;
            }

        }

        Helper helper = new Helper();

        List<Integer> expressionResults = helper.waysToAddParenthesis_Recursive_Memoization_Helper(
                expression);
        //output
        System.out.println("Different ways to add parenthesis : " + expressionResults);
    }

    private double soupServings_Recursive_Memoization_Helper(int A, int B, Double[][] memo) {

        //as question asked, 'plus half the probability that A and B become empty
        //at the same time', here as the base cond, we can see that both soups
        //A & B got emptied at same time so ideally their probabilty should be 1
        //but we just need to return half ==> 1/2 ==> 0.5
        if (A == 0 && B == 0) {
            return 0.5;
        }

        //if only the soup A is emptied first, we need to straight away return 1
        //as it probabiltiy
        if (A == 0) {
            return 1.0;
        }

        //ideally, we are not bothering about soup B is getting emptied but still
        //if it got emptied before soup A, return 0.0 (for not consideration)
        if (B == 0) {
            return 0.0;
        }

        if (memo[A][B] != null) {
            return memo[A][B];
        }

        double probability = 0.0;

        //as per question statement, 'If the remaining volume of soup is not
        //enough to complete the operation, we will serve as much as possible'
        //means atmost quantity of soup that we can serve is the
        //min(quantity_remaining, servings_per_oprns)
        //SERVINGS OPRN 1
        probability += soupServings_Recursive_Memoization_Helper(
                A - Math.min(A, 100), B - 0, memo);

        //SERVINGS OPRN 2
        probability += soupServings_Recursive_Memoization_Helper(
                A - Math.min(A, 75), B - Math.min(B, 25), memo);

        //SERVINGS OPRN 3
        probability += soupServings_Recursive_Memoization_Helper(
                A - Math.min(A, 50), B - Math.min(B, 50), memo);

        //SERVINGS OPRN 4
        probability += soupServings_Recursive_Memoization_Helper(
                A - Math.min(A, 25), B - Math.min(B, 75), memo);

        //as we performed all 4 oprn, and acc to question 'we will choose from
        //the four operations with an equal probability 0.25' so all these oprns
        //should be multiplied with 0.25
        return memo[A][B] = 0.25 * probability;
    }

    public void soupServings_Recursive_Memoization(int n) {
        //https://leetcode.com/problems/soup-servings/
        //explanation: https://youtu.be/BiA4x5Gj7io
        //RECURSIVE THOUGHT IS FINE BUT NOT SO INTUITIVE ON MEMOIZATION
        //intuition behind this if(n >= 5000) is that,
        //as per question, 'Note: that we do not have an operation where all
        //100 ml's of soup B are used first.', means since we don't have any oprn
        //on soup B that serves as large as 100ml which in turn means that in order
        //for soup B to reach 0, it has to go through smaller servings(provided)
        //which in turn means for larger 'n' values the chances/probability of soup
        //B getting to 0 reduced drastically which is in comparision to soup A which
        //has 100ml serving oprns, that on larger 'n' value will have the probabiltiy
        //to reaach 0, hence for larger n value 'probability that soup A will be empty
        //first,' is more likely, so default is 1.0,
        //why 5000?
        //that's not very clear but consider it as an arbitary large n value
        //(in an interview point of view, consider conveying some LARGE_N_VALUE
        //instead of exact 5000)
        if (n >= 5000) {
            System.out.println("Soup servings : " + 1.0);
            return;
        }

        Double[][] memo = new Double[n + 1][n + 1];

        double probability = soupServings_Recursive_Memoization_Helper(n, n, memo);
        //output
        System.out.println("Soup servings : " + probability);
    }

    private int minAsciiDeleteSumForTwoStrings_Recusrive_Memoization_Helper(
            String s1, String s2, int s1Index, int s2Index, Integer[][] memo) {

        int m = s1.length();
        int n = s2.length();

        //if both the strings ended at same time, means they are definitely equal
        //hence no need to delete any chars hence the deleted sum of char ascii
        //is returned 0
        if (s1Index >= m && s2Index >= n) {
            return 0;
        }

        //if s1 string is ended that mean till this point both s1 and s2 matches
        //somewhere, but after s1 ended we must delete the remaining chars of
        //string s2 so that both s1 and s2 can be called equal, for that return
        //the sum of char ascii remaining in s2 'remainingAsciiSumOfS2'
        if (s1Index >= m) {
            int remainingAsciiSumOfS2 = 0;
            for (int i = s2Index; i < n; i++) {
                remainingAsciiSumOfS2 += s2.charAt(i);
            }
            return remainingAsciiSumOfS2;
        }

        //if s2 string is ended that mean till this point both s1 and s2 matches
        //somewhere, but after s2 ended we must delete the remaining chars of
        //string s1 so that both s1 and s2 can be called equal, for that return
        //the sum of char ascii remaining in s1 'remainingAsciiSumOfS1'
        if (s2Index >= n) {
            int remainingAsciiSumOfS1 = 0;
            for (int i = s1Index; i < m; i++) {
                remainingAsciiSumOfS1 += s1.charAt(i);
            }
            return remainingAsciiSumOfS1;
        }

        //if cached
        if (memo[s1Index][s2Index] != null) {
            return memo[s1Index][s2Index];
        }

        //if two chars of both the strings are already equal we need not to delete
        //such chars but simply move to next indexes for both these string
        //(s1Index + 1) & (s2Index + 1)
        if (s1.charAt(s1Index) == s2.charAt(s2Index)) {
            return memo[s1Index][s2Index] = minAsciiDeleteSumForTwoStrings_Recusrive_Memoization_Helper(
                    s1, s2, s1Index + 1, s2Index + 1, memo);
        }

        //if two chars of both the strings are not equal then the two choices on
        //which chars of strings can be deleted and since we need lowest deleted
        //sum of char ascii we choose min() of these two choices
        return memo[s1Index][s2Index] = Math.min(
                //1. we can delete curr char @s1Index from s1 hence the ascii value of this
                //char is also added as deleted sum of char ascii 's1.charAt(s1Index)'
                //and move to next s1 index (s1Index + 1)
                s1.charAt(s1Index) + minAsciiDeleteSumForTwoStrings_Recusrive_Memoization_Helper(
                        s1, s2, s1Index + 1, s2Index, memo),
                //2. we can delete curr char @s2Index from s2 hence the ascii value of this
                //char is also added as deleted sum of char ascii 's2.charAt(s2Index)'
                //and move to next s2 index (s2Index + 1)
                s2.charAt(s2Index) + minAsciiDeleteSumForTwoStrings_Recusrive_Memoization_Helper(
                        s1, s2, s1Index, s2Index + 1, memo)
        );
    }

    public int minAsciiDeleteSumForTwoStrings_Recusrive_Memoization(String s1, String s2) {
        //https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/
        //exlanation: https://youtu.be/Hstr9Wpa5Sc
        //based on modified DP EDIT DISTANCE
        if (s1.equals(s2)) {
            return 0;
        }

        int m = s1.length();
        int n = s2.length();

        Integer[][] memo = new Integer[m + 1][n + 1];

        return minAsciiDeleteSumForTwoStrings_Recusrive_Memoization_Helper(s1, s2, 0, 0, memo);
    }

    public int minAsciiDeleteSumForTwoStrings_DP_Memoization(String s1, String s2) {
        //https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/
        //based on LONGEST COMMON SUBSEQUENCE (LCS)
        //more INTUITIVE than above Edit Distance based approach
        /*

        s1 = "sea"
        s2 = "eat"

        delete 's' from s1 and 't' from s2, you will be left with s1 = "ea" &
        s2 = "ea" which are equal, BUT to notice here is this remaining string
        "ea" is the LCS for both the strings. And, with this LCS approach we need
        not to find the longest length but sum of ascii of the LCS,
        that's why the ascii value is added in memo[][]

        if(s1.charAt(i - 1) == s2.charAt(j - 1)) {
            memo[i][j] = s1.charAt(i - 1) + memo[i - 1][j - 1];
        }

        So idea behind is quite simple,

        for string s1, get the total ascii sum for s1
        s,e,a ==> s + e + a
        assume: n1 = ascii for 's' & combined ascii sum for lcs("ea") is X
        this basically means
        s + (e + a) ==> n1 + X
        so totalACIISumS1 = n1 + X -----> (1)

        similarly, for string s2, get the total ascii sum for s2
        e,a,t ==> e + a + t
        assume: n2 = ascii for 't' & combined ascii sum for lcs("ea") is X
        this basically means
        (e + a) + t ==> X + n2
        so totalACIISumS2 = X + n2 -----> (2)

        now, find the total ASCII sum for both the strings,
        total ascii sum (s1 + s2) = eqn(1) + eqn(2)
        ==> n1 + X + X + n2
        ==> n1 + n2 + (2 * X) -----> (3)

        now this eqn(3) is the key to solve, only 2 * X is combined sum lcs
        added twice, still confused how?

        ==> "sea" + "eat" ==> "seaeat" ==> "steaea" ==> "s, t, 2 * (ea)" ==> n1 + n2 + (2 * X)

        as we already know that after deletion, only the lcs will remain and
        that is going to be equal for both the strings, so if we just remove
        this 2 * X factor we will be left with sum of those ascii values that
        needs to be deleted i.e, (n1 + n2) ==> (s + t)

         */
        if (s1.equals(s2)) {
            return 0;
        }

        int m = s1.length();
        int n = s2.length();

        //total ascii sum for both the strings s1 + s2
        int totalSumOfStringsASCII = 0;

        //sum of ascii of string s1
        for (char chr : s1.toCharArray()) {
            totalSumOfStringsASCII += chr;
        }

        //sum of ascii of string s2
        for (char chr : s2.toCharArray()) {
            totalSumOfStringsASCII += chr;
        }

        //find the sum of ascii of the longest common subsequence between these
        //two strings
        int[][] memoASCIISum = new int[m + 1][n + 1];

        for (int i = 1; i < m + 1; i++) {

            for (int j = 1; j < n + 1; j++) {

                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {

                    memoASCIISum[i][j] = s1.charAt(i - 1) + memoASCIISum[i - 1][j - 1];
                } else {

                    memoASCIISum[i][j] = Math.max(
                            memoASCIISum[i - 1][j],
                            memoASCIISum[i][j - 1]);
                }
            }
        }

        //output
        int sumOfLCSASCII = memoASCIISum[m][n];

        int sumOfDeletedCharASCII = (totalSumOfStringsASCII - 2 * sumOfLCSASCII);

        return sumOfDeletedCharASCII;
    }

    private long numberOfMusicPlaylists_Recursive_Memoization_Helper(
            int n, int goal, int k, int songsPlayed, int uniqueSongsPlayed, Long[][] memo) {

        int mod = 1000000007;

        //as we have to play in total of 'goal' number of songs from given 'n'
        //distinct songs, now total 'songsPlayed' till now has reached to 'goal'
        if (songsPlayed == goal) {
            //number of songs played 'songsPlayed' has all 'n' distinct songs
            //then return 1 otherwise 0
            return uniqueSongsPlayed == n ? 1 : 0;
        }

        if (memo[songsPlayed][uniqueSongsPlayed] != null) {
            return memo[songsPlayed][uniqueSongsPlayed];
        }

        long ways = 0;

        //2 choices we have,
        //1. if we can pick a unique songs to play(==> uniqueSongsPlayed < n)
        //we will pick that song and hence total number of songs played is
        //(==> songsPlayed + 1) and here we picked only a unique song that we
        //haven't played before so uniqueSongsPlayed + 1
        //(n - uniqueSongsPlayed) what this means?
        //for this option we are going to play a unique song but in some prev
        //recursions we already played unique songs 'uniqueSongsPlayed' so how
        //many unique songs are remaining that we can choose
        //now why it is multiplied?
        //suppose unique songs ==> 'n' is 5 and we already played [1,2,3] in this
        //playlist we now we need to play remaining 4, 5 unique songs now here
        //we have further more options, we can either pick 4 first or 5 first
        //choose the other one latter respec. hence this remaining songs will
        //remaining times(==> * remaining) ways to create playlist hence multiplied
        if (uniqueSongsPlayed < n) {

            ways += ((n - uniqueSongsPlayed)
                    * numberOfMusicPlaylists_Recursive_Memoization_Helper(
                    n, goal, k, songsPlayed + 1, uniqueSongsPlayed + 1, memo)) % mod;
        }

        //2. if we have played some(==> k) songs previously means
        //(==> uniqueSongsPlayed > k) now we have an option to repeat a song we
        //played earlier (==> uniqueSongsPlayed - k)
        //here total number of songs played is (==> songsPlayed + 1) and here we
        //didn't pick any unique song, we played a song that was already played
        //so uniqueSongsPlayed remains as it is
        //(uniqueSongsPlayed - k) what this means?
        //for this option, we are going to play a song that is already played in
        //some prev recursions, now we will repeat that song in the playlist but
        //we can't just pick any prev songs played we will only choose those prev
        //songs which are played before 'k' songs(means the curr song we will play
        //now and the song we will choose to repeat should have a gap of 'atleast' k)
        //this means that we can't choose last k songs that played, before that any
        //song we are allowed to repeat, now there can be many songs played before
        //last k songs. Now each of them has equal ways to be picked and played
        //again hence it will generate (uniqueSongsPlayed - k) more options
        if (uniqueSongsPlayed > k) {

            ways += ((uniqueSongsPlayed - k)
                    * numberOfMusicPlaylists_Recursive_Memoization_Helper(
                    n, goal, k, songsPlayed + 1, uniqueSongsPlayed, memo)) % mod;
        }

        return memo[songsPlayed][uniqueSongsPlayed] = ways % mod;
    }

    public void numberOfMusicPlaylists_Recursive_Memoization(int n, int goal, int k) {
        //https://leetcode.com/problems/number-of-music-playlists/description/
        //explanation: https://youtu.be/2H0zU6v-xck
        Long[][] memo = new Long[goal + 1][n + 1];

        int ways = (int) numberOfMusicPlaylists_Recursive_Memoization_Helper(
                n, goal, k, 0, 0, memo);

        //output
        System.out.println("Number of music playlists : " + ways);
    }

    private int onesAndZeroes_Recursive_Memoization_Helper(
            int[][] binaryCounts, int zeros, int ones, int index, Integer[][][] memo) {

        int n = binaryCounts.length;

        //as we have reached the end of binaryCounts, means we can't pick any
        //more binary string in the subset hence the length returned is 0
        if (index >= n) {
            return 0;
        }

        //if cached
        if (memo[index][zeros][ones] != null) {
            return memo[index][zeros][ones];
        }

        int largestSubsetLength = 0;

        //2 choices we have,
        //1. don't pick the curr binary string @index and move to next index
        //(==> index + 1) and since have not considered any binary string here
        //means the total 'zeros' & 'ones' are left as it is, also no length(+1)
        //will be considered but only choose any largest subset length retuned
        largestSubsetLength = Math.max(largestSubsetLength,
                onesAndZeroes_Recursive_Memoization_Helper(
                        binaryCounts, zeros, ones, index + 1, memo));

        //2. pick the curr binary string @index and move to next index
        //(==> index + 1) and since have considered the curr binary string here
        //means we added this binary string to subset and length increased (+1)
        //also, the 'zeros' will be reduced with total '0's & 'ones' will be
        //reduced with total '1's we have in the curr binary string, only if on
        //reducing them doesn't go below 0
        //i.e, (zeros - binaryCounts[index][0] >= 0 && ones - binaryCounts[index][1] >= 0)
        if (zeros - binaryCounts[index][0] >= 0 && ones - binaryCounts[index][1] >= 0) {

            largestSubsetLength = Math.max(largestSubsetLength,
                    //here we are considering this curr binary string into the
                    //subset hence length increased by 1 (==> +1)
                    1 + onesAndZeroes_Recursive_Memoization_Helper(
                            binaryCounts,
                            //reduce the remaining 'zeros' with total '0's we
                            //have in curr binary string
                            zeros - binaryCounts[index][0],
                            //reduce the remaining 'one' with total '1's we
                            //have in curr binary string
                            ones - binaryCounts[index][1],
                            //move to next index
                            index + 1,
                            memo));
        }

        return memo[index][zeros][ones] = largestSubsetLength;
    }

    public void onesAndZeroes_Recursive_Memoization(String[] binaries, int zeros, int ones) {
        //https://leetcode.com/problems/ones-and-zeroes/description/
        int n = binaries.length;

        Integer[][][] memo = new Integer[n + 1][zeros + 1][ones + 1];

        int[][] binaryCounts = new int[n][2];

        //pre-compute the counts of '0' & '1' for each i-th binary string from
        //binaries[] into binaryCounts[i][2]
        for (int i = 0; i < n; i++) {

            //curr binary string
            String binary = binaries[i];

            //since we only have binary string having just '0's or '1's
            //initial count for '0' & '1' is 0 only
            //binaryCounts[i][0] = 0, binaryCounts[i][1] = 0
            //iterate over each bit from curr i-th binary string and count their
            //respective '0's & '1's in i-th binaryCount
            //binaries[i] = binaryCounts[i]
            //binaryCounts[i][0] = count_zeros
            //binaryCounts[i][1] = count_ones
            for (char bit : binary.toCharArray()) {
                binaryCounts[i][bit - '0']++;
            }
        }

        int largestSubsetLength = onesAndZeroes_Recursive_Memoization_Helper(
                binaryCounts, zeros, ones, 0, memo);

        //output
        System.out.println("Ones and zeros : " + largestSubsetLength);
    }

    private int countVowelPermutation_Recursive_Memoization_Helper(
            int lengthLimit, int currLength, char prevCharUsed, Integer[][] memo) {

        int mod = 1000000007;

        //as per the question, we need to make a string of max length 'lengthLimit'
        //and when curr length becomes equal to the limit that means there is 1
        //way to forming such a string as required
        if (currLength == lengthLimit) {
            return 1;
        }

        //if cached
        if (memo[currLength][prevCharUsed - 'a'] != null) {
            return memo[currLength][prevCharUsed - 'a'];
        }

        int ways = 0;

        //rules as per we can create vowels string
        //each vowel 'a' may only be followed by an 'e'
        if (prevCharUsed == 'a') {

            ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'e', memo)) % mod;

        } else //each vowel 'e' may only be followed by an 'a' or an 'i'
            if (prevCharUsed == 'e') {

                ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'a', memo)) % mod;
                ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'i', memo)) % mod;

            } else //each vowel 'i' may not be followed by another 'i'
                if (prevCharUsed == 'i') {

                    ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'a', memo)) % mod;
                    ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'e', memo)) % mod;
                    ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'o', memo)) % mod;
                    ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'u', memo)) % mod;

                } else //each vowel 'o' may only be followed by an 'i' or a 'u'
                    if (prevCharUsed == 'o') {

                        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'i', memo)) % mod;
                        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'u', memo)) % mod;

                    } else //each vowel 'u' may only be followed by an 'a'
                        if (prevCharUsed == 'u') {

                            ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(lengthLimit, currLength + 1, 'a', memo)) % mod;
                        }

        return memo[currLength][prevCharUsed - 'a'] = ways;
    }

    public void countVowelPermutation_Recursive_Memoization(int n) {
        //https://leetcode.com/problems/count-vowels-permutation/description/
        //total length we need to make is 'n' and the chars can only be included
        //are vowels(a, e, i, o, u) hence 26 alphabets can hold the cache
        Integer[][] memo = new Integer[n + 1][26];

        int mod = 1000000007;

        int ways = 0;

        //if 'a' is first starting char of string hence starting length of this string is 1
        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(n, 1, 'a', memo)) % mod;

        //if 'e' is first starting char of string hence starting length of this string is 1
        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(n, 1, 'e', memo)) % mod;

        //if 'i' is first starting char of string hence starting length of this string is 1
        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(n, 1, 'i', memo)) % mod;

        //if 'o' is first starting char of string hence starting length of this string is 1
        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(n, 1, 'o', memo)) % mod;

        //if 'u' is first starting char of string hence starting length of this string is 1
        ways = (ways + countVowelPermutation_Recursive_Memoization_Helper(n, 1, 'u', memo)) % mod;

        //output
        System.out.println("Count vowel permutation : " + ways);
    }

    public void longestIdealSubsequence_DP_Memoization(String str, int k) {
        //https://leetcode.com/problems/longest-ideal-subsequence/description/
        int n = str.length();

        int[] memo = new int[150];

        int longestIdealSubseq = 1;

        for (char chr : str.toCharArray()) {

            int orderA = chr;

            for (int orderB = orderA - k; orderB <= orderA + k; orderB++) {
                memo[orderA] = Math.max(memo[orderA], memo[orderB]);
            }
            longestIdealSubseq = Math.max(longestIdealSubseq, ++memo[orderA]);
        }

        //output
        System.out.println("Longest ideal subeq : " + longestIdealSubseq);
    }

    private boolean checkIfValidPartitionOfArray_Recursive_Memoization_IsValidSubarray(
            int[] nums, int start, int end) {

        //The subarray consists of exactly 2 equal elements.
        //For example, the subarray [2,2] is good.
        if (end - start + 1 == 2) {
            return nums[start] == nums[end];
        }

        //subarray only have 3 elements in it, we just need to check which rule
        //is true
        if (end - start + 1 == 3) {

            //The subarray consists of exactly 3 equal elements.
            //For example, the subarray [4,4,4] is good.
            if (nums[start] == nums[start + 1] && nums[start + 1] == nums[end]) {
                return true;
            }

            //The subarray consists of exactly 3 consecutive increasing elements,
            //that is, the difference between adjacent elements is 1.
            //For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
            //here, nums[start] = 3 hence nums[start] + 1 ==> 3 + 1 == nums[start + 1] = 4
            //also, nums[start + 1] = 4 hence nums[start + 1] + 1 ==> 4 + 1 == nums[end] = 5
            if (nums[start] + 1 == nums[start + 1] && nums[start + 1] + 1 == nums[end]) {
                return true;
            }
        }

        return false;
    }

    private boolean checkIfValidPartitionOfArray_Recursive_Memoization_Helper(
            int[] nums, int startIndex, Boolean[] memo) {

        int n = nums.length;

        //as we have reached the end of nums[], means in between we have
        //partitioned num[] into valid subarrays acc to given rules hence
        //return true as the partition is valid
        if (startIndex >= n) {
            return true;
        }

        //if cached
        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        //try out all the possible subarrays ranging form [startIndex to endIndex]
        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //skip, acc to given rule, min length of subarray required is 2
            //so if the curr length of subarray is less, we still can incr
            //the length
            if (endIndex - startIndex + 1 <= 1) {
                continue;
            }

            //break, acc to given rule, max length of subarray required is 3
            //so if the curr length of subarray is more than 3, we should not
            //proceed further in this loop
            if (endIndex - startIndex + 1 > 3) {
                break;
            }

            //here, we will check 2 things
            //1. the subarray considered from [startIndex to endIndex] is valid
            //or not(acc to given rules), if it is valid then check for the next
            //subarray starting from endIndex + 1
            //2. recursive call to check if the remaining array can also be
            //partitioned into valid subarrays or not(==> overlapping subproblem)
            if (checkIfValidPartitionOfArray_Recursive_Memoization_IsValidSubarray(nums, startIndex, endIndex)
                    && checkIfValidPartitionOfArray_Recursive_Memoization_Helper(nums, endIndex + 1, memo)) {
                //if curr subarray is valid AND remaining array can also be partitioned
                //return true
                return memo[startIndex] = true;
            }
        }

        //if there are no valid partitions at all return false
        return memo[startIndex] = false;
    }

    public void checkIfValidPartitionOfArray_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/description/
        int n = nums.length;

        Boolean[] memo = new Boolean[n + 1];

        boolean isValidPartitionPossible = checkIfValidPartitionOfArray_Recursive_Memoization_Helper(
                nums, 0, memo);

        //output
        System.out.println("Check if valid partition of array is possible : " + isValidPartitionPossible);
    }

    private boolean checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization_Helper(
            int[][] grid, int row, int col, int pathSum, Map<String, Boolean> memo) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //if the curr row & col 'isOutOfBounds' then there is no way, hence
        //return false
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return false;
        }

        //next value to be added in the curr going pathSum is either 1 or -1
        //that is if the curr grid value at row & col is 0 add -1 otherwise 1
        int nextPathValToAdd = grid[row][col] == 0 ? -1 : 1;

        //here, we reached the destination row & col that is (ROW - 1, COL - 1)
        //but here we need to check if our pathSum is balanced out or not for
        //that we also need to add the curr row & col i.e, destination's value
        //in the pathSum(==> pathSum + nextPathValToAdd)
        //how pathSum should be balanced out?
        //as we mentioned above for every grid value 0 we add -1 and for 1 we
        //add 1 only, so if we are currently following a path from src (0, 0)
        //to dest (ROW - 1, COL - 1) then inorder for this path to have equal
        //0s and 1s, the pathSum should be total to 0 at the destination
        //ex: path we followed from src to dest have 0 -> 1 -> 1 -> 0 -> 1 -> 0
        //then pathSum along this path should be:
        //-1 + 1 + 1 + -1 + 1 + -1 which sum upto 0 at dest
        if (row == ROW - 1 && col == COL - 1) {
            //hence we are simply checking if the pathSum at dest (including
            //dest's value) has balanced out to 0, if yes return true, meaning
            //there is a path from src to dest where the path have equal 0s & 1s
            return (pathSum + nextPathValToAdd) == 0;
        }

        String key = row + "," + col + "," + pathSum;

        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        boolean hasAnyPath = false;

        //we can only go either DOWN or RIGHT hence we will never be visiting a
        //prev cell in the curr ongoing path, so no visited[][] required
        hasAnyPath |= checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization_Helper(
                grid, row + 1, col, pathSum + nextPathValToAdd, memo);

        hasAnyPath |= checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization_Helper(
                grid, row, col + 1, pathSum + nextPathValToAdd, memo);

        memo.put(key, hasAnyPath);

        return hasAnyPath;
    }

    public void checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/description/
        Map<String, Boolean> memo = new HashMap<>();
        boolean hasAnyPath = checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization_Helper(
                grid, 0, 0, 0, memo);

        //output
        System.out.println("Check if path exists with equal 0s and 1s : " + hasAnyPath);
    }

    private int waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization_Helper(
            int[] nums, int startIndex, Integer[] memo) {

        int mod = 1000000007;

        int n = nums.length;

        //return 1 as a possible way as we reached the end of array meaning in
        //between we split the arrays into good subarrays
        if (startIndex >= n) {
            return 1;
        }

        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int countOnesInSubarray = 0;

        int countGoodSubarray = 0;

        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //as this is a binary arrays, every time we see 1 it will be counted
            countOnesInSubarray += nums[endIndex];

            //each good subarray should have exactly one '1'
            if (countOnesInSubarray > 1) {
                break;
            }

            //skip, if we haven't found a single one for the curr subarray
            if (countOnesInSubarray == 0) {
                continue;
            }

            //here, we have exactly one '1' in the curr subarray [startIndex to endIndex]
            //after this, we can move to next subarray(==> endIndex + 1) to make
            //another subarray with good split
            countGoodSubarray = (countGoodSubarray
                    + waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization_Helper(
                    nums, endIndex + 1, memo)) % mod;
        }

        return memo[startIndex] = countGoodSubarray;
    }

    public int waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/description/
        //recursive memoization approach will give 'TLE' on large inputs hnece
        //its method calls will be commented
        int n = nums.length;

        //if the binary string don't have any '1' in it, there is no ways we can
        //split array into good subarrays
        int countZeros = 0;
        for (int bit : nums) {
            if (bit == 0) {
                countZeros++;
            }
        }

        //if count of '0' is same as the array's length means no '1' at all
        //return 0 as ways
        if (countZeros == n) {
            return 0;
        }

        Integer[] memo = new Integer[n + 1];

        int ways = waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization_Helper(nums, 0, memo);

        //output
        return ways;
    }

    public int waysToSplitBinaryArrayIntoGoodSubarrays_DP_Memoization(int[] nums) {
        //https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/description/
        int n = nums.length;

        long countZeros = 0;

        for (int bit : nums) {
            if (bit == 0) {
                countZeros++;
            }
        }

        //if there no 1 in the given binary string, there is now ways we can
        //split it into good subarrays
        if (countZeros == n) {
            return 0;
        }

        int mod = 1000000007;

        long countOnes = 0;
        long count = 0;
        long ways = 1;

        for (int bit : nums) {

            if (bit == 1) {
                countOnes++;
            }

            if (countOnes == 1) {
                count++;
            }

            if (countOnes > 1) {
                ways = (ways * count) % mod;
                countOnes = count = 1;
            }
        }

        return (int) ways;
    }

    public void nMeetingRooms_Greedy(int[] startTime, int[] finishTime) {

        int n = startTime.length;

        int[][] input = new int[n][3];

        for (int i = 0; i < n; i++) {
            input[i][0] = startTime[i];
            input[i][1] = finishTime[i];
            input[i][2] = i;
        }

        //sort the input in incr order of finishTime i.e, input[i][1]
        Arrays.sort(input, (a, b) -> a[1] - b[1]);

        int meetingsCanBeConducted = 1; //at least one meeting can be held
        List<Integer> indexOfMeetingTimings = new ArrayList<>();
        indexOfMeetingTimings.add(input[0][2] + 1); // 1 based index
        int prevEndTime = input[0][1];
        for (int i = 1; i < n; i++) {

            int currStartTime = input[i][0];
            int currEndTime = input[i][1];

            if (prevEndTime < currStartTime) {
                meetingsCanBeConducted++;
                prevEndTime = currEndTime;
                indexOfMeetingTimings.add(input[i][2] + 1);
            }
        }

        System.out.println("No. of meetings can be conducted: " + meetingsCanBeConducted);
        System.out.println("Index of meetings can be conducted: " + indexOfMeetingTimings);
    }

    public void longestNonDecrSubarrayFromTwoArrays_DP_Memoization(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/description/
        int n = nums1.length;

        int longestIncrSubseq = 1;

        int memoLISEndingWithNums1 = 1;
        int memoLISEndingWithNums2 = 1;

        for (int i = 1; i < n; i++) {

            int option1 = nums1[i - 1] <= nums1[i] ? memoLISEndingWithNums1 + 1 : 1;
            int option2 = nums2[i - 1] <= nums1[i] ? memoLISEndingWithNums2 + 1 : 1;

            int option3 = nums1[i - 1] <= nums2[i] ? memoLISEndingWithNums1 + 1 : 1;
            int option4 = nums2[i - 1] <= nums2[i] ? memoLISEndingWithNums2 + 1 : 1;

            memoLISEndingWithNums1 = Math.max(option1, option2);
            memoLISEndingWithNums2 = Math.max(option3, option4);

            longestIncrSubseq = Math.max(longestIncrSubseq,
                    Math.max(memoLISEndingWithNums1, memoLISEndingWithNums2));
        }

        //output
        System.out.println("Longest non decr subarray from two arrays : " + longestIncrSubseq);
    }

    private int extraCharsInString_Recursive_Memoization_Helper(
            String str, Set<String> dictionary, int startIndex, Integer[] memo) {

        int n = str.length();

        //return 0, if there are no chars at all in str that mean no 'extraChars'
        //OR we have reached the end of the str and in between we decided which
        //char to leave out as 'extraChar' so now here, no more chars left
        if (startIndex >= n) {
            return 0;
        }

        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        //2 choices we have here,
        //1. consider that the curr char @startIndex is the extra char in str
        //so we will move to next char in str and +1 will mean char at str[startIndex]
        //is an extraChar
        int extraChars = 1 + extraCharsInString_Recursive_Memoization_Helper(
                str, dictionary, startIndex + 1, memo);

        //2. consider all the substring of str in range [startIndex to endIndex]
        //and if all the possible substrings that generated in between are also
        //present in dictionary we split curr str till that 'endIndex' and start
        //with next sub-problem str from (endIndex + 1) and choose the min extra
        //chars from all sub-problems
        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            String substr = str.substring(startIndex, endIndex + 1);

            if (dictionary.contains(substr)) {

                extraChars = Math.min(
                        extraChars,
                        extraCharsInString_Recursive_Memoization_Helper(
                                str, dictionary, endIndex + 1, memo));
            }
        }

        return memo[startIndex] = extraChars;
    }

    public void extraCharsInString_Recursive_Memoization(String str, String[] dictionary) {
        //...........T: O(N ^ 3)
        //...........T: O(N + M), where N is space taken for memo[] and M is space
        //taken for dictionary set
        //https://leetcode.com/problems/extra-characters-in-a-string/description/
        int n = str.length();
        Set<String> dictionarySet = new HashSet<>(Arrays.asList(dictionary));
        Integer[] memo = new Integer[n + 1];
        int extraCharsInString = extraCharsInString_Recursive_Memoization_Helper(str, dictionarySet, 0, memo);

        //output
        System.out.println("Extra chars in string : " + extraCharsInString);
    }

    public void extraCharsInString_DP_Memoization(String str, String[] dictionary) {
        //https://leetcode.com/problems/extra-characters-in-a-string/description/

        class TrieNode {

            Map<Character, TrieNode> nodes;
            boolean isEnd;

            public TrieNode() {
                nodes = new HashMap<>();
                isEnd = false;
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void add(String word) {

                TrieNode currRoot = ROOT;

                for (char chr : word.toCharArray()) {

                    if (currRoot.nodes.containsKey(chr)) {
                        currRoot = currRoot.nodes.get(chr);
                    } else {
                        TrieNode node = new TrieNode();
                        currRoot.nodes.put(chr, node);
                        currRoot = node;
                    }
                }

                currRoot.isEnd = true;
            }
        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        int n = str.length();
        int[] memo = new int[n + 1];

        for (String word : dictionary) {
            trieUtil.add(word);
        }

        for (int startIndex = n - 1; startIndex >= 0; startIndex--) {

            TrieNode currRoot = ROOT;

            memo[startIndex] = 1 + memo[startIndex + 1];

            for (int endIndex = startIndex; endIndex < n; endIndex++) {

                char chr = str.charAt(endIndex);

                if (!currRoot.nodes.containsKey(chr)) {
                    break;
                }

                currRoot = currRoot.nodes.get(chr);

                if (currRoot.isEnd) {
                    memo[startIndex] = Math.min(memo[startIndex], memo[endIndex + 1]);
                }
            }

        }

        //output
        System.out.println("Extra chars in string : " + memo[0]);
    }

    public void countAllValidPickupAndDelivery_DP_Memoization(int n) {
        //https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/?envType=daily-question&envId=2023-09-10
        int mod = 1000000007;
        int places = 2 * n;
        long ways = 1;

        while (places > 0) {

            int currValidChoices = (places * (places - 1)) / 2;
            ways = (ways * currValidChoices) % mod;
            places -= 2;
        }

        //output
        System.out.println("Count all valid pickup and delivery : " + ways);
    }

    public void champagneTower_DP_Memoization(int poured, int queryRow, int queryGlass) {
        //https://leetcode.com/problems/champagne-tower/description/
        //explanation: https://youtu.be/-RwOEYcsQU0?si=vL9y-YHzhEkn4i9z
        double[][] memo = new double[101][101];

        memo[0][0] = (double) poured;

        double KEEP_FOR_CURRENT_GLASS = 1.0;

        for (int row = 0; row < queryRow; row++) {

            for (int col = 0; col <= row; col++) {

                double qtyTransfered = (memo[row][col] - KEEP_FOR_CURRENT_GLASS) / 2.0;

                if (qtyTransfered > 0) {
                    memo[row + 1][col] += qtyTransfered;
                    memo[row + 1][col + 1] += qtyTransfered;
                }
            }
        }

        //output
        System.out.println("Champagne tower : " + Math.min(1, memo[queryRow][queryGlass]));
    }

    private int integerBreak_Recursive_Memoization_Helper(int n, int valuePicked, Integer[][] memo) {

        //if the 'value' choosen in the process is summed up to 'n'
        //i.e sum('value') - n == 0, then we must check if have choosen
        //atleast 2 'value' in the process or not, if yes return 1 otherwise 0
        if (n == 0) {
            return valuePicked >= 2 ? 1 : 0;
        }

        //if cached
        if (memo[n][valuePicked] != null) {
            return memo[n][valuePicked];
        }

        //product of 'value' choosen that we need to maximize
        int maxProd = 0;

        for (int value = 1; value <= n; value++) {

            //maximize the product of 'value' choosen such that in the base
            //case above, sum('value') == n ==> sum('value') - n ==> 0
            maxProd = Math.max(
                    maxProd,
                    //we are choosing the curr 'value' such that we make the 'n'
                    // = 0 as sum('value') - n ==> 0 so when we pick a 'value'
                    //valuePicked is added with +1
                    value * integerBreak_Recursive_Memoization_Helper(n - value, valuePicked + 1, memo));
        }

        return memo[n][valuePicked] = maxProd;
    }

    public void integerBreak_Recursive_Memoization(int n) {
        //https://leetcode.com/problems/integer-break/description/
        Integer[][] memo = new Integer[n + 1][n + 1];
        int maxProductOfValueSummedToN = integerBreak_Recursive_Memoization_Helper(n, 0, memo);

        //output
        System.out.println("Integer break & max product of values : " + maxProductOfValueSummedToN);
    }

    private int buildArraysWithExactlyKMaximumValue_Recursive_Memoization_Helper(
            int length, int m, int k, int index, int maxValueInArray, Integer[][][] memo) {

        //as we need to create an array of size 'length' & currently our 'index'
        //is pointing to end of the array, means we have created the req array
        //BUT also, we need to have k maximum values in the array so if we have
        //palced 'k' max values in array and k is now 0 meaning no new max value
        //can be placed anymore then return 1 as there is one possible way of
        //creating array with required conditions otherwise 0
        if (index == length) {
            return k == 0 ? 1 : 0;
        }

        //return 0, in case where we might have placed max values in array more
        //than the given 'k' places, in that process (k - 1) would have gone
        //negative BUT we only need exact k max values
        if (k < 0) {
            return 0;
        }

        //if cached
        if (memo[index][maxValueInArray][k] != null) {
            return memo[index][maxValueInArray][k];
        }

        int mod = 1000000007;

        int ways = 0;

        //in the process of create an array of size 'length' we might place a
        //value that is not a new max value BUT any value in range [1, maxValueInArray]
        //since we are placing this value currently @index we must then move to next
        //index(==> index + 1) so that we can put more values in arrays
        //note: here, we knew that current max value in array is 'maxValueInArray'
        //and we have not added any new max value in array meaning k remains as
        //it is because 'k' counts for 'new max value in array'
        for (int value = 1; value <= maxValueInArray; value++) {

            ways = (ways + buildArraysWithExactlyKMaximumValue_Recursive_Memoization_Helper(
                    length, m, k, index + 1, maxValueInArray, memo)) % mod;
        }

        //here, we will simulate placing a new max value in array, so by far we
        //know that curr max value in array is 'maxValueInArray' before this value
        //all values are smaller BUT after this value i.e, (maxValueInArray + 1) we
        //will have 'new max value' and also we can pick values in range [1, m]
        //note: here, the current value is new max value in the array that means
        //the curr 'maxValueInArray' is comparatively smaller hence for next recursion
        //stack we must pass the new max value as curr 'value'
        for (int value = maxValueInArray + 1; value <= m; value++) {

            ways = (ways + buildArraysWithExactlyKMaximumValue_Recursive_Memoization_Helper(
                    length, m, k - 1, index + 1, value, memo)) % mod;
        }

        return memo[index][maxValueInArray][k] = ways;
    }

    public void buildArraysWithExactlyKMaximumValue_Recursive_Memoization(int n, int m, int k) {
        //https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/description/
        //explanation: https://youtu.be/YU9IGG5PB2Y?si=JOCR-JtXUhYEXp7_
        Integer[][][] memo = new Integer[n + 1][m + 1][k + 1];
        int waysToBuildArrays = buildArraysWithExactlyKMaximumValue_Recursive_Memoization_Helper(n, m, k, 0, 0, memo);

        //output
        System.out.println("Ways to build arrays of length n and values in range[1, m] having k max values : " + waysToBuildArrays);
    }

    private int maxDotProductsWithTwoSubseq_Recursive_Memoization_Helper(
            int[] nums1, int[] nums2, int nums1Index, int nums2Index, Integer[][] memo) {

        int m = nums1.length;
        int n = nums2.length;

        //return 0 as dot product for subseq, because nums1Index reach the end of
        //nums1[] and no more value can be picked into the subseq hence dot prod
        //can't be considered further
        if (nums1Index == m) {
            return 0;
        }

        //return 0 as dot product for subseq, because nums2Index reach the end of
        //nums2[] and no more value can be picked into the subseq hence dot prod
        //can't be considered further
        if (nums2Index == n) {
            return 0;
        }

        //if cached
        if (memo[nums1Index][nums2Index] != null) {
            return memo[nums1Index][nums2Index];
        }

        //3 choices we have,
        //1. we choose to pick the value @nums1Index from nums1[] and @nums2Index
        //from nums2[] and consider their dot product and we choose to move to
        //next index in both the arrays
        int maxProduct = (nums1[nums1Index] * nums2[nums2Index])
                + maxDotProductsWithTwoSubseq_Recursive_Memoization_Helper(
                nums1, nums2, nums1Index + 1, nums2Index + 1, memo);

        //2. we choose to skip the value @nums1Index from nums1[] but pick @nums2Index
        //from nums2[], consider max dot product from current and further from recursive call
        maxProduct = Math.max(
                maxProduct,
                maxDotProductsWithTwoSubseq_Recursive_Memoization_Helper(
                        nums1, nums2, nums1Index + 1, nums2Index, memo));

        //3. we choose to pick the value @nums1Index from nums1[] but skip @nums2Index
        //from nums2[], consider max dot product from current and further from recursive call
        maxProduct = Math.max(
                maxProduct,
                maxDotProductsWithTwoSubseq_Recursive_Memoization_Helper(
                        nums1, nums2, nums1Index, nums2Index + 1, memo));

        return memo[nums1Index][nums2Index] = maxProduct;
    }

    public void maxDotProductsWithTwoSubseq_Recursive_Memoization(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/
        //based on LCS
        int m = nums1.length;
        int n = nums2.length;

        int firstMax = Integer.MIN_VALUE;
        int secondMax = Integer.MIN_VALUE;
        int firstMin = Integer.MAX_VALUE;
        int secondMin = Integer.MAX_VALUE;

        for (int num : nums1) {
            firstMax = Math.max(firstMax, num);
            firstMin = Math.min(firstMin, num);
        }

        for (int num : nums2) {
            secondMax = Math.max(secondMax, num);
            secondMin = Math.min(secondMin, num);
        }

        if (firstMax < 0 && secondMin > 0) {
            System.out.println("Max dot product with two subseq : " + (firstMax * secondMin));
            return;
        }

        if (firstMin > 0 && secondMax < 0) {
            System.out.println("Max dot product with two subseq : " + (firstMin * secondMax));
            return;
        }

        Integer[][] memo = new Integer[m + 1][n + 1];
        int maxDotProduct = maxDotProductsWithTwoSubseq_Recursive_Memoization_Helper(
                nums1, nums2, 0, 0, memo);

        //output
        System.out.println("Max dot product with two subseq : " + maxDotProduct);
    }

    public boolean meetingRooms_Greedy(int[][] intervals) {
        //https://leetcode.com/problems/meeting-rooms/description/
        int n = intervals.length;

        if (n == 0) {
            return true;
        }

        //sort the intervals based on the incr order of the start time, if two
        //start time are same then sort in decr order of end time, this decr order
        //of end time will provide the max end range for the next i-th interval
        //for checking
        Arrays.sort(intervals, (a, b) -> a[0] == b[0]
                ? Integer.compare(b[1], a[1])
                : Integer.compare(a[0], b[0]));

        int prevEnd = intervals[0][1];

        for (int i = 1; i < n; i++) {

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            //if the next i-th interval's start time is less than the prev
            //interval's end time means the curr i-th meeting can't be taken
            //hence return false, meaning all the meetings can't be taken
            if (currStart < prevEnd) {
                return false;
            }

            //this would mean, how long a the curr meeting can run such that we
            //check the next i-th interval meeting can be taken or not
            prevEnd = Math.max(prevEnd, currEnd);
        }

        //reached here, means all the meeting can be taken
        return true;
    }

    public void meetingRoomTwo_Greedy(int[][] intervals) {
        //https://leetcode.com/problems/meeting-rooms-ii/description/
        int n = intervals.length;

        Integer[] startTime = new Integer[n];
        Integer[] endTime = new Integer[n];

        //separate the startTime and endTime of each interval
        for (int i = 0; i < n; i++) {
            startTime[i] = intervals[i][0];
            endTime[i] = intervals[i][1];
        }

        //sort the start time in inreasing order
        Arrays.sort(startTime);
        //sort the end time in inreasing order
        Arrays.sort(endTime);

        int start = 0;
        int end = 0;

        int roomsReq = 0;

        while (start < n) {

            //this cond here means, a new meeting that will start @startTime[start]
            //if this start time is greater or equal to the time the prev meeting
            //is ending @endTime[end] that would mean this curr room just got
            //vaccant and this new meeting can occupy the same room
            //hence room req is reduced
            //since a meeting already ended @endTime[end], we can move to next
            //end time(==> end++)
            if (endTime[end] <= startTime[start]) {
                roomsReq -= 1;
                end++;
            }

            //if the above if() block fails, means the curr new meeting @startTime[start]
            //can't be held in the same room occupied by the meeting still going on till
            //@endTime[end] hence we req a new room to conduct this new meeting
            //roomReq += 1
            roomsReq += 1;
            //since we alloted a new room to the curr new meeting @startTime[start]
            //we can move to new meetings(==> start++) to conduct them
            start++;
        }

        //output
        System.out.println("meeting rooms two : " + roomsReq);
    }

    public void pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(int[] movieLength, int K) {

        //prepare index wise data
        int[][] input = new int[movieLength.length][2];
        for (int i = 0; i < movieLength.length; i++) {
            input[i][0] = movieLength[i];
            input[i][1] = i;
        }

        //sort the input
        Arrays.sort(input, new Comparator<int[]>() {

            @Override
            public int compare(int[] a, int[] b) {
                //0th index holds movieLength and sortng asc on basis of that
                //shortest movie length first
                return a[0] - b[0];
            }
        });

        int n = movieLength.length;
        int start = 0;
        int end = n - 1;
        int i = 0;
        int j = 0;
        int sum = 0;
        while (end > start) {

            int firstMovie = input[start][0];
            int secondMovie = input[end][0];

            if (firstMovie + secondMovie <= K) {

                if (sum < firstMovie + secondMovie) {
                    sum = firstMovie + secondMovie;
                    i = input[start][1];
                    j = input[end][1];
                }
                start++;
            } else if (firstMovie + secondMovie > K) {
                end--;
            }
        }

        //output:
        System.out.println("Pair of movies can be watched during flight duration K: "
                + (i + "," + j) + "-"
                + (movieLength[i] + "," + movieLength[j]));
    }

    public int choclateDistribution_Greedy(int[] choclates, int students) {

        //.........................T: O(N.LogN)
        //https://www.geeksforgeeks.org/chocolate-distribution-problem/
        //if no choclates are there OR there are no student available for distribution
        if (choclates.length == 0 || students == 0) {
            return 0;
        }

        //if the no. of choclates is less than the no. of student
        if (choclates.length < students) {
            return -1;
        }

        //sort the no of choclates
        Arrays.sort(choclates);

        int minDiff = Integer.MAX_VALUE;
        for (int i = 0; i + students - 1 < choclates.length; i++) {
            int currDiff = choclates[i + students - 1] - choclates[i];
            minDiff = Math.min(minDiff, currDiff);
        }

        //output:
        return minDiff;
    }

    public void minimumPlatformNeeded_BruteForce(int[] arr, int[] dep) {

        //.......................T: O(N^2)
        int n = arr.length;

        int maxPlatform = 1;
        for (int i = 0; i < n; i++) {
            int currPlatform = 1;
            for (int j = i + 1; j < n; j++) {
                if ((arr[i] >= arr[j] && arr[i] <= dep[j])
                        || (arr[j] >= arr[i] && arr[j] <= dep[i])) {
                    currPlatform++;
                }
                maxPlatform = Math.max(maxPlatform, currPlatform);
            }
        }

        //output:
        System.out.println("max platfrm needed: " + maxPlatform);
    }

    public void minimumPlatformNeeded_Greedy(int[] arrival, int[] depart) {

        //.......................T: O(N.LogN)
        int n = arrival.length;

        //.................T: O(N.LogN)
        Arrays.sort(arrival);
        Arrays.sort(depart);

        int arrivalIndex = 1;
        int departIndex = 0;
        int maxPlatform = 1;
        int currPlatform = 1;

        while (arrivalIndex < n && departIndex < n) {

            if (arrival[arrivalIndex] <= depart[departIndex]) {
                currPlatform++;
                arrivalIndex++;
            } else if (arrival[arrivalIndex] > depart[departIndex]) {
                currPlatform--;
                departIndex++;
            }

            maxPlatform = Math.max(maxPlatform, currPlatform);
        }

        //output:
        System.out.println("max platform needed: " + maxPlatform);
    }

    public void fractionalKnapsack(int[] weight, int[] value, int W) {

        int n = weight.length;

        //prepare data
        double[][] input = new double[n][3];
        //0: weight, 1: value, 2: costPerWeight
        for (int i = 0; i < n; i++) {

            input[i][0] = weight[i];
            input[i][1] = value[i];
            input[i][2] = (double) value[i] / (double) weight[i];
        }

        //sort the input on basis of costPerWeight desc
        Arrays.sort(input, (a, b) -> (int) (b[2] - a[2])); //2: costPerWeight

        double maxValue = 0;
        for (int i = 0; i < n; i++) {

            int currWeight = (int) input[i][0];
            int currValue = (int) input[i][1];

            if (W - currWeight >= 0) {
                W -= currWeight;
                maxValue += currValue;
            } else {

                //if we can't pick up an item as whole
                //we will calculate the fraction we can pick up
                //i.e W/currWeight
                double frac = (double) W / currWeight;
                //value per frac
                maxValue += (currValue * frac);
                //estimating balanced capacity
                W = (int) (W - (currWeight * frac));
            }
        }

        //output:
        System.out.println("Max value can be picked up by fractional knapsack: " + maxValue);
    }

    public void swapTwoDigitAtMostToFormAGreaterNumber_Greedy(int num) {

        //https://leetcode.com/problems/maximum-swap/
        char[] digit = String.valueOf(num).toCharArray();
        int[] index = new int[10];
        for (int i = 0; i < digit.length; i++) {
            index[digit[i] - '0'] = i;
        }

        for (int i = 0; i < digit.length; i++) {
            for (int d = 9; d > digit[i] - '0'; d--) {
                if (index[d] > i) {
                    char temp = digit[i];
                    digit[i] = digit[index[d]];
                    digit[index[d]] = temp;
                    System.out.println("Greater number after 2 digit swaps atmost: " + Integer.parseInt(String.valueOf(digit)));
                    return;
                }
            }
        }

        //output
        System.out.println("Greater number after 2 digit swaps atmost: " + num);
    }

    public void singleThreadedCPU_Greedy(int[][] tasks) {
        //https://leetcode.com/problems/single-threaded-cpu/
        //explanation: https://youtu.be/RR1n-d4oYqE

        class Task {

            int startTime;
            int processingTime;
            int taskIndex;

            public Task(int startTime, int processingTime, int taskIndex) {
                this.startTime = startTime;
                this.processingTime = processingTime;
                this.taskIndex = taskIndex;
            }
        }

        int n = tasks.length;
        int[] result = new int[n];
        List<Task> tasksList = new ArrayList<>();
        //cpu task waiting queue based on which smallest processing time
        //task can be picked up
        PriorityQueue<Task> minHeap = new PriorityQueue<>(
                (a, b) -> a.processingTime == b.processingTime
                        ? a.taskIndex - b.taskIndex
                        : a.processingTime - b.processingTime);

        for (int i = 0; i < n; i++) {
            int startTime = tasks[i][0];
            int processingTime = tasks[i][1];
            int taskIndex = i;
            tasksList.add(new Task(startTime, processingTime, taskIndex));
        }

        Collections.sort(tasksList, (a, b) -> a.startTime - b.startTime);

        int resIndex = 0;
        int i = 0;
        //since our tasks are sorted by startTime, cpu will pick up the
        //task that is coming first acc to startTime and cpu will be
        //booked for this curr task initially
        int cpuBookedTime = tasksList.get(0).startTime;

        while (resIndex < n) {
            //since my cpu is already booked until cpuBookedTime
            //that means cpu will process the current task until this cpuBookedTime
            //so all the task that cpu will not be able to take because being busy
            //will go to cpu task waiting queue, where it will be sorted acc to
            //processingTime and taskIndex
            while (i < n && tasksList.get(i).startTime <= cpuBookedTime) {
                minHeap.add(tasksList.get(i));
                i++;
            }

            //cpu task waiting queue is empty that means, cpu is idle
            //we can directly assign the curr i-th task to cpu coming at
            //startTime
            if (minHeap.isEmpty()) {
                cpuBookedTime = tasksList.get(i).startTime;
                continue;
            }

            //if the cpu is not idle, we pick the optimal task from waiting queue,
            //simulate, cpuBookedTime by adding currTask processingTime added to it
            //that would mean whatever the task cpu is processing right now, after
            //finishing that assign the currTask to it. In that order we take taskIndex
            Task currTask = minHeap.poll();
            cpuBookedTime += currTask.processingTime;
            result[resIndex++] = currTask.taskIndex;
        }

        //output
        System.out.println("Order of tasks in which tasks can be consumed:");
        Arrays.stream(result).boxed().forEach(x -> System.out.print(x + " "));
        System.out.println();
    }

    public void minimumArrowsToBurstBalloons_Greedy(int[][] balloonPoints) {
        //https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
        //sort on balloon end point
        Arrays.sort(balloonPoints, (a, b) -> Integer.compare(a[1], b[1]));
        int prevEnd = balloonPoints[0][1];
        int n = balloonPoints.length;
        int minArrow = 1;
        for (int i = 0; i < n; i++) {
            int currStart = balloonPoints[i][0];
            int currEnd = balloonPoints[i][1];
            //curr start should be strictly greater than the prev end
            //that way we know we need extra arrows to burst these curr ballons
            //otherwise all the curr start that lesser than prev end falls under
            //the range of single arrow shot.
            if (currStart > prevEnd) {
                minArrow++;
                prevEnd = currEnd;
            }
        }
        //output
        System.out.println("Minimum arrows required to burst all balloon: " + minArrow);
    }

    public void partitionArrSuchThatMaxDiffIsK_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/
        int n = nums.length;
        Arrays.sort(nums);
        int partition = 1;
        int prevIndex = 0;

        for (int i = 1; i < n; i++) {
            int currDiffInMaxAndMinVals = nums[i] - nums[prevIndex];
            if (currDiffInMaxAndMinVals > k) {
                partition++;
                prevIndex = i;
            }
        }
        //output
        System.out.println("Partitions : " + partition);
    }

    public void efficientJanitor_Greedy(double[] arr) {
        //https://leetcode.com/problems/boats-to-save-people/
        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
        //TWO POINTER approach 1
        /*
         ex: {1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7}
         Output: 5 groups: (1.01 , 1.99), (1.01, 1.7), (3.0), (2.7), (2.3)
         */
        int n = arr.length;
        int start = 0;
        int end = n - 1;

        int groups = 0;
        Arrays.sort(arr);

        while (end >= start) {

            if (end == start) {
                groups++;
                break;
            } else if (arr[start] + arr[end] <= 3.0) {
                start++;
                end--;
                groups++;
            } else {
                end--;
                groups++;
            }
        }

        //output
        System.out.println("Groups of item with sum at most 3(approach 1): " + groups);
    }

    public void efficientJanitor2_Greedy(double[] arr) {
        //https://leetcode.com/problems/boats-to-save-people/
        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
        //TWO POINTER approach 2
        /*
         ex: {1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7}
         Output: 5 groups: (1.01 , 1.99), (1.01, 1.7), (3.0), (2.7), (2.3)
         */
        int n = arr.length;
        int start = 0;
        int end = n - 1;

        int groups = 0;
        Arrays.sort(arr);

        while (end >= start) {
            groups++;
            if (arr[start] + arr[end] <= 3.0) {
                start++;
            }
            end--;
        }

        //output
        System.out.println("Groups of item with sum at most 3(approach 2): " + groups);
    }

    public int farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(
            int[] heights, int bricks, int ladders) {
        //https://leetcode.com/problems/furthest-building-you-can-reach/
        int n = heights.length;
        int bricksUsed = 0;
        int index = 1;

        PriorityQueue<Integer> minHeapHeightDiff = new PriorityQueue<>();

        while (index < n) {

            int buildingHeightDiff = heights[index] - heights[index - 1];

            //if the buildingHeightDiff is less than or equal 0, means the prev
            //building heights[index - 1] was a higher than curr heights[index]
            //for prev higher building to curr lower height  we don't need any
            //ladder or bricks, just straight move to curr heights[index]
            if (buildingHeightDiff <= 0) {
                continue;
            }

            //if the curr index-th building height is greater than its prev building
            //that means we have used either bricks or ladder to reach curr building
            //but in some optimal way so add diff of heights in min heap
            minHeapHeightDiff.add(buildingHeightDiff);

            //here we greedily wants to use ladder first if our min heap's size is
            //lesser or equal to given ladder that means we can use ladders for
            //all the buildingHeightDiff in the min heap (==> size)
            if (minHeapHeightDiff.size() <= ladders) {
                continue;
            }

            //here we have used all ladders provided now we need to consume bricks
            //we want to use bricks as min as possible & from min heap we get the
            //min diff of heights that means we have consumed that much of bricks
            bricksUsed += minHeapHeightDiff.poll();
            //if our brickUsed is more than the brick given that means we could
            //not have reached curr index so return index - 1;
            if (bricksUsed > bricks) {
                return index - 1;
            }
            index++;
        }
        return n - 1;
    }

    public void taskSchedular_Greedy(char[] tasks, int n) {
        //https://leetcode.com/problems/task-scheduler/
        //https://leetcode.com/problems/task-scheduler/discuss/2314557/Easiest-Solution-or-O(n)-time-O(26)-space-or-Detailed-and-Easiest-explanation
        int len = tasks.length;
        int[] freqMap = new int[26];
        int maxFreq = 0;
        int maxFreqCount = 0;

        for (char task : tasks) {
            int index = task - 'A';
            freqMap[index]++;
            if (freqMap[index] > maxFreq) {
                //reset
                maxFreq = freqMap[index];
                maxFreqCount = 1;
            } else if (freqMap[index] == maxFreq) {
                maxFreqCount++;
            }
        }
        //output
        int output = Math.max(len, (maxFreq - 1) * (n + 1) + maxFreqCount);
        System.out.println("Least unit of time cpu will take to finish all tasks: " + output);
    }

    public void twoCityScheduling_Greedy(int[][] costs) {
        //https://leetcode.com/problems/two-city-scheduling/
        //explanation: https://youtu.be/d-B_gk_gJtQ

        class CostDiff {

            int costDiff;
            int costA;
            int costB;

            public CostDiff(int costDiff, int costA, int costB) {
                this.costDiff = costDiff;
                this.costA = costA;
                this.costB = costB;
            }

        }

        List<CostDiff> diffs = new ArrayList<>();
        //calculating the cost diff with intuition of how much
        //extra we have to pay if we send ith person to cityB so
        //cityB - cityA = diff
        for (int[] cost : costs) {
            int costA = cost[0];
            int costB = cost[1];
            diffs.add(new CostDiff(costB - costA, costA, costB));
        }

        //sort the list on basis of costDiff, this will sort diffs in incr order
        //that means on the left side of diffs list we will have min cost diff for ith
        //person to send to cityB, Now acc to quest we need to half of the person to cityA and
        //other half to cityB, we are greedily choosing min cost at which we can send
        //half ith person to cityB first and remaining can go to cityA
        Collections.sort(diffs, (d1, d2) -> d1.costDiff - d2.costDiff);
        int minCost = 0;
        for (int i = 0; i < diffs.size(); i++) {
            if (i < diffs.size() / 2) {
                minCost += diffs.get(i).costB;
            } else {
                minCost += diffs.get(i).costA;
            }
        }
        //output
        System.out.println("Total min cost at which half of people can travel to city A and half to cityB: "
                + minCost);
    }

    public int superWashingMachines_Greedy(int[] machines) {
        //https://leetcode.com/problems/super-washing-machines/
        //https://leetcode.com/problems/super-washing-machines/discuss/2309704/c-simple-loop
        int n = machines.length;

        int totalCloths = 0;

        for (int cloth : machines) {
            totalCloths += cloth;
        }

        //if total clothes are not enough to equally distributed among n machines
        if (totalCloths % n != 0) {
            return -1;
        }

        int clothsPerMachine = totalCloths / n;
        int moves = 0;
        int delta = 0;

        for (int cloth : machines) {

            delta += cloth - clothsPerMachine;

            moves = Math.max(moves,
                    Math.max(cloth - clothsPerMachine, Math.abs(delta)));
        }
        return moves;
    }

    public void courseSchedule_3_Greedy(int[][] courses) {
        //https://leetcode.com/problems/course-schedule-iii/
        //sort on the basis of lastDay of courses
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);

        PriorityQueue<Integer> maxHeapDurations = new PriorityQueue<>(
                (a, b) -> b - a);

        int totalDuration = 0;

        for (int[] course : courses) {
            int duration = course[0];
            int lastDay = course[1];

            if (totalDuration + duration <= lastDay) {
                totalDuration += duration;
                maxHeapDurations.add(duration);
            } else if (!maxHeapDurations.isEmpty() && maxHeapDurations.peek() > duration) {
                totalDuration += duration - maxHeapDurations.poll();
                maxHeapDurations.add(duration);
            }
        }
        //output
        System.out.println("Total courses we can take: " + maxHeapDurations.size());
    }

    public void numberOfWeakCharactersInGame_Greedy(int[][] properties) {
        //https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/
        int n = properties.length;
        //indexes
        int ATTACK = 0;
        int DEFENSE = 1;

        //sort the character properties in increasing order of their attack
        //if two attacks are same then sort their defenses in decreasing order
        Arrays.sort(properties, (a, b) -> a[ATTACK] == b[ATTACK]
                ? Integer.compare(b[DEFENSE], a[DEFENSE])
                : Integer.compare(a[ATTACK], b[ATTACK]));

        //with the above sorting we know that every
        //attack[i-th] character <= attack[j-th] character
        //now we are left to check defenses,
        //if defense[i-th] character < defense[j-th] character
        int weakCharacters = 0;
        //here we assume that the last charcter(==> n - 1) has max defense
        //as it is said to be j-th character
        int maxDefense = properties[n - 1][DEFENSE];
        //here we will iterate from [n - 2 to 0] as the i-th character
        for (int i = n - 2; i >= 0; i--) {
            //get the defense of the i-th character
            int currDefense = properties[i][DEFENSE];
            //here defense[i-th] character < defense[j-th] character(==> maxDefense)
            //hence making our i-th character, a week character so count +1
            if (currDefense < maxDefense) {
                weakCharacters++;
            } else {
                //if the defense[i-th] character > defense[j-th] character(==> maxDefense)
                //firstly we need to update the max defense as for other i-th characters
                //to left of curr 'i' this currDefense will then act as j-th character
                //but here we didn't increase count for week character why?
                //because, remeber the properties[][] is already sorted on 'attack'
                //that simply means attack[i-th] character <= attack[j-th] character
                //hence in this else-block current j-th character can't be considered
                //week
                maxDefense = currDefense;
            }
        }
        //output
        System.out.println("Number of weak characters in game: " + weakCharacters);
    }

    public void bagOfTokens_Greedy(int[] tokens, int power) {
        //https://leetcode.com/problems/bag-of-tokens/
        //based on TWO POINTER & GREEDY
        int n = tokens.length;
        int start = 0;
        int end = n - 1;
        int currScore = 0;
        int maxScore = 0;

        //sorting the tokens will allow us to pick tokens in a greedy way
        //those tokens where given power >= token[i]
        Arrays.sort(tokens);

        while (end >= start) {
            //If your current power is at least tokens[i], you may play the
            //ith token face up, losing tokens[i] power and gaining 1 score
            if (power >= tokens[start]) {
                currScore++;
                power -= tokens[start++];
                maxScore = Math.max(maxScore, currScore);
            } else if (power < tokens[start] && currScore >= 1) {
                //If your current score is at least 1, you may play the ith
                //token face down, gaining tokens[i] power and losing 1 score.
                currScore--;
                power += tokens[end--];
            } else {
                break;
            }
        }
        //output
        System.out.println("Max score from bag of tokens: " + maxScore);
    }

    public int maxNumberOfGroupsEnteringCompetition_Greedy(int[] grades) {
        //https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
        int n = grades.length;
        Arrays.sort(grades);
        int start = 0;
        int groupSize = 0;
        int groups = 0;
        for (; start < n; start += groupSize) {
            groups++;
            groupSize++;
        }
        if (start > n) {
            return groups - 1;
        }
        return groups;
    }

    public void maxScoreAfterApplyingKOperations_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/maximal-score-after-applying-k-operations/description/
        /*
        while saving the updated value back into max heap remeber that we have to
        consider a double division in order to to a ceil value
        ex: nums[] = [1,10,3,3,3], k = 3
        Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.
        ==> we chose 10 from maxHeap ceil(10.0 / 3.0) ==> ceil(3.33) ==> 4
        Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.
        Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.
        The final score is 10 + 4 + 3 = 17.

         */
        PriorityQueue<Double> maxHeap = new PriorityQueue<>(
                (a, b) -> Double.compare(b, a));

        for (double val : nums) {
            maxHeap.add(val);
        }

        long score = 0;

        while (!maxHeap.isEmpty() && k > 0) {
            k--;

            double currVal = maxHeap.poll();
            score += (long) currVal;
            maxHeap.add(Math.ceil(currVal / 3.0));
        }
        //output
        System.out.println("max score after applying k operations : " + score);
    }

    public void removeStonesToMinimizeTotal_Greedy(int[] piles, int k) {
        //https://leetcode.com/problems/remove-stones-to-minimize-the-total/
        //https://leetcode.com/problems/take-gifts-from-the-richest-pile/description/
        //somewhat based on minCostOfRope()
        PriorityQueue<Integer> maxHeapStones = new PriorityQueue<>((a, b) -> b - a);

        int totalPilesSum = 0;

        for (int pile : piles) {

            totalPilesSum += pile;
            maxHeapStones.add(pile);
        }

        int reducedPilesSum = 0;

        while (!maxHeapStones.isEmpty() && k > 0) {
            k--;

            int currPile = maxHeapStones.poll();

            //interger division of pile as (pile / 2) is actually same as
            //floor(pile / 2.0) value in double
            int pileReduced = currPile / 2;

            //add up all the reduced pile value
            reducedPilesSum += pileReduced;

            //new pile value will be curr pile - pile reduced
            maxHeapStones.add(currPile - pileReduced);
        }

        //output
        System.out.println("Remove stones to minimize the total stones in pile: " + (totalPilesSum - reducedPilesSum));
    }

    public void minOperationToHalveTheArraySum_Greedy(int[] arr) {
        //https://leetcode.com/problems/minimum-operations-to-halve-array-sum/
        //somewhat based on minCostOfRope() & removeStonesToMinimizeTotal_Greedy()
        //since we are using maxHeap of Double, avoid using the comparator this
        //way ((a, b) - (int)(b - a)) because this typecasting to int will cause issue
        //in maxHeap, hence cause wrong answer, instead we can use ((a, b) - Double.compare(b - a))
        //or Collections.reverseOrder()
        PriorityQueue<Double> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        double sum = 0.0;
        for (double val : arr) {
            sum += val;
            maxHeap.add(val);
        }

        int oprn = 0;
        double currSum = sum;
        double halfTheSum = sum / 2.0;

        while (!maxHeap.isEmpty()) {
            oprn++;
            double val = maxHeap.poll();
            double half = val / 2.0;

            currSum = currSum - half;
            maxHeap.add(half);

            if (currSum < halfTheSum) {
                break;
            }
        }
        //output
        System.out.println("Min operation to halve the array sum: " + oprn);
    }

    public void reduceArraySizeTohalf_Greedy(int[] arr) {
        //https://leetcode.com/problems/reduce-array-size-to-the-half/
        /*
        nums[] = [3,3,3,3,5,5,5,2,2,7]

        maxArrSize = nums.length = 10
        halfArrSize = maxArrSize / 2 = 5

        freq = {3 = 4, 5 = 3, 2 = 2, 7 = 1}

        freqVals = [4, 3, 2, 1]
        sort(freqVals) = [4,3,2,1]

        greedily reduce the size of arr by removing most occuring val from nums

        int removed = 0;

        while(maxArrSize > halfArrSize)
        ==> maxArrSize -= freqVals.get(remove++)

         */
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int val : arr) {
            freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);
        }

        List<Integer> freqVals = new ArrayList<>(freqMap.values());
        //sort max freq first
        Collections.sort(freqVals, (a, b) -> b - a);

        int maxArrSize = arr.length;
        int halfArrSize = maxArrSize / 2;
        int removed = 0;
        while (maxArrSize > halfArrSize) {
            maxArrSize -= freqVals.get(removed++);
        }
        //output
        System.out.println("Removals to make array half: " + removed);
    }

    public void minimizeMaxPairSumInArray_Greedy(int[] arr) {
        //https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/
        int n = arr.length;
        int start = 0;
        int end = n - 1;
        //sort the arr in incr order
        Arrays.sort(arr);
        int minimizedMaxPairSum = 0;
        while (end > start) {
            //here we are minimizing the pair sum by choosing the max value from
            //end of arr and min value from start of the arr in sorted array,
            //and choosing max value from them
            minimizedMaxPairSum = Math.max(minimizedMaxPairSum, arr[start] + arr[end]);
            start++;
            end--;
        }
        //output
        System.out.println("Minimized max pair sum: " + minimizedMaxPairSum);
    }

    public void minSubseqOfNonIncreasingOrder_Greedy_HeapBased(int[] nums) {
        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
        //somewhat based on subseqOfLengthKWithLargestSum()
        class Pair {

            int val;
            int index;

            public Pair(int val, int index) {
                this.val = val;
                this.index = index;
            }
        }

        List<Integer> result = new ArrayList<>();
        PriorityQueue<Pair> maxHeap = new PriorityQueue<>((a, b) -> b.val - a.val);
        int totalSum = 0;
        for (int i = 0; i < nums.length; i++) {
            totalSum += nums[i];
            maxHeap.add(new Pair(nums[i], i));
        }

        int maxSum = 0;
        while (!maxHeap.isEmpty()) {
            Pair currPair = maxHeap.poll();
            maxSum += currPair.val;
            totalSum -= currPair.val;
            result.add(currPair.val);
            if (maxSum > totalSum) {
                break;
            }
        }
        //output
        System.out.println("Min subseq where its sum is stricly greater than the left over elements sum: " + result);
    }

    public void minSubseqOfNonIncreasingOrder_Greedy(int[] nums) {
        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
        //simple straight forward sorting & OPTIMIZED
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        Arrays.sort(nums);

        int totalSum = 0;
        for (int val : nums) {
            totalSum += val;
        }

        int maxSum = 0;
        //after sorting the greater nums are in the end of the array
        //creating the maxSum from end and also reducing the same value from totalSum
        //until our maxSum > totalSum (maxSum strictly greater than totalSum)
        //all those max nums we are taking, we will put in result
        for (int i = n - 1; i >= 0; i--) {
            maxSum += nums[i];
            totalSum -= nums[i];
            result.add(nums[i]);
            if (maxSum > totalSum) {
                break;
            }
        }

        //output
        System.out.println("Min subseq where its sum is stricly greater than the left over elements sum: " + result);
    }

    public int minRoundsToCompleteAllTasks_Greedy(int[] tasks) {
        //https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/
        Map<Integer, Integer> freq = new HashMap<>();
        for (int val : tasks) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        int rounds = 0;
        //can pick task that are 2 or 3 in freq, if we can't pick the task in
        //such freq return -1
        for (int key : freq.keySet()) {
            int count = freq.get(key);
            if (count < 2) {
                return -1;
            } else if (count < 3) {
                rounds++;
            } else if (count % 3 == 0) {
                rounds += (count / 3);
            } else {
                rounds += (count / 3) + 1;
            }
        }
        return rounds;
    }

    public void maxMatchingOfPlayersWithTrainers_Greedy(int[] players, int[] trainers) {
        //https://leetcode.com/problems/maximum-matching-of-players-with-trainers/
        //based on GREEDY & TWO POINTERS
        int n = players.length;
        int m = trainers.length;

        int i = 0;
        int j = 0;

        int match = 0;

        Arrays.sort(players);
        Arrays.sort(trainers);

        while (i < n && j < m) {
            //since a players[i] can only be trained by a trainers[j] only if
            //(players[i] < trainers[j]) so with this loop we will skip all those
            //players[i] that can't trained by curr j-th trainer
            //(i.e, players[i] > trainers[j])
            while (j < m && players[i] > trainers[j]) {
                j++;
            }

            //break/return match, if there are no more trainers left to train any
            //player
            if (j >= m) {
                break;
            }

            //here players[i] is now matched with trainers[j]
            match++;
            //so move to next player
            i++;
            //since there can only be one trainer to player pair is possible and
            //curr trainers[j] is matched with players[i] so also move to next
            //trainer
            j++;
        }
        //output
        System.out.println("Max players with trainers match: " + match);
    }

    public void eliminateMaxNumberOfMonster_Greedy(int[] dist, int[] speed) {
        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/discuss/2730968/JAVA-oror-Sorting-oror-Greedy
        int n = dist.length;

        //times = time taken by the monster to reach the city
        double[] times = new double[n];

        //Speed = (Dist / Time)
        //==> Time = (Dist / Time)
        //time taken by each monster to reach the city
        //==> time[i-th monster] = dist[i-th monster] / speed[i-th monster]
        for (int monster = 0; monster < n; monster++) {
            times[monster] = ((double) dist[monster] / (double) speed[monster]);
        }

        //sort the times[], so that we can have the monster that can reach the
        //city earliest in the starting
        Arrays.sort(times);

        //since, initially the weapon is already fully charged
        //hence time taken to charge the weapon is 0.0
        double timeToChargeWeapon = 0.0;
        int monsterKilled = 0;

        for (int monster = 0; monster < n; monster++) {

            //if the time for curr 'monster' to reach the city is less or equal
            //than the time taken to charge the weapon, means weapon will not be
            //ready and monster will reach the city hence we will loose, break
            if (times[monster] <= timeToChargeWeapon) {
                break;
            }

            //otherwise here, time for curr 'monster' to reach city was more
            //than the time taken to charge the weapon, means weapon will be
            //charged before the monster reach the city, hence weapon can kill
            //the coming monster
            monsterKilled++;
            //as given time to fully charge the weapon is 1 min, hence after
            //a monster is killed, weapon will take (+1) min to charge itself
            timeToChargeWeapon += 1.0;
        }
        //output
        System.out.println("Max monster kills: " + monsterKilled);
    }

    public void maxBagsCompletelyFilledWithRocks_Greedy(int[] capacities, int[] rocks, int additionalRocks) {
        //https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/

        int n = capacities.length;

        //find the reamining capacity for the i-th bag that is yet to be
        //filled by taking some rocks from 'additonalRocks'
        //remaining capacities of i-th bag can be calculated as max capacity
        //of i-th bag i.e, capacities[i] subtracted with curr rocks held in
        //the same i-th bag i.e, rocks[i]
        //remainingBagCapacity = capacities[i] - rocks[i]
        for (int i = 0; i < n; i++) {
            capacities[i] -= rocks[i];
        }

        //sort the remaining capacities of bags, so that we can greedily
        //pick bags with min remaining capacity and fill them using rocks
        //from additionalRocks as long as we have additionalRocks
        Arrays.sort(capacities);

        int completelyFilledBags = 0;

        for (int remainingBagCapacity : capacities) {

            //bags that is already filled up with rocks upto their max capacity
            //their remaining capacity will be 0 means no additionalRock is req
            //and they already completely filled bags
            if (remainingBagCapacity == 0) {
                completelyFilledBags++;
                continue;
            }

            //break, if the additionalRocks are less as compared to remainingBagCapacity
            //to completely fill this curr bag means with the curr additionalRocks
            //left, the curr bag can't be filled compeletely and as the remaining
            //capacity ==> capacities[] is also sorted incr means further it won't
            //be possible
            if (remainingBagCapacity > additionalRocks) {
                break;
            }

            //fill the curr bag's remaining capacity by taking some 'additionalRocks'
            //that way this additionalRocks will be reduced by 'remainingBagCapacity'
            //amount of rocks
            additionalRocks -= remainingBagCapacity;

            //by taking 'remainingBagCapacity' from the additionalRocks, we filled
            //curr bag completely
            completelyFilledBags++;
        }

        //output
        System.out.println("Bags that completly filled with rocks: " + completelyFilledBags);
    }

    public int minMovesToReachTarget_Greedy(int target, int maxDoubles) {
        //https://leetcode.com/problems/minimum-moves-to-reach-target-score/
        //https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
        //https://leetcode.com/problems/count-operations-to-obtain-zero/
        //aim is to reach target from src == 1 either by
        //1. adding 1 to src or
        //2. doubling the src(2 * src)
        //here backward approach is used, going from target to src using the
        //reverse moves that means reducing by 1 or dividing by 2
        //since we can't reduce our target half as maxDoubles == 0, the max moves
        //we can perform to reach to src == 1 from target is target - src
        //==> target - 1 moves
        if (maxDoubles == 0) {
            return target - 1;
        }

        int moves = 0;

        while (target > 1 && maxDoubles > 0) {

            if (target % 2 == 0) {

                target /= 2;
                maxDoubles--;
            } else {

                target -= 1;
            }
            moves++;
        }
        //if above loops breaks because we used all our maxDoubles and target still
        //not reached 1 then total moves to perform is curr moves we did + remaining
        //moves to each from remaining target to src == 1 i.e, target - src
        //==> target - 1 ==> moves + (target - 1)
        //else if above loop break because we reached to target == src == 1
        //we can simply return moves we perform in that
        return target == 1 ? moves : moves + (target - 1);
    }

    public int maximizeTopmostElementAfterKMoves_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/
        int n = nums.length;

        if (n == 1 && k % 2 == 1) {
            return -1;
        }

        int maxPile = -1;

        for (int pile : nums) {
            //if k = 0, means we will neither remove the topmost pile nor add
            //any other pile hence the max pile that can remain at top will be
            //max(maxPile, pile) which eventually be the pile == nums[0] why?
            //because after checking first pile k-- will become negative and
            //below if() block will never run
            //if k > 1, means k can greater or equal to 2(==> k > 1 == k >= 2)
            //hence with atleast 2 moves we can remove a pile and also add back
            //to it again before we exhaust all k moves hence we can choose the
            //max pile as long as (k > 1)
            if (k == 0 || k > 1) {
                maxPile = Math.max(maxPile, pile);
            }

            k--;
        }
        return maxPile;
    }

    public int minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(int[] nums) {
        //https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/
        int n = nums.length;
        if (n <= 4) {
            return 0;
        }

        int minDiff = Integer.MAX_VALUE;
        Arrays.sort(nums);

        minDiff = Math.min(minDiff, nums[n - 1] - nums[3]);
        minDiff = Math.min(minDiff, nums[n - 2] - nums[2]);
        minDiff = Math.min(minDiff, nums[n - 3] - nums[1]);
        minDiff = Math.min(minDiff, nums[n - 4] - nums[0]);

        return minDiff;
    }

    public void previousPermutationWithOneSwap_Greedy(int[] num) {
        //https://leetcode.com/problems/previous-permutation-with-one-swap/description/
        //somewhat same as nextPermutation()
        /*
        ex: num[] = [3,1,1,3], n = 4
        output = [1,3,1,3]

        1313 as a num value is just smaller/previous permutaion of 3113 as num
        1. index = n - 1 == 3, currVal = 3, rightSide = [index + 1, n] == [n, n]
        Not valid for() loop
        2. index = 2, currVal = 1, rightSide = [index + 1, n] == [3, n] == num == [3]
        no smallerThanCurrVal in rightSide
        3. index = 1, currVal = 1, rightSide = [idnex + 1, n] == [2, n] == num == [1,3]
        no smallerThanCurrVal in rightSide
        4. index = 0, currVal = 3, rightSide = [index + 1, n] == [1, n] == num == [1,1,3]
        smallerThanCurrVal in rightSide == num[1] == 1 (num[i] < currVal)
        therefore
        [3,1,1,3] = swap(0, 1) = [1,3,1,3]
         */
        int n = num.length;
        int index = n - 1;
        while (index >= 0) {
            //curr val at index-th
            int currVal = num[index];
            //default smaller value
            int smallerThanCurrVal = -1;
            //default smaller val's index
            int smallerThanCurrValIndex = -1;
            //with this for loop we will find the a smallerThanCurrVal == num[i],
            //in the right side of the index-th point which is smaller than
            //curr val but this num[i] should be max in num[index + 1, n]
            for (int i = index + 1; i < n; i++) {
                //num[i] should be less than currVal
                if (num[i] < currVal) {
                    //but this num[i] should be max in num[index + 1, n]
                    if (num[i] > smallerThanCurrVal) {
                        smallerThanCurrVal = num[i];
                        smallerThanCurrValIndex = i;
                    }
                }
            }
            //if smallerThanCurrValIndex is a valid index then we can swap
            //the values at curr index & smallerThanCurrValIndex. since only
            //one swap is allowed then we have to break/return from here
            if (smallerThanCurrValIndex != -1) {
                //swap
                int temp = num[index];
                num[index] = num[smallerThanCurrValIndex];
                num[smallerThanCurrValIndex] = temp;
                break;
            }
            index--;
        }
        //output
        System.out.println("Previous permutation with one swap: " + Arrays.toString(num));
    }

    public void maxIcecreamBars_Greedy(int[] costs, int coins) {
        //https://leetcode.com/problems/maximum-ice-cream-bars/description/
        //based on BASIC GREEDY LOGIC
        //sort all the icecreams by their cost, so min cost first
        //motive is to pick as many bars as possible from the given
        //coins, so pick all the min cost bars first
        Arrays.sort(costs);
        int icecreamPicks = 0;
        for (int cost : costs) {
            //if at any point we have less coins that can't buy this bar at curr
            //cost, break; we can't even buy further
            if (coins < cost) {
                break;
            }
            //picking a bar with curr cost, so we will reduce our coins by that
            //cost of bar
            coins -= cost;
            //picked this bar
            icecreamPicks++;
        }
        //output
        System.out.println("Max icecreams bars: " + icecreamPicks);
    }

    public void longestChunkedPallindromeDecomposition_Greedy(String word) {
        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/
        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/solutions/350560/java-c-python-easy-greedy-with-prove/
        /*
        looping the word from 0 to n so that the

        1. chunk will be counted as 1 when there is no intermediate pallindrome
        chunk is possible
        ex: "merchant", there is no intermediate pallindrome chunk so when
        i == n - 1, leftChunk == "merchant", rightChunk == "merchant" hence
        at this point chunk++ ==> 1 and loop ends

        2. chunk itself will be doubled
        ex: word = "ghiabcdefhelloadamhelloabcdefghi"
        #1.
        leftChar = g, rightChar = i
        leftChunk = append() = "g", rightChunk = insert(0) = "i"
        #2.
        leftChar = h, rightChar = h
        leftChunk = append() = "gh", rightChunk = insert(0) = "hi"
        #3.
        leftChar = i, rightChar = g
        leftChunk = append() = "ghi", rightChunk = insert(0) = "ghi"
        ==> leftChunk == rightChunk
        ====> partiiton++
        //reset chunks once leftChunk equals to rightChunk
        ====> leftChunk = "", rightChunk = ""
        ....
        iteratively, next chunk will be picked

        also since we are looping 0 to n, when i reaches (n / 2)
        left & right chunks will be seen again, hence our chunks will get doubled

         */
        int n = word.length();
        int chunk = 0;
        StringBuilder leftChunk = new StringBuilder();
        StringBuilder rightChunk = new StringBuilder();

        for (int i = 0; i < n; i++) {
            char leftChar = word.charAt(i);
            char rightChar = word.charAt(n - i - 1);

            leftChunk.append(leftChar);
            rightChunk.insert(0, rightChar);

            if (leftChunk.toString().equals(rightChunk.toString())) {
                chunk++;
                //reset chunks
                leftChunk.setLength(0);
                rightChunk.setLength(0);
            }
        }
        //output
        System.out.println("Longest chunked pallindrome decomposition: " + chunk);
    }

    public void appendKIntegerWithMinSum_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/
        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/1823848/java-solution-use-n-n-1-2/
        /*

        Intuition:

        sum of n positive integers = 1 + 2 + 3 + 4 ..... + n
        ==> n * (n + 1) / 2

        we also know that from all the positive integers like 1,2,3,4....n
        if we want to choose k smallest positive integers that should be from
        starting range of these positive integers
        ex: k = 3 smallest unique positive integer that will be 1, 2, 3

        similarly, sum of k-smallest unique postive integers will be
        1 + 2 + 3 ... + k ==> k * (k + 1) / 2

        Now, acc to this question statement,

        'Append k unique positive integers that do not appear in nums to nums
        such that the resulting total sum is minimum.'

        simplified as 'we need k-unique positive integers whose sum is minimum'
        for this we use the intuition and sum of k-smallest unique integers
        ==> k * (k + 1) / 2

        BUT

        this question also states that these k positive integers should not
        appear in the given nums[]

        ex: nums[] = [1,4,25,10], k = 5
        ==> 'we need k-unique positive integers whose sum is minimum'
        so we know what smallest unique positive integers to choose and i.e,
        1, 2, 3, 4, 5 ==> k-unique positive integers and their sum will be min

        so, k * (k + 1) / 2 ==> 5 * (5 + 1) / 2 ==> 15

        BUT
        see here, this first k-unique positive integers also contains some number
        from nums[] ==> 1, 4 so we must exclude them and their sum

        2, 3, 5 and now we have 3 unique positive integers but we still need two
        more as we need k = 5, so we choose the just next two positive integers
        2, 3, 5, 6, 7 ==> k-unique positive integers whose sum will still be less

        sum ==> 2, 3, 5, 6, 7 ==> 23

        now because of 1, 4 we lost two unique integers, we technically increased
        k = k + 2 ==> 7

        1 + 2 + 3 + 4 + 5 + 6 + 7 ==> 7 * (7 + 1) / 2 ==> 28

        but, 1 and 4 were excluded ==> 1 + 4 ==> 5

        28 - 5 ==> 23 ==> [2, 3, 5, 6, 7]


        iterations:

        nums[] = [1,4,25,10,25], k = 2

        //sorting will  help in arranging 'seq of positive integers' in incr order
        sort(nums) ==> [1, 4, 10, 25, 25]

        //initally, k = 2 so we need
        //k * (k + 1) / 2 ==> 3 ==> [1, 2] k-unique positive integers

        set = {}

        sum = 0

        #1
        val = 1
        if(!set[1] && 1 <= 2) TRUE
        ==> k++ ==> 3
        ==> sum += val ==> 0 + 1 ==> 1
        //1 should ideally be in k-unique positive integers ==> [1, 2] but this
        //exist in nums[] hence we need to exclude this 1 but this also creates
        //a vacancy to add one more unique element hence ==> k++ ==> 3
        //now, k-unique positive integers ==> [1, 2, 3] exclude = sum = 1

        set.add(1) ==> {1}

        #2
        val = 4
        if(!set[4] && 4 <= 3) FALSE
        set.add(4) ==> {1, 4}

        #3
        val = 10
        if(!set[10] && 10 <= 3) FALSE
        set.add(10) ==> {1, 4, 10}

        #4
        val = 25
        if(!set[25] && 25 <= 3) FALSE
        set.add(10) ==> {1, 4, 10, 25}

        #5
        val = 25
        if(!set[25] && 25 <= 3) FALSE
        set.add(10) ==> {1, 4, 10, 25}

        ...END

        k = 3, sum = 1
        sum of k-unique positive integers = k * (k + 1) / 2 ==> 6
        but, 1 needs to be excluded from this ==> k * (k + 1) / 2 - sum
        ==> 6 - 1 ==> 5

         */
        int n = nums.length;
        Arrays.sort(nums);
        Set<Integer> set = new HashSet<>();
        long sum = 0;
        for (int val : nums) {
            if (!set.contains(val) && val <= k) {
                k++;
                sum += val;
            }
            set.add(val);
        }
        long minSum = (long) (1 + k) * k / 2 - sum;
        //output
        System.out.println("Minimal sum : " + minSum);
    }

    public void maxNumberOfIntegersToChooseFromRange_Greedy(int[] banned, int n, int maxSum) {
        //https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/description/

        Set<Integer> bannedSet = IntStream.of(banned).boxed()
                //keep only those val in the set that are smaller or equal to 'n'
                .filter(val -> val <= n)
                .collect(Collectors.toSet());

        int picked = 0;
        int currSum = 0;
        int val = 1;

        //as the range of numbers are val = [1, n]
        while (val <= n) {

            //any 'val' that is not banned should be considered
            if (!bannedSet.contains(val)) {

                //make sum with val
                currSum += val;

                //break, if the currSum is now more that maxSum, as per question,
                //any val picked, their sum should be atmost given 'maxSum'
                if (currSum > maxSum) {
                    break;
                }
                //successfully picked a val
                picked++;
            }
            //move to next val
            val++;
        }

        //output
        System.out.println("Max numbers picked from the range : " + picked);
    }

    public boolean canPlaceFlowers_Greedy(int[] flowerbed, int flowers) {
        //https://leetcode.com/problems/can-place-flowers/description/
        int len = flowerbed.length;

        if (flowers == 0) {
            return true;
        }

        for (int i = 0; i < len; i++) {

            boolean hasNoFlowerInLeftSide = (i == 0 || flowerbed[i - 1] == 0);

            boolean isCurrPlotEmpty = flowerbed[i] == 0;

            boolean hasNoFlowerInRightSide = (i == len - 1 || flowerbed[i + 1] == 0);

            if (hasNoFlowerInLeftSide && isCurrPlotEmpty && hasNoFlowerInRightSide) {
                //then pick 1 flower and place it in the flowerbed at i-th location
                //that has 0 flower in prev bed and 0 flower in next bed
                flowers--;
                flowerbed[i] = 1;
            }
            //if we have used all the flowers return true
            if (flowers == 0) {
                return true;
            }
        }
        //not possible
        return false;
    }

    public void maxScoreForString_Greedy(String str, int x, int y) {
        //https://leetcode.com/problems/maximum-score-from-removing-substrings/description/
        //https://practice.geeksforgeeks.org/problems/d25f415de2ff3e02134de03e17ad019d723ab2e9/1
        long totalScore = 0;
        //this StringBuilder will act as stack
        StringBuilder sb = new StringBuilder();
        //greedily choose which substring will give more score at first, then
        //process all the substring for that
        //here if score("ab") >= score("ba") then process all "ab" first then
        //process "ba" latter on the left over chars of given string
        if (x >= y) {
            //process all "ab" first
            for (char ch : str.toCharArray()) {
                if (!sb.isEmpty() && sb.charAt(sb.length() - 1) == 'a' && ch == 'b') {
                    totalScore += x;
                    //pop the last added a because curr chr == b hence substring
                    //formed is "ab"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }

            //process all "ba" latter on left over chars of str in StringBuilder
            str = sb.toString();
            //reset stack
            sb.setLength(0);
            for (char ch : str.toCharArray()) {
                if (!sb.isEmpty() && sb.charAt(sb.length() - 1) == 'b' && ch == 'a') {
                    totalScore += y;
                    //pop the last added b because curr chr == a hence substring
                    //formed is "ba"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }
        } else {
            //process all "ba" first
            for (char ch : str.toCharArray()) {
                if (!sb.isEmpty() && sb.charAt(sb.length() - 1) == 'b' && ch == 'a') {
                    totalScore += y;
                    //pop the last added b because curr chr == a hence substring
                    //formed is "ba"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }

            //process all "ab" latter on left over chars of str in StringBuilder
            str = sb.toString();
            //reset stack
            sb.setLength(0);
            for (char ch : str.toCharArray()) {
                if (!sb.isEmpty() && sb.charAt(sb.length() - 1) == 'a' && ch == 'b') {
                    totalScore += x;
                    //pop the last added a because curr chr == b hence substring
                    //formed is "ab"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }
        }

        //output
        System.out.println("Max score of string ab Or ba: " + totalScore);
    }

    public void reducingDishes_Greedy(int[] satisfaction) {
        //https://leetcode.com/problems/reducing-dishes/description/
        //this is GREEDY solution to same question solved with Recursive memo
        int n = satisfaction.length;
        Arrays.sort(satisfaction);
        int maxSatisfaction = 0;
        int currSatisfaction = 0;

        for (int i = n - 1; i >= 0; i--) {
            if (currSatisfaction + satisfaction[i] < 0) {
                break;
            }
            currSatisfaction += satisfaction[i];
            maxSatisfaction += currSatisfaction;
        }
        //output
        System.out.println("Max like time coefficient (Greedy): " + maxSatisfaction);
    }

    public void minStepsReqToMakeStringEmpty_Greedy(String str) {
        //https://practice.geeksforgeeks.org/problems/6a1b365b520f10c8a29b533eb72951b4b4237b57/1
        //given string str only contains a and b, count all the groups that has
        //some consecutive groups of either a's OR b's
        int n = str.length();
        int count = 0;
        for (int i = 0; i < n; i++) {
            //at these indexes (i - 1) and i where the consecutivity breaks like
            //ab or ba do count++
            if (i > 0 && str.charAt(i - 1) != str.charAt(i)) {
                count++;
            }
        }
        //output
        System.out.println("Min steps required to make string empty: "
                + ((int) Math.ceil(count / 2.0) + 1));
    }

    public void minimizeMaxArray_Greedy(int[] nums) {
        //.....................T: O(N), N is length of the array
        //https://leetcode.com/problems/minimize-maximum-of-array/description/
        //https://leetcode.com/problems/minimize-maximum-of-array/editorial/
        //explanation: https://youtu.be/AeHMvcKuR0Y
        int n = nums.length;
        long minimizedMaxVal = 0;
        long prefixSum = 0;

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            //below expression (prefixSum + i) / (i + 1) is same as
            //Math.ceil(prefixSum / (i + 1))
            minimizedMaxVal = Math.max(minimizedMaxVal, (prefixSum + i) / (i + 1));
        }
        //output
        System.out.println("Minimized max value in array: " + minimizedMaxVal);
    }

    public void stringWithoutAAAOrBBB_Greedy(int a, int b) {
        //https://leetcode.com/problems/string-without-aaa-or-bbb/description/
        int[] freq = {a, b};
        char prevChar = '.';

        StringBuilder sb = new StringBuilder();

        while (true) {
            //default
            char currChar = '.';
            int currMaxFreq = 0;

            //choose a char which has a max freq and should also not be same as
            //prev char to prevent AAA or BBB
            for (char ch = 'a'; ch <= 'b'; ch++) {
                if (ch != prevChar && freq[ch - 'a'] > currMaxFreq) {
                    currMaxFreq = freq[ch - 'a'];
                    currChar = ch;
                }
            }

            if (currMaxFreq == 0) {
                break;
            }

            //we picked up this currChar having max freq as currMaxFreq so we
            //must reduce by 1 for choosing this char
            sb.append(currChar);
            freq[currChar - 'a']--;

            //here we need to check if we can take one more char of the same
            //currChar because we need to stop AAA or BBB that means we can have
            //atmost AA or BB
            if (currMaxFreq >= 2 && (prevChar == '.' || currMaxFreq > freq[prevChar - 'a'])) {
                sb.append(currChar);
                freq[currChar - 'a']--;
            }
            prevChar = currChar;
        }
        //output
        System.out.println("String without AAA or BBB: " + sb);
    }

    public void maxNumberOfMarkedIndices_Greedy(int[] nums) {
        //https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/description/
        /*
        nums[] = [9,2,5,4]
        sort() = [2,4,5,9]
        n = 4
        i = (n / 2) - 1 = 1
        j = n - 1 = 3
        count = 0

        #1 i = 1, j = 3
        2 * nums[1] <= nums[3] ==> 2 * 4 <= 9 OK
        ===>count += 2 (mark i & j) => 2
        ===>j-- => 2
        ==>i-- => 0

        #1 i = 0, j = 2
        2 * nums[0] <= nums[2] ==> 2 * 2 <= 5 OK
        ===>count += 2 (mark i & j) => 4
        ===>j-- => 1
        ==>i-- => -1

         */
        int n = nums.length;
        int i = (n / 2) - 1;
        int j = n - 1;
        int count = 0;

        Arrays.sort(nums);

        while (i >= 0) {

            if (2 * nums[i] <= nums[j]) {
                // +2 because at this point we are marking 2 indices i & j
                count += 2;
                //since we used index j need to move to next j-th index
                j--;
            }
            i--;
        }
        //output
        System.out.println("Find max number of marked indices : " + count);
    }

    public void dota2Senate_Greedy(String senate) {
        //........................T: O(N)
        //........................S: O(N)
        //https://leetcode.com/problems/dota2-senate/description/
        //explanation: https://youtu.be/zZA5KskfMuQ
        int n = senate.length();
        Queue<Integer> radiant = new LinkedList<>();
        Queue<Integer> dire = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            if (senate.charAt(i) == 'R') {
                radiant.add(i);
            } else {
                dire.add(i);
            }
        }

        while (!radiant.isEmpty() && !dire.isEmpty()) {

            int radiantIndex = radiant.poll();

            int direIndex = dire.poll();

            //whoever came earlier, gets to apply the rule on other
            if (radiantIndex < direIndex) {
                //radiant came first, so it cancels the right to vote for next
                //dire candidate.
                //but this radiant candidate needs to be there in count for next
                //round
                radiant.add(radiantIndex + n);
            } else {
                //dire came first, so it cancels the right to vote for next
                //radiant candidate.
                //but this dire candidate needs to be there in count for next
                //round
                dire.add(direIndex + n);
            }
        }
        //output
        //above loop will break when either radiant or dire party memeber loose
        //all the votes count
        //if there are voters left from radiant party only(== !radiant.isEmpty())
        //then radiant is the winner otherwise dire
        String winner = !radiant.isEmpty() ? "Radiant" : "Dire";
        System.out.println("Dota2 senate : " + winner);
    }

    public void minTimeToFillCups_Greedy(int[] amount) {
        //https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/description/
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        for (int val : amount) {
            if (val != 0) {
                maxHeap.add(val);
            }
        }

        int time = 0;
        //greedily pick 2 cups at a time to fill them until we are allowed to pick
        //2 cups
        while (maxHeap.size() >= 2) {
            time++;

            int cup1 = maxHeap.poll();
            int cup2 = maxHeap.poll();

            cup1--;
            if (cup1 > 0) {
                maxHeap.add(cup1);
            }

            cup2--;
            if (cup2 > 0) {
                maxHeap.add(cup2);
            }
        }
        //outpput
        //once there are just X amount of one-type of cups left then this X amount
        //of the cups in heap will be the amount of time in seconds required additionally
        //else if heap is empty that means we have successfully used all cups and no
        //additional time is required
        //time required
        time = time + (maxHeap.isEmpty() ? 0 : maxHeap.peek());
        System.out.println("Min time to fill the cups : " + time);
    }

    public void minElementsToAddToFormGivenSum_Greedy(int[] nums, int limit, int goal) {
        //https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/description/
        //convert the given int[] to long[] so the total sum of nums[] can be held
        long[] longArr = Arrays.stream(nums).mapToLong(val -> val).toArray();
        //sum up the value in longArr[]
        long arrSum = Arrays.stream(longArr).sum();
        //the diff between goal & curr arrSum is the sum needs to add to become 'goal'
        double requiredSumToAdd = Math.abs((long) goal - arrSum);
        //required sum / limit will give the no of new elements to add (where each
        //new elements should be less than equal to limit) this division can be fractional
        //so as we need a min no of elements, we need to ceil this divison
        int minCountOfElementsToInclude = (int) Math.ceil(requiredSumToAdd / (double) limit);
        //output
        System.out.println("Min elements to add to form a given sum : " + minCountOfElementsToInclude);
    }

    public void scoreForArrayAfterMarkingAllElements_Greedy(int[] nums) {
        //......................T: O(N * LogN), N is length of the nums[]
        //......................S: O(N), N is length of the marked[]
        //https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/
        int n = nums.length;
        boolean[] marked = new boolean[n];
        PriorityQueue<Integer> indexes = new PriorityQueue<>(
                //if two nums values are same then sort the indexes in incr order
                //else sort them in incr order of nums[i] value
                (a, b) -> nums[a] == nums[b]
                        ? Integer.compare(a, b)
                        : Integer.compare(nums[a], nums[b]));

        //put all the nums[] index in indexes heap
        for (int index = 0; index < n; index++) {
            indexes.add(index);
        }

        long score = 0;
        while (!indexes.isEmpty()) {
            //pick the index with the smallest value that is 'smallestValIndex'
            int smallestValIndex = indexes.poll();
            //if this smallestValIndex is already marked, we can't consider
            //this value in score hence continue
            if (marked[smallestValIndex]) {
                continue;
            }

            //mark this smallestValIndex as true
            marked[smallestValIndex] = true;

            //mark the adjacent left value(== that is (smallestValIndex - 1)) of
            //'smallestValIndex' as true
            if (smallestValIndex - 1 >= 0) {
                marked[smallestValIndex - 1] = true;
            }

            //mark the adjacent right value(== that is (smallestValIndex + 1)) of
            //'smallestValIndex' as true
            if (smallestValIndex + 1 < n) {
                marked[smallestValIndex + 1] = true;
            }

            //add the nums['smallestValIndex'] in our score
            score += nums[smallestValIndex];
        }
        //output
        System.out.println("Score of array after marking all elements : " + score);
    }

    public void addMinNumberOfRungs_Greedy(int[] rungs, int dist) {
        //https://leetcode.com/problems/add-minimum-number-of-rungs/description/
        /*
        intuition here is,
        initially we are standing at height = 0 ==> prevHeight = 0
        and from some prevHeight we need to cover a 'dist' and if there is
        prevHeight + dist >= rungs[i] then it is good we can atleast reach our
        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist]
        as prevHeight < rungs[i] <= (prevHeight + dist)

        BUT

        if our prevHeight + dist < rungs[i] we don't have much range to reach our
        rungs[i] so what we have to do is to add new rungs in between prevHeight
        and rungs[i] so to calculate that
        dest = rungs[i]
        src = prevHeight
        adjust = -1 "adjust", why?
        because, as we need to reach to dest from our src and we also know that
        we definitely have dest == rungs[i] available so we don't need to count
        the dest rungs but those required in between thats why!!!

        so with this we need to cover a 'total-length' of (dest - src - 1) between src & dest
        so how many rungs would be reuired to cover this 'total-length' provided that we can
        move by dist 'dist', then rungs required would be ('total-length' / 'dist')

        hence, number of rungs required to add
        ==> addedRungs = ((dest - src - 1) / dist);
        ==> ((rungs[i] - prevHeight - 1) / dist)

         */
        int n = rungs.length;
        int prevHeight = 0;
        int addedRungs = 0;
        for (int i = 0; i < n; i++) {
            if (prevHeight + dist < rungs[i]) {
                addedRungs += ((rungs[i] - prevHeight - 1) / dist);
            }
            prevHeight = rungs[i];
        }
        //output
        System.out.println("Min numbers of rungs added to reach the last point : " + addedRungs);
    }

    public void maxPerformanceOfTeam_Greedy(int n, int k, int[] efficiency, int[] speed) {
        //https://leetcode.com/problems/maximum-performance-of-a-team/
        //explanation: https://youtu.be/Y7UTvogADH0
        class Engineer {

            int efficiency;
            int speed;

            public Engineer(int efficiency, int speed) {
                this.efficiency = efficiency;
                this.speed = speed;
            }

        }

        int mod = 1000000007;
        long maxPerformance = 0;
        long currSpeedSum = 0;
        PriorityQueue<Integer> minHeapSpeed = new PriorityQueue<>();
        List<Engineer> engineers = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            engineers.add(new Engineer(
                    efficiency[i],
                    speed[i]
            ));
        }

        //sort the engineers in descending order of their efficiency
        //because each time we need to take the min efficiency
        Collections.sort(engineers, (a, b) -> Integer.compare(b.efficiency, a.efficiency));

        for (Engineer engineer : engineers) {
            //since we are only choosing atmost k engineers and in below
            //line we are going to add in minHeapSpeed but before adding
            //check if the we already have added k enineers before, so
            //remove the min speed from heap and adjust the currSpeedSum
            if (minHeapSpeed.size() == k) {
                currSpeedSum -= minHeapSpeed.poll();
            }
            //from all the engieers choose atmost k engineers here
            minHeapSpeed.add(engineer.speed);
            currSpeedSum += engineer.speed;
            maxPerformance = Math.max(maxPerformance, (engineer.efficiency * currSpeedSum));
        }
        //output
        System.out.println("Max performance of team: " + (maxPerformance % mod));
    }

    public void maxPerformanceOfTeam_Greedy2(int n, int k, int[] efficiency, int[] speed) {
        //https://leetcode.com/problems/maximum-performance-of-a-team/
        //explanation: https://youtu.be/Y7UTvogADH0
        int mod = 1000000007;
        long maxPerformance = 0;
        long currSpeedSum = 0;

        int[][] pairs = new int[n][2];

        for (int i = 0; i < n; i++) {
            pairs[i] = new int[]{speed[i], efficiency[i]};
        }

        //sort pairs[][] in the decreasing order of the efficiency
        Arrays.sort(pairs, (a, b) -> Integer.compare(b[1], a[1]));

        PriorityQueue<Integer> minHeapSpeed = new PriorityQueue<>();

        int index = 0;
        for (; index < k; index++) {

            currSpeedSum += pairs[index][0];

            //add speed @index into minHeap
            minHeapSpeed.add(pairs[index][0]);

            //as we can choose 'at most k' different engineers out of the n
            //then we need to consider all the engineers also less then k
            maxPerformance = Math.max(maxPerformance, currSpeedSum * pairs[index][1]);
        }

        while (index < n) {

            currSpeedSum += pairs[index][0] - minHeapSpeed.poll();

            minHeapSpeed.add(pairs[index][0]);

            maxPerformance = Math.max(maxPerformance, currSpeedSum * pairs[index][1]);

            index++;
        }
        //output
        System.out.println("Max performance of team (Approach 2): " + (maxPerformance % mod));
    }

    public void maxSubsequenceScore_Greedy(int[] nums1, int[] nums2, int k) {
        //https://leetcode.com/problems/maximum-subsequence-score/description/
        //explanation: https://youtu.be/z9oUzKhEYJU | https://youtu.be/ax1DKi5lJwk
        //based on maxPerformanceOfTeam_Greedy2()
        /*

        ex: nums1[] = [1,3,3,2], nums2[] = [2,1,3,4], k = 3

        As per questions, we need to pick same k indices from both the arrays
        nums1 and nums2,

        k indices 'value' picked from nums1[] are to be added
        and
        k indices 'value' picked from nums2[], need to find min 'value' from all
        picked values

        hence our score will be sum(k-indices-nums1-value) * min(k-indices-nums2-value)
        and we need to max our score

        from the given ex: our result is 12
        as k = {0, 2, 3}
        then k-indices-values from nums1[] is {1, 3, 2} and from nums2[] is {2, 1, 4}
        score = sum({1,3,2}) * min({2,1,4}) ==> 6 * 2 ==> 12

        the DP solution to solve this will give TLE

        here is the Greedy intuition

        ==> make pair as pairs[][] of both nums1 and nums2 for the same i-th index
        pairs[i][0] = nums1, pairs[i][1] = nums2
        pairs[i][] = [|1|2|
                      |3|1|
                      |3|3|
                      |2|4|]

        ==> sort the pairs[][] in decreasing order of values in nums2
        pairs[i][] = [|2|4|
                      |3|3|
                      |1|2|
                      |3|1|]

        now consider the row = index = 0 as min value BUT keep in mind that, since
        pairs[][] is sorted in decr order so curr nums2 value @index is max value
        from rest other values of nums2 currently in pairs[][]
        4 > 3 > 2 > 1

        to understand better lets rearrange pairs[][]
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        @index = 0, condider min = 4, now we can't consider values on right because
        in that case our min value will change to 3 and so on but we still need to pick
        k indices and there are no further values to left of curr @index hence we can't
        pick min as 4 @index = 0

        ==> due to above reason, we will process first k value
        put first k nums1 values from pairs into minHeap
        also add first k nums1 values from pairs[][] into initial kSum

        during first k process we would have considered this,
        .............______|
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        .............------|

        i.e, |2|3|1|
             |4|3|2|

        here our very first k indices process will be
        maxSubseqScore = kSum * pairs[k - 1][1]; ==> 12
        ==> kSum = sum({2,3,1}) * min(4,3,2) = 6 * 2 = 12

        ==> later on we need to process the remaining values of our pair
        .............________|
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        .............--------|

        i.e, |2|3|1|3|
             |4|3|2|1|

        now here our min is shifted to nums2 value == 1
        but we need to adjust our kSum because we would have summed all the values
        i.e 2 + 3 + 1 + 3 but only need k value, so think here how can we make our
        curr kSum max by maintaining picking k-values thats greedy, just subtract
        the min nums1 value from kSum i.e, nums1 value 1
        for that reason minHeapNums1 is maintained to subtract the min nums1 value

         */
        int n = nums1.length;
        long currKSum = 0;
        long maxSubseqScore = 0;
        int[][] pairs = new int[n][2];

        int index = 0;
        for (; index < n; index++) {
            pairs[index] = new int[]{nums1[index], nums2[index]};
        }

        //sort the pairs[][] in decreasing order of nums2 added in pairs @index = 1
        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);

        PriorityQueue<Integer> minHeapNums1 = new PriorityQueue<>();

        //add the first k elements in minHeap and also take the sum of nums1 of
        //first k elements from pairs[][]
        index = 0;
        for (; index < k; index++) {
            currKSum += pairs[index][0];
            minHeapNums1.add(pairs[index][0]);
        }

        maxSubseqScore = currKSum * pairs[k - 1][1];

        while (index < n) {

            currKSum += pairs[index][0] - minHeapNums1.poll();

            minHeapNums1.add(pairs[index][0]);

            maxSubseqScore = Math.max(maxSubseqScore, currKSum * pairs[index][1]);

            index++;
        }
        //output
        System.out.println("Max subsequence score : " + maxSubseqScore);
    }

    public void maxSplitOfPositiveEvenIntegers_Greedy(long finalSum) {
        //https://leetcode.com/problems/maximum-split-of-positive-even-integers/description/
        List<Long> splitsEvenIntegers = new ArrayList<>();

        //if the given final sum is an odd value, then we can never split it with
        //even integers, print empty list
        if (finalSum % 2L == 1) {
            System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
            return;
        }

        long evenInteger = 2;

        //greedily reduce the final sum by positive even integer that is 'evenInteger'
        //also we need to take unique even integer so same 'evenInteger' should not be
        //used again hence 'evenInteger' should be increamented to next positive even
        //integer i.e, +2
        while ((finalSum - evenInteger) >= 0) {

            splitsEvenIntegers.add(evenInteger);

            finalSum -= evenInteger;

            evenInteger += 2;
        }

        //if on reducing the final sum by evenInteger our final sum becomes 0
        //print all the positive even integer we took to make it '0'
        if (finalSum == 0) {
            System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
            return;
        }

        //here final sum is not yet '0', then we will add the the remaining final sum
        //in the last value of 'splitsEvenInteger' list
        int size = splitsEvenIntegers.size();
        splitsEvenIntegers.set(size - 1, finalSum + splitsEvenIntegers.get(size - 1));

        System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
    }

    public void rearrangeArrayToMaxPrefixScore_Greedy(int[] nums) {
        //https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/description/
        //based on GREEDY, SORTING, PREFIX SUM
        int n = nums.length;
        //sort() will arrange the nums[] in increasing order so all the negatives
        //on left side and all positives on right side
        Arrays.sort(nums);
        //prefix sum can get big for int type so take long instead
        long prefixSum = 0;

        int countPositive = 0;

        //since nums[] is now sorted and all positives are in the right side
        //thats why we will start our prefix sum calculations from end of nums[]
        //Greedily we will add positive values and hence our positive prefixSum
        //magnitude increases at each i-th index, we can count positive value
        //at i-th index
        for (int i = n - 1; i >= 0; i--) {

            prefixSum += nums[i];

            countPositive += prefixSum > 0 ? 1 : 0;
        }
        //output
        System.out.println("Rearrange array to maximize prefix score : " + countPositive);
    }

    public String largestNumberAfterMutatingSubstring_Greedy(String num, int[] change) {
        //https://leetcode.com/problems/largest-number-after-mutating-substring/description/
        //based on GREEDY
        /*

        ex: num = "132", change = [9,8,5,0,3,6,4,2,6,8]

                digit      change-to   change[j]
                  0            ==>         9
        nums[0]   1            ==>         8
        nums[2]   2            ==>         5
        nums[1]   3            ==>         0
                  4            ==>         3
                  5            ==>         6
                  6            ==>         4
                  7            ==>         2
                  8            ==>         6
                  9            ==>         8

        output of above example is  "832"
        as digit = 1 in num change-to change[digit] = 8
        since we made a change hasMutatedOnce = true

        for digit = 3 in num change-to change[digit] = 0
        but here (digit > changeVal) ==> (3 > 0) so ideally we will not be
        making a change for this digit = 3 and should continue to some other
        digit in num for any possible change BUT see we have changed a substring
        of num that is ["1"] ==> "8" so we have already mutated a single substring
        and if there is any possibilty of further change in num that should not
        be done why?
        BECAUSE
        see this, when digit is 3, that becomes discontinuity for previous subtring
        we considered that is ["1"] ==> discontinuity "3" due to this discontinuity
        it breaks the previous substring (marked as 'hasMutatedOnce' = true) so
        whenever we see (digit > changeVal) we also need to check if we had made
        changes to any substring of num earlier or not,
        if YES ==> if(hasMutatedOnce) return whatever changes we made till here
        if NO ==> continue, continue in this case implies that we have not considered
        a substring before but there may be some substring after.

         */

        int n = num.length();

        char[] digits = num.toCharArray();
        boolean hasMutatedOnce = false;

        //loop over each i-th digit in num string
        for (int i = 0; i < n; i++) {

            int digit = digits[i] - '0';

            int changeVal = change[digit];

            //keep continue, if curr 'digit' and its change value is same
            if (digit == changeVal) {
                continue;
            }

            //if the curr i-th digit is already greater than its changeVal
            //then we have 2 things to take care of:
            if (digit > changeVal) {

                //1. if we made any changes previoulsy to a part of
                //substring of num (if hasMutatedOnce is true in this if())
                //then further we won't be making any change as we are
                //restricted to "mutate a single substring of num"
                if (hasMutatedOnce) {
                    return String.valueOf(digits);
                }

                //2. if no substring was considered previously for any change
                //then here also we can skip as there is no point in replacing
                //the curr 'digit' which is already greater than changeVal
                continue;
            }

            //this block here, changeVal > digit and we are considering
            //this as substring of num
            //set a greater value than i-th digit in num which is changeVal
            digits[i] = (char) (changeVal + '0');
            //in curr ongoing substring we made a change
            hasMutatedOnce = true;
        }
        return String.valueOf(digits);
    }

    public int ticketCounter_Greedy(int n, int k) {
        //https://practice.geeksforgeeks.org/problems/ticket-counter-2731/1
        int firstPerson = 1;
        int lastPerson = n;

        while (lastPerson > firstPerson) {

            //if we can't dequeue 'k' more people from front side of queue as it
            //will go beyond last person then last person is final person to be
            //dequeued from front side
            if (firstPerson + k >= lastPerson) {
                return lastPerson;
            }
            //if above if() is not valid then dequeue 'k' people from front side
            //of queue
            firstPerson += k;

            //if we can't dequeue 'k' more people from back side of queue as it
            //will go below first person then first person is final person to be
            //dequeued from back side
            if (lastPerson - k <= firstPerson) {
                return firstPerson;
            }
            //if above if() is not valid then dequeue 'k' people from back side
            //of queue
            lastPerson -= k;
        }
        return firstPerson;
    }

    public void minCostToMakeArrayEqual_Greedy(int[] nums, int[] cost) {
        //https://leetcode.com/problems/minimum-cost-to-make-array-equal/description/
        /*

        nums[] = [1,3,5,2], cost[] = [2,3,1,14]
        pairs[] = [[1,2], [3,3], [5,1], [2,14]]

        sort(pairs, (nums)) = [[1,2], [2,14], [3,3], [5,1]]

        prefixCostArr = [2,16,19,20]
        prefixCostTotal = 20

        //since pairs[] is sorted on nums[i] so for making all nums[1 to n - 1] reach down to nums[0]
        //will take the max cost
        maxCost = 0;

        for i = 1 i < n
        maxCost += (pairs[i][0] - pairs[0][0]) * pairs[i][1];

        maxCost += (2 - 1) * 14 = 0 + 14
        maxCost += (3 - 1) * 3 = 14 + (6) = 20
        maxCost += (5 - 1) * 1 = 20 + (4) = 24

        result = maxCost = 24

        //try to minimize this maxCost by considering each nums[i to n - 1] as base num that
        //we can reduce other nums[i] to
        for i = 1 i < n
        gap = pairs[i][0] - pairs[i - 1][0]
        maxCost += prefixCostArr[i - 1] * gap
        maxCost -= (prefixCostTotal - prefixCostArr[i - 1]) * gap

        result = min(result, maxCost);

        //iterations
        initial
        pairs[] = [[1,2], [2,14], [3,3], [5,1]]
        prefixCostArr = [2,16,19,20]
        prefixCostTotal = 20


        1. i = 1
        gap = 2 - 1 = 1
        maxCost += gap * prefixCostArr[i - 1] = 1 * 2 = 2 ==> 24 + 2 = 26
        maxCost -= gap * (prefixCostTotal - prefixCostArr[i - 1]) = 1 * (20 - 2) = 18 ==> 26 - 18 = 8
        result = min(24, 8) = 8

        2. i = 2
        gap = 3 - 2 = 1
        maxCost += gap * prefixCostArr[i - 1] = 1 * 16 = 16 ==> 8 + 16 = 24
        maxCost -= gap * (prefixCostTotal - prefixCostArr[i - 1]) = 1 * (20 - 16) = 4 ==> 24 - 4 = 20
        result = min(8, 20) = 8

        2. i = 3
        gap = 5 - 3 = 2
        maxCost += gap * prefixCostArr[i - 1] = 2 * 19 = 38 ==> 20 + 38 = 58
        maxCost -= gap * (prefixCostTotal - prefixCostArr[i - 1]) = 2 * (20 - 19) = 2 ==> 58 - 2 = 56
        result = min(8, 56) = 8
        ......END.....

        result = 8

         */
        int n = nums.length;
        long[][] pairs = new long[n][2];

        for (int i = 0; i < n; i++) {
            pairs[i] = new long[]{nums[i], cost[i]};
        }

        Arrays.sort(pairs, (a, b) -> (int) (a[0] - b[0]));

        long[] prefixCostSumArr = new long[n];
        long prefixCostTotal = 0;
        for (int i = 0; i < n; i++) {
            prefixCostTotal += pairs[i][1];
            prefixCostSumArr[i] = prefixCostTotal;
        }

        long minCost = 0l;

        //initial attempt, if we choose nums[0] as base value and try to convert
        //all other nums[1 to n - 1] value to match as nums[0]
        long maxCost = 0l;
        for (int i = 1; i < n; i++) {
            //steps to convert nums[i] value equals to nums[0] ==> diff of (nums[i] - nums[0])
            //cost of converting ==> steps * cost[i]
            //==> (nums[i] - nums[0]) * cost[i]
            maxCost += (pairs[i][0] - pairs[0][0]) * pairs[i][1];
        }

        minCost = maxCost;

        //from this loop we will try to choose each nums[i] as base value and try
        //to minimize the maxCost, in this process we will find 'gap' between
        //nums[i - 1] & nums[i], now this gap is actually the amount of cost increased
        //in the prefix side of nums[i] and amount of cost decreased in the suffix side
        //of the nums[i]
        for (int i = 1; i < n; i++) {

            long gap = pairs[i][0] - pairs[i - 1][0];

            maxCost += prefixCostSumArr[i - 1] * gap;

            maxCost -= (prefixCostTotal - prefixCostSumArr[i - 1]) * gap;

            minCost = Math.min(minCost, maxCost);
        }
        //output
        System.out.println("Min cost to make array equal (Greedy approach): " + minCost);
    }

    public void putMarblesInBag_Greedy(int[] weights, int bags) {
        //https://leetcode.com/problems/put-marbles-in-bags/description/
        //explanation: https://youtu.be/L-KWU8W3OqE
        /*
        how this logic works?

        weights[] = [1,3,5,1], k = 2

        we have k bags and we have to put some subarrays in either bags
        and no single bag will be empty so each bag should have atleast one
        element.

        score of each bag is the sum of first & last weight in that bag

        score of bag1 = (w1,w2...wx) = w1 + wx
        score of bag2 = (w3,w4...wy) = w3 + wy

        AND

        score of each possible partitions is sum of scores of each bag

        partition score = score of bag1 + score of bag2

        All the possible ways of partitioning some subarrays into k bags & as
        we have k bags then there will be only k - 1 splitting

        1. [1] | [3,5,1]
        score of bag k = 1 ==> [1] first & last weight is 1 only (1 + 1)
        score of bag k = 2 ==> [3, 5, 1] first & last weight is 3 & 1 (3 + 1)
        score of curr partition ==> (1 + 1) + (3 + 1) = 6

        2. [1,3] | [5,1]
        score of bag k = 1 ==> [1,3] first & last weight is 1 & 3 (1 + 3)
        score of bag k = 2 ==> [5, 1] first & last weight is 5 & 1 (5 + 1)
        score of curr partition ==> (1 + 3) + (5 + 1) = 10

        3. [1,3,5] | [1]
        score of bag k = 1 ==> [1,3,5] first & last weight is 1 & 5 (1 + 5)
        score of bag k = 2 ==> [1] first & last weight is 1 only (1 + 1)
        score of curr partition ==> (1 + 5) + (1 + 1) = 8

        now acc to question, out of all the possibilties, we got some score of
        partitions calculated above, now from all those partitions we have one
        maxScore(10) and one minScore(6), result is diff of maxScore and minScore

        ==> 10 - 6 = 4
        ==> ((1 + 3) + (5 + 1)) - ((1 + 1) + (3 + 1)) = 4
        ==> 1 + 3 + 5 + 1 - 1 - 1 - 3 - 1 = 4
        ==> 3 + 5 - 1 - 3 = 5
        ==> (3 + 5) - (1 + 3) = 4

        observation here is,
        for each score of partition, starting and ending values will always
        remain constant

        here starting constant values is represented in []
        (([1] + 3) + (5 + 1)), (([1] + 1) + (3 + 1))

        here ending constant values is represented in []
        ((1 + 3) + (5 + [1])),  ((1 + 1) + (3 + [1]))

        these starting & ending values are actually weights[0] & weights[n - 1]

        in any partitions these constants can be ignored, so after ignoring them
        1. (1 + 1) + (3 + 1) = 6
        ==> (weights[0] + 1) + (3 + weights[n - 1])
        ==> ............|_________|
        ==> 1 + 3 = 4 ==> 'min' score adjusted

        2. (1 + 3) + (5 + 1) = 10
        ==> (weights[0] + 3) + (5 + weights[n - 1])
        ==> ............|_________|
        ==> 3 + 5 = 8 ==> 'max' score adjusted

        3. (1 + 5) + (1 + 1) = 8
        ==> (weights[0] + 5) + (1 + weights[n - 1])
        ==> ............|_________|
        ==> 5 + 1 = 6 ==> score adjusted

        now that we have ignored these weights[0] & weights[n - 1] from all the
        partitions our scores are adjusted, see above

        BUT

        still overall result will remain same as weights[0] & weights[n - 1]
        were common in possible partitions,
        hence result = maxScore - minScore = 8 - 4 = 4

        now another observation from above adjusted score is
        1. 1 + 3 ==> split between 1 | 3
        2. 3 + 5 ==> split between 3 | 5
        3. 5 + 1 ==> split between 5 | 1

        in given weights[] = [1,3,5,1]
        above combinations are actually consecutive element pair sum
        i.e, pairWeight[i] = weights[i] + weights[i + 1]

        hence pairWeight[] will be of n - 1 size as pairs will be always (n - 1)
        for n array elements
        pairWeight[0] = 1 + 3 = 4
        pairWeight[1] = 3 + 5 = 8
        pairWeight[2] = 5 + 1 = 6

        as we just want maxScore and minScore of all possible partitions then we
        can simply sort this pairWeight[]
        ==> [4, 6, 8]

        now each value in this pairWeight[] i.e, pairWeight[i] represents score
        of partition after a split made in i-th partition in pairWeight[]

         */
        int n = weights.length;
        int[] pairWeight = new int[n - 1];

        for (int i = 0; i < n - 1; i++) {
            pairWeight[i] = weights[i] + weights[i + 1];
        }

        Arrays.sort(pairWeight);

        long result = 0L;

        //also ==> n - 1
        int pairWeightLen = pairWeight.length;

        for (int i = 0; i < bags - 1; i++) {
            result += pairWeight[pairWeightLen - i - 1] - pairWeight[i];
        }

        //output
        System.out.println("Put marbles in bags : " + result);
    }

    public void maxNumberOfEventsThatCanBeAttended_Greedy(int[][] events) {
        //https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/
        int n = events.length;
        //as per the constraints
        int MAX_DAYS = 100000;

        //sort the events[][] in incr order of start day
        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));

        //create a min heap of end days, that will simulate as if events ending
        //earlier will have end day on top of min heap and events ending later
        //will be on bottom of min heap
        PriorityQueue<Integer> minHeapEndDay = new PriorityQueue<>();

        int countEvents = 0;
        int index = 0;

        //loop through all the possible days
        for (int day = 1; day <= MAX_DAYS; day++) {

            //if min heap has an end day which is smaller than the curr 'day' means
            //this event has ended now, so remove that event
            while (!minHeapEndDay.isEmpty() && minHeapEndDay.peek() < day) {
                minHeapEndDay.poll();
            }

            //if we have events starting on same day as of curr 'day' then we will
            //add their event's end day in min heap, this simulates that an event
            //has satrted on 'day' and will be in continuation via min heap
            while (index < n && events[index][0] == day) {
                minHeapEndDay.add(events[index++][1]);
            }

            //if we still have some events in min heap, that will mean these events
            //are still in process/attending state, hence countEvents should be
            //increamented and at the same time we can say, we attended an event
            //that will end as early as 'minHeapEndDay' root/peek day value so
            //remove this event now
            if (!minHeapEndDay.isEmpty()) {
                minHeapEndDay.poll();
                countEvents++;
            }
        }
        //output
        System.out.println("Max number of events that can be attended : " + countEvents);
    }

    public void wiggleSortTwo_Greedy(int[] nums) {
        //https://leetcode.com/problems/wiggle-sort/submissions/
        //https://leetcode.com/problems/wiggle-sort-ii/description/
        int n = nums.length;

        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
                (a, b) -> Integer.compare(b, a));

        for (int val : nums) {
            maxHeap.add(val);
        }

        //fill up all the max values at odd-index
        for (int i = 1; i < n; i += 2) {
            nums[i] = maxHeap.poll();
        }

        //fill up all the other values at even-index
        for (int i = 0; i < n; i += 2) {
            nums[i] = maxHeap.poll();
        }

        //output
        System.out.println("Wiggle sort two : " + Arrays.toString(nums));
    }

    public int partitionIntoSubstringWithValueAtmostK_Greedy(String nums, int k) {
        //https://leetcode.com/problems/partition-string-into-substrings-with-values-at-most-k/description/
        //based on GREEDY, optimalStringPartitions()
        int n = nums.length();

        int countSubstringPartitions = 0;

        long num = 0;

        for (char digit : nums.toCharArray()) {

            //keep forming a number 'num' GREEDILY using the digits in nums str
            num = num * 10 + (digit - '0');

            //as soon as we reach 'num' greater than k, meaning the curr addition
            //of 'digit' into 'num' has made it a bigger number than k which
            //also means just before adding the curr 'digit', this 'num' was less
            //or equal to k, hence we can count partition when a 'num' > k
            if (num > k) {

                //count the partition as we know just before adding curr 'digit'
                //to 'num', we have num <= k
                countSubstringPartitions++;

                //start the next substring number from curr 'digit' itself
                num = (digit - '0');

                //a case where the single digit is greater than the given k
                //ex: digit = '8' but k = 5
                //so nums = "123458" partitons = "1", "2", "3", "4", "5", "8"
                //And see all other substring partitions are less or equal k
                //{"1", "2", "3", "4", "5"} <= k
                //BUT "8" a single digit itself which is greater than k hence
                //the last substring can't be a valid partiton, return -1
                if (num > k) {
                    return -1;
                }
            }
        }

        //count the very last segment of 'num' partiton formed above but for()
        //ended and could not be counted
        //note : as per question, we are given that the digits in string nums
        //will only be [1 to 9] meaning no 0, that means we will never have a
        //case when last segment 'num' is 0 it will always be (num > 0) so we
        //can simply count that last 'num' segment
        countSubstringPartitions++;

        //countSubstringPartitions is still 0 means no valid partitons found
        //return -1 otherwise, countSubstringPartitions
        return countSubstringPartitions == 0 ? -1 : countSubstringPartitions;
    }

    public int latestTimeToCatchBus_Greedy(int[] buses, int[] passengers, int capacity) {
        //https://leetcode.com/problems/the-latest-time-to-catch-a-bus/description/
        int n = buses.length;
        int m = passengers.length;

        Arrays.sort(buses);
        Arrays.sort(passengers);

        if (passengers[0] > buses[n - 1]) {
            return buses[n - 1];
        }

        int index = 0;

        int latestArrivalTime = passengers[0] - 1;

        for (int i = 0; i < n; i++) {

            int availableSeats = capacity;

            while (availableSeats > 0 && index < m && passengers[index] <= buses[i]) {

                if (index > 0 && Math.abs(passengers[index - 1] - passengers[index]) != 1) {

                    latestArrivalTime = passengers[index] - 1;
                }

                index++;

                availableSeats--;
            }

            if (availableSeats > 0 && index > 0 && passengers[index - 1] != buses[i]) {
                latestArrivalTime = buses[i];
            }
        }

        return latestArrivalTime;
    }

    public void maxNumberOfCoinsYouCanGet_Greedy(int[] piles) {
        //https://leetcode.com/problems/maximum-number-of-coins-you-can-get/description/
        int n = piles.length;

        //as given, turns are in order 1. alice, 2. you, 3. bob
        //as seen alice will have upper hand to pick max pile
        //of coins, so you need to pick second max pile of coins
        //and bob will pick last in turn so he will take the min,
        //sorting the piles[] will help 'you' getting max pile
        //of coins after alice but before bob
        Arrays.sort(piles);

        int you = n - 1;
        int bob = 0;

        int yourScore = 0;

        while (you > bob) {

            //'you' are currently standing at alice pick index
            //so 'you' can't pick coins from her turn
            //so 'you' move to your turn that is after alice
            you -= 1;

            yourScore += piles[you];

            //as 'you' have picked coins on your turn @you index
            //so 'you' move to next pile index(ideally, after 'you'
            //& 'bob' turn, it will again be alice's turn that is
            //handled above (you -= 1))
            you -= 1;

            //as bob will pick coins after alice & 'you'
            //so greedily he is left to pick the smallest
            //pile of coins, that is picked @bob index so
            //bob also moved to next index
            bob += 1;
        }

        //output
        System.out.println("Max number of coins you can pick : " + yourScore);
    }

    public void removingMinNumberOfMagicBeans_Greedy(int[] beans) {
        //https://leetcode.com/problems/removing-minimum-number-of-magic-beans/description/
        int n = beans.length;

        Arrays.sort(beans);

        long totalBeans = 0;

        for (long bean : beans) {
            totalBeans += bean;
        }

        long minRemoval = Long.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            minRemoval = Math.min(minRemoval, totalBeans - ((n - i) * (long) beans[i]));
        }

        //output
        System.out.println("Removing min number of magic beans : " + minRemoval);
    }

    public void minReplacementsToSortTheArray_Greedy(int[] nums) {
        //https://leetcode.com/problems/minimum-replacements-to-sort-the-array/description/
        //explanation: https://youtu.be/2nRXvlxkU2Y?si=fpfTFLvBrCM4Vdfz
        int n = nums.length;

        long oprns = 0;

        for (int i = n - 2; i >= 0; i--) {

            int currNum = nums[i];
            int nextNum = nums[i + 1];

            //skip, if curr i-th val and its next (i + 1)-th val are
            //already in non-decr order (==> 4 <= 5 or 4 <= 4)
            if (currNum <= nextNum) {
                continue;
            }

            //ex: currNum = 11, nextNum = 3
            //number of splits = 11 / 3 ==> 3 remainder is 2
            //this means that 3 can't fully divide number 11 as remainder is 2
            //==> {3, 3, 3} & 2 ==> 3 + 3 + 3 + 2 ==> 11
            //how the split will happen acc to question?
            //11 ==> oprn-1 ==> {2, 9}
            //11 ==> oprn-2 ==> {2, 3, 6}
            //11 ==> oprn-3 ==> {2, 3, 3, 3}
            //observation here is, oprns required to split curr num is equal to
            //number of split made on currNum -1
            //as compared to, if currNum = 12, nextNum = 3
            //number of splits = 12 / 3 ==> 4 remainder is 0 ==> {3, 3, 3, 3}
            long numberOfSplits = (long) currNum / (long) nextNum;

            //so whenever there is a case where nextNum is not fully dividiing
            //currNum there will be 1 extra split also required
            if (currNum % nextNum != 0) {
                numberOfSplits += 1;
            }

            //as seen above, oprns = number of splits made on currNum -1
            oprns += (numberOfSplits - 1);

            //here, if we are splitting a num, it should be optimal for all other
            //number in order to minimize the oprns taken
            //ex: nums[] = [9, 7, 6]
            //various possible splits on 7
            //1. ==> {1, 6} ==> [9, 1, 6, 6] ==> [1, 6, 6] are already non-decr
            //but in this case 9 will also required to be splitted based on its
            //nextNum == 1, in this case, split on 9 ==> {1,1,1,1,1,1,1,1,1}
            //oprns on 7 = splits - 1 ==> 2 - 1 ==> 1
            //oprns on 9 = splits - 1 ==> 9 - 1 ==> 8
            //total ==> 1 + 8 = 9
            //2. ==> {2, 5} ==> [9, 2, 5, 6] ==> [2, 5, 6] are already non-decr
            //but in this case 9 will also required to be splitted based on its
            //nextNum == 2, in this case, split on 9 ==> {1,1,1,1,1,1,1,2}
            //oprns on 7 = splits - 1 ==> 2 - 1 ==> 1
            //oprns on 9 = splits - 1 ==> 8 - 1 ==> 7
            //total ==> 1 + 7 = 8
            //3. ==> {3, 4} ==> [9, 3, 4, 6] ==> [3, 4, 6] are already non-decr
            //but in this case 9 will also required to be splitted based on its
            //nextNum == 3, in this case, split on 9 ==> {3,3,3}
            //oprns on 7 = splits - 1 ==> 2 - 1 ==> 1
            //oprns on 9 = splits - 1 ==> 3 - 1 ==> 2
            //total ==> 1 + 2 = 3
            //out of all possible splits for num = 7 the most optimal oprns will
            //be when we split 7 = {3, 4}, in that case 9 will split {3, 3, 3}
            //and oprns will be minimized as required
            //how we can get this split value?
            //observation here is, optimal split on 9 depends on the (i + 1)-th
            //value so when we splitted 7 = {3, 4}, '3' will be become the nextNum
            //value for '9', to get that nums[i] / numberOfsplits ==> 7 / 2 ==> 3
            nums[i] /= (int) numberOfSplits;
        }

        //output
        System.out.println("Min Replacement to sort the array : " + oprns);
    }

    public int minNumberOfTapsToOpenToWaterGarden_Greedy(int n, int[] ranges) {
        //https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/
        int[] maxEndCovered = new int[n + 1];

        for (int i = 0; i <= n; i++) {

            int start = Math.max(0, i - ranges[i]);
            int end = Math.min(n, i + ranges[i]);

            maxEndCovered[start] = Math.max(maxEndCovered[start], end);
        }

        int taps = 0;
        int farthestReachableEnd = 0;
        int mediateReachableEnd = 0;

        for (int start = 0; start <= n; start++) {

            //return -1 as we can not water the whole garden as farthest range
            //for prev tap ended before the curr start meaning the dist between
            //farthestReachableEnd & start is not covered
            if (farthestReachableEnd < start) {
                return -1;
            }

            //if the start reached the prev tap's end range ==> mediateReachableEnd
            //mean from this point we need to start another tap and curr farthest
            //reachable end will become next mediate reachable end
            if (mediateReachableEnd < start) {
                taps++;
                mediateReachableEnd = farthestReachableEnd;
            }

            //choose the next farthest reachable end from curr start
            farthestReachableEnd = Math.max(farthestReachableEnd, maxEndCovered[start]);
        }

        return taps;
    }

    public void minDeletionsToMakeCharFreqUnique_Greedy(String str) {
        //https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/description/
        /*

        ex: str = "aaabbbccc"

        as per question, we need min deletions so that each char in str will have
        unique freqs

        current freqs = {a = 3, b = 3, c = 3} ==> freqs[26] = [3, 3, 3, ... 0]

        sort(freqs[26]) ==> [0, 0, 0, ... 3, 3, 3]

        maxAllowed = n ==> 9
        deletions = 0;

        iterations:

        #1.
        index = 25 >= 0 && freqs[index] > 0 ==> (25 >= 0 && 3 > 0) ==> TRUE

        if(freqs[25] > maxAllowed) ==> (3 > 9) ==> FALSE

        //as curr index has freqs of 3, inorder for the next next char to have
        //unique freq it should have 1 freq number less than the curr index
        //i.e, greedily
        maxAllowed = Math.max(0, freqs[25] - 1) ==> max(0, 3 - 1) ==> 2

        #2.
        index = 24 >= 0 && freqs[index] > 0 ==> (24 >= 0 && 3 > 0) ==> TRUE

        //here, curr index == 24 need to have freqs 2 because its prev char freq
        //at index == 25 has freq of 3 BUT we found the freqs[24] to 3 so extra
        //chars must be deleted so that freq of char at index == 24 is 2
        //==> freqs[24] - maxAllowed
        //once the extra chars are deleted, freqs[index] will be exactly what is
        //allowed ==> freqs[index] = maxAllowed

        if(freqs[24] > maxAllowed) ==> (3 > 2) ==> TRUE
        ==> deletion += freqs[24] - maxAllowed ==> 0 + (3 - 2) ==> 0 + 1
        ==> freqs[24] = maxAllowed ==> 2

        maxAllowed = Math.max(0, freqs[24] - 1) ==> max(0, 2 - 1) ==> 1

        #3.
        index = 23 >= 0 && freqs[index] > 0 ==> (23 >= 0 && 3 > 0) ==> TRUE

        //here, curr index == 23 need to have freqs 1 because its prev char freq
        //at index == 24 has freq of 2 BUT we found the freqs[23] to 3 so extra
        //chars must be deleted so that freq of char at index == 23 is 1
        //==> freqs[23] - maxAllowed
        //once the extra chars are deleted, freqs[index] will be exactly what is
        //allowed ==> freqs[index] = maxAllowed

        if(freqs[23] > maxAllowed) ==> (3 > 1) ==> TRUE
        ==> deletion += freqs[23] - maxAllowed ==> 1 + (3 - 1) ==> 3
        ==> freqs[23] = maxAllowed ==> 1

        maxAllowed = Math.max(0, freqs[23] - 1) ==> max(0, 1 - 1) ==> 0

        #4.
        index = 22 >= 0 && freqs[index] > 0 ==> (22 >= 0 && 0 > 0) ==> FALSE

        ...END..

         */
        int n = str.length();
        int[] freqs = new int[26];

        for (char chr : str.toCharArray()) {
            freqs[chr - 'a']++;
        }

        //initially, any i-th char can have a char freq 'atmost n'
        int maxAllowedFreqs = n;
        int deletions = 0;

        //sort the freqs of each char, such that larger freqs number moved to
        //right-side of the array
        Arrays.sort(freqs);

        //starting loop from right-side of freqs array i.e, index = 25 so that
        //we can traget max freqs number from the right-side
        for (int index = 25; index >= 0 && freqs[index] > 0; index--) {

            //right now, we are assuming curr i-th char need to have 'maxAllowedFreqs'
            //but we have a max freqs freqs[index] is more than 'maxAllowedFreqs'
            //means there are few extra freqs that we must delete
            if (freqs[index] > maxAllowedFreqs) {

                //delete those extra freqs from what we have currently freqs[index]
                //and what is required 'maxAllowedFreqs'
                deletions += freqs[index] - maxAllowedFreqs;
                //after deleting those extra chars above, freqs[index] is now
                //same as 'maxAllowedFreqs'
                freqs[index] = maxAllowedFreqs;
            }

            //here, choose the max allowed freqs for the next i-th char which
            //should be 1 less the freqs req at curr i-th char
            maxAllowedFreqs = Math.max(0, freqs[index] - 1);
        }

        //output
        System.out.println("Min deletions to make char freqs unique : " + deletions);
    }

    public void removeColoredPiecesIfNeighboursAreSame_Greedy(String colors) {
        //https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/description/
        int n = colors.length();

        int aliceScore = 0;
        int consecutiveAColorCount = 0;

        for (int i = 0; i < n; i++) {

            //count the consecutive 'A' colors
            if (i == 0 || colors.charAt(i - 1) == colors.charAt(i)
                    && colors.charAt(i) == 'A') {

                consecutiveAColorCount++;

            } else {
                //if there is a discontinuity in consecutive 'A', we must calculate
                //alice's score from these 'A's
                //why -2?
                //because as per the game's rule 'A' at the edges can't be removed
                //ex: if color pattern is like this "A", "AA", 'A' can't be removed
                //because "A" ==> 1 -2 == -1 OR "AA" ==> 2 -2 == 0
                //that's why keeping max(0) for this as well
                //otherwise color pattern is like this "AAA", "AAAAA" we can only
                //remove 'A' in between the two outer edges 'A' means we can never
                //remove extreme-left & extreme-right 'A', means the (total
                //count of consecutive 'A' -2)
                aliceScore += Math.max(0, consecutiveAColorCount - 2);
                consecutiveAColorCount = 1;
            }
        }

        //check if the some consecutive 'A' left at the last section of color str
        //which will be missed by above loop's else{}
        aliceScore += Math.max(0, consecutiveAColorCount - 2);

        int bobScore = 0;
        int consecutiveBColorCount = 0;

        for (int i = 0; i < n; i++) {

            //count the consecutive 'A' colors
            if (i == 0 || colors.charAt(i - 1) == colors.charAt(i)
                    && colors.charAt(i) == 'B') {

                consecutiveBColorCount++;

            } else {
                //if there is a discontinuity in consecutive 'B', we must calculate
                //bob's score from these 'B's
                //why -2?
                //because as per the game's rule 'B' at the edges can't be removed
                //ex: if color pattern is like this "B", "BB", 'B' can't be removed
                //because "B" ==> 1 -2 == -1 OR "BB" ==> 2 -2 == 0
                //that's why keeping max(0) for this as well
                //otherwise color pattern is like this "BBB", "BBBBB" we can only
                //remove 'B' in between the two outer edges 'B' means we can never
                //remove extreme-left & extreme-right 'B', means the (total
                //count of consecutive 'B' -2)
                bobScore += Math.max(0, consecutiveBColorCount - 2);
                consecutiveBColorCount = 1;
            }
        }

        //check if the some consecutive 'B' left at the last section of color str
        //which will be missed by above loop's else{}
        bobScore += Math.max(0, consecutiveBColorCount - 2);

        boolean isAliceWinner = aliceScore > bobScore;

        System.out.println("Is alice winner : " + isAliceWinner);
    }

    public void graphBFSAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        System.out.println("Actual graph : ");
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<Integer> result = new ArrayList<>();

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;

        queue.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!queue.isEmpty()) {

            int node = queue.poll();

            result.add(node);

            List<Integer> childrens = adjList.get(node);

            if (childrens == null || childrens.isEmpty()) {
                continue;
            }

            for (int childVertex : childrens) {

                if (visited[childVertex]) {
                    continue;
                }
                queue.add(childVertex);
                visited[childVertex] = true;
            }
        }

        //output:
        System.out.println("BFS of graph: " + result);
    }

    public void graphBFSLevelOrderAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        System.out.println("Actual graph : ");
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<List<Integer>> result = new ArrayList<>();

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;

        queue.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!queue.isEmpty()) {

            int size = queue.size();
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                int node = queue.poll();

                level.add(node);
                List<Integer> childrens = adjList.get(node);

                if (childrens == null || childrens.isEmpty()) {
                    continue;
                }

                for (int childVertex : childrens) {

                    if (visited[childVertex]) {
                        continue;
                    }
                    queue.add(childVertex);
                    visited[childVertex] = true;
                }
            }
            result.add(level);
        }

        //output:
        System.out.println("BFS level order of graph: " + result);
    }

    public void graphDFSAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<Integer> result = new ArrayList<>();

        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;
        stack.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!stack.isEmpty()) {

            int node = stack.pop();

            result.add(node);

            List<Integer> childrens = adjList.get(node);

            if (childrens == null || childrens.isEmpty()) {
                continue;
            }

            for (int childVertex : childrens) {
                if (visited[childVertex]) {
                    continue;
                }
                stack.push(childVertex);
                visited[childVertex] = true;
            }
        }

        //output:
        System.out.println("DFS of graph: " + result);
    }

    private void graphDFSAdjList_Recursive_Helper(List<List<Integer>> adjList, int vertex,
                                                  boolean[] visited, List<Integer> result) {

        visited[vertex] = true;
        result.add(vertex);
        List<Integer> childrens = adjList.get(vertex);
        for (int childVertex : childrens) {
            if (visited[childVertex] != true) {
                graphDFSAdjList_Recursive_Helper(adjList, childVertex, visited, result);
            }
        }
    }

    public void graphDFSAdjList_Recursive_Graph(int V, List<List<Integer>> adjList) {
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[V];
        int sourceVertex = 0; //source point
        graphDFSAdjList_Recursive_Helper(adjList, sourceVertex, visited, result);
        System.out.println("DFS using recursion: " + result);
    }

    private void findPathRatInMaze_Helper(int[][] m, int n, int x, int y,
                                          StringBuilder sb, ArrayList<String> output) {

        if (x < 0 || x >= n || y < 0 || y >= n || m[x][y] == 0) {
            return;
        }

        if (x == n - 1 && y == n - 1 && m[x][y] == 1) {
            output.add(sb.toString());
            return;
        }

        int original = m[x][y];
        m[x][y] = 0;

        //Down
        sb.append("D");
        findPathRatInMaze_Helper(m, n, x + 1, y, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Right
        sb.append("R");
        findPathRatInMaze_Helper(m, n, x, y + 1, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Left
        sb.append("L");
        findPathRatInMaze_Helper(m, n, x, y - 1, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Up
        sb.append("U");
        findPathRatInMaze_Helper(m, n, x - 1, y, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        m[x][y] = original;
    }

    public void findPathRatInMaze_Graph(int[][] m, int n) {
        ArrayList<String> output = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        findPathRatInMaze_Helper(m, n, 0, 0, sb, output);
        System.out.println("All possible paths: " + output);
    }

    private void numberOfIslands_Helper(int[][] grid, int row, int col,
                                        int[][] dirs) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //return, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return;
        }

        //return, if curr row & col doesn't have the land cell (==> 1)
        if (grid[row][col] == 0) {
            return;
        }

        //mark the curr land cell @(row, col) as visited by converting it into
        //an empty cell, also preventing visiting same (row, col) again & again
        grid[row][col] = 0;

        for (int[] dir : dirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];

            numberOfIslands_Helper(grid, newRow, newCol, dirs);
        }
    }

    public void numberOfIslands_Graph(int[][] grid) {
        //https://leetcode.com/problems/number-of-islands
        //https://leetcode.com/problems/battleships-in-a-board/
        //https://leetcode.com/problems/max-area-of-island/
        //based on above max-area-of-islands //https://leetcode.com/problems/number-of-enclaves/

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dir = {
                {-1, -1},
                {-1, 0},
                {-1, 1},
                {0, -1},
                {0, 1},
                {1, -1},
                {1, 0},
                {1, 1}
        };

        int islandCount = 0;

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {

                if (grid[row][col] == 1) {
                    islandCount++;
                    numberOfIslands_Helper(grid, row, col, dir);
                }
            }
        }

        System.out.println("Number of separated islands: " + islandCount);
    }

    public void numberOfClosedIslands_Graph(int[][] grid) {
        //https://leetcode.com/problems/number-of-closed-islands/description/
        //based on DFS, numberOfIslands_Graph() and surroundedRegions_Graph()
        int ROW = grid.length;
        int COL = grid[0].length;

        int LAND = 0;
        int REMOVE_LAND = -1;
        int VISITED_LAND = 2;

        int TOP_BOUNDARY = 0;
        int BOTTOM_BOUNDARY = ROW - 1;
        int LEFT_BOUNDARY = 0;
        int RIGHT_BOUNDARY = COL - 1;

        //both removeLandAtBoundary() & numberOfCLosedIslands() below
        //are DFS methods & doing the same things but just for clarity and
        //readbiltiy, made 2 separate methods here
        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void removeLandAtBoundary(int[][] grid, int row, int col) {
                if (isOutOfBounds(row, col) || grid[row][col] != LAND) {
                    return;
                }

                grid[row][col] = REMOVE_LAND;

                removeLandAtBoundary(grid, row - 1, col);
                removeLandAtBoundary(grid, row + 1, col);
                removeLandAtBoundary(grid, row, col - 1);
                removeLandAtBoundary(grid, row, col + 1);
            }

            //number of islands
            void numberOfCLosedIslands(int[][] grid, int row, int col) {
                if (isOutOfBounds(row, col) || grid[row][col] != LAND) {
                    return;
                }

                grid[row][col] = VISITED_LAND;

                numberOfCLosedIslands(grid, row - 1, col);
                numberOfCLosedIslands(grid, row + 1, col);
                numberOfCLosedIslands(grid, row, col - 1);
                numberOfCLosedIslands(grid, row, col + 1);
            }

        }

        Helper helper = new Helper();
        int numberOfClosedIslands = 0;

        //here we are removing all the LAND cells and their connected LAND cells
        //that are on the boundary because those LAND cells are not covered 4-dir
        //between WATER(== 1) cells around them
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == LAND
                        && ((r == TOP_BOUNDARY || r == BOTTOM_BOUNDARY)
                        || (c == LEFT_BOUNDARY || c == RIGHT_BOUNDARY))) {
                    helper.removeLandAtBoundary(grid, r, c);
                }
            }
        }

        //now from the above removeLand DFS call, we have left with those LAND
        //cells that actually surrounded 4-dir by WATER(== 1) cells, now we can
        //do the same number of islands dfs logic to count the closed islands
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == LAND) {
                    numberOfClosedIslands++;
                    helper.numberOfCLosedIslands(grid, r, c);
                }
            }
        }

        //output
        System.out.println("Number of closed islands in between water: " + numberOfClosedIslands);
    }

    private boolean detectCycleInUndirectedGraphDFS_Helper(
            List<List<Integer>> adjList, int vertex, int parent, boolean[] visited) {

        visited[vertex] = true;

        for (int childVertex : adjList.get(vertex)) {

            if (!visited[childVertex]) {
                if (detectCycleInUndirectedGraphDFS_Helper(adjList, childVertex, vertex, visited)) {
                    return true;
                }
            } else if (childVertex != parent) {
                return true;
            }
        }
        return false;
    }

    public boolean detectCycleInUndirectedGraphDFS_Graph(int V, List<List<Integer>> adjList) {

        boolean[] visited = new boolean[V];

        for (int u = 0; u < V; u++) {

            if (visited[u] == true) {
                continue;
            }

            if (detectCycleInUndirectedGraphDFS_Helper(adjList, u, -1, visited)) {
                return true;
            }
        }

        return false;
    }

    private void topologicalSort_Helper(
            List<List<Integer>> adjList, int vertex, boolean[] visited, Stack<Integer> resultStack) {

        visited[vertex] = true;

        for (int childVertex : adjList.get(vertex)) {

            if (visited[childVertex] == true) {
                continue;
            }

            topologicalSort_Helper(adjList, childVertex, visited, resultStack);
        }

        resultStack.push(vertex);
    }

    public void topologicalSort_Graph(int V, List<List<Integer>> adjList) {

        Stack<Integer> resultStack = new Stack<>();

        boolean[] visited = new boolean[V];

        for (int u = 0; u < V; u++) {

            if (visited[u] == true) {
                continue;
            }

            topologicalSort_Helper(adjList, u, visited, resultStack);
        }

        System.out.println("Topological sort: ");
        while (!resultStack.isEmpty()) {
            System.out.print(resultStack.pop() + " ");
        }
        System.out.println();
    }

    public boolean detectCycleInDirectedGraphDFS_Helper(List<List<Integer>> adjList, int vertex,
                                                        boolean[] visited, boolean[] recurStack) {

        if (recurStack[vertex]) {
            return true;
        }

        if (visited[vertex]) {
            return false;
        }

        recurStack[vertex] = true;
        visited[vertex] = true;

        List<Integer> childrens = adjList.get(vertex);
        if (childrens != null && !childrens.isEmpty()) {
            for (int childVertex : childrens) {
                if (detectCycleInDirectedGraphDFS_Helper(adjList, childVertex, visited, recurStack)) {
                    return true;
                }
            }
        }
        recurStack[vertex] = false;
        return false;
    }

    public boolean detectCycleInDirectedGraphDFS_Graph(int V, List<List<Integer>> adjList) {
        boolean[] visited = new boolean[V];
        boolean[] recurStack = new boolean[V];
        for (int u = 0; u < V; u++) {
            if (detectCycleInDirectedGraphDFS_Helper(adjList, u, visited, recurStack)) {
                return true;
            }
        }
        return false;
    }

    private void djikstraAlgorithm_Graph_Helper(
            Map<Integer, List<GraphEdge>> graph, int V, int src) {
        //Single source shortest path
        int MAX = Integer.MAX_VALUE;

        //parents arr is optional
        int[] parents = new int[V];
        Arrays.fill(parents, MAX);

        int[] minWeights = new int[V];
        Arrays.fill(minWeights, MAX);

        int weightToSrc = 0;
        minWeights[src] = weightToSrc;

        int parentToSrc = -1;
        parents[src] = parentToSrc;

        //minHeap of weights to get the least weighted edge from the breadth first order
        PriorityQueue<GraphEdge> minHeapWeightQueue = new PriorityQueue<>(
                (g1, g2) -> g1.weight - g2.weight);

        minHeapWeightQueue.add(new GraphEdge(src, weightToSrc));

        while (!minHeapWeightQueue.isEmpty()) {

            GraphEdge currEdge = minHeapWeightQueue.poll();
            int currVertex = currEdge.vertex;

            for (GraphEdge childEdge : graph.getOrDefault(currVertex, new ArrayList<>())) {

                int childVertex = childEdge.vertex;
                //cost to reach child vertex
                int childWeight = childEdge.weight;

                if (minWeights[childVertex] > minWeights[currVertex] + childWeight) {

                    minWeights[childVertex] = minWeights[currVertex] + childWeight;
                    //updating the child edge weight with new weight which is less
                    //costlier than previous
                    childEdge.weight = minWeights[childVertex];

                    parents[childVertex] = currVertex;

                    minHeapWeightQueue.add(childEdge);
                }
            }
        }
        //output
        for (int u = 0; u < V; u++) {
            System.out.println("From src: "
                    + src
                    + " to vertex: "
                    + u
                    + " min weight is: "
                    + (minWeights[u] == MAX ? " Not Possible " : minWeights[u])
                    + " parent of "
                    + u
                    + " is "
                    + (parents[u] == MAX ? " Not Possible " : parents[u]));
        }
    }

    public void djikstraAlgorithm_Graph() {
        //..........................T: O(V^2)
        //Djikstra algo fails for negatve weight cycle
        //input
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        int V = 5;
        for (int u = 0; u < V; u++) {
            graph.put(u, new ArrayList<>());
        }

        graph.get(0).addAll(Arrays.asList(
                new GraphEdge(2, 6),
                new GraphEdge(3, 6)));
        graph.get(1).addAll(Arrays.asList(
                new GraphEdge(0, 3)));
        graph.get(2).addAll(Arrays.asList(
                new GraphEdge(3, 2)));
        graph.get(3).addAll(Arrays.asList(
                new GraphEdge(1, 1),
                new GraphEdge(2, 1)));
        graph.get(4).addAll(Arrays.asList(
                new GraphEdge(1, 4),
                new GraphEdge(3, 2)));

        djikstraAlgorithm_Graph_Helper(graph, V, 4);
        djikstraAlgorithm_Graph_Helper(graph, V, 0);
    }

    public void networkTimeDelay_Graph(int[][] times, int V, int source) {
        //https://leetcode.com/problems/network-delay-time/
        //based on DJIKSTRA ALGO
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] time : times) {

            int u = time[0];
            int v = time[1];
            int weight = time[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));
        }

        int MAX = Integer.MAX_VALUE;

        int[] timeDelay = new int[V + 1];

        Arrays.fill(timeDelay, MAX);

        int sourceTime = 0;

        timeDelay[source] = sourceTime;

        Queue<GraphEdge> queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        queue.add(new GraphEdge(source, sourceTime));

        while (!queue.isEmpty()) {

            GraphEdge currEdge = queue.poll();

            for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, new ArrayList<>())) {

                if (timeDelay[childEdge.vertex] > timeDelay[currEdge.vertex] + childEdge.weight) {

                    timeDelay[childEdge.vertex] = timeDelay[currEdge.vertex] + childEdge.weight;

                    queue.add(new GraphEdge(childEdge.vertex, timeDelay[childEdge.vertex]));
                }
            }
        }

        int maxNetworkDelayTime = Integer.MIN_VALUE;
        //considering [1 to V] nodes as given
        for (int i = 1; i < timeDelay.length; i++) {
            int delayTime = timeDelay[i];
            //if from [1 to V] any node is not reachable(disconnected graph) that node's
            //delay time will be left as MAX in that case we have to return -1
            if (delayTime == MAX) {
                maxNetworkDelayTime = -1;
                break;
            }
            maxNetworkDelayTime = Math.max(maxNetworkDelayTime, delayTime);
        }
        //output
        System.out.println("Max network delay time to reach far end node: " + maxNetworkDelayTime);
    }

    public void findEventualSafeNodes_Graph(int[][] graph) {
        //https://leetcode.com/problems/find-eventual-safe-states/
        //based on REVERSE GRAPH BFS
        int V = graph.length;
        //using boolean[] for marking nodes safe beacause this will keep
        //nodes in sorted order, which is req in question
        boolean[] markSafeNodes = new boolean[V];
        List<Integer> safeNodes = new ArrayList<>();
        Queue<Integer> terminalNodesQueue = new LinkedList<>();
        //parent = [child] relation
        Map<Integer, Set<Integer>> parentToChildGraph = new HashMap<>();
        //child = [parent] relation
        Map<Integer, Set<Integer>> childToParentGraph = new HashMap<>();

        for (int parent = 0; parent < V; parent++) {
            //if a parent node don't have any outgoing edges(terminal node)
            if (graph[parent].length == 0) {
                terminalNodesQueue.add(parent);
            }

            parentToChildGraph.putIfAbsent(parent, new HashSet<>());

            for (int childVertex : graph[parent]) {

                parentToChildGraph.get(parent).add(childVertex);

                childToParentGraph.putIfAbsent(childVertex, new HashSet<>());
                childToParentGraph.get(childVertex).add(parent);
            }
        }

        //queue will start from terminal nodes where we can't move further
        //and we will fill the parents in queue if they can be made terminal
        //node while going the rev graph
        while (!terminalNodesQueue.isEmpty()) {

            int terminalNode = terminalNodesQueue.poll();
            //if any node is taken out of the queue, that means this curr terminal
            //node don't have any outgoing edges
            markSafeNodes[terminalNode] = true;

            for (int parentVertex : childToParentGraph.getOrDefault(terminalNode, new HashSet<>())) {
                //we will remove curr terminal node from its parent graph
                //nodes if that parent can be made terminal. Because if that parent
                //can't be made terminal node that would mean, there will exist a node from
                //this parent where that whole path will lead to no terminal node
                parentToChildGraph.get(parentVertex).remove(terminalNode);
                //parent nodes list is empty means it has become a terminal node now
                //we can add it in the queue
                if (parentToChildGraph.get(parentVertex).isEmpty()) {
                    terminalNodesQueue.add(parentVertex);
                }
            }
        }

        for (int src = 0; src < V; src++) {
            if (markSafeNodes[src]) {
                safeNodes.add(src);
            }
        }
        //output
        System.out.println("Safe nodes in sorted format (approach revrse graph BFS): " + safeNodes);
    }

    private boolean findEventualSafeNodes_Graph2_HelperDetectDirectedGraphCycleDFS(
            int[][] graph, boolean[] recurStack, boolean[] visited, int vertex) {

        //same as detect cycle in directed graph
        if (recurStack[vertex]) {
            return true;
        }

        if (visited[vertex]) {
            return false;
        }

        recurStack[vertex] = true;

        visited[vertex] = true;

        for (int childVertex : graph[vertex]) {

            //return true, if exists a cycle in the graph
            if (findEventualSafeNodes_Graph2_HelperDetectDirectedGraphCycleDFS(
                    graph, recurStack, visited, childVertex)) {
                return true;
            }
        }

        recurStack[vertex] = false;

        return false;
    }

    public void findEventualSafeNodes_Graph2(int[][] graph) {
        //https://leetcode.com/problems/find-eventual-safe-states/
        //explanation: https://youtu.be/k8LBJqGLLQE
        //based on DFS & DETECT DIRECTED GRAPH CYCLE
        //OPTIMIZED than above reverse graph BFS
        /*

        intuition:

        nodes that are involved in the cycle will never reach to a terminal node
        and hence can't ever be called as safe nodes.

        As we are doing the DFS directed graph cycle check, we are maintating
        recurStack[] which basically tells that, along this curr DFS path we are
        travelling, if we a see a node again which is already seen in the same
        path then this would result into cycle = true

        if(recurStack[vertex]) return true, where vertex is node seen again in
        the curr DFS path we are travelling

        whenever the above statement return true indicating a cycle exists in
        the curr DFS nodes path then this below statement in for() bounds to
        return true

        if (helperDetectDirectedGraphCycleDFS(graph, recurStack, visited, childVertex)) {
            return true;
        }

        due to this we will never put the nodes out from the recurStack[] which
        we added along the path in DFS, means below statement will never reach
        again, the moment we encounter a cycle

        recurStack[vertex] = false, where vertex is a node we travelled along in
        the curr DFS path

        this gives the intution that the nodes that are involded in cycle,
        firstly, they will never put out from recurStack[] meaning the below
        statment will always remain true for such vertices

        recurStack[vertex] = true, where vertex belongs to nodes in cyclic path

        secondly, the nodes involved in the cycle will never reach to a terminal
        node, as they will always have an edge that is keeping them in cycle

        hence, our safe nodes are those which are not in the recurStack[] meaning,
        recurStack[vertex] = false, where vertex are nodes that do not belongs
        to any cyclic path

         */
        int V = graph.length;

        List<Integer> safeNodes = new ArrayList<>();

        boolean[] recurStack = new boolean[V];
        boolean[] visited = new boolean[V];

        for (int node = 0; node < V; node++) {

            //skip, if a node is already visited as part of previous graph cycle
            if (visited[node]) {
                continue;
            }

            findEventualSafeNodes_Graph2_HelperDetectDirectedGraphCycleDFS(
                    graph, recurStack, visited, node);
        }

        for (int node = 0; node < V; node++) {

            if (recurStack[node]) {
                continue;
            }

            safeNodes.add(node);
        }

        //output
        System.out.println("Safe nodes in sorted format (approach DFS detect directed graph cycle): " + safeNodes);
    }

    private void numberOfProvince_Graph_HelperDFS(
            Map<Integer, List<Integer>> graph, int src, Set<Integer> visited) {
        if (visited.contains(src)) {
            return;
        }
        visited.add(src);
        for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {
            numberOfProvince_Graph_HelperDFS(graph, childVertex, visited);
        }
    }

    public void numberOfProvince_Graph(int[][] isConnected) {
        //https://leetcode.com/problems/number-of-provinces/
        //this questions is somewhat similar to number of islands problem
        //and actually based on graph connected components
        //acc to quest row or col is V
        int ROW = isConnected.length;
        int COL = isConnected[0].length;
        int provinces = 0;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();
        //all the vertices are 1-based thats why r + 1 and c + 1 is done here
        for (int r = 0; r < ROW; r++) {
            graph.putIfAbsent(r + 1, new ArrayList<>());
            for (int c = 0; c < COL; c++) {
                if (r != c && isConnected[r][c] == 1) {
                    graph.get(r + 1).add(c + 1);
                }
            }
        }

        for (int src = 1; src <= ROW; src++) {
            //a single dfs call from curr src will visit all of its
            //connected child vertices. In that way each time we are entring
            //below if cond that means we are going to do a dfs on a disconnected graph
            //ex: 1 = [2,3], 2 = [1], 3 = [1], 4 = []
            //graph : 1 <--> 2 <--> 3     4
            //two component [1,2,3], [4]
            if (!visited.contains(src)) {
                provinces++;
                numberOfProvince_Graph_HelperDFS(graph, src, visited);
            }
        }
        //output
        System.out.println("Number of provinces (number of disconnected graphs): " + provinces);
    }

    public void numberOfProvince_Graph_UnionFind(int[][] isConnected) {
        //https://leetcode.com/problems/number-of-provinces/
        //based on UNION FIND/ CONNECTED GRAPH COMPONENTS
        //acc to quest row or col is V
        int V = isConnected.length;

        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];

                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int nod1, int node2) {

                int parent1 = find(nod1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                connectedGroups--;
            }

            public int numberOfProvinces() {
                return connectedGroups;
            }
        }

        UnionFind unionFind = new UnionFind(V);

        for (int u = 0; u < V; u++) {
            for (int v = 0; v < V; v++) {

                if (u == v) {
                    continue;
                }

                if (isConnected[u][v] == 1) {
                    unionFind.union(u, v);
                }
            }
        }
        //output
        System.out.println("Number of provinces (Union Find): " + unionFind.numberOfProvinces());
    }

    private void mostStonesRemovedInSameRowCol_Graph_DFS(int index, int[][] stones, boolean[] visited) {

        visited[index] = true;

        for (int i = 0; i < stones.length; i++) {

            if (visited[i]) {
                continue;
            }
            //visiting all those stones index whose either curr i-th index row or col
            //is same as curr index, this way we will do dfs on connected indexes
            //that are on same row or col and by dfs we will put these indexes in
            //visited
            if (stones[index][0] == stones[i][0] || stones[index][1] == stones[i][1]) {
                mostStonesRemovedInSameRowCol_Graph_DFS(i, stones, visited);
            }
        }
    }

    public void mostStonesRemovedInSameRowCol_Graph(int[][] stones) {
        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/2813985/dfs-solution
        int n = stones.length;
        boolean[] visited = new boolean[n];
        int disconnectedIndexCount = 0;
        for (int i = 0; i < n; i++) {
            //if the curr i-th index is visited that means this i-th index
            //has been a part of a previous connected point(means belongs to same
            //row or col)
            if (visited[i]) {
                continue;
            }
            //if i-th index is not in visited that means this i-th index is a disconnected
            //index from a previously visited stones points
            disconnectedIndexCount++;
            mostStonesRemovedInSameRowCol_Graph_DFS(i, stones, visited);
        }
        System.out.println("Connected stones removed: " + (n - disconnectedIndexCount));
    }

    public void reorderPathsToMakeAllCitiesReachToCityZero_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/2449037/Easy-to-understand-BFS-solution-in-Java
        /*

        for ex: [0,1],[1,3],[2,3],[4,0],[4,5]
        graph = {0 = [-1, 4], 1 = [0, -3], 2 = [-3], 3 = [1, 2], 4 = [0, -5], 5 = [4]}
        src = 0
        BFS:
        ....................................0
        .........................[-ve]/............\[+ve]
        .............................1..............4
        ......................[vis]/...\[-ve].[vis]/.\[-ve]
        ..........................0.....3.........0...5
        ..........................[vis]/.\[+ve]........\[vis]
        ..............................1...2.............4
        ............................[vis]/
        ................................3
        each of the [-ve] edged childVertex needs to be reordered
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            //in actual (i --> j) edge, the dest vertex j
            //as an outgoing edge(i --> j) is add as -ve
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(-v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int pathReordered = 0;
        int src = 0;

        boolean[] visited = new boolean[V];
        Queue<Integer> queue = new LinkedList<>();

        queue.add(src);
        visited[src] = true;

        while (!queue.isEmpty()) {

            int currSrc = queue.poll();

            for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {

                int absChildVertex = Math.abs(childVertex);

                //above intuition's [vis], no need to go to vertex
                //that is already visited
                if (visited[absChildVertex]) {
                    continue;
                }
                //above intuition's [-ve], each time we see a -ve edge
                //vertex we must reorder it, so that this edge(or path going from this edge)
                //should reach to city zero(since our src = 0)
                if (childVertex < 0) {
                    pathReordered++;
                }

                visited[absChildVertex] = true;
                //since there are no actual -ve edges in input,
                //we must add the childVertex in their abs form
                queue.add(absChildVertex);
            }
        }
        //output
        System.out.println("Path reordered: " + pathReordered);
    }

    public void minObstaclesRemovalToReachBottomRightCorner_Graph(int[][] grid) {
        //https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/
        //this quest is also like minimum path sum from top-left to bottom-right corner
        //but in binary matrix
        class Cell {

            int obstaclesRemoved;
            int row;
            int col;

            public Cell(int obstaclesRemoved, int row, int col) {
                this.obstaclesRemoved = obstaclesRemoved;
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int initRow = 0;
        int initCol = 0;
        int initObstacleRemoved = 0;

        boolean[][] visited = new boolean[ROW][COL];

        //to remove obstacles in min way possible,choose the
        //min obstacles path
        Queue<Cell> minHeapObstacles = new PriorityQueue<>(
                (a, b) -> a.obstaclesRemoved - b.obstaclesRemoved);

        minHeapObstacles.add(new Cell(initObstacleRemoved, initRow, initCol));
        visited[initRow][initCol] = true;

        int minObstaclesRemoval = 0;

        while (!minHeapObstacles.isEmpty()) {

            Cell currCell = minHeapObstacles.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                minObstaclesRemoval = currCell.obstaclesRemoved;
                break;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if the new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if the new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                minHeapObstacles.add(new Cell(
                        currCell.obstaclesRemoved + grid[newRow][newCol],
                        newRow,
                        newCol));
            }
        }
        //output
        System.out.println("Min obstacles removal: " + minObstaclesRemoval);
    }

    public void shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
            int[][] grid, int k) {
        //https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
        //based on minObstaclesRemovalToReachBottomRightCorner_Graph()
        /*
        intution behind this solution, is to save the cell's data in queue.
        each cell value will also hold kThRemoval variable, this will denote while doing
        bfs if we reach a OBSTACLE( == 1) then we will count it as a movable path but
        since we are considering it as a movable path that means we have removed this OBSTACLE
        so for this removal we will increase the kThRemoval count by 1 for that cell.
        And whenever we encounter any other OBSTACLE in a given path we will simulate this
        kThRemoval until kThRemoval <= k
         */
        class Cell {

            int dist;
            int row;
            int col;
            int kThRemoval;

            public Cell(int dist, int row, int col, int kThRemoval) {
                this.dist = dist;
                this.row = row;
                this.col = col;
                this.kThRemoval = kThRemoval;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int OBSTACLE = 1;
        int EMPTY_SPACE = 0;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int initRow = 0;
        int initCol = 0;
        int initObstacle = 0;
        int initKThRemoval = 0;

        boolean[][][] visited = new boolean[ROW][COL][k + 1];

        Queue<Cell> queue = new PriorityQueue<>(
                (a, b) -> a.dist - b.dist);

        queue.add(new Cell(initObstacle, initRow, initCol, initKThRemoval));
        visited[initRow][initCol][k] = true;

        int shortestPathWithAtMostKObstacleRemoval = -1;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                shortestPathWithAtMostKObstacleRemoval = currCell.dist;
                break;
            }

            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if the new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //if this new row & col is an OBSTACLE but we can still try to
                //remove this OBSTACLE because our currCell KThRemoval count is
                //greater than equal to k and also this  new row & col & (currCell.KThRemoval - 1)
                //combination path should not have previously visited, then we will
                //add it to queue and mark the state as visited means this OBSTACLE
                //will be count as a movable path
                if (grid[newRow][newCol] == OBSTACLE
                        && currCell.kThRemoval - 1 >= 0
                        && !visited[newRow][newCol][currCell.kThRemoval - 1]) {

                    visited[newRow][newCol][currCell.kThRemoval - 1] = true;
                    queue.add(new Cell(currCell.dist + 1, newRow, newCol, currCell.kThRemoval - 1));
                }

                //if this new row & col is an EMPY_SPACE, we can move normally,
                //we don't have removal restrictions on EMPTY_SPACE only thing we need to
                //check is the same new row & col with currKThRemoval is not visited previously
                if (grid[newRow][newCol] == EMPTY_SPACE
                        && ! !visited[newRow][newCol][currCell.kThRemoval]) {

                    visited[newRow][newCol][currCell.kThRemoval] = true;
                    queue.add(new Cell(currCell.dist + 1, newRow, newCol, currCell.kThRemoval));
                }
            }
        }
        //output
        System.out.println("Shortest path from top-left to bottom-right with atmost k obstacle removal: "
                + shortestPathWithAtMostKObstacleRemoval);

    }

    public void minHeightTrees_Graph_BruteForce(int V, int[][] edges) {
        //https://leetcode.com/problems/minimum-height-trees/
        //okay but it will give TLE
        List<Integer> minHeightTreeNodes = new ArrayList<>();
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int minLevel = Integer.MAX_VALUE;
        Set<Integer> visited;
        Queue<Integer> queue = new LinkedList<>();

        //for each src node i, we will consider that this i is the root of our
        //tree and we will do BFS(basically to calculate height) to min level
        for (int u = 0; u < V; u++) {

            visited = new HashSet<>();
            queue.add(u);
            int currLevel = 0;

            //perform a simple BFS on each src node i and calculate the level and
            //maintain the minLevel trees formed from all the src node i
            while (!queue.isEmpty()) {

                int size = queue.size();
                for (int i = 0; i < size; i++) {

                    int currSrc = queue.poll();

                    for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {

                        if (visited.contains(childVertex)) {
                            continue;
                        }

                        visited.add(childVertex);

                        queue.add(childVertex);
                    }
                }
                currLevel++;
            }
            //after each BFS from the curr src node i, we can compare the levels
            //formed with the minLevel, if we have seen a currLevel which is
            //now smaller than the prev minLevel, that means all the previousy
            //saved minHeightTreeNodes are not req, clear them, and save the new
            //new tree node starting from i
            if (currLevel < minLevel) {
                minLevel = currLevel;
                minHeightTreeNodes.clear();
                minHeightTreeNodes.add(u);
            } else if (currLevel == minLevel) {
                //if there are other tree nodes i that gives the same min tree height
                //also save them
                minHeightTreeNodes.add(u);
            }
        }
        //output
        System.out.println("Min height tree nodes(Brute force): " + minHeightTreeNodes);
    }

    public void minHeightTrees_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/minimum-height-trees/
        List<Integer> minHeightTreeNodes = new ArrayList<>();
        //edge case
        if (V < 2) {
            for (int u = 0; u < V; u++) {
                minHeightTreeNodes.add(u);
            }
            System.out.println("Min height tree nodes: " + minHeightTreeNodes);
            return;
        }

        Map<Integer, Set<Integer>> graph = new HashMap<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new HashSet<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new HashSet<>());
            graph.get(v).add(u);
        }

        Queue<Integer> leaves = new LinkedList<>();

        for (int u = 0; u < V; u++) {
            //in an undirected graph both node i contains j and j contains i
            //if a node is leaf that means it should only contains 1 node as edge
            //and that is to its parent
            if (graph.get(u).size() == 1) {
                leaves.add(u);
            }
        }

        while (V > 2) {

            int size = leaves.size();
            V -= size;

            for (int i = 0; i < size; i++) {

                int currLeafNode = leaves.poll();

                for (int parentNode : graph.getOrDefault(currLeafNode, new HashSet<>())) {

                    graph.get(parentNode).remove(currLeafNode);

                    if (graph.get(parentNode).size() == 1) {
                        leaves.add(parentNode);
                    }
                }
            }
        }

        minHeightTreeNodes.addAll(leaves);

        //output
        System.out.println("Min height tree nodes: " + minHeightTreeNodes);
    }

    private int uniquePaths_Graph_Memoization_DFS(
            int row, int col, int ROW, int COL, Integer[][] pathCountsCache) {

        //return 0, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        if (row == ROW - 1 && col == COL - 1) {
            return 1;
        }

        if (pathCountsCache[row][col] != null) {
            return pathCountsCache[row][col];
        }

        int currPathCount = 0;

        currPathCount += uniquePaths_Graph_Memoization_DFS(row + 1, col, ROW, COL, pathCountsCache);
        currPathCount += uniquePaths_Graph_Memoization_DFS(row, col + 1, ROW, COL, pathCountsCache);

        return pathCountsCache[row][col] = currPathCount;
    }

    public void uniquePaths_Graph_Memoization(int row, int col) {
        //https://leetcode.com/problems/unique-paths/
        //https://leetcode.com/problems/unique-paths-ii/
        Integer[][] pathCountsCache = new Integer[row][col];
        int uniquePathCount = uniquePaths_Graph_Memoization_DFS(0, 0, row, col, pathCountsCache);
        //output
        System.out.println("Unique paths count in given row & col grid: " + uniquePathCount);
    }

    public void uniquePathsThree_Graph(int[][] grid) {
        //https://leetcode.com/problems/unique-paths-iii/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        int SRC_CELL = 1;
        int DEST_CELL = 2;
        int EMPTY_CELL = 0;
        int BLOCKED_CELL = -1;

        int srcRow = 0;
        int srcCol = 0;

        //all the empty cells == 0 are the allowed cells for movement
        int allowedCellsForMovement = 0;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            int srcToDestPathCount(int[][] grid, int row, int col, int allowedCellsForMovement) {

                //if the curr row & col cell is out of bounds
                if (isOutOfBounds(row, col)) {
                    return 0;
                }

                //curr row & col is already visited
                if (visited[row][col]) {
                    return 0;
                }

                //cell at curr row & col is BLOCKED_CELL
                if (grid[row][col] == BLOCKED_CELL) {
                    return 0;
                }

                //when the curr row & col reaches the DEST_CELL, cells to cover in the path
                //should be 0, that means from src to dest we should have travelled all the cells
                //except those are BLOCKED_CELL
                if (grid[row][col] == DEST_CELL && allowedCellsForMovement == 0) {
                    //successfully covered a path by covering all the cells
                    //means (1 -> all 0s -> 2)
                    return 1;
                }

                //for the curr on-going path this curr row & col is marked visited
                //so that we don't reach the same cell in DFS
                visited[row][col] = true;

                //count the paths from src_cell to dest_cell via the allowed empty_cells
                int paths = 0;

                for (int[] dir : dirs) {

                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    paths += srcToDestPathCount(grid, newRow, newCol, allowedCellsForMovement - 1);
                }

                //once we have covered all the 4-dirs from this curr row & col
                //we can mark the curr row & col as un-visited
                visited[row][col] = false;

                return paths;
            }

        }

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == SRC_CELL) {
                    srcRow = r;
                    srcCol = c;
                } else if (grid[r][c] == EMPTY_CELL) {
                    allowedCellsForMovement++;
                }
            }
        }

        //add +1 in allowed movement cells as we need to reach DEST_CELL where
        //'allowedCellsForMovement' should become 0
        allowedCellsForMovement += 1;

        Helper helper = new Helper();

        int srcToDestPathCount = helper.srcToDestPathCount(grid, srcRow, srcCol, allowedCellsForMovement);
        //output
        System.out.println("Unique paths count from src to dest covering all empty cells: " + srcToDestPathCount);
    }

    public void parallelCourseThree_Graph(int V, int[][] edges, int[] time) {
        //https://leetcode.com/problems/parallel-courses-iii/
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[V];
        for (int[] edge : edges) {
            //to used it as 0-based index that's why -1
            int u = edge[0] - 1;
            int v = edge[1] - 1;

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
            //all the vertex who have incoming edges to them
            indegree[v]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        int[] completionTime = new int[V];

        for (int u = 0; u < V; u++) {
            //for all those vertexes who don't have any incoming edges to them
            //they can be taken first individually
            if (indegree[u] == 0) {
                completionTime[u] = time[u];
                queue.add(u);
            }
        }

        int minTimeUsed = 0;

        while (!queue.isEmpty()) {
            int src = queue.poll();
            minTimeUsed = Math.max(minTimeUsed, completionTime[src]);
            for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {

                completionTime[childVertex] = Math.max(
                        completionTime[childVertex], completionTime[src]);

                indegree[childVertex]--;

                if (indegree[childVertex] == 0) {
                    completionTime[childVertex] += time[childVertex];
                    queue.add(childVertex);
                }
            }
        }
        //output
        System.out.println("Min time used to complete the course: " + minTimeUsed);
    }

    public void parallelCourseThree_Graph_TopologicalSort(int V, int[][] edges, int[] time) {
        //https://leetcode.com/problems/parallel-courses-iii/
        //based on GRAPH TOPOLOGICAL SORT
        Map<Integer, List<Integer>> graph = new HashMap<>();
        boolean[] visited = new boolean[V];
        List<Integer> topoSort = new ArrayList<>();
        int[] completionTime = new int[V];

        class Helper {

            void topoSortHelper(int vertex, List<Integer> topoSort) {

                visited[vertex] = true;

                for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
                    //skip, if the child vertex is already visited
                    if (visited[childVertex]) {
                        continue;
                    }
                    topoSortHelper(childVertex, topoSort);
                }

                topoSort.add(vertex);
            }
        }

        Helper helper = new Helper();

        //create graph
        for (int[] edge : edges) {
            //to used it as 0-based index that's why -1
            int u = edge[0] - 1;
            int v = edge[1] - 1;
            //directed graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        //do a topoSort on the graph vertex, the graph can be disconnected
        //hence we need to loop over all the vetices of the graph
        for (int u = 0; u < V; u++) {
            //skip, if the curr src vertex == i is already visited in some previous
            //topo sort dfs call
            if (visited[u]) {
                continue;
            }
            helper.topoSortHelper(u, topoSort);
        }

        //loop over all the course in topo sort
        for (int course : topoSort) {
            //initial completion time for each course
            completionTime[course] = time[course];
        }

        //as we have directed edge relations in graph: course --> mandatoryCourse
        //thats why we need to revers loop to get first independent course to
        //access its child mandatoryCourse
        for (int i = 0; i < topoSort.size(); i++) {
            //get the first independent course that must be taken first before
            //any other course
            int course = topoSort.get(i);

            //in order to complete curr 'course', we might need to complete
            //child course first, hence we need to calculate the max time taken
            //for the curr 'childCourse'
            for (int childCourse : graph.getOrDefault(course, new ArrayList<>())) {

                if (completionTime[childCourse] < completionTime[course] + time[childCourse]) {

                    completionTime[childCourse] = completionTime[course] + time[childCourse];
                }
            }
        }

        int minTimeUsed = 0;

        for (int timeTaken : completionTime) {
            minTimeUsed = Math.max(minTimeUsed, timeTaken);
        }

        //output
        System.out.println("Min time used to complete the course (using topological sort): " + minTimeUsed);
    }

    public int shortestPathInBinaryMatrix_Graph(int[][] grid) {
        //https://leetcode.com/problems/shortest-path-in-binary-matrix/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1
        //based on BFS
        //our shortest path should go from 0 in binary matrix, 1 means block
        class Cell {

            int cost;
            int row;
            int col;

            public Cell(int cost, int row, int col) {
                this.cost = cost;
                this.row = row;
                this.col = col;
            }

        }
        int ROW = grid.length;
        int COL = grid[0].length;

        if (grid[0][0] == 1 || grid[ROW - 1][COL - 1] == 1) {
            return -1;
        }

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1},
                {-1, -1},
                {-1, 1},
                {1, -1},
                {1, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        //to choose the shortest path from (0,0) to (ROW - 1, COL - 1)
        //minHeap cost to pick the shortest path of all possibility
        PriorityQueue<Cell> queue = new PriorityQueue<>((a, b) -> a.cost - b.cost);
        //curr cost, curr row, curr col
        queue.add(new Cell(1, 0, 0));
        visited[0][0] = true;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.cost;
            }

            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL
                        //if new row & col is blocked (==> 1)
                        || grid[newRow][newCol] == 1
                        //if new row & col is previously visited
                        || visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                queue.add(new Cell(currCell.cost + 1, newRow, newCol));
            }
        }
        return -1;
    }

    public boolean satisfiabilityOfEqualityEquation_Graph(String[] equations) {
        //https://leetcode.com/problems/satisfiability-of-equality-equations/
        //https://leetcode.com/problems/satisfiability-of-equality-equations/discuss/2625039/LeetCode-The-Hard-Way-Explained-Line-By-Line
        //based on UNION-FIND DISJOINT SET
        class UnionFind {

            int[] parent;
            int[] rank;

            public UnionFind() {
                parent = new int[26];
                rank = new int[26];
                for (int node = 0; node < 26; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind();

        for (String eqn : equations) {
            if (eqn.charAt(1) == '=') {
                int nodeU = eqn.charAt(0) - 'a';
                int nodeV = eqn.charAt(3) - 'a';
                unionFind.union(nodeU, nodeV);
            }
        }

        for (String eqn : equations) {
            if (eqn.charAt(1) == '!') {
                int nodeU = eqn.charAt(0) - 'a';
                int nodeV = eqn.charAt(3) - 'a';
                if (unionFind.find(nodeU) == unionFind.find(nodeV)) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean sentenceSimilarityTwo_Graph(
            String[] sentence1, String[] sentence2, String[][] similarPairs) {
        //https://leetcode.com/problems/sentence-similarity-ii/description/
        //based on UNION-FIND DISJOINT SET
        /*

        Step 1:
        From the given similarPairs, given 'each' word a unique 'countUniqueWords'
        and keep it in wordsToUniqueIndex
        Do not give a already seen word another unique index

        After this 'countUniqueWords' will tell the total number of unique words
        are there in similarPairs that are also disconnected, we can use
        'countUniqueWords' to set up UnionFind.

        Step 2:
        Set up UnionFind with total number of words/ nodes/ 'countUniqueWords' as index
        (initially disconnected). After that, again iterate over similarPairs
        and for each pair make union of words pair(first, second). Since we have
        given each word an index/node, using that we can make union of similar
        words and hence it will form a connected groups of similar words.

        Step 3:
        Now, iterate over sentences,
        if i-th word of both the sentences are same then 'continue',
        if they are not same then we need to check wheather they belong to same
        connected group of similar pairs or not, for that we need their unique
        index, that we can get easily from wordsToUniqueIndex.

        BUT remember we haven't added any words from given sentences array

        so there might be chances that word from sentences may not be in the
        wordsToUniqueIndex hence we will return a default index i.e, -1

        this -1 signifies that there exist words in any of the sentence or may
        be both, that is not at all forming any pair in similarPairs with any
        other word, hence any word from sentence(s) that is not in similarPairs,
        we can straight away return false

        Otherwise, we got valid indices for both the i-th words from sentences,
        now in order for them to be called 'same' these words should have some
        valid pairs in similarPairs. That we can check using find() method,
        if both word's index belong to same connected group of similar pair
        words then both the words, word1 & word2 can be called 'same', if not
        return false.

         */
        class UnionFind {

            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        int m = sentence1.length;
        int n = sentence1.length;

        if (m != n) {
            return false;
        }

        //also provides unique index to the words in similarPairs
        int countUniqueWords = 0;

        Map<String, Integer> wordToUniqueIndex = new HashMap<>();

        for (String[] pair : similarPairs) {

            String firstWord = pair[0];
            String secondWord = pair[1];

            wordToUniqueIndex.putIfAbsent(firstWord, countUniqueWords++);
            wordToUniqueIndex.putIfAbsent(secondWord, countUniqueWords++);

        }

        UnionFind unionFind = new UnionFind(countUniqueWords);

        for (String[] pair : similarPairs) {

            String firstWord = pair[0];
            String secondWord = pair[1];

            int nodeU = wordToUniqueIndex.get(firstWord);
            int nodeV = wordToUniqueIndex.get(secondWord);

            unionFind.union(nodeU, nodeV);
        }

        for (int i = 0; i < n; i++) {

            String word1 = sentence1[i];
            String word2 = sentence2[i];

            //skip, if the i-th words of both sentences are already same
            if (word1.equals(word2)) {
                continue;
            }

            //since, we are working on word's index we have given them we will
            //fetch their respective index/node
            //note: we have only provided index to words in similarPairs so if
            //any word from sentence1 or sentence2 fetches -1 as index that would
            //mean that word is not at all present in similarPairs and hence such a
            //word can't found a similar pair for itself & can't be called 'same'
            int nodeU = wordToUniqueIndex.getOrDefault(word1, -1);
            int nodeV = wordToUniqueIndex.getOrDefault(word2, -1);

            if (nodeU == -1 || nodeV == -1) {
                return false;
            }

            //here, we have found valid index to the words, word1 & word2
            //till here word1 and word2 are not directly same but we need to
            //check if they belong to same connected group of similar pairs of
            //word
            //if find(word1) ==> find(nodeU) is not same as find(word2) ==> find(nodeV)
            //that means both these words are not similar & can't be called same
            if (unionFind.find(nodeU) != unionFind.find(nodeV)) {
                return false;
            }
        }

        return true;
    }

    public void countReachableNodesWithRestrictions_Graph(int[][] edges, int[] restrictions) {
        //https://leetcode.com/problems/reachable-nodes-with-restrictions/
        Set<Integer> blocked = new HashSet<>(IntStream
                .of(restrictions)
                .boxed()
                .collect(Collectors.toSet()));
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();

        queue.add(root);
        visited.add(root);

        int count = 0;

        while (!queue.isEmpty()) {

            root = queue.poll();

            if (!blocked.contains(root)) {
                count++;
            }

            for (int childVertex : graph.getOrDefault(root, new ArrayList<>())) {
                if (visited.contains(childVertex) || blocked.contains(childVertex)) {
                    continue;
                }

                visited.add(childVertex);
                queue.add(childVertex);
            }
        }
        //output
        System.out.println("All the reachable nodes after the given node restrictions: " + count);
    }

    public void asFarFromLandAsPossible_Graph(int[][] grid) {
        //https://leetcode.com/problems/as-far-from-land-as-possible/
        //https://leetcode.com/problems/as-far-from-land-as-possible/discuss/360963/C%2B%2B-with-picture-DFS-and-BFS
        //based on BFS
        class Cell {

            int row;
            int col;
            int dist;

            public Cell(int row, int col, int dist) {
                this.row = row;
                this.col = col;
                this.dist = dist;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        Queue<Cell> landCellsQueue = new LinkedList<>();

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 1) {
                    landCellsQueue.add(new Cell(r, c, 1));
                    visited[r][c] = true;
                }
            }
        }

        int maxDist = 0;

        while (!landCellsQueue.isEmpty()) {

            int size = landCellsQueue.size();

            for (int i = 0; i < size; i++) {

                Cell currLandCell = landCellsQueue.poll();

                maxDist = Math.max(maxDist, currLandCell.dist);

                //for the curr land cell coord (row, col) we are only traversing
                //its immediate 4-neighbour, if its a water cell then we can reach
                //there by dist of currLand.dist + 1
                for (int[] dir : dirs) {

                    int newRow = currLandCell.row + dir[0];
                    int newCol = currLandCell.col + dir[1];

                    //skip, if new row & col 'isOutOfBounds'
                    if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                        continue;
                    }

                    //skip, if new row & col is already visited
                    if (visited[newRow][newCol]) {
                        continue;
                    }

                    visited[newRow][newCol] = true;

                    landCellsQueue.add(new Cell(newRow, newCol, currLandCell.dist + 1));
                }
            }
        }
        //output
        maxDist = maxDist == 1 ? -1 : maxDist - 1;
        System.out.println("Farthest water cell from the land cell: " + maxDist);
    }

    public int minGeneticMutation_Graph(String start, String end, List<String> bank) {
        //https://leetcode.com/problems/minimum-genetic-mutation/
        //based on BFS
        Set<String> geneBank = new HashSet<>(bank);
        if (!geneBank.contains(end)) {
            return -1;
        }

        Set<Character> genes = new HashSet<>(Arrays.asList('A', 'C', 'G', 'T'));

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        queue.add(start);
        visited.add(start);

        int mutation = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                String currGene = queue.poll();

                if (end.equals(currGene)) {
                    return mutation;
                }

                char[] currGeneArr = currGene.toCharArray();

                //try to generate all the possible genes from the
                //currGene by changing each char at each j-th position
                for (int j = 0; j < currGene.length(); j++) {

                    char original = currGeneArr[j];

                    for (char gene : genes) {

                        currGeneArr[j] = gene;
                        String newGene = String.valueOf(currGeneArr);
                        //if the new gene combination is not in given bank or it
                        //is already visited then continue
                        if (!geneBank.contains(newGene) || visited.contains(newGene)) {
                            continue;
                        }
                        queue.add(newGene);
                        visited.add(newGene);
                    }
                    //after generating all the possible gene by trying out all the
                    //chars at curr j-th position place the original char at j-th
                    //position
                    currGeneArr[j] = original;
                }
            }
            mutation++;
        }
        return -1;
    }

    public int wordLadder_Graph(String startWord, String endWord, List<String> wordList) {
        //https://leetcode.com/problems/word-ladder/
        //based on BFS & minGeneticMutation_Graph()
        Set<String> words = new HashSet<>(wordList);
        if (!words.contains(endWord)) {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        queue.add(startWord);
        visited.add(startWord);

        int ladder = 1;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                String currWord = queue.poll();

                if (endWord.equals(currWord)) {
                    return ladder;
                }

                char[] currWordArr = currWord.toCharArray();

                //try to generate all the possible words from the
                //currWord by changing each char at each j-th position
                for (int j = 0; j < currWord.length(); j++) {

                    char original = currWordArr[j];

                    for (char ch = 'a'; ch <= 'z'; ch++) {

                        currWordArr[j] = ch;
                        String newWord = String.valueOf(currWordArr);
                        //if the new word is not in given wordList or it is already
                        //visited then continue
                        if (!words.contains(newWord) || visited.contains(newWord)) {
                            continue;
                        }
                        queue.add(newWord);
                        visited.add(newWord);
                    }
                    //after generating all the possible words by trying out all the
                    //chars at curr j-th position place the original char at j-th
                    //position
                    currWordArr[j] = original;
                }
            }
            ladder++;
        }
        return 0;
    }

    private int whereWillTheBallsFall_Graph_GetLocation(int[][] board, int row, int currBallCol) {

        int ROW = board.length;
        int COL = board[0].length;

        //ball reaches the end of board, return the final location of ball
        if (row == ROW) {
            return currBallCol;
        }

        //nextBallCol will be ball location from 'currBallCol' with dirs from
        //board[row][currBallCol]
        int nextBallCol = currBallCol + board[row][currBallCol];

        //hitting the left-edge wall, how?
        //if currBallCol = 0 and dir = -1 means slide-to-left-diagonal-col
        //nextBallCol = 0 + -1 = -1 < 0, board left-edge wall
        //hitting the right-edge wall, how?
        //if currBallCol = COL - 1 and dir = 1 means slide-to-right-diagonal-col
        //nextBallCol = (COL - 1) + 1 = COL >= 0, board right-edge wall
        if (nextBallCol < 0 || nextBallCol >= COL) {
            return -1;
        }

        //ball blocked within 'V' shape, how?
        //if the ball reaches a point where the next move is not
        //possible by forming 'V' block i.e, [-1, 1] or [1, -1]
        if (board[row][currBallCol] != board[row][nextBallCol]) {
            return -1;
        }

        //if not blocked above move the ball to nextBallCol but its a
        //slide-to-[left/right]-diagonal movement that means also move to row + 1
        return whereWillTheBallsFall_Graph_GetLocation(board, row + 1, nextBallCol);
    }

    public void whereWillTheBallsFall_Graph(int[][] board) {
        //https://leetcode.com/problems/where-will-the-ball-fall/
        //https://leetcode.com/problems/where-will-the-ball-fall/solution/
        //based on DFS
        int ROW = board.length;
        int COL = board[0].length;
        int[] lastLocation = new int[COL];
        for (int ball = 0; ball < COL; ball++) {
            lastLocation[ball] = whereWillTheBallsFall_Graph_GetLocation(board, 0, ball);
        }
        //output
        System.out.println("Ball's final location: " + Arrays.toString(lastLocation));
    }

    private boolean wordSearch_Graph_Helper(char[][] board, int row, int col,
                                            int wordIndex, String word) {

        int ROW = board.length;
        int COL = board[0].length;

        if (wordIndex >= word.length()) {
            return true;
        }

        //return, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return false;
        }

        //return, if curr row & col already visited
        if (board[row][col] == '-') {
            return false;
        }

        //return, if char in board[][] at curr row & col doesn't match with the
        //char in word and which is should be next char in DFS path
        if (board[row][col] != word.charAt(wordIndex)) {
            return false;
        }

        char original = board[row][col];
        //mark row & col visited
        board[row][col] = '-';

        boolean found = false;

        //UP
        found = found || wordSearch_Graph_Helper(board, row - 1, col, wordIndex + 1, word);

        //Down
        found = found || wordSearch_Graph_Helper(board, row + 1, col, wordIndex + 1, word);

        //Left
        found = found || wordSearch_Graph_Helper(board, row, col - 1, wordIndex + 1, word);

        //Right
        found = found || wordSearch_Graph_Helper(board, row, col + 1, wordIndex + 1, word);

        board[row][col] = original;

        return found;
    }

    public boolean wordSearch_Graph(char[][] board, String word) {
        //https://leetcode.com/problems/word-search/

        int ROW = board.length;
        int COL = board[0].length;

        int wordIndex = 0;

        for (int row = 0; row < ROW; row++) {

            for (int col = 0; col < COL; col++) {
                if (board[row][col] == word.charAt(wordIndex)
                        && wordSearch_Graph_Helper(board, row, col, wordIndex, word)) {
                    return true;
                }
            }
        }
        return false;
    }

    public void wordSearchTwo_Graph(char[][] board, String[] words) {
        //https://leetcode.com/problems/word-search-ii/
        //based on wordSearch_Graph(), but it was giving TLE for long inputs
        List<String> matched = new ArrayList<>();

        int ROW = board.length;
        int COL = board[0].length;

        for (String word : words) {
            //using same logic as wordSearch for finding a single 'word' in the
            //given board[][], but n words in given words[] it will throw TLE
            if (wordSearch_Graph(board, word)) {
                matched.add(word);
            }
        }

        //output
        System.out.println("Words that are found in matrix (DFS): " + matched);
    }

    public void wordSearchTwo_Graph_TrieBased(char[][] board, String[] words) {
        //https://leetcode.com/problems/word-search-ii/

        int ROW = board.length;
        int COL = board[0].length;

        List<String> matched = new ArrayList<>();

        class TrieNode {

            Map<Character, TrieNode> nodes;
            boolean isEnd;
            String word;

            public TrieNode() {
                this.nodes = new HashMap<>();
                this.isEnd = false;
                this.word = "";
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                for (char ch : word.toCharArray()) {

                    if (currNode.nodes.containsKey(ch)) {

                        currNode = currNode.nodes.get(ch);

                    } else {

                        TrieNode node = new TrieNode();
                        currNode.nodes.put(ch, node);
                        currNode = node;
                    }
                }
                currNode.isEnd = true;
                currNode.word = word;
            }

            /*
            how trie based approach is working here?
            first, from the given words[] we will create the trie structure.
            then we will loop over the matrix and char at each matrix[row][col]
            we will check if this char can be used to from a word already in the trie (prefix check),
            if yes, we will move char by char in all 4-dir of matrix and check
            which char will help in forming a word(char that get add up to form prefix of the word)
            because by the end of forming a word we will reach the root.isEnd for
            that word and there we can add that word in our result list also we
            will mark this word isEnd as false so that we dont get the same word again and again
            (how we can get the same word again and again? the matrix may contain
            the same char at different row & col locations that will match
            initial or complete prefix part of word in trie, so if we reach the same
            word more than once its isEnd need to be marked as false.
            so when we first time reach a word's end or root.isEnd == true mark it as false)

             */
            void searchWordFromMatrix(
                    char[][] board, int row, int col, TrieNode currRoot, List<String> matched) {

                if (currRoot.isEnd) {
                    matched.add(currRoot.word);
                    currRoot.isEnd = false;
                }

                //return, if curr row  & col 'isOutOfBounds'
                if (row < 0 || row >= ROW || col < 0 || col >= COL) {
                    return;
                }

                //return, if curr row & col is already visited
                //this will help prevent one such eede case
                //ex: boars[][] = ['a', 'a'], word = "aaa"
                if (board[row][col] == '.') {
                    return;
                }

                //return, if the char at curr row & col, is not forming any valid
                //word present in trie
                if (!currRoot.nodes.containsKey(board[row][col])) {
                    return;
                }

                //keep the original char, and mark the board[row][col] as '.' means
                //visited
                char original = board[row][col];
                board[row][col] = '.';

                //UP
                searchWordFromMatrix(board, row - 1, col, currRoot.nodes.get(original), matched);

                //DOWN
                searchWordFromMatrix(board, row + 1, col, currRoot.nodes.get(original), matched);

                //LEFT
                searchWordFromMatrix(board, row, col - 1, currRoot.nodes.get(original), matched);

                //RIGHT
                searchWordFromMatrix(board, row, col + 1, currRoot.nodes.get(original), matched);

                board[row][col] = original;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                trieUtil.searchWordFromMatrix(board, row, col, ROOT, matched);
            }
        }

        //output
        System.out.println("Words that are found in matrix (Trie Based): " + matched);
    }

    public int nearestExitFromMaze_Graph(char[][] maze, int[] entrance) {
        //https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/

        class Cell {

            int row;
            int col;
            int dist;

            public Cell(int row, int col, int dist) {
                this.row = row;
                this.col = col;
                this.dist = dist;
            }

        }

        int ROW = maze.length;
        int COL = maze[0].length;

        int TOP_EDGE = 0;
        int BOTTOM_EDGE = ROW - 1;
        int LEFT_EDGE = 0;
        int RIGHT_EDGE = COL - 1;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int srcRow = entrance[0];
        int srcCol = entrance[1];
        int srcDist = 0;

        Set<String> exitsAtBorder = new HashSet<>();

        //put all the valid 'exit' at TOP & BOTTOM row of the maze in exitAtBorder
        for (int col = 0; col < COL; col++) {

            if (maze[TOP_EDGE][col] == '.') {
                exitsAtBorder.add(TOP_EDGE + "," + col);
            }

            if (maze[BOTTOM_EDGE][col] == '.') {
                exitsAtBorder.add(BOTTOM_EDGE + "," + col);
            }
        }

        //put all the valid 'exit' at LEDT & RIGHT col of the maze in exitAtBorder
        for (int row = 0; row < ROW; row++) {

            if (maze[row][LEFT_EDGE] == '.') {
                exitsAtBorder.add(row + "," + LEFT_EDGE);
            }

            if (maze[row][RIGHT_EDGE] == '.') {
                exitsAtBorder.add(row + "," + RIGHT_EDGE);
            }
        }

        //if curr src row & col is itself a valid 'exit', that should not be
        //checked, hence remove this src row * col exit(if exists in existAtBorder)
        exitsAtBorder.remove(srcRow + "," + srcCol);

        boolean[][] visited = new boolean[ROW][COL];

        //queue to maintain the shortest dist (minHeapDist)
        Queue<Cell> queue = new PriorityQueue<>((a, b) -> a.dist - b.dist);

        queue.add(new Cell(srcRow, srcCol, srcDist));
        visited[srcRow][srcCol] = true;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            //in the shortest path BFS traversal, we reach a row & col that is
            //a valid 'exit', return the steps/dist
            if (exitsAtBorder.contains(currCell.row + "," + currCell.col)) {
                return currCell.dist;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if new row & col 'isOutOfBounds'
                if ((newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL)) {
                    continue;
                }

                //skip, if new row & col is blocked with wall cell
                if (maze[newRow][newCol] == '+') {
                    continue;
                }

                //skip, if new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                queue.add(new Cell(newRow, newCol, currCell.dist + 1));
            }
        }
        return -1;
    }

    public void nodesWithHighestEdgeScore_Graph(int[] edges) {
        //https://leetcode.com/problems/node-with-highest-edge-score/

        int V = edges.length;
        long[] edgeScores = new long[V];

        long maxEdgeScore = 0;
        int minNodeWithMaxEdgeScore = V;

        for (int u = 0; u < V; u++) {

            int v = edges[u];
            //here node u has and directed edge to node v(==> u --> v)
            //so we will calculate the edge score for node v, as it has incoming
            //edge from node u, score will be the sum of all those node 'u' that
            //has an incoming edge towards node 'v' ==> edges[u]
            edgeScores[v] += u;

            //a new node 'v' is found that has max edge score, hence this marks
            //as reset to new max edge score and new min node with max edge score
            if (edgeScores[v] > maxEdgeScore) {

                maxEdgeScore = edgeScores[v];
                minNodeWithMaxEdgeScore = v;

            } else if (edgeScores[v] == maxEdgeScore) {
                //if more node 'v' have same max edge score then choose the
                //min node among all those nodes 'v'
                minNodeWithMaxEdgeScore = Math.min(minNodeWithMaxEdgeScore, v);
            }
        }

        //output
        System.out.println("Node with max edge score: " + minNodeWithMaxEdgeScore);
    }

    private long countUnreachablePairOfNodes_Graph_Helper(
            Map<Integer, List<Integer>> graph, Set<Integer> visited, int vertex) {
        //here we will count all the nodes that connected in the given graph
        visited.add(vertex);
        long connectedNodesCount = 1;
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (visited.contains(childVertex)) {
                continue;
            }
            connectedNodesCount += countUnreachablePairOfNodes_Graph_Helper(graph, visited, childVertex);
        }
        return connectedNodesCount;
    }

    public void countUnreachablePairOfNodes_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/
        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solutions/2195836/fully-explained-simple-logic-connected-component-dfs-cpp/
        /*
        graph: n = 5, edges: [[0, 1],[1, 2], [0, 2], [3, 4]]
        undirected graph: 0 ---- 1
        ...................\..../
        .....................2
        .........................
        .........................
        ...................3 --- 4

        there are 2 disconnected graphs in the given graph
        DFS helper method will count the nodes in each of disconnected graph
        1. starting from any of nodes = 0, 1 or 2 connectedNodesCount will be 3 as 3 nodes are there
        in this that are connected
        pairs += connectedNodesCount * (n - connectedNodesCount)
                   3 * (5 - 3)
        means curr nodes count paired with rest of remaining nodes in graph
        3 * 2 = 6

        2. starting from any of nodes = 3 or 4 connectedNodesCount will be 2 as 2 nodes are there
        in this that are connected
        pairs += connectedNodesCount * (n - connectedNodesCount)
                   2 * (5 - 2)
        means curr nodes count paired with rest of remaining nodes in graph
        2 * 3 = 6

        using this we ae counting pairs twice thats why output pair should be / 2

         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        long pairs = 0;
        //in the for loop we will count nodes of connected nodes of sub-graph
        //in the disconnected graph
        for (int u = 0; u < n; u++) {
            if (visited.contains(u)) {
                continue;
            }
            //if the curr src == i is not visited that means this i will be
            //a part of separate disconnected graph then we will do DFS on this
            //to count all the nodes that are connected in this disconnected graph
            long connectedNodesCount = countUnreachablePairOfNodes_Graph_Helper(graph, visited, u);
            pairs += (connectedNodesCount * (n - connectedNodesCount));
        }
        //output
        System.out.println("Count of pairs of nodes that are unreachable from each other: " + (pairs / 2l));
    }

    public int shortestBridge_Graph(int[][] grid) {
        //https://leetcode.com/problems/shortest-bridge/description/
        //https://leetcode.com/problems/shortest-bridge/solutions/189235/java-bidirectional-bfs/
        //based on Number of islands, DFS, BI-DIRECTION BFS
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int ISLAND = 1;
        int VISITED_BY_ISLAND_A = 2;
        int VISITED_BY_ISLAND_B = 3;

        //as there are going to be 2 islands in the grid[][], between which we need
        //to make the bridge
        //island A will hold cell for all the '1' as part of connected island A
        Queue<Cell> islandA = new LinkedList<>();
        //island B will hold cell for all the '1' as part of connected island B
        Queue<Cell> islandB = new LinkedList<>();

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void numberOfIsland_DFS_Helper(int[][] grid, int row, int col, Queue<Cell> island, int VISITED) {
                if (isOutOfBounds(row, col) || grid[row][col] != ISLAND) {
                    return;
                }

                grid[row][col] = VISITED;

                island.add(new Cell(row, col));

                numberOfIsland_DFS_Helper(grid, row - 1, col, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row + 1, col, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row, col - 1, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row, col + 1, island, VISITED);
            }

        }

        Helper helper = new Helper();

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 1) {
                    //if island A is empty then we fill all the cell coord for island A
                    //then we move to fill the cell coord for island B
                    if (islandA.isEmpty()) {
                        //since firstly we fill cells for island A, then we mark all
                        //the connected island parts with VISITED_BY_ISLAND_A (also
                        // says the this whole group is island A)
                        helper.numberOfIsland_DFS_Helper(grid, r, c, islandA, VISITED_BY_ISLAND_A);
                    } else {
                        //since secondly we fill cells for island B, then we mark all
                        //the connected island parts with VISITED_BY_ISLAND_B (also
                        // says the this whole group is island B)
                        helper.numberOfIsland_DFS_Helper(grid, r, c, islandB, VISITED_BY_ISLAND_B);
                    }
                }
            }
        }

        //bi-direction BFS
        //our goal with bi-directional BFS is that, since we have two set of island
        //groups A & B in grid[][], we make a move from both the islands at same
        //time so that when either A touch B OR B touch A at a particular cell, the
        //dist calculated till that touch point is the shortest bridge
        int dist = 0;
        while (!islandA.isEmpty() && !islandB.isEmpty()) {

            //doing BFS from island A side
            int sizeA = islandA.size();
            for (int i = 0; i < sizeA; i++) {

                Cell currCell = islandA.poll();

                for (int[] dir : dirs) {

                    int newRow = currCell.row + dir[0];
                    int newCol = currCell.col + dir[1];

                    //skip if new row & col is out of bounds
                    //OR this new row & col is already a part of the same island A
                    if (helper.isOutOfBounds(newRow, newCol)
                            || grid[newRow][newCol] == VISITED_BY_ISLAND_A) {
                        continue;
                    }

                    //this if block is the point where if A is making a move
                    //and it touches the a cell that is already visited by island B
                    //that means the shortest bridge between these 2 islands is dist
                    //here A touch B
                    if (grid[newRow][newCol] == VISITED_BY_ISLAND_B) {
                        return dist;
                    }

                    //here in this move, island A is currently making a next move
                    //form currCell, so if the above new row & col was not previoulsy
                    //visited by island A and also not visited by island B then this
                    //new row & col is just touched by island A only so mark it
                    //VISITED_BY_ISLAND_A (cell occupied by island A)
                    grid[newRow][newCol] = VISITED_BY_ISLAND_A;
                    islandA.add(new Cell(newRow, newCol));
                }
            }

            //doing BFS from island B side
            int sizeB = islandB.size();
            for (int i = 0; i < sizeB; i++) {

                Cell currCell = islandB.poll();

                for (int[] dir : dirs) {

                    int newRow = currCell.row + dir[0];
                    int newCol = currCell.col + dir[1];

                    //skip if new row & col is out of bounds
                    //OR this new row & col is already a part of the same island B
                    if (helper.isOutOfBounds(newRow, newCol)
                            || grid[newRow][newCol] == VISITED_BY_ISLAND_B) {
                        continue;
                    }

                    //this if block is the point where if B is making a move
                    //and it touches the a cell that is already visited by island A
                    //that means the shortest bridge between these 2 islands is dist + 1
                    //here B touch A
                    if (grid[newRow][newCol] == VISITED_BY_ISLAND_A) {
                        return dist + 1;
                    }

                    //here in this move, island B is currently making a next move
                    //form currCell, so if the above new row & col was not previoulsy
                    //visited by island B and also not visited by island A then this
                    //new row & col is just touched by island B only so mark it
                    //VISITED_BY_ISLAND_B (cell occupied by island B)
                    grid[newRow][newCol] = VISITED_BY_ISLAND_B;
                    islandB.add(new Cell(newRow, newCol));
                }
            }

            //since both island A & island B are moving simultaneously
            //in the single BFS move, both are travelling 1 dist from their
            //respec currCells, so 1 move from island A cell & 1 move from island B cell
            //adds up to +2 dist move
            dist += 2;
        }
        return 1;
    }

    public void detonateMaxBombs_Graph(int[][] bombs) {
        //https://leetcode.com/problems/detonate-the-maximum-bombs/description/
        //https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/1623297/python-bfs-dfs-start-with-every-point-explanation/
        //based on BFS
        int n = bombs.length;
        int X = 0;
        int Y = 1;
        int RADIUS = 2;

        Map<Integer, List<Integer>> graph = new HashMap<>();

        //create the directed graph where a bomb[j] coord falls under the area of
        //bomb[i], that means if bomb[i] is started with detonation then all the
        //v-index bombs connected to i-index bomb will be exploded
        //why directed? because if bomb[i] is able to explode bomb[j] it is not
        //always true that bomb[j] can also explode bomb[i] because of the dist
        //& radius range between them, as bomb[j] radius might be so small that
        //it is not able to cover the dist to bomb[i] hence graph become directed
        for (int u = 0; u < n; u++) {

            int[] bombU = bombs[u];

            long explosionAreaBombU = (long) Math.pow(bombU[RADIUS], 2);

            for (int v = 0; v < n; v++) {

                if (u == v) {
                    continue;
                }

                int[] bombV = bombs[v];

                long xSqr = (long) Math.pow(bombU[X] - bombV[X], 2);
                long ySqr = (long) Math.pow(bombU[Y] - bombV[Y], 2);

                //euclidean dist between the 2 centers coords:
                //(dist^2 = (x2 - x1)^2 + (y2 - y1)^2)
                //of curr bomb[u] and curr bomb[v]
                long distance = xSqr + ySqr;

                //if the dist between the 2 centers coords is covered under the
                //bomb[u] explosion range, then bombU has directed edge towards
                //bombV meaning bombU will irectly explode bombV
                if (distance <= explosionAreaBombU) {
                    graph.putIfAbsent(u, new ArrayList<>());
                    graph.get(u).add(v);
                }
            }
        }

        int maxExplode = 0;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();

        //if curr srcBomb is detonated then from this point how many further
        //'level' of bombs that can be chain-exploded, choose the maxExplode
        //using BFS to find max level of chained-explosion
        for (int srcBomb = 0; srcBomb < n; srcBomb++) {

            visited = new boolean[n];

            queue.add(srcBomb);
            visited[srcBomb] = true;

            int explode = 0;

            while (!queue.isEmpty()) {

                int currBomb = queue.poll();

                for (int childBomb : graph.getOrDefault(currBomb, new ArrayList<>())) {

                    if (visited[childBomb]) {
                        continue;
                    }

                    visited[childBomb] = true;

                    queue.add(childBomb);
                }
                explode++;
            }
            maxExplode = Math.max(maxExplode, explode);
        }

        //output
        System.out.println("Detonate max bombs: " + maxExplode);
    }

    public void findAllGroupOfFarmland_Graph(int[][] land) {
        //https://leetcode.com/problems/find-all-groups-of-farmland/description/
        //based on numberOfIsland(), DFS
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = land.length;
        int COL = land[0].length;

        int FARM_LAND = 1;

        //number of islands helper
        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void numberOfIsland(int[][] land, int row, int col, Cell bottomRight) {
                if (isOutOfBounds(row, col)) {
                    return;
                }

                if (land[row][col] != FARM_LAND) {
                    return;
                }

                //find the farthest posiible row & col of farmland (== 1)
                bottomRight.row = Math.max(bottomRight.row, row);
                bottomRight.col = Math.max(bottomRight.col, col);

                //curr farmland at row & col is visited
                land[row][col] = 0;

                //DFS on curr farmland to go in depth/far of the land
                //to find the max row & col of this farmland
                numberOfIsland(land, row - 1, col, bottomRight);
                numberOfIsland(land, row + 1, col, bottomRight);
                numberOfIsland(land, row, col - 1, bottomRight);
                numberOfIsland(land, row, col + 1, bottomRight);
            }
        }

        //contains the top-left and bottom-right row & col in int[] for
        //all the farm/ island
        List<int[]> groupsOfFarmland = new ArrayList<>();

        Helper helper = new Helper();

        for (int topLeftRow = 0; topLeftRow < ROW; topLeftRow++) {

            for (int topLeftCol = 0; topLeftCol < COL; topLeftCol++) {

                if (land[topLeftRow][topLeftCol] != FARM_LAND) {
                    continue;
                }
                //starting from topLeftRow & topLeftCol as the start point
                //find the farthest row and col of this farm/ island
                //in the bottomRight.
                Cell bottomRight = new Cell(topLeftRow, topLeftCol);

                helper.numberOfIsland(land, topLeftRow, topLeftRow, bottomRight);

                groupsOfFarmland.add(new int[]{topLeftRow, topLeftCol, bottomRight.row, bottomRight.col});
            }
        }
        //output
        //return coord.toArray(new int[coord.size()][]);
        groupsOfFarmland.stream().forEach(farmCoord -> System.out.println(Arrays.toString(farmCoord)));
        System.out.println();
    }

    private void sumOfDistancesInTree_Graph_DFS1(Map<Integer, List<Integer>> graph,
                                                 int[] distances, int[] count, int vertex, int parent) {
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (childVertex == parent) {
                continue;
            }
            sumOfDistancesInTree_Graph_DFS1(graph, distances, count, childVertex, vertex);
            count[vertex] += count[childVertex];
            distances[vertex] += distances[childVertex] + count[childVertex];
        }
    }

    private void sumOfDistancesInTree_Graph_DFS2(Map<Integer, List<Integer>> graph,
                                                 int[] distances, int[] count, int vertex, int parent, int n) {
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (childVertex == parent) {
                continue;
            }
            distances[childVertex] = distances[vertex] - count[childVertex] + n - count[childVertex];
            sumOfDistancesInTree_Graph_DFS2(graph, distances, count, childVertex, vertex, n);
        }
    }

    public void sumOfDistancesInTree_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/sum-of-distances-in-tree/description/
        //https://leetcode.com/problems/sum-of-distances-in-tree/solutions/130611/sum-of-distances-in-tree/
        int[] distances = new int[n];
        int[] count = new int[n];

        Arrays.fill(count, 1);

        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        sumOfDistancesInTree_Graph_DFS1(graph, distances, count, 0, -1);
        sumOfDistancesInTree_Graph_DFS2(graph, distances, count, 0, -1, n);
        //output
        System.out.println("Sum of distances in tree: " + Arrays.toString(distances));
    }

    public void allAncestorsOfAllNodesInDAG_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/
        //based on BFS
        List<List<Integer>> ancestors = new ArrayList<>();
        //here create a graph that will hold the relation of child -> [parents]
        Map<Integer, Set<Integer>> parentGraph = new HashMap<>();
        for (int[] edge : edges) {
            //u == parent
            int u = edge[0];
            //v == child
            int v = edge[1];

            parentGraph.putIfAbsent(v, new HashSet<>());
            //child -> [parents]
            parentGraph.get(v).add(u);
        }

        Queue<Integer> queue = new LinkedList<>();

        for (int node = 0; node < n; node++) {

            boolean[] visited = new boolean[n];

            queue.add(node);
            visited[node] = true;

            //here node == child node, we will find all the ancestors of this
            //child node using BFS, since we are maintaining visited[] so that
            //we don't visit same node again, hence our ancestors list will be
            //distinct
            List<Integer> nodeAncestors = new ArrayList<>();

            while (!queue.isEmpty()) {

                int currChildVertex = queue.poll();

                //traverse back from curr child vertex to back to its parent vertex
                for (int parentVertex : parentGraph.getOrDefault(currChildVertex, new HashSet<>())) {

                    //if two nodes share the same parent vertex, then in that case
                    //we don't want to traverse multiple times on that parent vertex
                    //this will also prevent to consider duplicated ancestor nodes
                    //in the 'nodeAncestors' list
                    if (visited[parentVertex]) {
                        continue;
                    }

                    //since the graph has a relation of child -> [parents], so when we
                    //traverse from curr child vertex to its parent vertex, that parent
                    //will be called as the ancestor
                    nodeAncestors.add(parentVertex);

                    visited[parentVertex] = true;
                    queue.add(parentVertex);
                }
            }

            //as all the ancestors of the curr node are required in sorted order
            Collections.sort(nodeAncestors);

            ancestors.add(new ArrayList<>(nodeAncestors));
        }
        //output
        System.out.println("All ancestors of all nodes in directed acyclic graph: " + ancestors);
    }

    public void kThAncestorOfTreeNode_Graph(int n, int[] parent, int[][] queries) {
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/solutions/686256/java-treemap/
        //child to ancestor wise graph
        //<child, <k-th ancestor level, parent>>
        Map<Integer, TreeMap<Integer, Integer>> graph = new HashMap<>();

        int level = 1;

        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;

            graph.put(v, new TreeMap<>());
            //u is the 1-level parent of child v
            graph.get(v).put(level, u);
        }

        class Helper {

            int getKthAncestorNode(int childNode, int k) {

                //since 0 is the root node and -1 is the default parent of the root == 0
                //so if the query is for the root node(childNode == root == 0) we should
                //return -1 as there can't be any ancestor above the root node
                if (k > 0 && (childNode == 0 || childNode == -1)) {
                    return -1;
                }

                //if for the curr childNode we can have its k-th ancestor level, simply
                //return the ancestor node of the curr childNode at k-th level
                if (graph.get(childNode).containsKey(k)) {
                    return graph.get(childNode).get(k);
                }

                //if the k-th ancestor level is not have found for the curr childNode
                //then we will start finding the closest reachable ancestor node's
                //level (i.e, floorKey(k) will give the closest ancestor level from curr
                //k-th level that will be reachableAncestorLevel <= k)
                int reachableAncestorLevel = graph.get(childNode).floorKey(k);
                //curr ancestor node at the closest reachable ancestor level
                int reachableAncestorNode = graph.get(childNode).get(reachableAncestorLevel);

                //recursively find the remaing k - reachableAncestorLevel from the closest
                //reachable ancestor node (== reachableAncestorNode) of curr childNode
                int ancestorNode = getKthAncestorNode(
                        reachableAncestorNode,
                        k - reachableAncestorLevel);

                //also store the newly found k-th ancestor node of curr childNode
                //the child -> {kth, ancestor node} graph
                graph.get(childNode).put(k, ancestorNode);

                return ancestorNode;
            }
        }

        Helper helper = new Helper();

        for (int[] query : queries) {
            int node = query[0];
            int ancestorLevel = query[1];
            int ancestorNode = helper.getKthAncestorNode(node, ancestorLevel);
            System.out.println("K-th: " + ancestorLevel + " of parent node: " + node + " is: " + ancestorNode);
        }
    }

    public void coloringBorders_Graph(int[][] grid, int row, int col, int color) {
        //https://leetcode.com/problems/coloring-a-border/description/
        //actual:
        System.out.println("Actual grid: ");
        for (int[] rows : grid) {
            System.out.println(Arrays.toString(rows));
        }

        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];
        Queue<Cell> queue = new LinkedList<>();

        queue.add(new Cell(row, col));
        visited[row][col] = true;

        List<Cell> borderCells = new ArrayList<>();

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];
                //as per question,
                //The border of a connected component is all the squares in the
                //connected component that are either adjacent to (at least) a
                //square not in the component, or on the boundary of the grid
                //(the first or last row or column).

                //we can that curr cell row & col is at border(TOP, BOTTOM, LEFT, RIGHT)
                //if one of 4-dirs from this curr cell row & col is out of the grid
                //making it 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL
                        //if the curr cell row & col is not at the border(TOP, BOTTOM, LEFT, RIGHT)
                        //but still can be called a border cell, if the next cell row & col from
                        //its 4-dirs has diff color than the color of given src(row, col) of grid[][]
                        || grid[newRow][newCol] != grid[currCell.row][currCell.col]) {

                    borderCells.add(currCell);
                    continue;
                }

                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                queue.add(new Cell(newRow, newCol));

            }
        }

        for (Cell cell : borderCells) {
            grid[cell.row][cell.col] = color;
        }

        //output
        System.out.println("Coloring border grid: ");
        for (int[] rows : grid) {
            System.out.println(Arrays.toString(rows));
        }
    }

    private int minTimeToCollectAllApplesInATree_Graph_Helper(
            Map<Integer, List<Integer>> graph, boolean[] hasApple, int root, int parent) {

        int totalTimeTaken = 0;
        int timeTakenToFetchApplesAndComeBack = 0;

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {

            if (childRoot == parent) {
                continue;
            }

            timeTakenToFetchApplesAndComeBack = minTimeToCollectAllApplesInATree_Graph_Helper(
                    graph, hasApple, childRoot, root);

            //as we are doing a recursive call to curr childRoot's subtree, in a
            //hope that there are apples in the substree then the time to reach
            //that node in the subtree and come back to curr childRoot will take
            //some time 'timeTakenToFetchApplesAndComeBack', now if there actually
            //has apples and we fetched it then definitely the time taken is more
            //than 0 (==> timeTakenToFetchApplesAndComeBack > 0) then we must add
            //up this time taken into 'totalTimeTaken' also +2 (==> +1 coming to
            //this childRoot node from its parent and +1 to go back to the parent
            //as curr childRoot will go back to its parent recursive call with this
            //+2 time taken added)
            //OR
            //even if there were no apples in childRoot's subtree means
            //'timeTakenToFetchApplesAndComeBack' must have returned 0 BUT if the curr
            //childRoot itself has apples(==> hasApple[childRoot]) then we must
            //add +2 time in 'totalTimeTaken' (==> +1 coming to
            //this childRoot node from its parent and +1 to go back to the parent
            //as curr childRoot will go back to its parent recursive call with this
            //+2 time taken added)
            //this would mean totalTimeTaken += 0 +2
            if (timeTakenToFetchApplesAndComeBack > 0 || hasApple[childRoot]) {
                totalTimeTaken += timeTakenToFetchApplesAndComeBack + 2;
            }
        }
        return totalTimeTaken;
    }

    public void minTimeToCollectAllApplesInATree_Graph(int n, int[][] edges, boolean[] hasApple) {
        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/
        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/2864715/minimum-time-to-collect-all-apples-in-a-tree/
        /*
        Given edges[][] are of tree
        Here we have to start dfs from root and add up all the time taken to reach
        nodes that has apple (== hasApple[node] = true)
        hasApple[] = [false,false,true,false,true,true,false]
        tree nodes/index that has apples = [2,4,5]
        tree: ................0
        ..................../...\
        ...................1.....2
        ................../.\.../.\
        .................4...5..3..6

        route to pick apple and back to root again:
        0 -> 1 -> 4 -> 1 -> 5 -> 1 -> 0 -> 2 -> 0
        each path in this route takes 1 unit of time = timeTaken = 8

        Intution is to calulate the time to reach a node with apple and back to root
        ex here node 4, 5 & 2 has apple
        node: 2 = 0 -> 2 -> 0 = 2 unit time
        node: 4 = 0 -> 1 -> 4 -> 1 -> 0 = 4 unit time
        node: 5 = 0 -> 1 -> 4 -> 1 -> 0 = 4 unit time

        but technically there is a route common to them (0 -> 1 -> 0)
        optimal route be:
        0 -> 1 -> 4 -> 1 -> 5 -> 1 -> 0 = 6 unit time
        0 -> 2 -> 0 = 2 unit time
        so totalTime = 6 + 2 = 8 unit time

        so calculate time, each parent to its immediate child that will always be 2
        meaning parent -> child -> parent again
        0 -> 1 -> 0 = 2 unit time
        1 -> 4 -> 1 = 2 unit time
        1 -> 5 -> 1 = 2 unit time
        0 -> 2 -> 0 = 2 unit time
        2 -> 3 -> 2 = 2 unit time
        2 -> 6 -> 2 = 2 unit time

        for each curr root node, while itertaing over its childRoot using dfs calls
        we will consider two possibility
        1. if the childRoot's subtree also has some apples in it so there will be
        some time taken to fetch them in that case timeTakenToFetchApplesAndComeBack > 0
        2. we will also check if that childRoot is a node that hasApple[node] == true

        if any of these cond meets
        if (timeTakenToFetchApplesAndComeBack > 0 || hasApple[childRoot]) {
            totalTimeTaken += timeTakenToFetchApplesAndComeBack + 2;
        }

        totalTimeTaken will be time taken to fetch apples in child's subtree
        + time taken between curr parent -> child -> parent == 2 unit time

         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        int timeTaken = minTimeToCollectAllApplesInATree_Graph_Helper(graph, hasApple, root, -1);
        //output
        System.out.println("Time taken to collect all apples and return back to root: " + timeTaken);
    }

    private Map<Character, Integer> numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
            Map<Integer, List<Integer>> graph, int root, int parent,
            String labels, int[] nodesWithSameLabelInSubtree) {

        Map<Character, Integer> rootToLabelCount = new HashMap<>();

        //add 1 for the label associated with this curr root
        char rootLabel = labels.charAt(root);
        rootToLabelCount.put(rootLabel, 1);

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {
            //skip, if the childRoot is same as its parent because given undirected
            //graph is a tree
            if (childRoot == parent) {
                continue;
            }

            //childRoots will return the count of labels for itself and their subtrees
            Map<Character, Integer> subtreeNodesToLabelCount
                    = numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
                    graph, childRoot, root, labels, nodesWithSameLabelInSubtree);

            //merge all childRoots subtree lable counts in the curr root's
            //currRootLabelFreq one by one
            for (char childRootLabel : subtreeNodesToLabelCount.keySet()) {
                //if already the key exist in curr root's label count then add this
                //childRoot subtree's label counts with that existing freq
                rootToLabelCount.put(childRootLabel,
                        rootToLabelCount.getOrDefault(childRootLabel, 0)
                                + subtreeNodesToLabelCount.get(childRootLabel));
            }
        }

        //now fetch how many counts are there in curr root's subtree that matches
        //the label as that of curr root(== currRootlabel)
        nodesWithSameLabelInSubtree[root] = rootToLabelCount.get(rootLabel);

        return rootToLabelCount;
    }

    public void numberOfNodesInSubtreeWithSameLabel_Graph(int n, int[][] edges, String labels) {
        //https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description/
        /*
        Given edges[][] is of tree(could be n-ary tree)
        labels = "abaedcd" where i-th belongs to labels[i-th node]
        ==> [0 = a, 1 = b, 2 = a, 3 = e, 4 = d, 5 = c, 6 = d]
        tree: ................0
        ..................../...\
        ...................1.....2
        ................../.\.../.\
        .................4...5..3..6

        **DFS call will go in depth first simulating Bottom-top recursion stack**

        nodes 4, 5, 3, 6 being leaf nodes so they will count labels for themselves

        callStack(root = 4, parent = 1)

            char currRootLabel = labels.charAt(root); == d
            currRootLabelFreq.put(currRootLabel, 1); == {d = 1}

            for(childRoot : graph[4] -> [1]) childRoot == parent == 1 ==> skipped and loop end

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {d = 1} = 1
            ==result[4] = 1

            return currRootLabelFreq == {d = 1} to parent root == 1

        callStack(root = 5, parent = 1)

            char currRootLabel = labels.charAt(root); == c
            currRootLabelFreq.put(currRootLabel, 1); == {c = 1}

            for(childRoot : graph[5] -> [1]) childRoot == parent == 1 ==> skipped and loop end

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {c = 1} = 1
            ==result[5] = 1

            return currRootLabelFreq == {c = 1} to parent root == 1

        callStack(root = 3, parent = 2)

            char currRootLabel = labels.charAt(root); == e
            currRootLabelFreq.put(currRootLabel, 1); == {e = 1}

            for(childRoot : graph[3] -> [2]) childRoot == parent == 2 ==> skipped and loop end

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {e = 1} = 1
            ==result[3] = 1

            return currRootLabelFreq == {e = 1} to parent root == 2

        callStack(root = 6, parent = 2)

            char currRootLabel = labels.charAt(root); == d
            currRootLabelFreq.put(currRootLabel, 1); == {d = 1}

            for(childRoot : graph[6] -> [2]) childRoot == parent == 2 ==> skipped and loop end

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {d = 1} = 1
            ==result[6] = 1

            return currRootLabelFreq == {d = 1} to parent root == 2

        **moving back to parent callStack**
        node 1, 2

        callStack(root = 1, parent = 0)

            char currRootLabel = labels.charAt(root); == b
            currRootLabelFreq.put(currRootLabel, 1); == {b = 1}

            for(childRoot : graph[1] -> [0,4,5])
                1. childRoot == parent == 0 ==> skipped

                2. childRoot == 4, currChildRootSubtreeLabelFreq = {d = 1}
                merge with currRootLabelFreq == {b = 1, d = 1}

                3. childRoot == 5, currChildRootSubtreeLabelFreq = {c = 1}
                merge with currRootLabelFreq == {b = 1, d = 1, c = 1}
                loop end...

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {b = 1} = 1
            ==result[1] = 1

            return currRootLabelFreq == {b = 1, d = 1, c = 1} to parent root == 0

        callStack(root = 2, parent = 0)

            char currRootLabel = labels.charAt(root); == a
            currRootLabelFreq.put(currRootLabel, 1); == {a = 1}

            for(childRoot : graph[2] -> [0,3,6])
                1. childRoot == parent == 0 ==> skipped

                2. childRoot == 3, currChildRootSubtreeLabelFreq = {e = 1}
                merge with currRootLabelFreq == {a = 1, e = 1}

                3. childRoot == 5, currChildRootSubtreeLabelFreq = {d = 1}
                merge with currRootLabelFreq == {a = 1, e = 1, d = 1}
                loop end...

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {a = 1} = 1
            ==result[2] = 1

            return currRootLabelFreq == {a = 1, e = 1, d = 1} to parent root == 0

        **moving back to parent callStack**
        node 0

        callStack(root = 0, parent = -1)

            char currRootLabel = labels.charAt(root); == a
            currRootLabelFreq.put(currRootLabel, 1); == {a = 1}

            for(childRoot : graph[0] -> [1,2])
                1. childRoot == 1, currChildRootSubtreeLabelFreq = {b = 1, d = 1, c = 1}
                merge with currRootLabelFreq == {a = 1, b = 1, d = 1, c = 1}

                2. childRoot == 5, currChildRootSubtreeLabelFreq = {a = 1, e = 1, d = 1}
                merge with currRootLabelFreq == {a = 2, b = 1, d = 2, c = 1, e = 1}
                loop end...

            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {a = 2} = 2
            ==result[0] = 2

            return currRootLabelFreq == {a = 2, b = 1, d = 2, c = 1, e = 1} to main call()

        **END**


         */
        int[] nodesWithSameLabelInSubtree = new int[n];
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
                graph, root, -1, labels, nodesWithSameLabelInSubtree);

        //output
        System.out.println("Number of nodes in subtree with same label: " + Arrays.toString(nodesWithSameLabelInSubtree));
    }

    private int longestPathWithDiffAdjacentCharsInTree_Graph_Helper(
            Map<Integer, List<Integer>> graph, String labels, int root, int parent) {

        //label associated with curr root
        int currRootLabel = labels.charAt(root);

        //2 branches from the curr root node that will the max path length from the
        //curr root node
        int firstMaxChildPathLength = 0;
        int secondMaxChildPathLength = 0;

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {

            //skip, if the childRoot is same as parent as given undirected graph
            //is a tree
            if (childRoot == parent) {
                continue;
            }

            //label associated with child root
            int childRootLabel = labels.charAt(childRoot);

            //do dfs call for the childRoot to calculate the path lengths from
            //child to its parent
            int childRootPathLength = longestPathWithDiffAdjacentCharsInTree_Graph_Helper(
                    graph, labels, childRoot, root);

            //skip, because as per question, a path should not have two adjacent
            //nodes having same char label, so here if the curr root and one of
            //its childRoot have the same char label it is not required to count
            //that path comming from this childRoot
            if (childRootLabel == currRootLabel) {
                continue;
            }

            //finding the 2 max height branches from curr root
            if (childRootPathLength > firstMaxChildPathLength) {

                secondMaxChildPathLength = firstMaxChildPathLength;
                firstMaxChildPathLength = childRootPathLength;

            } else if (childRootPathLength > secondMaxChildPathLength) {

                secondMaxChildPathLength = childRootPathLength;
            }
        }

        //now the longestPath can be formed from this curr root node and including
        //2 branches of max paths
        longestPathWithDiffAdjacentCharsInTree_LongestLength = Math.max(
                longestPathWithDiffAdjacentCharsInTree_LongestLength,
                //2 branches of max path + 1 for curr root
                firstMaxChildPathLength + 1 + secondMaxChildPathLength);

        //now choose the max from both max branches/path + 1 for curr root node
        return Math.max(firstMaxChildPathLength, secondMaxChildPathLength) + 1;
    }

    private int longestPathWithDiffAdjacentCharsInTree_LongestLength;

    public void longestPathWithDiffAdjacentCharsInTree_Graph(int[] parent, String labels) {
        //https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/
        //somewhat based on DIAMETER OF TREE
        /*

        ex: parent[] = [-1, 0, 1], label = "aab"
        tree:
        ..........................0(a)
        ......................../
        .......................1(a)
        ....................../
        .....................2(b)

        output is path length  = 2 for path 1(a) -> 2(b), this path don't have
        two adjacent nodes having same char

        **simulating DFS call stacks**

        main: call(0, -1)

        #0 call(0, -1)
            ==> for(childRoot : graph[0] ==> [-1, 1])

            ===> 1. childRoot = -1
            if(childRoot == parent) ==> (-1 == -1) SKIPPED

            ===> 2. childRoot = 1
            call(1, 0) ==> #1

        #1 call(1, 0)
            ==> for(childRoot : graph[1] ==> [0, 2])

            ===> 1. childRoot = 0
            if(childRoot == parent) ==> (0 == 0) SKIPPED

            ===> 2. childRoot = 2
            call(2, 1) ==> #2

        #2 call(2, 1)
            ==> for(childRoot : graph[2] ==> [1])

            ===> 1. childRoot = 1
            if(childRoot == parent) ==> (1 == 1) SKIPPED

            ...LOOP END..

            longestPath = max(longestPath, firstMaxChildPathLength + 1 + secondMaxChildPathLength);
            ==> max(0, 0 + 1 + 0) ==> 1

            return max(firstMaxChildPathLength, secondMaxChildPathLength) + 1 ==> 1 back to #1

        #1 childRootPathLength = call(2, 1) ==> 1 ret from #2

            if(rootLabel == childRootLabel) ==> (a == b) ==> FAILED

            if(childRootPathLength > firstMaxChildPathLength)
            ===> secondMaxChildPathLength = firstMaxChildPathLength ==> 0
            ===> firstMaxChildPathLength = childRootPathLength ==> 1

            ...LOOP END..

            longestPath = max(longestPath, firstMaxChildPathLength + 1 + secondMaxChildPathLength);
            ==> max(1, 1 + 1 + 0) ==> 2

            return max(firstMaxChildPathLength, secondMaxChildPathLength) + 1 ==> 2 back to #0

        #0: childRootPathLength = call(1, 0) ==> 2 ret from #1

            if(rootLabel == childRootLabel) ==> (a == a) ==> SKIPPED

            ...LOOP END..

            longestPath = max(longestPath, firstMaxChildPathLength + 1 + secondMaxChildPathLength);
            ==> max(2, 0 + 1 + 0) ==> 2

            return max(firstMaxChildPathLength, secondMaxChildPathLength) + 1 ==> 1 back to #main

         */
        int n = parent.length;

        longestPathWithDiffAdjacentCharsInTree_LongestLength = 0;

        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        longestPathWithDiffAdjacentCharsInTree_Graph_Helper(graph, labels, root, -1);

        //output
        System.out.println("Longest path with diff adjacent chars: "
                + longestPathWithDiffAdjacentCharsInTree_LongestLength);
    }

    private int lexicographicallySmallestEquivalentString_Graph_Helper(
            Map<Character, Set<Character>> graph, char vertex, boolean[] visited, Set<Character> connectedComponent) {

        visited[vertex - 'a'] = true;

        connectedComponent.add(vertex);

        int minCharAscii = vertex;

        for (char childVertex : graph.getOrDefault(vertex, new HashSet<>())) {

            if (visited[childVertex - 'a']) {
                continue;
            }

            minCharAscii = Math.min(
                    minCharAscii,
                    lexicographicallySmallestEquivalentString_Graph_Helper(
                            graph, childVertex, visited, connectedComponent));
        }

        return minCharAscii;
    }

    public void lexicographicallySmallestEquivalentString_Graph(String str1, String str2, String baseStr) {
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2867563/lexicographically-smallest-equivalent-string/
        /*
        str1 = "parker", str2 = "morris", baseStr = "parser"
        smallestString = "makkek"

        undirected edges between the chars of str1 & str2
        p -> m | m -> p
        a -> o | o -> a
        r -> r | r -> r
        k -> r | r -> k
        e -> i | i -> e
        r -> s | s -> r

        simplified groups of char/ connected component in graph
        [m, p] = m & p has relation with each other == smallestChar = m
        [a, o] = a & o has relation with each other == smallestChar = a
        [k, r, s] = r, k & s has relation with each other == smallestChar = k
        [e, i] = e & i has relation with each other == smallestChar = e

        so smallestChar will be mapped like
        for m = minChar = m
        for p = minChar = m
        for a = minChar = a
        for o = minChar = a
        for k = minChar = k
        for r = minChar = k
        for s = minChar = k
        for e = minChar = e
        for i = minChar = e

        now each char for baseStr if this char is in minCharMap then get that
        smallestChar otherwise keep the same char from baseStr as it is

         */
        //given str1.length = str2.length = n
        int n = str1.length();

        Map<Character, Set<Character>> graph = new HashMap<>();

        for (int i = 0; i < n; i++) {

            char u = str1.charAt(i);
            char v = str2.charAt(i);

            if (u == v) {
                continue;
            }

            graph.put(u, new HashSet<>());
            graph.get(u).add(v);

            graph.put(v, new HashSet<>());
            graph.get(v).add(u);
        }

        //all the chars from str1 and str2 that can be associated to some smallest
        //char in their connected component nodes
        char[] smallestCharMap = new char[26];
        boolean[] visited = new boolean[26];

        for (char chr = 'a'; chr <= 'z'; chr++) {

            //skip, if curr chr is already visited
            if (visited[chr - 'a']) {
                continue;
            }

            //all the connected component nodes from curr chr
            Set<Character> connectedComponentNodes = new HashSet<>();

            //do dfs from curr chr to all of its connected component nodes
            //during this dfs we will do 2 things
            //1. save all those connected component in connectedComponentNodes
            //2. find and return the smallest char ascii out of all its connected
            //vertex (means find the smallest char in a particular connected graph
            //of chars from chr)
            int smallestCharAscii = lexicographicallySmallestEquivalentString_Graph_Helper(
                    graph, chr, visited, connectedComponentNodes);

            //all the connected component from/including curr chr will have same
            //smallest char ascii associated to them
            for (char node : connectedComponentNodes) {
                smallestCharMap[node - 'a'] = (char) smallestCharAscii;
            }
        }

        StringBuilder smallestString = new StringBuilder();
        //to make the lexicographically equivalent smallest string for the
        //baseStr made from str1 and str2
        for (char chr : baseStr.toCharArray()) {
            //if we have any minChar associated to curr chr then get that
            //else we will keep chr as default char in our smallest string
            smallestString.append(smallestCharMap[chr - 'a']);
        }

        //output
        System.out.println("Lexicographically smallest equivalent string: " + smallestString.toString());
    }

    private void accountsMerge_Graph_Helper(
            Map<String, List<String>> graph, String email, List<String> connectedEmails, Set<String> visited) {

        visited.add(email);
        connectedEmails.add(email);

        for (String childEmail : graph.getOrDefault(email, new ArrayList<>())) {

            if (visited.contains(childEmail)) {
                continue;
            }

            accountsMerge_Graph_Helper(graph, childEmail, connectedEmails, visited);
        }
    }

    public void accountsMerge_Graph(String[][] accounts) {
        //https://leetcode.com/problems/accounts-merge/description/
        //based on GRAPH, CONNECTED COMPONENT
        /*
        accounts[][] = [
        ["John","johnsmith@mail.com","john_newyork@mail.com"],
        ["John","johnsmith@mail.com","john00@mail.com"],
        ["Mary","mary@mail.com"],
        ["John","johnnybravo@mail.com"]]

        email 'johnnybravo@mail.com' also has owner name as 'John' just like
        other 2 'John' accounts but 'johnnybravo@mail.com' is not a common email to
        any of the other 2 accounts of 'John'

        graph = {
            johnsmith@mail.com = [john_newyork@mail.com, john00@mail.com],
            john_newyork@mail.com = [johnsmith@mail.com],
            john00@mail.com = [johnsmith@mail.com],
            mary@mail.com = [],
            johnnybravo@mail.com = []
        }
         */
        List<List<String>> mergedAccounts = new ArrayList<>();
        //graph will hold all the emails that are connected to each other
        Map<String, List<String>> graph = new HashMap<>();
        Map<String, String> emailToOwner = new HashMap<>();
        Set<String> visited = new HashSet<>();

        //since we need to merge accounts based on emails, where the cond for this
        //merge is a particular email say: emailX is present in multiple
        //account[] in accounts[][] then all this account[] should be merged into one
        //and all emails in the merged account should be sorted as well
        //accounts[][] = [[owner1, email1, email2, emailX,...],
        //[owner2, email3, email4, email5,...],
        //[owner1, email6, email7, emailX,...]]
        //so here account for owner1 should be merged as they have emailX common
        //[[owner1, email1, email2, email6, email7, emailX], [owner2, email3, email4, email5,...]]
        //curr owner's all account
        //ex: [owner, email1, email2, ...]
        for (String[] account : accounts) {

            //owner will be at 0-th index
            String emailOwner = account[0];

            //creating graph for all connected emails, hence starting from 1
            //(starting index of emails as 0-th index has owner)
            for (int i = 1; i < account.length; i++) {

                //i-th index will be src email == i
                String emailU = account[i];

                //map all unique u-emails to their owner as well
                emailToOwner.put(emailU, emailOwner);

                //now going to store all other emails in this same account
                //where each u-email connected to v-email and vice versa in
                //undirected graph way
                graph.putIfAbsent(emailU, new ArrayList<>());

                for (int j = i + 1; j < account.length; j++) {

                    String emailV = account[j];

                    //u-email -> v-email
                    graph.get(emailU).add(emailV);

                    //v-email -> u-email
                    graph.putIfAbsent(emailV, new ArrayList<>());
                    graph.get(emailV).add(emailU);

                    //also map all unique v-emails to their owner as well
                    emailToOwner.put(emailV, emailOwner);
                }
            }
        }

        //now we have all unique emails mapped to their owner
        //so considering each email as a srcEmail do a dfs on it find out all the
        //connected emails attached to it
        for (String srcEmail : emailToOwner.keySet()) {

            //as output requires owner in it
            String emailOwner = emailToOwner.get(srcEmail);

            //if a particular src email is already visited that means this src email
            //has already been a part of a connected email group that has previously
            //been traveresed
            if (visited.contains(srcEmail)) {
                continue;
            }

            //now if a src email is not visited, we have to find all the connected
            //emails to it
            List<String> connectedEmails = new ArrayList<>();

            //do dfs call to find & list together all the connected emails to this
            //src email
            accountsMerge_Graph_Helper(graph, srcEmail, connectedEmails, visited);

            //since we needed the connected emails in sorted order
            Collections.sort(connectedEmails);
            //also output should have onwer of this connected email group
            connectedEmails.add(0, emailOwner);

            //put this merged connected email group in result list
            mergedAccounts.add(connectedEmails);
        }

        //output
        System.out.println("Account merged: " + mergedAccounts);
    }

    public void snakesAndLadder_Graph(int[][] board) {
        //https://leetcode.com/problems/snakes-and-ladders/description/
        //https://leetcode.com/problems/snakes-and-ladders/solutions/2912646/snakes-and-ladders/
        //based on GRAPH, DJIKSTRA ALGO
        //board is n * n matrix
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int n = board.length;
        int target = n * n;

        List<Integer> cols = new ArrayList<>();
        for (int col = 0; col < n; col++) {
            cols.add(col);
        }

        int startLabel = 1;

        Cell[] labelToCell = new Cell[target + 1];
        int currLabel = startLabel;

        for (int row = n - 1; row >= 0; row--) {

            for (int col : cols) {

                labelToCell[currLabel] = new Cell(row, col);
                currLabel++;
            }
            //reverse col after creating labels for each row, this ways the actual
            //snakes & ladder board will have its look
            Collections.reverse(cols);
        }

        //since we need to find the min dist/steps to reach the target(== n * n)
        //cell but inorder to include that target in dist we need target + 1 size
        int[] dist = new int[target + 1];

        int UNREACHABLE = -1;
        //default dist/steps to reach i-th label cell in board is UNREACHABLE
        Arrays.fill(dist, UNREACHABLE);

        //we always have to start from 1 just like actual snake & ladded game
        //so dist/steps to reach the start label is 0 (basic djikstra)
        dist[startLabel] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(startLabel);

        while (!queue.isEmpty()) {

            currLabel = queue.poll();

            //this will simulate generating the next possible value from curr label
            //if we roll a dice on board
            int start = currLabel + 1;
            int end = Math.min(currLabel + 6, target);

            for (int nextLabel = start; nextLabel <= end; nextLabel++) {
                //actual row & col location for the next label generated here
                int row = labelToCell[nextLabel].row;
                int col = labelToCell[nextLabel].col;

                //from this actual row & col location, we will check what can be
                //the possible next move based on the info given in board[][]
                //if board[row][col] == -1 means we can move to that next label
                //if board[row][col] != -1 means there is either snake or ladder
                //which will give you dest label (dest to snake tail after snake
                //bite or ladder top after climbing ladder)
                int destLabel = board[row][col] == UNREACHABLE ? nextLabel : board[row][col];

                //if previously this dest label was unreachable(== -1)
                //now it can be reached by dist[currLabel] + 1
                if (dist[destLabel] == -1) {
                    dist[destLabel] = dist[currLabel] + 1;
                    queue.add(destLabel);
                }
            }
        }
        //output
        System.out.println("Min steps to reach target in snake & ladder game: " + dist[target]);
    }

    private int[] findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(int[] edges, int node) {
        int n = edges.length;

        Set<Integer> visited = new HashSet<>();

        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[node] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(node);

        while (!queue.isEmpty()) {

            int currNode = queue.poll();

            if (visited.contains(currNode)) {
                continue;
            }

            visited.add(currNode);

            int childNode = edges[currNode];
            if (childNode != -1 && !visited.contains(childNode)) {
                dist[childNode] = 1 + dist[currNode];
                queue.add(childNode);
            }
        }
        return dist;
    }

    public void findClosestNodeToGivenTwoNodes_Graph(int[] edges, int node1, int node2) {
        //https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/
        //based on BFS, DIJIKSTRA ALGO
        int n = edges.length;
        //get the smallest dist to reach other vertices from given nodes 1 & 2 respec
        int[] distFromNode1 = findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(edges, node1);
        int[] distFromNode2 = findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(edges, node2);

        //resultant node that will be closest to both the given nodes
        int closestNode = -1;
        //this is the max dist we can think of, that we need to minimize
        int minimizedDist = Integer.MAX_VALUE;

        for (int currNode = 0; currNode < n; currNode++) {
            //max dist to reach the curr node as dist calculated from both node1
            //and node2 respec
            int maxOfDists = Math.max(distFromNode1[currNode], distFromNode2[currNode]);
            //minimize the max dists
            if (minimizedDist > maxOfDists) {
                minimizedDist = maxOfDists;
                closestNode = currNode;
            }
        }
        //output
        System.out.println("Closest node to given two nodes: " + closestNode);
    }

    public void shortestPathWithAlternatingColors_Graph(int n, int[][] redEdges, int[][] blueEdges) {
        //https://leetcode.com/problems/shortest-path-with-alternating-colors/description/

        int RED = 0;
        int BLUE = 1;

        Set<Integer> EMPTY = Collections.emptySet();

        Map<Integer, Set<Integer>>[] coloredGraph = new HashMap[2];

        //shortest path to be filled from src 0 to each i-th index/ vertex
        final int[] shortestPath = new int[n];
        Arrays.fill(shortestPath, -1);

        class Helper {

            //<color, set<visited vertex>>
            Set<Integer>[] visitedViaColor;

            private void shortestPathWithAlternatingColorsHelper(int root, int color) {

                //for each color based BFS call to find shortest path, we have to
                //reset visitedViaColor
                visitedViaColor = new HashSet[2];
                visitedViaColor[RED] = new HashSet<>();
                visitedViaColor[BLUE] = new HashSet<>();

                Queue<Integer> queue = new LinkedList<>();
                queue.add(root);

                //curr start from curr color is marked visited
                visitedViaColor[color].add(root);

                int distance = 0;

                while (!queue.isEmpty()) {

                    //alternate the color, thats why 1 & -1 were choosen
                    //RED to BLUE then BLUE to RED
                    color = color == RED ? BLUE : RED;

                    distance++;

                    int size = queue.size();

                    for (int i = 0; i < size; i++) {

                        int currVertex = queue.poll();

                        for (int childVertex : coloredGraph[color].getOrDefault(currVertex, EMPTY)) {

                            if (visitedViaColor[color].contains(childVertex)) {
                                continue;
                            }

                            visitedViaColor[color].add(childVertex);
                            queue.add(childVertex);

                            shortestPath[childVertex] = (shortestPath[childVertex] == -1)
                                    ? distance
                                    : Math.min(shortestPath[childVertex], distance);
                        }
                    }
                }
            }
        }

        Helper helper = new Helper();

        coloredGraph[RED] = new HashMap<>();
        coloredGraph[BLUE] = new HashMap<>();

        for (int[] edge : redEdges) {

            int u = edge[0];
            int v = edge[1];

            coloredGraph[RED].putIfAbsent(u, new HashSet<>());
            coloredGraph[RED].get(u).add(v);
        }

        for (int[] edge : blueEdges) {

            int u = edge[0];
            int v = edge[1];

            coloredGraph[BLUE].putIfAbsent(u, new HashSet<>());
            coloredGraph[BLUE].get(u).add(v);
        }

        Arrays.fill(shortestPath, -1);

        int root = 0;

        shortestPath[root] = 0;

        //since we have two colors, we have two possibilities to find shortest path
        //form src node 0 to every other node, i.e, find shortest path from both
        //colors
        helper.shortestPathWithAlternatingColorsHelper(0, RED);
        helper.shortestPathWithAlternatingColorsHelper(0, BLUE);

        //output
        System.out.println("Shortest path with alternating colors: "
                + Arrays.toString(shortestPath));
    }

    public void minFuelToReachCapitalCity_Graph(int[][] roads, int seats) {
        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/
        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/3080167/minimum-fuel-cost-to-report-to-the-capital/
        /*
        roads[][] = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
        tree =
        .......................0
        ..................../..|..\
        ...................1...4...5
        ................../....|....
        .................3.....6....
        ................/...........
        ...............2............

        its a tree dfs so here the approach is to reach the leaf ends of tree
        and calculate size(== passanger) of that node in its substree

        ex: 2 there is no substree and 2 is only representative == 1
        same for 6 & 5

        2 == passanger == 1
        6 == passanger == 1
        5 == passanger == 1

        from these end nodes we will only recurse back in the call stack to calling node 0
        so before going back to previous call stack we have calculate the fuel used for
        curr node for it(and other passanger, if any) to travel to its parent(means prev
        call stack)

        since end nodes are not node 0, we can caluculate fuel used

        fuel += Math.ceil(passanger / seat)

        the above line means that if at any point the curr node and its passanger, if any
        has to travel to its parent, we are limited by the seats in the car that curr node has
        now we have X passanger that should travel and only Y can sit a car
        then how many cars can be required to take all the passangers?
        that will be number of cars req == X / Y == (passanger / seat)
        this division will be double so use ceil() to have upper limit of fuel req
        the number of cars req is same as total fuel from curr node to its parent

        fuel = 0
        call stack at end nodes 2, 6, 5

        call(2, 3)
        ---represn = 1
        ---for(childVertex : graph[2] -> [3]) childVertex == parent; END
        ---if(vertex != 0) == (2 != 0) fuel += ceil(passanger / seat) == ceil(1 / 2) = 1
        -----fuel = 0 + 1 == 1
        ---return represen == 1

        going back to previous call stack of node 2 i.e node 3

        call(3, 1)
        ---represn = 1
        ---for(childVertex : graph[3] -> [1,2])
        ----- 1. for node 1 == childVertex == parent; CONTINUE
        ----- 2. for node 2 (ret 1) == passanger += 1 == 1 + 1 = 2
        ---if(vertex != 0) == (3 != 0) fuel += ceil(passanger / seat) == ceil(2 / 2) = 1
        -----fuel = 3 + 1 == 4
        ---return passanger == 2

        going back to previous call stack of node 3 i.e node 1

        call(1, 0)
        ---represn = 1
        ---for(childVertex : graph[1] -> [0,3])
        ----- 1. for node 0 == childVertex == parent; CONTINUE
        ----- 2. for node 3 (ret 2) == passanger += 1 == 2 + 1 = 3
        ---if(vertex != 0) == (1 != 0) fuel += ceil(passanger / seat) == ceil(3 / 2) = 2
        -----fuel = 5 + 2 == 7 ***
        ---return passanger == 3

        ..........................
        call(6, 4)
        ---represn = 1
        ---for(childVertex : graph[6] -> [4]) childVertex == parent; END
        ---if(vertex != 0) == (6 != 0) fuel += ceil(passanger / seat) == ceil(1 / 2) = 1
        -----fuel = 1 + 1 == 2
        ---return passanger == 1

        going back to previous call stack of node 6 i.e node 4

        call(4, 0)
        ---represn = 1
        ---for(childVertex : graph[4] -> [0,6])
        ----- 1. for node 0 == childVertex == parent; CONTINUE
        ----- 2. for node 6 (ret 1) == passanger += 1 == 1 + 1 = 2
        ---if(vertex != 0) == (4 != 0) fuel += ceil(passanger / seat) == ceil(2 / 2) = 1
        -----fuel = 4 + 1 == 5
        ---return passanger == 2

        .............................
        call(5, 0)
        ---represn = 1
        ---for(childVertex : graph[5] -> [0]) childVertex == parent; END
        ---if(vertex != 0) == (5 != 0) fuel += ceil(passanger / seat) == ceil(1 / 2) = 1
        -----fuel = 2 + 1 == 3
        ---return passanger == 1

        .........................
        call(0, -1)
        ---represn = 1
        ---for(childVertex : graph[0] -> [1,4,5])
        ----- 1. for node 1(ret 3) == passanger += 1 == 1 + 3 = 4
        ----- 2. for node 4 (ret 2) == passanger += 1 == 4 + 2 = 6
        ----- 2. for node 5 (ret 2) == passanger += 1 == 6 + 1 = 7
        ---if(vertex != 0) == (0 != 0) FALSE
        ---return passanger == 2

        fuel == 7
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] road : roads) {
            int u = road[0];
            int v = road[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        class Helper {

            long fuel = 0;

            int minFuelToReachCapitalCity_Graph_DFS(int vertex, int parent) {

                int passanger = 1;

                for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {

                    if (childVertex == parent) {
                        continue;
                    }

                    passanger += minFuelToReachCapitalCity_Graph_DFS(childVertex, vertex);
                }

                if (vertex != 0) {
                    fuel += Math.ceil((double) passanger / (double) seats);
                }

                return passanger;
            }
        }

        Helper helper = new Helper();
        helper.minFuelToReachCapitalCity_Graph_DFS(0, -1);

        //output
        System.out.println("Min Fuel to reach to capital city: " + helper.fuel);
    }

    public void cheapestFlightsWithinKStops_Graph(int n, int[][] flights, int src, int dest, int k) {
        //https://leetcode.com/problems/cheapest-flights-within-k-stops/description/
        //explanation: https://youtu.be/VmUpydhNmuw
        //based on LEVEL-WISE BFS TRAVERSAL with modified DIJKSTRA ALGO
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] flight : flights) {
            int u = flight[0];
            int v = flight[1];
            int weight = flight[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));
        }

        int MAX = Integer.MAX_VALUE;

        int[] dist = new int[n];

        Arrays.fill(dist, MAX);

        dist[src] = 0;

        Queue<GraphEdge> queue = new LinkedList<>();
        queue.add(new GraphEdge(src, 0));

        int stops = 0;

        while (!queue.isEmpty() && stops <= k) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                GraphEdge currEdge = queue.poll();

                for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, Collections.emptyList())) {

                    if (dist[childEdge.vertex] > currEdge.weight + childEdge.weight) {

                        dist[childEdge.vertex] = currEdge.weight + childEdge.weight;
                        queue.add(new GraphEdge(childEdge.vertex, dist[childEdge.vertex]));
                    }
                }
            }
            stops++;
        }
        //output
        int minPriceWithinKStops = dist[dest] == MAX ? -1 : dist[dest];
        System.out.println("Cheapest flights within k stops: " + minPriceWithinKStops);
    }

    public void createBinaryTreeFromDescription_Graph(int[][] descriptions) {
        //https://leetcode.com/problems/create-binary-tree-from-descriptions/description/
        class Edge {

            int vertex;
            boolean isLeft;

            public Edge(int vertex, boolean isLeft) {
                this.vertex = vertex;
                this.isLeft = isLeft;
            }

        }

        Map<Integer, List<Edge>> graph = new HashMap<>();
        Map<Integer, Integer> indegree = new HashMap<>();

        class Helper {

            TreeNode<Integer> createTreeDFS(int parentNode) {

                TreeNode<Integer> root = new TreeNode<>(parentNode);

                for (Edge childEdge : graph.getOrDefault(parentNode, new ArrayList<>())) {

                    TreeNode<Integer> childRoot = createTreeDFS(childEdge.vertex);

                    if (childEdge.isLeft) {
                        root.setLeft(childRoot);
                    } else {
                        root.setRight(childRoot);
                    }
                }

                return root;
            }
        }

        for (int[] desc : descriptions) {

            int root = desc[0];
            int child = desc[1];
            boolean isLeft = desc[2] == 1;

            //directed graph having parent -> child edge or we can also say
            //(root -> child) relation
            graph.putIfAbsent(root, new ArrayList<>());
            graph.get(root).add(new Edge(child, isLeft));

            //since we are given, parent -> child edge so child will always
            //have an indegree toward itself hence +1 is for that BUT the
            //given description is actually a tree so there will be a 'ROOT'
            //who will never have any indegree coming towards itself hence
            //this tree's 'ROOT' will not be in the indegree map
            indegree.put(child, indegree.getOrDefault(child, 0) + 1);
        }

        int ROOT = -1;

        //as mentioned above, graph has root -> child relation meaning each of
        //the root is connected to its child nodes hence graph's key will contain
        //all the roots of the tree
        for (int root : graph.keySet()) {
            //if a 'root' from graph is not in the indegree map then its clear
            //this 'root' is actually the tree 'ROOT'
            if (!indegree.containsKey(root)) {
                ROOT = root;
                break;
            }
        }

        TreeNode<Integer> treeRoot = new Helper().createTreeDFS(ROOT);

        //output
        new BinaryTree<Integer>(treeRoot).treeBFS();
        System.out.println();
    }

    public int minNumberOfOperationsToConvertNumber_Graph(int[] nums, int start, int goal) {
        //https://leetcode.com/problems/minimum-operations-to-convert-number/description/
        //based on BFS
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);

        Set<Integer> visited = new HashSet<>();

        int oprn = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                int currNum = queue.poll();

                //if we have reached our goal return min oprn
                if (currNum == goal) {
                    return oprn;
                }

                //skip, if currNum is not in this range
                if (!(currNum >= 0 && currNum <= 1000)) {
                    continue;
                }

                //skip, if currNum is already visited
                if (visited.contains(currNum)) {
                    continue;
                }

                visited.add(currNum);

                //generate all possible next numbers from currNum
                for (int val : nums) {
                    queue.add(currNum + val);
                    queue.add(currNum - val);
                    queue.add(currNum ^ val);
                }
            }
            oprn++;
        }
        return -1;
    }

    private void minScoreOfPathBetweenTwoCities_Graph_Helper(
            Map<Integer, List<GraphEdge>> graph, Set<Integer> visited, List<Integer> nodes, int src) {

        //simple DFS
        visited.add(src);
        for (GraphEdge childEdge : graph.getOrDefault(src, new ArrayList<>())) {

            //if a child vertex is laready visited, skip it
            if (visited.contains(childEdge.vertex)) {
                continue;
            }

            nodes.add(childEdge.vertex);
            minScoreOfPathBetweenTwoCities_Graph_Helper(graph, visited, nodes, childEdge.vertex);
        }
    }

    public void minScoreOfPathBetweenTwoCities_Graph(int n, int[][] roads) {
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326589/daily-leetcoding-challenge-march-day-22/
        //constraint: There is at least one path between 1 and n.
        int minDist = Integer.MAX_VALUE;
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] road : roads) {
            int u = road[0];
            int v = road[1];
            int dist = road[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, dist));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, dist));
        }

        int src = 1;
        Set<Integer> visited = new HashSet<>();
        //since our starting src node is src == 1 so this nodes list will save
        //all the intermediate nodes connected to src == 1 in a DFS way also a constraint
        //is given that there is atleast one edge connecting 1 to n-th node
        //so through this nodes list we can check all the edges connected and hence
        //there will always a path 1 to n-th node we just need to find an egde
        //with min dist
        List<Integer> nodes = new ArrayList<>();

        minScoreOfPathBetweenTwoCities_Graph_Helper(graph, visited, nodes, src);

        //check edges to find the minDist
        for (int node : nodes) {
            for (GraphEdge childEdge : graph.getOrDefault(node, new ArrayList<>())) {
                //here dist == weight
                minDist = Math.min(minDist, childEdge.weight);
            }
        }
        //output
        System.out.println("Min score of path between two cities: " + minDist);
    }

    public void minScoreOfPathBetweenTwoCities_Graph_UnionFind(int n, int[][] roads) {
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
        //based on GRAPH DISJOINT SET/ UNION FIND
        //constraint: There is at least one path between 1 and n.
        class UnionFind {

            int n;
            int[] parent;
            int[] rank;

            public UnionFind(int n) {
                this.n = n;
                parent = new int[n + 1];
                rank = new int[n + 1];
                for (int node = 0; node <= n; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind(n);
        int minDist = Integer.MAX_VALUE;

        for (int[] road : roads) {
            int nodeU = road[0];
            int nodeV = road[1];
            //put all the roads/ edges into the union()
            unionFind.union(nodeU, nodeV);
        }

        for (int[] road : roads) {
            int nodeU = road[0];
            int dist = road[2];
            //now here in this loop for roads/ edges, we are checking if each of
            //the roads[i]/ edge given is a connected part of node '1' then we can
            //calculate the minDist, why we are checking each nodeU is connected with
            //node '1'?
            //because we need to find the minDist of the paths between node
            //'1' to 'n' so src = 1 that is fixed now we also know that nodeU
            //and nodeV are bidirectional and we also made union() of these
            //edges so we can pick any of the node as they belong to same
            //connected group, only here they have to be connected to src = 1
            if (unionFind.find(1) == unionFind.find(nodeU)) {
                minDist = Math.min(minDist, dist);
            }
        }

        //output
        System.out.println("Min score of path between two cities: " + minDist);
    }

    private void numberOfOperationToMakeNetworkConnected_Graph_Helper(
            Map<Integer, List<Integer>> graph, Set<Integer> visited, int src) {

        //simple DFS call
        visited.add(src);
        for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {
            if (visited.contains(childVertex)) {
                continue;
            }

            numberOfOperationToMakeNetworkConnected_Graph_Helper(graph, visited, childVertex);
        }
    }

    public int numberOfOperationToMakeNetworkConnected_Graph(int n, int[][] connections) {
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        //connections[][] array contains edges/ wires that connect these n nodes
        //some nodes may not be conncted to each other in group but we can make
        //those nodes connected if we have edges/ wires atleast (n - 1)
        int edges = connections.length;
        //if there no sufficient edges/ wires to connect other nodes then not
        //operations can be made so return -1
        if (edges < n - 1) {
            return -1;
        }

        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        for (int[] connection : connections) {
            int u = connection[0];
            int v = connection[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        //this will keep the count of all the connected graph in the given graph
        //connections
        int connectedGraphComponent = 0;

        //loop over all the nodes so that we can visit all the connected graph
        //component and count all the components
        for (int src = 0; src < n; src++) {
            //if any node src is already visited(because it might be a part of
            //connected graph component that we already process) then skip this node
            if (visited.contains(src)) {
                continue;
            }

            //from this curr src node we will visit all of its connected nodes
            //hence form a connected graph component
            connectedGraphComponent++;
            //DFS call to visit all the connected nodes from curr src node
            numberOfOperationToMakeNetworkConnected_Graph_Helper(graph, visited, src);
        }
        //since we have already checked that we sufficient edges/ wires that we
        //can readjust among other connected gragh component, so there will be
        //one edge/ wire req to connect one connected graph component to another
        //so we need to adjust edges or re-wire (connectedGraphComponent - 1)
        //so all the connected graph forms a single graph component
        return connectedGraphComponent - 1;
    }

    public int numberOfOperationToMakeNetworkConnected_Graph_UnionFind(int n, int[][] connections) {
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        //based on UNION-FIND, CONNECTED COMPONENT GRAPH
        //same as numberOfOperationToMakeNetworkConnected_Graph()
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];
                //initially each node is in its own groups and parent of itself
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                //each time we union node1 & node2, connected groups reduces
                connectedGroups--;
            }

            //with union(), we made all the nodes given as per connections[][]
            //connected within some groups and now we have 'connectedGroups'
            //number of groups that needs to be connected with each other so
            //to connected 'connectedGroups' we will require connectedGroups - 1
            //edges/connection
            public int connectionsRequired() {
                return connectedGroups - 1;
            }
        }

        //if we have n nodes in graph, so to connect each node together we need
        //atleast n - 1 edges between them
        int edges = connections.length;
        //if the total edges given is less than what is needed(==> n - 1) then
        //we can never connect all n nodes given number of edges/connections
        if (edges < n - 1) {
            return -1;
        }

        UnionFind unionFind = new UnionFind(n);

        for (int[] connection : connections) {
            int u = connection[0];
            int v = connection[1];

            unionFind.union(u, v);
        }
        return unionFind.connectionsRequired();
    }

    private boolean checkIfValidPathInStreetGrid_Graph_Helper(int[][] grid, boolean[][] visited,
                                                              Map<Integer, int[][]> dirs, int row, int col) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //isOutOfBounds() OR row and col already visited
        if (row < 0 || row >= ROW || col < 0 || col >= COL || visited[row][col]) {
            return false;
        }

        if (row == ROW - 1 && col == COL - 1) {
            return true;
        }

        boolean isPathValid = false;

        visited[row][col] = true;

        int currStreet = grid[row][col];

        //a specific street has a specific allowed dir of movement
        for (int[] nextDir : dirs.get(currStreet)) {

            int nextRow = row + nextDir[0];
            int nextCol = col + nextDir[1];

            //isOutOfBounds() OR next row and col already visited
            //this check is req here because we need to validate this next row & col
            //below
            if (nextRow < 0 || nextRow >= ROW || nextCol < 0 || nextCol >= COL || visited[nextRow][nextCol]) {
                continue;
            }

            //now from this potential next street where we can move to, we need
            //to validate that we can also go back to the prev cell from here
            //if we can validate this thing, then we can go to next row and col
            int nextStreet = grid[nextRow][nextCol];

            for (int[] backDir : dirs.get(nextStreet)) {
                //from this next row and col if we can go back to prev row and col
                if (nextRow + backDir[0] == row && nextCol + backDir[1] == col) {
                    isPathValid = isPathValid || checkIfValidPathInStreetGrid_Graph_Helper(
                            grid, visited, dirs, nextRow, nextCol);
                }
            }
        }

        return isPathValid;
    }

    public void checkIfValidPathInStreetGrid_Graph(int[][] grid) {
        //https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        boolean[][] visited = new boolean[ROW][COL];
        //<street, dirs>
        Map<Integer, int[][]> dirs = new HashMap<>();
        //refer question for street wise images
        /*  ------  movement: LEFT(0, -1), RIGHT(0, 1) */
        dirs.put(1, new int[][]{{0, -1}, {0, 1}});
        /*
            |
            |
            |
        movement: TOP(-1, 0), BOTTOM(1, 0) */
        dirs.put(2, new int[][]{{-1, 0}, {1, 0}});
        /*
        -----
            |
            |
        movement: LEFT(0, -1), BOTTOM(1, 0) */
        dirs.put(3, new int[][]{{0, -1}, {1, 0}});
        /*
            -----
            |
            |
        movement: RIGHT(0, 1), BOTTOM(1, 0) */
        dirs.put(4, new int[][]{{0, 1}, {1, 0}});
        /*
            |
            |
        -----
        movement: LEFT(0, -1), TOP(-1, 0) */
        dirs.put(5, new int[][]{{0, -1}, {-1, 0}});
        /*
            |
            |
            -----
        movement: RIGHT(0, 1), TOP(-1, 0) */
        dirs.put(6, new int[][]{{0, 1}, {-1, 0}});

        boolean isPathValid = checkIfValidPathInStreetGrid_Graph_Helper(grid, visited, dirs, 0, 0);
        //output
        System.out.println("Is path valid in street grid: " + isPathValid);
    }

    private boolean longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
            int[] edges, boolean[] visited, boolean[] recurStack,
            Integer[] nodeToPathStep, int srcVertex, int currSteps) {

        //if at any point from a given src node i there is no outgoing edge == -1
        //then we can't move further hence no path exist ahead hence no possibilty
        //of any cycle
        //note: in a version of HashMap based graph, this if cond is handled
        //by getOrDefault()
        if (edges[srcVertex] == -1) {
            return false;
        }

        //note: here recurStack and nodeToPathStep are basically the same thing
        //doing slightly different work
        //if (recurStack[srcVertex]) can be replaced with
        //if (nodeToPathStep[srcVertex] != null)
        //OR
        //instead of using boolean[] recurStack we can use Integer[] recurStack
        //any of the above can do the same thing, just for simplicity & understanding
        //keeping these two things separately
        if (recurStack[srcVertex]) {
            longestCycleInGraph_Graph_MaxCycleLength = Math.max(
                    longestCycleInGraph_Graph_MaxCycleLength,
                    //calculates the length of path having cycle
                    currSteps - nodeToPathStep[srcVertex]);
            return true;
        }

        if (visited[srcVertex]) {
            return false;
        }

        recurStack[srcVertex] = true;
        visited[srcVertex] = true;

        nodeToPathStep[srcVertex] = currSteps;

        boolean hasCycle = longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
                edges, visited, recurStack,
                nodeToPathStep, edges[srcVertex], currSteps + 1);

        recurStack[srcVertex] = false;

        return hasCycle;
    }

    private int longestCycleInGraph_Graph_MaxCycleLength;

    public void longestCycleInGraph_Graph(int[] edges) {
        //https://leetcode.com/problems/longest-cycle-in-a-graph/description/
        //based on detectCycleInDirectedGraphDFS_Graph()
        //here given edges[] will be our graph that we generally create as HashMap
        //u = i-th index & j = edges[i]
        //the given graph is directed and each node can have atmost 1 outgoing
        //edge, so if there is a cycle then a particular node can be part of a
        //cyle only once(because of atmost one outgoign edge from node)
        int n = edges.length;

        boolean[] visited = new boolean[n];

        //here recurStack will check if we encounter a cycle
        boolean[] recurStack = new boolean[n];
        //this will keep step count for each node in DFS call so when we are in
        //cycle path and see a node already in nodeToPathStep previously
        //then there we will calculate our cycle length by curr step at that time
        //minus step already in nodeToPathStep for that node
        Integer[] nodeToPathStep = new Integer[n];

        //default value is -1 if there is no cycle in the graph
        longestCycleInGraph_Graph_MaxCycleLength = -1;

        //since the graph can be disconnected/ connected graph component
        //a cycle may occur in any sub-graph so we have to check all the
        //src == i for longest cycle path
        for (int u = 0; u < n; u++) {
            //skip, if a src == i already been visited
            if (visited[u]) {
                continue;
            }
            longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
                    edges, visited, recurStack, nodeToPathStep, u, 0);
        }
        //output
        System.out.println("Longest cycle length in graph: " + longestCycleInGraph_Graph_MaxCycleLength);
    }

    private int largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
            Map<Integer, List<Integer>> graph, boolean[] recurStack, boolean[] visited,
            String colors, int[][] nodeToColorFreq, int vertex) {

        //based on detect cycle of directed graph
        //color associated to the vertex
        int vertexColorIndex = colors.charAt(vertex) - 'a';

        //if a vertex is already there in the recur stack, means we are visiting
        //a vertex again in the same path, hence its a cycle, reurn MAX_VALUE
        //representing cycle in graph
        if (recurStack[vertex]) {
            return Integer.MAX_VALUE;
        }

        //if a vertex is already visited, means we must have calculated color
        //freqs starting from this vertex in that path, hence return the
        //maxColorFreq already calculated at vertex for colorIndex == vertexColorIndex
        if (visited[vertex]) {
            return nodeToColorFreq[vertex][vertexColorIndex];
        }

        recurStack[vertex] = true;
        visited[vertex] = true;

        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            //if there is cycle in the graph, represent it with MAX_VALUE
            if (largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
                    graph, recurStack, visited, colors, nodeToColorFreq, childVertex) == Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }

            for (int colorIndex = 0; colorIndex < 26; colorIndex++) {
                nodeToColorFreq[vertex][colorIndex] = Math.max(
                        nodeToColorFreq[vertex][colorIndex],
                        nodeToColorFreq[childVertex][colorIndex]);
            }
        }

        nodeToColorFreq[vertex][vertexColorIndex]++;

        recurStack[vertex] = false;
        return nodeToColorFreq[vertex][vertexColorIndex];
    }

    public int largestColorValueInDirectedGraph_Graph(String colors, int[][] edges) {
        //https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/
        //explanation: https://youtu.be/xLoDjKczUSk
        int V = colors.length();
        //given colors string will have [a-z] named colors means limited to only
        //26 colors to all the V nodes of the given graph
        int TOTAL_COLORS = 26;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        boolean[] recurStack = new boolean[V];
        boolean[] visited = new boolean[V];
        //this will hold the max freq of each color type(a-z) under the curr
        //node(== i) at that time.
        int[][] nodeToColorFreq = new int[V][TOTAL_COLORS];

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        int maxColorFreq = 0;
        for (int u = 0; u < V; u++) {
            maxColorFreq = Math.max(maxColorFreq,
                    largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
                            graph, recurStack, visited, colors, nodeToColorFreq, u));
        }
        return maxColorFreq == Integer.MAX_VALUE ? -1 : maxColorFreq;
    }

    public void similarStringGroups_Graph(String[] strs) {
        /*
        Here n is the size of strs and m is length of each word in strs.

        ..................T: O(n^2 * m)
        To iterate over all the pairs of words that can be formed using strs, we need O(n^2)
        time. We also need O(m) time to determine whether the chosen two words are similar or
        not, which results in O(n^2 * m) operations to check all the pairs.
        The dfs function visits each node once, which takes O(n) time because there are n nodes
        in total. We can have up to O(n^2) edges between n nodes (assume every word is similar
        to every other word). Because we have undirected edges, each edge can only be iterated
        twice (by nodes at the end), resulting in O(n^2) operations total in the worst-case
        scenario while visiting all nodes.

        ..................S: O(n^2)
        As there can be a maximum of O(n^2) edges, building the adjacency list takes O(n^2) space.
        The visit array takes O(n) space. The recursion call stack used by dfs can have no more
        than nnn elements in the worst-case scenario. It would take up O(n) space in that case.
         */
        //https://leetcode.com/problems/similar-string-groups/description/
        //based on GRAPH, CONNECTED GRAPH COMPONENTS
        int V = strs.length;
        boolean[] visited = new boolean[V];
        Map<Integer, List<Integer>> graph = new HashMap<>();

        class Helper {

            boolean isSimilar(String str1, String str2) {
                int n = str1.length();
                int mismatchedChar = 0;
                for (int i = 0; i < n; i++) {
                    if (str1.charAt(i) != str2.charAt(i)) {
                        mismatchedChar++;
                    }
                }
                //if 2 strings have to be similar then they should either have
                //0 mismatched OR only 2 mismatched chars acc to question
                return mismatchedChar == 0 || mismatchedChar == 2;
            }

            void helperDFS(int srcVertex) {
                //simple DFS call to mark all the connected srcVertex
                //(index of string of strs[]) of the curr connected graph
                visited[srcVertex] = true;
                for (int childVertex : graph.getOrDefault(srcVertex, new ArrayList<>())) {
                    if (visited[childVertex]) {
                        continue;
                    }
                    helperDFS(childVertex);
                }
            }
        }

        Helper helper = new Helper();

        //from given strs[], we will try to form i -> j & j -> i edge between each
        //pair for strings in strs[]
        for (int u = 0; u < V; u++) {
            for (int v = u + 1; v < V; v++) {

                //if 2 strings are similar then they are part of the same connected
                //graph hence the src i can have edge to dest j and vice versa in
                //undirected graph structure
                //those 2 strings, that are not similar with each other will actually
                //form a separate graph
                //hence after this we might have a disconnected graph structure
                //from given strs[]
                if (helper.isSimilar(strs[u], strs[v])) {

                    graph.putIfAbsent(u, new ArrayList<>());
                    graph.get(u).add(v);

                    graph.putIfAbsent(v, new ArrayList<>());
                    graph.get(v).add(u);
                }
            }
        }

        //now, here we will count the number of different connected graph, that
        //connected graph is basically the connected edges of all those similar
        //strings
        int similarStringGroups = 0;
        for (int u = 0; u < V; u++) {

            //if the particular index (== i) of the strs[] is already visited
            //that means this i-index string is already a part of similar string
            //that might previously visited in some connected groups
            if (visited[u]) {
                continue;
            }
            //starting of a connected graph(here it means connected groups
            //similar strings)
            similarStringGroups++;
            //do a DFS call from src vertex i to mark all the connected index as
            //visited
            helper.helperDFS(u);
        }
        //output
        System.out.println("Similar string groups : " + similarStringGroups);
    }

    public void similarStringGroups_Graph_UnionFind(String[] strs) {
        /*
        Here n is the size of strs and m is length of each word in strs.

        .....................T: O(n^2 * m)
        We need O(n^2) time to iterate over all the pairs of words that can be formed
        using strs. We further need O(m) time to check whether the chosen two words
        are similar or not, resulting in O(n^2 * m) operations to check all the pairs.
        For T operations, the amortized time complexity of the union-find algorithm
        (using path compression with union by rank) is O(alpha(T)). Here, (T) is the
        inverse Ackermann function that grows so slowly, that it doesn't exceed 4 for
        all reasonable T (approximately T<10^600). You can read more about the complexity
        of union-find here. Because the function grows so slowly, we consider it to be O(1).
        Initializing UnionFind takes O(n) time beacuse we are initializing the parent and
        rank arrays of size n each.
        We iterate through every edge and use the find operation to find the component of
        nodes connected by each edge. It takes O(1) per operation and takes O(e) time for
        all the e edges. As discussed above, we can have a maximum of O(n^2) edges in between
        n nodes, so it would take O(n^2) time. If nodes from different components are connected
        by an edge, we also perform union of the nodes, which takes O(1) time per operation.
        In the worst-case scenario, it may be called O(n) times to connect all the components
        to form a connected graph with only one component.

        ......................S: O(n)
        We are using the parent and rank arrays, both of which require O(n) space each.
         */
        //https://leetcode.com/problems/similar-string-groups/description/
        //based on UNION FIND
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                connectedGroups--;
            }

            public int countSimilarGroups() {
                return connectedGroups;
            }
        }

        class Helper {

            public boolean isSimilarStrings(String str1, String str2) {

                int n = str1.length();
                int mismatchedChars = 0;

                for (int i = 0; i < n; i++) {

                    if (str1.charAt(i) != str2.charAt(i)) {
                        mismatchedChars++;
                    }
                }
                return mismatchedChars == 0 || mismatchedChars == 2;
            }
        }

        int V = strs.length;

        UnionFind unionFind = new UnionFind(V);
        Helper helper = new Helper();

        for (int u = 0; u < V; u++) {

            for (int v = u + 1; v < V; v++) {

                if (helper.isSimilarStrings(strs[u], strs[v])) {
                    unionFind.union(u, v);
                }
            }
        }

        //output
        System.out.println("Similar string groups : " + unionFind.countSimilarGroups());
    }

    private int graphAsTreeDiameter_Graph_Helper(Map<Integer, List<Integer>> graph, int root) {

        //from the curr root node, there should be 2 max length branches going
        //down from this 'root'
        int firstMaxChildPathLength = 0;
        int secondMaxChildPathLength = 0;

        for (int childVertex : graph.getOrDefault(root, new ArrayList<>())) {

            int childPathLength = graphAsTreeDiameter_Graph_Helper(graph, childVertex);

            if (childPathLength > firstMaxChildPathLength) {

                secondMaxChildPathLength = firstMaxChildPathLength;

                firstMaxChildPathLength = childPathLength;

            } else if (childPathLength > secondMaxChildPathLength) {

                secondMaxChildPathLength = childPathLength;
            }
        }

        //max diameter can be formed from max-left-branch(== firstMaxChildPathLength)
        //and max-right-branch(== secondMaxChildPathLength) + 1 for the root node itself
        graphAsTreeDiameter_Graph_MaxDiameter = Math.max(
                graphAsTreeDiameter_Graph_MaxDiameter,
                firstMaxChildPathLength + 1 + secondMaxChildPathLength);

        //further find a max length branch, so choose one from
        //max-left-branch or max-right-branch + 1 for root node itself
        return Math.max(firstMaxChildPathLength, secondMaxChildPathLength) + 1;
    }

    private int graphAsTreeDiameter_Graph_MaxDiameter;

    public void graphAsTreeDiameter_Graph(int[][] edges) {
        //https://leetcode.com/problems/tree-diameter/
        //https://leetcode.ca/all/1245.html
        //based on TREE DIAMETER
        graphAsTreeDiameter_Graph_MaxDiameter = Integer.MIN_VALUE;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {

            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        int root = 0;

        graphAsTreeDiameter_Graph_Helper(graph, root);

        //output
        System.out.println("Graph as tree diameter (nodes in diameter): "
                + graphAsTreeDiameter_Graph_MaxDiameter);
        System.out.println("Graph as tree diameter (length diameter): "
                + (graphAsTreeDiameter_Graph_MaxDiameter - 1));
    }

    public void shorestPathInWeightedUndirectedGraph_Graph(int V, int[][] edges) {
        //same but for directed weighted graph : https://leetcode.com/problems/design-graph-with-shortest-path-calculator/description/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
        //explanation : https://youtu.be/icVJUN45f1E
        //based on DJIKSTRA ALGO
        List<Integer> path = new ArrayList<>();
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, weight));
        }

        int src = 1;
        int dest = V;

        int[] parent = new int[V + 1];
        int[] dist = new int[V + 1];

        Arrays.fill(parent, Integer.MAX_VALUE);
        Arrays.fill(dist, Integer.MAX_VALUE);

        //parent of the src is -1
        parent[src] = -1;
        //dist to reach the src vertex is 0
        dist[src] = 0;

        PriorityQueue<GraphEdge> queue = new PriorityQueue<>(
                (a, b) -> a.weight - b.weight);

        queue.add(new GraphEdge(src, 0));

        while (!queue.isEmpty()) {

            GraphEdge currEdge = queue.poll();

            for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, new ArrayList<>())) {

                if (dist[currEdge.vertex] + childEdge.weight < dist[childEdge.vertex]) {

                    dist[childEdge.vertex] = dist[currEdge.vertex] + childEdge.weight;
                    queue.add(new GraphEdge(childEdge.vertex, dist[childEdge.vertex]));

                    parent[childEdge.vertex] = currEdge.vertex;
                }
            }
        }

        if (parent[dest] == Integer.MAX_VALUE) {
            System.out.println(String.format("No path from src : %d to dest : %d is possible", src, V));
            return;
        }

        path.add(dest);
        //backtrack from dest vertex's parent to src vertex
        //so src vertex's parent is -1
        while (parent[dest] != -1) {
            path.add(parent[dest]);
            dest = parent[dest];
        }

        Collections.reverse(path);
        //output
        System.out.println(String.format("Path from src : %d to dest : %d is : ", src, V) + path);
    }

    private boolean checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(
            Map<Integer, List<GraphEdge>> graph, boolean[] visited,
            int srcVertex, int destVertex, int limit) {

        //simple DFS call but it will give TLE
        if (srcVertex == destVertex) {
            return true;
        }

        visited[srcVertex] = true;

        boolean hasPath = false;

        for (GraphEdge childNode : graph.getOrDefault(srcVertex, new ArrayList<>())) {

            //skip, if a vertex is already visited earlier
            if (visited[childNode.vertex]) {
                continue;
            }

            //skip, if the weight associated to this child vertex is more or equal
            //to limit, as we need to choose those paths/edges where their weight
            //is STRICTLY LESS than given limit
            if (childNode.weight >= limit) {
                continue;
            }

            //if there exists such path where the weight of each edge in that path
            //is less than given limit, then hasPath will be true
            hasPath = hasPath
                    || checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(graph, visited,
                    childNode.vertex, destVertex, limit);
        }

        //since we might need to check many paths from the same srcVertex, we have
        //to un-visit srcVertex here after we have complete DFS on path from this
        //srcVertex
        visited[srcVertex] = false;

        return hasPath;
    }

    public void checkExistenceOfEdgeLengthLimitedPaths_Graph(int V, int[][] edges, int[][] queries) {
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //based on DFS but TLE
        int m = queries.length;
        boolean[] result = new boolean[m];
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        boolean[] visited = new boolean[V];

        //undirected graph
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, weight));
        }

        for (int i = 0; i < m; i++) {
            int src = queries[i][0];
            int dest = queries[i][1];
            int limit = queries[i][2];

            boolean hasPath = checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(
                    graph, visited, src, dest, limit);
            result[i] = hasPath;
        }
        //output
        System.out.println("Check existence of edge length limited paths : " + Arrays.toString(result));
    }

    public void checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(
            int V, int[][] edges, int[][] queries) {
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/editorial/
        //based on UNION FIND
        class UnionFind {

            //explanation union-find : https://youtu.be/Kptz-NVA2RE
            private int[] parent;
            private int[] rank;

            UnionFind(int size) {
                parent = new int[size];
                rank = new int[size];
                for (int i = 0; i < size; ++i) {
                    parent[i] = i;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void join(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                // node1 and node2 already belong to same group.
                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {

                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {

                    parent[parent1] = parent2;
                } else {

                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }

            public boolean areConnected(int node1, int node2) {
                return find(node1) == find(node2);
            }
        }

        UnionFind unionFind = new UnionFind(V);

        int queriesLen = queries.length;

        boolean[] answer = new boolean[queriesLen];

        // Store original indices with all queries.
        int[][] queriesWithIndex = new int[queriesLen][4];

        for (int i = 0; i < queriesLen; i++) {

            queriesWithIndex[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i};
        }

        // Sort all edges in increasing order of their edge weights.
        Arrays.sort(edges, (a, b) -> Integer.compare(a[2], b[2]));

        // Sort all queries in increasing order of the limit of edge allowed.
        Arrays.sort(queriesWithIndex, (a, b) -> Integer.compare(a[2], b[2]));

        int edgeLength = edges.length;
        int edgeIndex = 0;

        // Iterate on each query one by one.
        for (int[] query : queriesWithIndex) {

            int nodeU = query[0];
            int nodeV = query[1];
            int limit = query[2];
            int queryOriginalIndex = query[3];

            //we can attach all edges which satisfy the limit given by the query.
            //since the edges and queries are sorted by their weight/ limits, from
            //below while loop, we will form the disjoint set of only those edges
            //whose edge-weight is STRICTLY LESS than the curr 'limit'
            while (edgeIndex < edgeLength && edges[edgeIndex][2] < limit) {

                int u = edges[edgeIndex][0];
                int v = edges[edgeIndex][1];

                unionFind.join(u, v);

                edgeIndex++;
            }

            // If both nodes belong to the same component, it means we can reach them.
            answer[queryOriginalIndex] = unionFind.areConnected(nodeU, nodeV);
        }
        //output
        System.out.println("Check existence of edge length limited paths : " + Arrays.toString(answer));
    }

    public void redundantConnections_Graph(int[][] edges) {
        //https://leetcode.com/problems/redundant-connection/description/
        //based on UNION FIND/ DISJOINT SET
        int n = edges.length;
        class UnionFind {

            //explanation union-find : https://youtu.be/Kptz-NVA2RE
            int[] parent;
            int[] rank;

            public UnionFind(int n) {
                //n + 1 because nodes in this graphs are labeled as [1 to n]
                parent = new int[n + 1];
                rank = new int[n + 1];
                //initailly each node i is representative of itself
                for (int u = 0; u < n + 1; u++) {
                    parent[u] = u;
                }
            }

            public int find(int node) {
                //for a given node 'node' find the top most root/representative
                //of this node in a certain set
                if (parent[node] == node) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int rep1 = find(node1);
                int rep2 = find(node2);

                //if the representative of both the nodes node1 & node2 are same
                //that means these two nodes have the same root, hence an edge
                //between node1 to node2 or vice versa will a redundant connection
                if (rep1 == rep2) {
                    return;
                }

                if (rank[rep1] < rank[rep2]) {
                    parent[rep1] = rep2;
                } else if (rank[rep1] > rank[rep2]) {
                    parent[rep2] = rep1;
                } else {
                    //both the representative have the same ranks then we can
                    //assign anyone as others node's representative
                    //here rep1 will become parent of rep2 hence rank of rep1 should
                    //be increased
                    parent[rep2] = rep1;
                    rank[rep1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind(n);
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int repU = unionFind.find(u);
            int repV = unionFind.find(v);
            //if the representative of nodes i & j are same, means they already
            //have a common root with which this i & j are connected then here
            //if we form an edge i -> j or j -> i that will a redundant connection
            //And any redundant connection/edge that occurs first in given edges[][]
            //return that
            if (repU == repV) {
                System.out.println("Redundant connection : " + Arrays.toString(new int[]{u, v}));
                return;
            }
            //if the above if() cond fails, means there is no common representative
            //or root of the nodes i & j yet, now we can put them in a set and then
            //we will have a common representative/root for them later on
            unionFind.union(u, v);
        }
        //if no redundant connection occures, however according to question there
        //will always a redundant edge
        System.out.println("Redundant connection : " + Arrays.toString(new int[]{}));
    }

    public void removeMaxEdgesToKeepGraphFullyTraversable_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int n) {
                //a connectedGroups in union find will tell how many diff disjoint
                //sets/groups are there in the graph
                //initially, each node in graph is in its own group
                //hence connectedGroups = n
                connectedGroups = n;
                parent = new int[n + 1];
                rank = new int[n + 1];
                //initially, each node is the root/representative of itself
                for (int node = 0; node < n + 1; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public int union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                //if the parent of both the nodes node1 & node2 are same then
                //no union needs to perform, return 0
                if (parent1 == parent2) {
                    return 0;
                }

                if (rank[parent1] > rank[parent2]) {

                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {

                    parent[parent1] = parent2;
                } else {

                    parent[parent2] = parent1;
                    rank[parent1]++;
                }

                //here we have successfully performed union on node1 & node2 that
                //means now either node1 is in node2 group OR node2 is in node1
                //group but any of the case we are merging one group into another
                //hence one connectedGroups is removed with this
                connectedGroups--;
                //return 1, as we have successfully performed union
                return 1;
            }

            public boolean areAllNodesConnected() {
                //with this question, we need that from every node in the graph,
                //we should be able to traverse to every other nodes, in terms of
                //disjoints set/ union-find, if every node is traversable by every
                //other nodes of the graph then all those nodes/edges are in the
                //same group that means initially connectedGroups started off as n
                //(each nodes in its own groups), now after union operations if
                //connectedGroups == 1 means that all nodes are now in same group
                //and hence tells that we can traverse every node from every other node.
                return connectedGroups == 1;
            }
        }

        int totalEdges = edges.length;

        int connectedEdges = 0;

        UnionFind aliceSet = new UnionFind(V);
        UnionFind bobSet = new UnionFind(V);

        //sort the edges based on their type in decr order i.e, 3, 2, 1
        //as we need to process all edges with type == 3 first
        Arrays.sort(edges, (a, b) -> Integer.compare(b[0], a[0]));

        for (int[] edge : edges) {

            int type = edge[0];
            int u = edge[1];
            int v = edge[2];

            //since, are edges[][] is now sorted, all case for type == 3 will be
            //executed first and then for alice & bob resepctively
            switch (type) {
                case 3:
                    //bitwise OR(|) means (0 | 1 == 1), (0 | 0 == 0), (1 | 1 == 1)
                    //similar to (aliceSet.union(i, j) == 1 || bobSet.union(i, j) == 1) ? 1 : 0;
                    //if a common edge can be added in these two diff sets that means
                    //we have used 1 edge that allows both alice & bob to travel
                    connectedEdges += (aliceSet.union(u, v) | bobSet.union(u, v));
                    break;
                case 1:
                    //connect edges for alice, connectedEdges will be counted
                    //as +1 only if the curr edge is not already connected as
                    //type == 3 edge
                    connectedEdges += aliceSet.union(u, v);
                    break;
                case 2:
                    //connect edges for bob, connectedEdges will be counted
                    //as +1 only if the curr edge is not already connected as
                    //type == 3 edge
                    connectedEdges += bobSet.union(u, v);
                    break;
            }
        }

        if (aliceSet.areAllNodesConnected() && bobSet.areAllNodesConnected()) {
            System.out.println("Max edge removed to keep all the nodes fully traversable : "
                    + (totalEdges - connectedEdges));
            return;
        }
        System.out.println("Max edge removed to keep all the nodes fully traversable : -1");
    }

    public void detectCycleIn2DGrid_Graph(char[][] grid) {
        //https://leetcode.com/problems/detect-cycles-in-2d-grid/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        boolean[][] visited = new boolean[ROW][COL];
        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            boolean helperDFS(char[][] grid, int row, int col, int prevRow, int prevCol, char toMatch) {

                if (isOutOfBounds(row, col)) {
                    return false;
                }

                //if the row & col, is already in visited, means we are in the cycle here
                if (visited[row][col]) {
                    return true;
                }

                visited[row][col] = true;

                for (int[] dir : dirs) {

                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    //skip, if new row & col are not valid locations on grid
                    if (isOutOfBounds(newRow, newCol)) {
                        continue;
                    }

                    //skip, if new row & col is same as prev row & col from where we come to
                    //curr row & col we don't want to traverse back to that location
                    //note: we can't use visited[][] for this if() block, why?
                    //because this will give a FALSE presence of cycle in the curr
                    //path, cycle path is checked in starting of recursion
                    if (newRow == prevRow && newCol == prevCol) {
                        continue;
                    }

                    //skip, if char at new row & col in grid is not same as the
                    //char we need to 'toMatch'
                    if (grid[newRow][newCol] != toMatch) {
                        continue;
                    }

                    //traverse in all 4-dir to check if there is any cycle
                    //newRow & newCol will become curr row & col for next recur
                    //here curr row & col will become prevRow & prevCol for next recur
                    //toMatch remain same, as we need to find cycle in grid[][] having
                    //char same as 'toMatch'
                    if (helperDFS(grid, newRow, newCol, row, col, toMatch)) {
                        return true;
                    }
                }

                return false;
            }
        }

        Helper helper = new Helper();

        boolean hasCycle = false;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (visited[r][c]) {
                    continue;
                }
                //bitwise OR check (|=) same as hasCycle = hasCycle || helper(...)
                //starting to check the cycle in grid from row & col == r & c
                //-1, -1 as prev row & col, as there is no prev row & col to r & c
                //and the cycle should contains char same as 'grid[r][c]'
                //In question, we need to return true if we find a single cycle
                //if(helper.helperDFS(grid, r, c, -1, -1, grid[r][c])) return true
                hasCycle |= helper.helperDFS(grid, r, c, -1, -1, grid[r][c]);
            }
        }
        //output
        System.out.println("Detect cycle in 2D grid : " + hasCycle);
    }

    public int makingALargeIsland_Graph(int[][] grid) {
        //https://leetcode.com/problems/making-a-large-island/description/
        //https://leetcode.com/problems/making-a-large-island/solutions/2460067/java-simple-easy-to-understand-using-dsu/
        //explanation: https://youtu.be/lgiz0Oup6gM
        //based on DSU/ UNION FIND on 2D grid graph
        //given grid is N * N matrix hence ROW == COL == N
        int ROW = grid.length;
        int COL = ROW;

        int[][] dirs = new int[][]{
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        //if grid contains only 1 row and col(means single element) and that is
        //also 1 then return 1
        if (ROW == 1 && grid[0][0] == 1) {
            return 1;
        }

        int maxConnectedIslandSize = 0;

        //for this question, we will have UnionFind by size[]
        class UnionFind {

            int[] parent;
            //size[node] is size of connected graph(==> all the connected nodes)
            //whoose parent/representative is node
            int[] size;

            int maxSizeDistinctIsland = 0;

            public UnionFind(int V) {
                parent = new int[V];
                //size of connected groups, initially all the nodes are in their
                //own group hence their individual size is 1
                size = new int[V];
                Arrays.fill(size, 1);
                //initially all the nodes are in their own group hence each node
                //is parent of its own group
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (size[parent1] > size[parent2]) {
                    parent[parent2] = parent1;
                    //since parent1 is now the parent of connected group that
                    //contains all the nodes from parent1 & now parent2
                    //hence the size[parent1] also increased by size[parent2]
                    //means total nodes under parent1 = nodes under parent1 + nodes under parent2
                    size[parent1] += size[parent2];
                } else if (size[parent1] < size[parent2]) {
                    parent[parent1] = parent2;
                    //since parent2 is now the parent of connected group that
                    //contains all the nodes from parent2 & now parent1
                    //hence the size[parent2] also increased by size[parent1]
                    //means total nodes under parent2 = nodes under parent1 + nodes under parent2
                    size[parent2] += size[parent1];
                } else {
                    parent[parent2] = parent1;
                    //since parent1 is now the parent of connected group that
                    //contains all the nodes from parent1 & now parent2
                    //hence the size[parent1] also increased by size[parent2]
                    //means total nodes under parent1 = nodes under parent1 + nodes under parent2
                    size[parent1] += size[parent2];
                }

                //this represents the max size of any distinct/separated island group
                maxSizeDistinctIsland = Math.max(
                        maxSizeDistinctIsland,
                        Math.max(size[parent1], size[parent2]));

            }

            public int sizeOfConnectedIslandGroup(int parent) {
                return size[parent];
            }
        }

        UnionFind unionFind = new UnionFind(ROW * COL);

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                if (grid[r][c] == 1) {
                    //src node U == cell index of curr grid[r][c] cell
                    int nodeU = r * ROW + c;

                    //generate all the 4 adjacent row & col from the curr r & c
                    for (int[] dir : dirs) {
                        int newRow = r + dir[0];
                        int newCol = c + dir[1];

                        //skip, if new row & col locations on grid 'isOutOfBounds'
                        if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                            continue;
                        }

                        //skip, if new row & col locations on grid is not '1' cell
                        if (grid[newRow][newCol] == 0) {
                            continue;
                        }

                        //valid dest node V == cell index of 4-dir adjacent to curr r & c
                        int nodeV = newRow * ROW + newCol;
                        //make a union between nodeU and nodeV, where both
                        //nodeU and nodeV belongs to diff but 4-dir adjacent (row, col)
                        //having '1' in their cells
                        unionFind.union(nodeU, nodeV);
                    }
                }
            }
        }

        //from here we will check which '0' cell on grid will give us the larger
        //connected island group if we convert that '0' cell to '1' cell
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                //if the curr cell is '0', then check to which '1' it is connected,
                //in adjacent 4-dir, find the parent for that '1' island group
                if (grid[r][c] == 0) {

                    //since we are going to check adjacent 4-dir to curr grid[r][c] = 0
                    //and that should also contains 1 inorder to make one large island
                    //in worst case parents set can have atmost 4 parent of cells having 1
                    Set<Integer> parents = new HashSet<>();

                    //generate all the 4 adjacent row & col from the curr r & c
                    //if these new row & col are valid and have '1' in cell then
                    //find the parent for this '1' island group
                    for (int[] dir : dirs) {

                        int newRow = r + dir[0];
                        int newCol = c + dir[1];

                        //skip, if new row & col locations on grid 'isOutOfBounds'
                        if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                            continue;
                        }

                        //skip, if new row & col locations on grid is not '1' cell
                        if (grid[newRow][newCol] == 0) {
                            continue;
                        }

                        //a node == cell index, which is 4-dir adjacent to curr
                        //r & c
                        int node = newRow * ROW + newCol;
                        int parent = unionFind.find(node);
                        parents.add(parent);
                    }

                    //connectedIslandSize is 1 because we are simulating to convert
                    //curr '0' as '1' AND, it will add up all the distinct island sizes
                    //connected to each other
                    int connectedIslandSize = 1;
                    for (int parent : parents) {
                        connectedIslandSize += unionFind.sizeOfConnectedIslandGroup(parent);
                    }

                    maxConnectedIslandSize = Math.max(
                            maxConnectedIslandSize,
                            connectedIslandSize);
                }
            }
        }
        return Math.max(maxConnectedIslandSize, unionFind.maxSizeDistinctIsland);
    }

    public boolean validateBinaryTreeNodes_Graph(int n, int[] leftChild, int[] rightChild) {
        //......................T: O(N * alpha(N)), N is total roots provided,
        //alpha(N) is inverse ackmann function which is near about constant.
        //find() & union) operations take alpha(n) time and we have to perform
        //find & union operation over N roots hence gives the O(N * alpha(N))
        //......................S: O(N), N is space required by parent[]
        //https://leetcode.com/problems/validate-binary-tree-nodes/description/
        //based on UNION FIND
        class UnionFind {

            //here rank[] is not neccessary as we just want to assign/make union of
            //each child nodes (left or right) to its 'root' node
            int[] parent;
            int connectedGroups;

            public UnionFind(int n) {
                connectedGroups = n;
                parent = new int[n];
                for (int node = 0; node < n; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public boolean union(int root, int child) {
                //parent1 is top-most root node/parent of curr 'root'
                int parent1 = find(root);
                //parent2 is top-most root node/parent of curr 'child'
                //but while finding a parent to any child at this point should
                //only belongs to itself (==> child should be parent of
                //itself ==> parent2 == child
                //==> only for this question and given condition)
                int parent2 = find(child);

                //union is not possible(== return false) because
                //1. root & child forming a cycle condition (parent1 == parent2)
                //2. child is already associated to different parent but
                //ideally all the child should be parent of itself initailly (parent2 != child)
                if (parent1 == parent2 || parent2 != child) {
                    return false;
                }

                //rank[] is not necessary here and use of rank[] might give you
                //the wrong answer, why?
                //because with use of rank[] we determine that either 'parent1'
                //will become parent of 'parent2' group or vice verse but here
                //we already know that given 'root' will be the parent of child
                //below statement is same as parent['child'] = 'root'
                parent[parent2] = parent1;

                connectedGroups--;
                return true;
            }

            public boolean isTree() {
                return connectedGroups == 1;
            }
        }

        UnionFind unionFind = new UnionFind(n);

        for (int root = 0; root < n; root++) {
            int left = leftChild[root];
            int right = rightChild[root];

            if (left != -1 && !unionFind.union(root, left)) {
                return false;
            }

            if (right != -1 && !unionFind.union(root, right)) {
                return false;
            }
        }
        return unionFind.isTree();
    }

    public void maximalNetworkRank_Graph(int n, int[][] roads) {
        //https://leetcode.com/problems/maximal-network-rank/description/
        /*
        The network rank of two different cities is defined as the total number
        of directly connected roads to either city. If a road is directly connected
        to both cities, it is only counted once.
         */
        boolean[][] isConnected = new boolean[n][n];
        int[] inDegrees = new int[n];

        for (int[] road : roads) {

            int cityA = road[0];
            int cityB = road[1];

            //given road[] are bidirectional, cityA has an outgoing edge to cityB
            //causing indegree to cityB
            //similarly, cityB also has an outgoing edge to cityA causing indegree
            //to cityA
            inDegrees[cityA]++;
            inDegrees[cityB]++;

            //given roads[] are bidirectional, so cityA is connected to cityB
            //and cityB is connected to cityA
            //cityA <--> cityB
            isConnected[cityA][cityB] = true;
            isConnected[cityB][cityA] = true;
        }

        int maxRank = 0;

        //there can be disconnected roads in roads[] so need to check all the pairs
        for (int cityA = 0; cityA < n; cityA++) {
            for (int cityB = cityA + 1; cityB < n; cityB++) {
                maxRank = Math.max(
                        maxRank,
                        //ranks for curr city A & B will be, all the road connections from A to other cities
                        //+ all the road connections from B to other cities
                        //- remove 1, if both city A & B are also connected to each other causing
                        //indegrees to be counted twice between city A & B
                        //otherwise if they are not connected then nothing to remove (==> 0)
                        inDegrees[cityA] + inDegrees[cityB] - (isConnected[cityA][cityB] ? 1 : 0)
                );
            }
        }
        //output
        System.out.println("Maximal network ranks : " + maxRank);
    }

    public void evaluateDivision_Graph(String[][] equations, double[] values, String[][] queries) {
        //https://leetcode.com/problems/evaluate-division/description/
        //based on BFS and some basic maths divisions
        class Node {

            String vertex;
            double value;

            public Node(String vertex, double value) {
                this.vertex = vertex;
                this.value = value;
            }

        }

        int eqnLen = equations.length;
        Map<String, List<Node>> graph = new HashMap<>();

        int qLen = queries.length;
        double[] evaluatedResult = new double[qLen];

        class Helper {

            double helperBFS(String srcVertex, String destVertex) {

                //return -1.0, if either of the numerator or denominator is not
                //present in the graph means the equation "srcVertex / destVertex" is
                //invalid
                if (!graph.containsKey(srcVertex) || !graph.containsKey(destVertex)) {
                    return -1.0;
                }

                Set<String> visited = new HashSet<>();
                Queue<Node> queue = new LinkedList<>();

                //initial src == srcVertex, initial product value == 1
                queue.add(new Node(srcVertex, 1));
                visited.add(srcVertex);

                while (!queue.isEmpty()) {

                    Node currNode = queue.poll();

                    //if we have reached our dest vertex, we can return our final
                    //product value == currNode.value
                    if (currNode.vertex.equals(destVertex)) {
                        return currNode.value;
                    }

                    for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                        if (visited.contains(childNode.vertex)) {
                            continue;
                        }

                        visited.add(childNode.vertex);
                        queue.add(new Node(childNode.vertex, currNode.value * childNode.value));
                    }
                }
                return -1.0;
            }

        }

        Helper helper = new Helper();

        for (int i = 0; i < eqnLen; i++) {

            String nodeU = equations[i][0];
            String nodeV = equations[i][1];
            double value = values[i];

            //in the curr equations[i] ex: ["a", "b"] whose value = values[i]
            //any curr i-th equation will mean "a" / "b" = 'value'
            //by basic math logic we have a relationship that is,
            //expression : a/b = value then reciprocated relationship will be
            //expression : b/a = 1/value
            //here we need to form a graph which will be undirected-weighted graph
            //means each numerator and denominator value from the equation will
            //have a weighted edge to each other based on maths division & reciprocal
            //concept
            //nodeU --> {nodeV, value} ==> "a" --> {"b", 'value'}
            graph.putIfAbsent(nodeU, new ArrayList<>());
            graph.get(nodeU).add(new Node(nodeV, value));

            //nodeV --> {nodeU, 1 / value} ==> "b" --> {"a", '1.0 / value'}
            graph.putIfAbsent(nodeV, new ArrayList<>());
            graph.get(nodeV).add(new Node(nodeU, (1.0 / value)));
        }

        for (int i = 0; i < qLen; i++) {

            String nodeU = queries[i][0];
            String nodeV = queries[i][1];

            evaluatedResult[i] = helper.helperBFS(nodeU, nodeV);
        }
        //output
        System.out.println("Evaluate division : " + Arrays.toString(evaluatedResult));
    }

    public void cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(int n, int[][] edges, int distThreshold) {
        //https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/
        //based on DIJKSTRA ALGO, SHORTEST PATH from all NODES to all OTHER-NODES
        class Node {

            int vertex;
            int weight;

            public Node(int vertex, int weight) {
                this.vertex = vertex;
                this.weight = weight;
            }

        }

        Map<Integer, List<Node>> graph = new HashMap<>();

        class Helper {

            int helperDijkstraForShortestPathWithinThreshold(int srcCity) {

                int[] dist = new int[n];
                Arrays.fill(dist, Integer.MAX_VALUE);

                int srcCityConnectedCities = 0;

                PriorityQueue<Node> minHeapWeight = new PriorityQueue<>(
                        (a, b) -> a.weight - b.weight);

                minHeapWeight.add(new Node(srcCity, 0));
                dist[srcCity] = 0;

                while (!minHeapWeight.isEmpty()) {

                    Node currNode = minHeapWeight.poll();

                    for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                        //skip, if the dist to reach next child node from curr node
                        //having weight in between as 'childNode.weight' is more than
                        //the threshold given
                        if (dist[currNode.vertex] + childNode.weight > distThreshold) {
                            continue;
                        }

                        //if the dist to reach child node from curr node is under the threshold
                        //we can perform our typical 'dijkstra algo'
                        if (dist[childNode.vertex] > dist[currNode.vertex] + childNode.weight) {

                            //here we are updating the dist to reach child node for the
                            //first time, because only for the first time dist[childNode.vertex]
                            //will be Integer.MAX_VALUE hence this curr child node is reachable
                            //via the curr node under threshold limit given and we only need to
                            //count these connected cities only once
                            if (dist[childNode.vertex] == Integer.MAX_VALUE) {
                                srcCityConnectedCities++;
                            }

                            dist[childNode.vertex] = dist[currNode.vertex] + childNode.weight;
                            minHeapWeight.add(new Node(childNode.vertex, dist[childNode.vertex]));
                        }
                    }
                }
                return srcCityConnectedCities;
            }

        }

        Helper helper = new Helper();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            //undirected-weighted graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new Node(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new Node(u, weight));
        }

        //minConnectedCities = will have the least number of cities connected to
        //a city
        int minConnectedCities = Integer.MAX_VALUE;
        //city = city that have the smallest number of cities connected
        int city = -1;

        for (int srcCity = 0; srcCity < n; srcCity++) {

            int currNodeConnectedCities = helper.helperDijkstraForShortestPathWithinThreshold(srcCity);

            if (currNodeConnectedCities < minConnectedCities) {
                minConnectedCities = currNodeConnectedCities;
                city = srcCity;
            } else if (currNodeConnectedCities == minConnectedCities) {
                //if two cities have same number of cities connected to them then
                //choose the city with bigger city index(its a linear loop so curr
                //srcCity will always be bigger than previous 'city')
                city = srcCity;
            }
        }
        //output
        System.out.println("City with smallest number of cities connected within given threshold : " + city);
    }

    public boolean waterAndJug_Graph(int jug1Capacity, int jug2Capacity, int targetCapacity) {
        //https://leetcode.com/problems/water-and-jug-problem/description/
        //https://leetcode.com/problems/water-and-jug-problem/solutions/3456539/bfs-java-solution/
        //based on BFS
        //if the target capacity is more than the combined capacities of jugs
        //then we can never achieve target capacity using these jugs
        if (targetCapacity > jug1Capacity + jug2Capacity) {
            return false;
        }

        //operations allowed on both the given jugs
        int[] operations = {
                //fill jug 1 to its full capacity
                jug1Capacity,
                //empty jug 1 completely
                -jug1Capacity,
                //fill jug 2 to its full capacity
                jug2Capacity,
                //empty jug 2 completely
                -jug2Capacity
        };

        //starting with water capacity
        int initialWaterCapacity = 0;

        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();

        visited.add(initialWaterCapacity);
        queue.add(initialWaterCapacity);

        while (!queue.isEmpty()) {

            int currWaterCapacity = queue.poll();

            //return true, if target capacity is reached
            if (currWaterCapacity == targetCapacity) {
                return true;
            }

            for (int oprn : operations) {

                //possible next capacity after applying it on the curr water capacity
                int nextWaterCapacity = currWaterCapacity + oprn;

                //skip, if the next water capacity is already considered
                if (visited.contains(nextWaterCapacity)) {
                    continue;
                }

                //skip, if the next water capacity is not in the range of
                //(0 <= nextWaterCapacity <= jug1Capacity + jug2Capacity) because
                //we can hold this much of water using both the jugs
                if (!(nextWaterCapacity >= 0 && nextWaterCapacity <= jug1Capacity + jug2Capacity)) {
                    continue;
                }

                visited.add(nextWaterCapacity);
                queue.add(nextWaterCapacity);
            }
        }
        return false;
    }

    public void buildMatrixWithConditions_Graph(int k, int[][] rowConditions, int[][] colConditions) {
        //https://leetcode.com/problems/build-a-matrix-with-conditions/description/
        //based on GRAPH, TOPOLOGICAL SORT, DETECT DIRECTED GRAPH CYCLE, courseScheduleTwo_Graph()
        /*
        constraint:
        1. rowConditions[i].length == colConditions[i].length == 2
        2. 1 <= abovei, belowi, lefti, righti <= k
        3. abovei != belowi
        4. lefti != righti
         */
        //k == V == total nodes to be placed in k * k matrix, that is [1 to k] nodes
        Map<Integer, List<Integer>> graph = new HashMap<>();
        final boolean[] visited = new boolean[k + 1];
        final boolean[] recurStack = new boolean[k + 1];

        class Helper {

            void createGraph(int[][] edges) {

                for (int[] edge : edges) {

                    int nodeU = edge[0];
                    int nodeV = edge[1];

                    //directed graph
                    //where edge is from i --> j
                    graph.putIfAbsent(nodeU, new ArrayList<>());
                    graph.get(nodeU).add(nodeV);
                }
            }

            boolean topoSortWithDetectDirectedGraphCycle(int node, List<Integer> orders) {

                if (recurStack[node]) {
                    return true;
                }

                if (visited[node]) {
                    return false;
                }

                visited[node] = true;
                recurStack[node] = true;

                for (int mandatoryNode : graph.getOrDefault(node, new ArrayList<>())) {
                    //return true, if there exist any cyclic case in any of the
                    //given rowConditions[] or colConditions[]
                    if (topoSortWithDetectDirectedGraphCycle(mandatoryNode, orders)) {
                        return true;
                    }
                }

                orders.add(node);

                recurStack[node] = false;

                return false;
            }

            int[][] createMatrix(int k, List<Integer> rowOrders, List<Integer> colOrders) {

                int[][] matrix = new int[k][k];

                //cells[kth-value] = [row, col]
                int[][] cells = new int[k + 1][2];

                //why saving row & col index (k - i - 1)?
                //beacuse both rowOrders & colOrders saved k-value in dependent
                //orders in the stack wise order(reverse order for both rowOrder and colOrders)
                //where their 0-th index value should be place in either last
                //row or last col
                for (int row = 0; row < k; row++) {
                    int val = rowOrders.get(row);
                    cells[val][0] = k - row - 1;
                }

                for (int col = 0; col < k; col++) {
                    int val = colOrders.get(col);
                    cells[val][1] = k - col - 1;
                }

                for (int val = 1; val <= k; val++) {

                    int row = cells[val][0];
                    int col = cells[val][1];

                    matrix[row][col] = val;
                }

                return matrix;
            }

        }

        Helper helper = new Helper();

        //given rowConditions[] states that in order to place a value denoted
        //as 'above' we first place a value denoted as 'below', hence this causes
        //the rowConditions[] to have dependent directed edges from above --> below
        //so create a directed-graph out of rowConditions[]
        helper.createGraph(rowConditions);

        //once we have a directed-graph for the row conditions on above --> below
        //now find the row wise order placing all the [1 to k] values in matrix
        List<Integer> rowOrders = new ArrayList<>();
        for (int node = 1; node <= k; node++) {

            if (visited[node]) {
                continue;
            }

            if (helper.topoSortWithDetectDirectedGraphCycle(node, rowOrders)) {
                //here exist a cyclic cond in the given rowConditions[]
                System.out.println("Matrix can't be build");
                return;
            }
        }

        //reset
        graph.clear();
        Arrays.fill(visited, false);
        Arrays.fill(recurStack, false);

        //given colConditions[] states that in order to place a value denoted
        //as 'left' we first place a value denoted as 'right', hence this causes
        //the colConditions[] to have dependent directed edges from left --> right
        //so create a directed-graph out of colConditions[]
        helper.createGraph(colConditions);

        //once we have a directed-graph for the col conditions on left --> right
        //now find the col wise order placing all the [1 to k] values in matrix
        List<Integer> colOrders = new ArrayList<>();
        for (int node = 1; node <= k; node++) {

            if (visited[node]) {
                continue;
            }

            if (helper.topoSortWithDetectDirectedGraphCycle(node, colOrders)) {
                //here exist a cyclic cond in the given colConditions[]
                System.out.println("Matrix can't be build");
                return;
            }
        }

        int[][] matrix = helper.createMatrix(k, rowOrders, colOrders);
        //output
        System.out.println("Matrix with condition : ");
        for (int[] row : matrix) {
            System.out.println(Arrays.toString(row));
        }
    }

    public int minCostToReachDestinationInTime_Graph(int[][] edges, int maxTime, int[] fees) {
        //https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/description/
        //based on DIJKSTRA ALGO but little modified

        class Node {

            int vertex;
            int totalTime;
            int totalCost;

            public Node(int vertex, int totalTime, int totalCost) {
                this.vertex = vertex;
                this.totalTime = totalTime;
                this.totalCost = totalCost;
            }

        }

        int V = fees.length;
        Map<Integer, List<Node>> graph = new HashMap<>();

        //create a weighted undirected graph
        for (int[] edge : edges) {

            int u = edge[0];
            int v = edge[1];
            int time = edge[2];

            graph.putIfAbsent(u, new ArrayList<>());
            //edge between u -> v where 'time' is the time taken to reach
            //u to v and fees[v] is the passing fees needs to be
            //paid to reach node v from node u
            graph.get(u).add(new Node(v, time, fees[v]));

            graph.putIfAbsent(v, new ArrayList<>());
            //edge between v -> u where 'time' is the time taken to reach
            //v to u and fees[u] is the passing fees needs to be
            //paid to reach node u from node v
            graph.get(v).add(new Node(u, time, fees[u]));
        }

        int[] minTime = new int[V];
        Arrays.fill(minTime, Integer.MAX_VALUE);

        //queue to store nodes where we get min cost at top of heap,
        //if costs are same sort nodes by their min times otherwise min costs
        PriorityQueue<Node> queue = new PriorityQueue<>(
                (a, b) -> a.totalCost == b.totalCost
                        ? Integer.compare(a.totalTime, b.totalTime)
                        : Integer.compare(a.totalCost, b.totalCost));

        int src = 0;
        int DEST_VERTEX = V - 1;
        minTime[src] = 0;
        queue.add(new Node(src, 0, fees[src]));

        while (!queue.isEmpty()) {

            Node currNode = queue.poll();

            if (currNode.vertex == DEST_VERTEX) {
                return currNode.totalCost;
            }

            for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                //skip, if the total time to reach the curr child node from its
                //parent currNode is taking currNode.totalTime + childNode.totalTime
                //which is more than the given threshold 'maxTime'
                //here we will not consider minTime[currNode.vertex] as minTime[]
                //is based on dijkstra algo 'dist[]' which will store shortest dist/
                //min time taken to reach a child node from its parent node, here
                //we need to consider the total time taken from actual
                //(src node == 0 to actual final dest node == (j - 1))
                if (currNode.totalTime + childNode.totalTime > maxTime) {
                    continue;
                }

                if (minTime[childNode.vertex] > currNode.totalTime + childNode.totalTime) {

                    minTime[childNode.vertex] = currNode.totalTime + childNode.totalTime;

                    queue.add(new Node(
                            childNode.vertex,
                            minTime[childNode.vertex],
                            currNode.totalCost + fees[childNode.vertex]));
                }
            }
        }
        return -1;
    }

    public double pathWithMaxProbability_Graph(int n, int[][] edges, double[] succProb, int start, int end) {
        //https://leetcode.com/problems/path-with-maximum-probability/description/
        //based on GRAPH BFS SHORTEST PATH
        class Node {

            int vertex;
            double succProb;

            public Node(int vertex, double succProb) {
                this.vertex = vertex;
                this.succProb = succProb;
            }

        }

        int edgeLen = edges.length;
        Map<Integer, List<Node>> graph = new HashMap<>();

        for (int i = 0; i < edgeLen; i++) {

            int u = edges[i][0];
            int v = edges[i][1];

            //currEdgeSuccProb is the common succ probability between the undirected
            //edge (u <---> v) that is
            //(u ---> currEdgeSuccProb ---> v)
            //(v ---> currEdgeSuccProb ---> u)
            double currEdgeSuccProb = succProb[i];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new Node(v, currEdgeSuccProb));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new Node(u, currEdgeSuccProb));
        }

        boolean[] visited = new boolean[n];

        //as we need the max success probability path between the start to end, so
        //creating the max heap of success probability that means a higher success
        //probability will be on peek of queue
        PriorityQueue<Node> queue = new PriorityQueue<>(
                //max heap of succProb
                (a, b) -> Double.compare(b.succProb, a.succProb));

        visited[start] = true;
        //a success probability for a path is the multiplication of succProb in
        //the edges followed in that path
        //ex: 0 <-0.5-> 1 <-0.5-> 2 ==> 1.0 * 0.5 * 0.5 = 0.25
        //probability to reach start from start is 1.0 thats why starting with
        //a prod value of 1.0
        queue.add(new Node(start, 1.0));

        while (!queue.isEmpty()) {

            Node currNode = queue.poll();

            //if we have reached the dest-node(==> end), we can return the success
            //probability product till dest-node, as we have used a max heap to
            //get max success probability for that same reason we have travelled
            //a shortest path(==> shortest BFS level) to reach dest-node with
            //max success value
            if (currNode.vertex == end) {
                return currNode.succProb;
            }

            //this visited[vertex] marking to true is required here only, because
            //we want to put all the possible paths in the queue, that could lead
            //to our dest-node BUT if we had placed this statement in below for()
            //it would have added only 1 vertex(==> say dest-node) and would have marked
            //that vertex as visited = true, now if any other paths that also reaches
            //the same dest-node but with max succ prob value will then be skipped
            //by if(visited[vertex]) statement
            visited[currNode.vertex] = true;

            for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                //skip, if a child node is already visited earlier
                if (visited[childNode.vertex]) {
                    continue;
                }

                //here, put all the possible paths that could reach to dest-node
                //in the queue first, then above we can check if a node is already
                //in the queue then it should not be visited again in next level
                queue.add(new Node(
                        childNode.vertex,
                        currNode.succProb * childNode.succProb));
            }
        }
        //if no path between start to end is possible (in case of disconnected graph
        //where both start and end present in diff graph groups)
        return 0.0;
    }

    public void shortestPathToGetAllKeys_Graph(String[] grid) {
        //https://leetcode.com/problems/shortest-path-to-get-all-keys/description/
        //explanation: https://youtu.be/yt6bi_g4C0I
        //based on GRAPH BFS SHORTEST PATH
        //ideally this questions requires BIT-MAIPULATION technique to optimize
        //this question but this approach is also accepted
        /*
        grid[] = ["@...a", "###.#", "b.A.B"]

        chrGrid[][] =
        [[@ . . . a]
         [# # # . #]
         [b . A . B]]

        '@' ==> srcRow = 0, srcCol = 0

        ideal path:
        -> (0, 0, move = 0, key()) -> (0, 1, move = 1, key()) -> (0, 2, move = 2, key())
        -> (0, 3, move = 3, key()) -> (0, 4, move = 4, key(a)) -> (0, 3, move = 5, key(a))
        -> (1, 3, move = 6, key(a)) -> (2, 3, move = 7, key(a)) -> (2, 2, move = 8, key(a), unlock(A))
        -> (2, 1, move = 9, key(a)) -> (2, 0, move = 10, key(a, b))

        within 10 moves we have collected totalKeys == keys(a, b)

        here we need to maintain 3 parameters as visited state, why?

        see this section of path in above example
        (0, 3, move = 3, key()) -> (0, 4, move = 4, key(a)) -> (0, 3, move = 5, key(a))

        we are moving from cell(0,3) to cell(0,4) and back again to cell(0,3)

        if we had considered visited with just 2 parameter i.e cell(row,col)
        then above 'going back reverse along same path' was not possible as

        cell(0,3) we would have marked visited = true
        then cell(0,4) we would have marked visited = true
        then when we will try to move back to cell(0,3) again we will be skipped
        as visited(cell(0,3)) was already visited and path can't be completed

        BUT

        this same path has given us the intuition on why we should have 3 paramters
        for visited state

        see the same section of path in above example again
        (0, 3, move = 3, key()) -> (0, 4, move = 4, key(a)) -> (0, 3, move = 5, key(a))

        initially cell(0,3) we didn't have any key ==> key()
        then cell(0,4) we collected a key at this cell ==> key(a)
        then when we will try to move back to cell(0,3) again, our state is not
        just cell(0,3) but we have retured with a key(a) as well hence keys collected
        till curr cell is also important state as it makes the path traversal unique

         */

        int ROW = grid.length;
        int COL = grid[0].length();

        int srcRow = 0;
        int srcCol = 0;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int totalKeys = 0;

        class Cell {

            int row;
            int col;
            int moves;
            Set<Character> keys;

            public Cell(int row, int col, int moves) {
                this.row = row;
                this.col = col;
                this.moves = moves;
                keys = new HashSet<>();
            }
        }

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            boolean isAKey(char key) {
                //validate the given 'key' is actually a key or not
                //means it should be a <= key <= f
                //(as per question, ideally it will be just first 6 alphabet,
                //i.e, keys = (a, f) and its respective locks = (A, F))
                return 'a' <= key && key <= 'f';
            }

            boolean isALock(char lock) {
                //validate the given 'lock' is actually a lock or not
                //means it should be A <= lock <= F
                //(as per question, ideally it will be just first 6 alphabet,
                //i.e, keys = (a, f) and its respective locks = (A, F))
                return 'A' <= lock && lock <= 'F';
            }

            boolean hasAKeyForLock(char lock, Set<Character> holdingKeys) {
                //check if curr cell has appropriate key to open this lock
                return holdingKeys.contains(Character.toLowerCase(lock));
            }

            public int helperMinMovesBFS(char[][] grid, int srcRow, int srcCol, int totalKeysToCollect) {

                Set<String> visited = new HashSet<>();

                //minHeap of moves, to have min moves at peek of heap
                PriorityQueue<Cell> queue = new PriorityQueue<>(
                        (a, b) -> Integer.compare(a.moves, b.moves));

                //inital state for visited when we don't have keys along any path
                //we have covered
                visited.add(srcRow + "," + srcCol);
                queue.add(new Cell(srcRow, srcCol, 0));

                while (!queue.isEmpty()) {

                    Cell currCell = queue.poll();

                    //as we have collected all the keys from the grid, return the
                    //moves till this point
                    if (currCell.keys.size() == totalKeysToCollect) {
                        return currCell.moves;
                    }

                    for (int[] dir : dirs) {

                        int newRow = currCell.row + dir[0];
                        int newCol = currCell.col + dir[1];

                        //skip, if new row & col 'isOutOfBounds'
                        if (isOutOfBounds(newRow, newCol)) {
                            continue;
                        }

                        //skip, if new row & col has 'wall' in its grid[][] cell
                        if (grid[newRow][newCol] == '#') {
                            continue;
                        }

                        //skip, if new row & col has a 'lock' but till this curr
                        //cell we don't have access to its associated 'key'
                        if (isALock(grid[newRow][newCol])
                                && !hasAKeyForLock(grid[newRow][newCol], currCell.keys)) {
                            continue;
                        }

                        //skip, if new row & col with keys collected till this curr
                        //cell, collectively has visited previously
                        if (visited.contains(newRow + "," + newCol + "," + currCell.keys)) {
                            continue;
                        }

                        Cell newCell = new Cell(
                                newRow,
                                newCol,
                                currCell.moves + 1);

                        //in next move to new cell from curr cell we pass on all
                        //the keys we have collected so far
                        newCell.keys.addAll(currCell.keys);

                        //if new cell has a 'key' then it is neccessary to collect it
                        if (isAKey(grid[newRow][newCol])) {
                            newCell.keys.add(grid[newRow][newCol]);
                        }

                        visited.add(newRow + "," + newCol + "," + currCell.keys);
                        queue.add(newCell);
                    }
                }

                //return -1, if we can't pick all the keys with any path
                return -1;
            }

        }

        Helper helper = new Helper();

        //converting the string[] grid into char[][] equivalent
        char[][] chrGrid = new char[ROW][COL];
        for (int r = 0; r < ROW; r++) {
            chrGrid[r] = grid[r].toCharArray();
        }

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                //find where should we start our path search from(==> '@' row & col)
                if (chrGrid[r][c] == '@') {

                    srcRow = r;
                    srcCol = c;
                }

                //count all the keys that we ultimately need to collect
                if (helper.isAKey(chrGrid[r][c])) {
                    totalKeys++;
                }
            }
        }

        int minMoves = helper.helperMinMovesBFS(chrGrid, srcRow, srcCol, totalKeys);

        //output
        System.out.println("Shortest path moves to get all the keys : " + minMoves);
    }

    public void lastDayWhereYouCanStillCross_Graph(int ROW, int COL, int[][] cells) {
        //...........................T: O(ROW * COL * LogN)
        //we are doing the binary search on cells[][] of size n taking O(LogN)
        //At each step, we need to BFS over the modified grid, which takes O(ROW * COL)
        //...........................S: O(ROW * COL)
        //space used for visited[][] and grid[][] in each BFS call
        //https://leetcode.com/problems/last-day-where-you-can-still-cross/description/
        //based on GRAPH BFS BINARY SEARCH, EASY TO UNDERSTAND
        /*
        why do we need BINARY SEARCH?

        consider this brute force approach where we will iterate over each cells[i]
        flood the grid[][] and do BFS to check if we can cross the grid 'TOP' to
        'BOTTOM', this brute force approach will not be time efficient as for each
        day of cells[day] we will have to perform BFS

        thats why binary search intuition comes!

        we can check intermediate 'mid' value and can consider it as last day
        only if this mid day has allowed us to cross grid from 'TOP' to 'BOTTOM'

         */
        int n = cells.length;
        int start = 0;
        int end = n - 1;
        int lastDay = 0;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            boolean canCrossGridTopToBottom(int day) {

                boolean[][] isLandCellFlooded = new boolean[ROW][COL];

                //with binary search we are considering 'mid' as the last day upto
                //which we can cross the grid 'TOP' to 'BOTTOM' but that also means
                //from index = 0 to this 'day' isLandCellFlooded/grid has to be
                //flooded with water sequentially
                for (int i = 0; i <= day; i++) {

                    //cells(row, col) given as 1-based index that why do -1 to
                    //get actual grid[row][col] index
                    int currRow = cells[i][0] - 1;
                    int currCol = cells[i][1] - 1;
                    //mark the curr row & col from cells as flooded = true
                    isLandCellFlooded[currRow][currCol] = true;
                }

                int TOP = 0;
                int BOTTOM = ROW - 1;

                boolean[][] visited = new boolean[ROW][COL];
                //int[] represents as {row, col}
                Queue<int[]> queue = new LinkedList<>();

                //put all 'TOP' row's available land cells in queue and with BFS
                //try to reach 'BOTTOM' row by any land paths
                for (int col = 0; col < COL; col++) {

                    //skip, if curr 'TOP' row has some cells which are flooded
                    //with water
                    if (isLandCellFlooded[TOP][col]) {
                        continue;
                    }

                    //pick only available land cells as {row, col}
                    queue.add(new int[]{TOP, col});
                }

                while (!queue.isEmpty()) {

                    int[] currLandCell = queue.poll();

                    int currRow = currLandCell[0];
                    int currCol = currLandCell[1];

                    //if we have reached 'BOTTOM' row, return true as there is a
                    //path from 'TOP' to 'BOTTOM' via available land cells
                    if (currRow == BOTTOM) {
                        return true;
                    }

                    for (int[] dir : dirs) {

                        int newRow = currRow + dir[0];
                        int newCol = currCol + dir[1];

                        //skip, if the new row & col 'isOutOfBounds'
                        if (isOutOfBounds(newRow, newCol)) {
                            continue;
                        }

                        //skip, if the new row & col is already flooded with water
                        //so we can't consider it
                        if (isLandCellFlooded[newRow][newCol]) {
                            continue;
                        }

                        //skip, if the new row & col is already visited
                        if (visited[newRow][newCol]) {
                            continue;
                        }

                        visited[newRow][newCol] = true;
                        //pick only available land cells
                        queue.add(new int[]{newRow, newCol});
                    }
                }
                return false;
            }

        }

        Helper helper = new Helper();

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //if we consider 'mid' as the last day, that means till this day
            //from cells[0 to mid], grid should have been flooded with water
            //now if canCrossGridTopToBottom() return true that would mean 'mid'
            //could be the last day but we would still try some higher 'mid' value
            //to check if some higher 'mid' value can be said the last day so we
            //will move our search space to higher side of cells[] that is [mid + 1 to end]
            if (helper.canCrossGridTopToBottom(mid)) {
                //as day should be in 1-based form so mid index is actually
                //(mid + 1) day
                lastDay = mid + 1;
                start = mid + 1;
            } else {
                //if canCrossGridTopToBottom() return false that would mean 'mid'
                //could not be the last day and also any higher 'mid' value will
                //also not be a valid last day that means we need to move our search
                //space to lower side of cells[] that is [start to mid - 1]
                end = mid - 1;
            }
        }
        //output
        System.out.println("Last day where you can still cross : " + lastDay);
    }

    public int lastDayWhereYouCanStillCross_Graph_UnionFind(int ROW, int COL, int[][] cells) {
        //https://leetcode.com/problems/last-day-where-you-can-still-cross/description/
        //based on GRAPH UNION-FIND
        class UnionFind {

            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }

        }

        UnionFind unionFind = new UnionFind(ROW * COL + 2);

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int[][] waterGrid = new int[ROW][COL];

        int cellLen = cells.length;

        for (int day = cellLen - 1; day >= 0; day--) {

            int currRow = cells[day][0] - 1;
            int currCol = cells[day][1] - 1;

            waterGrid[currRow][currCol] = 1;

            int nodeU = currRow * COL + currCol + 1;

            for (int[] dir : dirs) {

                int newRow = currRow + dir[0];
                int newCol = currCol + dir[1];

                //skip, if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if cell at new row & col is not a water cell to change it
                //to land cell
                if (waterGrid[newRow][newCol] != 1) {
                    continue;
                }

                int nodeV = newRow * COL + newCol + 1;

                unionFind.union(nodeU, nodeV);
            }

            //if curr row is the 'TOP' row
            if (currRow == 0) {
                unionFind.union(0, nodeU);
            }

            //if curr row is the 'BOTTOM' row
            if (currRow == ROW - 1) {
                unionFind.union(ROW * COL + 1, nodeU);
            }

            //by this if(), if 'TOP' row and 'BOTTOM' row are connected via path
            //then they will share same parent, hence return the day-th index as
            //last day
            if (unionFind.find(0) == unionFind.find(ROW * COL + 1)) {
                return day;
            }
        }
        return -1;
    }

    private int loudAndRich_Graph_HelperDFS(
            Map<Integer, List<Integer>> graph, int[] quiet, int vertex, int[] result) {

        if (result[vertex] != -1) {
            return result[vertex];
        }

        result[vertex] = vertex;

        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {

            int candVertex = loudAndRich_Graph_HelperDFS(graph, quiet, childVertex, result);

            if (quiet[candVertex] < quiet[result[vertex]]) {
                result[vertex] = candVertex;
            }
        }
        return result[vertex];
    }

    public void loudAndRich_Graph(int[][] richer, int[] quiet) {
        //https://leetcode.com/problems/loud-and-rich/description/
        int V = quiet.length;

        int[] result = new int[V];
        Arrays.fill(result, -1);

        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] edge : richer) {

            int richU = edge[0];
            int lessRichV = edge[1];

            graph.putIfAbsent(lessRichV, new ArrayList<>());
            graph.get(lessRichV).add(richU);
        }

        for (int u = 0; u < V; u++) {
            loudAndRich_Graph_HelperDFS(graph, quiet, u, result);
        }

        //output
        System.out.println("Lound and rich : " + Arrays.toString(result));
    }

    private int countNumberOfCompleteComponents_Graph_Helper(
            Map<Integer, List<Integer>> graph, boolean[] visited, int vertex, Set<Integer> uniqueEdgesCount) {

        visited[vertex] = true;

        uniqueEdgesCount.add(graph.getOrDefault(vertex, new ArrayList<>()).size());

        int edges = 1;

        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {

            if (visited[childVertex]) {
                continue;
            }

            edges += countNumberOfCompleteComponents_Graph_Helper(
                    graph, visited, childVertex, uniqueEdgesCount);
        }
        return edges;
    }

    public void countNumberOfCompleteComponents_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/count-the-number-of-complete-components/description/
        /*

        A connected component is said to be complete if there exists an edge
        between every pair of its vertices.

        consider this complete component graph

        ..............0--------1
        ...............\....../
        ................\..../
        ..................2

        here {0 = [1,2], 1 = [0,2], 2 = [0,1]} has edge betwen every pair of vertices

        now consider this incomplete graph

        ..............0--------1
        ...............\
        ................\
        ..................2

        here {0 = [1,2], 1 = [0], 2 = [0]}

        whenever we run DFS on a connected component graph and if this connected
        grpah is complete component then

        each vertex as edge count is same
        {0 = [1,2], 1 = [0,2], 2 = [0,1]}
        0.size = 1.size = 2.size == 2
        and hence uniqueEdgeCount for a complete component will have just one value
        as edgeCount

        uniqueEdgeCount = {2} ==> size = 1

        Also, in DFS calls we are calculating the edges through recursive call
        suppose we start witn vertex = 0
        1. call(0) edges = 1 ==> edges += call(1)
        2. call(1) edges = 1 ==> edges += call(2)
        3. call(2) edges = 1 ==> as visited(0, 1) so only return edges ==> 1
        ==> back 2.

        2. edges += call(2) ==> 1 + 1 ==> 2
        ==> as visited(0) so only return edges ==> 2
        ==> back 1.

        1. edges += call(1) ==> 1 + 2 ==> 3
        ==> as visited(2) so only return edges ==> 3
        ==> back main with edges = 3

        connectedEdgesCount = 3

        hence when this statement reached

        ==> uniqueEdgesCount.size() == 1 means the connected graph is complete component
        ==> uniqueEdgesCount.contains(connectedEdgesCount - 1) means total edge count
        should be equal

        if (uniqueEdgesCount.size() == 1 && uniqueEdgesCount.contains(connectedEdgesCount - 1)) {
            completeConnectedGraphs++;
        }

         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {

            int u = edge[0];
            int v = edge[1];

            //undirected graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        boolean[] visited = new boolean[n];

        int completeConnectedGraphs = 0;

        for (int node = 0; node < n; node++) {

            //skip, if the curr 'node' is already visited as a part of previous
            //connected graph
            if (visited[node]) {
                continue;
            }

            //if we say that a connected graph is a complete component that means
            //each vertex of this connected graph will have equal number of edges
            //to other vertices of this connected graph, hence uniqueEdgesCount
            //size should then be 1
            Set<Integer> uniqueEdgesCount = new HashSet<>();

            //in the DFS calls, we will calculate the edge count in the same
            //connected graph, in a complete component this the edgeCount in
            //uniqueEdgeCount should be 1 less than 'connectedEdgesCount'
            int connectedEdgesCount = countNumberOfCompleteComponents_Graph_Helper(
                    graph, visited, node, uniqueEdgesCount);

            //here uniqueEdgesCount.size() == 1 means that its a complete component
            //and the 'connectedEdgesCount' should be 1 less than the edge count in
            //uniqueEdgesCount
            if (uniqueEdgesCount.size() == 1 && uniqueEdgesCount.contains(connectedEdgesCount - 1)) {
                completeConnectedGraphs++;
            }
        }

        //output
        System.out.println("Count number of complete components : " + completeConnectedGraphs);
    }

    public int earliestMomentEveryoneBecomeFriends_Graph(int[][] logs, int n) {
        //https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/description/
        //based on GRAPH, UNION-FIND/ DISJOINT-SET

        class UnionFind {

            int connectedGroups;
            int[] parent;
            int[] rank;

            public UnionFind(int n) {
                connectedGroups = n;
                parent = new int[n];
                rank = new int[n];

                for (int node = 0; node < n; node++) {
                    parent[node] = node;
                }
            }

            int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }

                connectedGroups--;
            }

            boolean areAllFriends() {
                return connectedGroups == 1;
            }
        }

        UnionFind unionFind = new UnionFind(n);

        //sort the logs based on the timestamp value given logs[i][0]
        //since we need to find the 'earliest time' when all the 'n'
        //people will become friend of each other, sorting on time
        //will help find the earliest time
        Arrays.sort(logs, (a, b) -> Integer.compare(a[0], b[0]));

        //looping over sorted logs[][],
        //now here friend1 = logs[i][1] & friend2 = logs[i][2] will become
        //friend of each other(union) and hence form one 'friend' connected
        //group, at timestamp 'time'
        //as we iterate further, and if we possibly make all the 'n' people
        //friend of each other then they together form one big group of friends
        //hence areAllFriends ==> connectedGroups == 1
        for (int[] log : logs) {

            int time = log[0];
            int friend1 = log[1];
            int friend2 = log[2];

            //union here means, friend1 is friend of friend2 and like wise
            //friend2 is friend of friend1 and all their mutual friends are
            //also friends of each other(union to form one connected group)
            unionFind.union(friend1, friend2);

            //if at any point in time, all 'n' people become friend of each
            //other, they will represent just one big group of friends, return
            //this 'time' when they all become friends, since logs[][] is sorted
            //on 'time' only, this curr 'time' will be the earliest time
            if (unionFind.areAllFriends()) {
                return time;
            }
        }

        //if it is impossible to make all 'n' people friend of each other
        //return -1
        return -1;
    }

    public void smallestStringWithSwaps_Graph(String str, int[][] pairs) {
        //https://leetcode.com/problems/smallest-string-with-swaps/description/
        //based on UNION-FIND/ DISJOINT-SET
        /*

        Given that,

        each pair(a, b) from pairs[][] we can swap the chars of str at index(a, b)
        and we can pick and swap chars any number of times.

        this relation between the swapping indices pair(a, b) from pairs[][]
        forms the inuition for GRAPH problem

        since each pair(a, b) can be swapped so the form undirected edge between
        them

        a <--> b and so between their chars at that time str[a] <--> str[b]

        here, we are using union find to make union of all the pairs that can
        be swapped with each other (hence behaving as connected component of
        swappable indices in that connected group)

        form all those connected indices we will fetch their respective chars
        from the str at that index 'node', sorting these connected chars will
        help to choose smallest chars for the index 'node' and hence form
        lexicographically smallest string

         */
        class UnionFind {

            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                parent = new int[V];
                rank = new int[V];

                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        int V = str.length();

        UnionFind unionFind = new UnionFind(V);

        for (int[] pair : pairs) {

            int u = pair[0];
            int v = pair[1];

            //make union of all the index pairs, such they form a connected
            //group of swappable indices with each other
            unionFind.union(u, v);
        }

        //group all the connected indices
        Map<Integer, List<Integer>> parentToConnectedIndices = new HashMap<>();

        //here, each index have a parent of their connected group
        //we will group togther all the indices as represented by
        //their 'parent'
        for (int index = 0; index < V; index++) {

            int parent = unionFind.find(index);

            parentToConnectedIndices.putIfAbsent(parent, new ArrayList<>());
            parentToConnectedIndices.get(parent).add(index);
        }

        char[] smallestStrChrArr = new char[V];

        //iterate over each conncted group of indices
        for (List<Integer> connectedIndices : parentToConnectedIndices.values()) {

            //fetch and sort all the chars associted to the index in this curr
            //'connectedIndices' group
            List<Character> sortedCharsOfEachIndex = connectedIndices.stream()
                    .map(index -> str.charAt(index))
                    .sorted()
                    .collect(Collectors.toList());

            for (int i = 0; i < connectedIndices.size(); i++) {
                //for each i-th index of actual str we will place i-th smallest
                //char in that 'index' because this 'sortedCharsOfEachIndex'
                //are the chars of index of the curr connected indices group
                //meaning, if we were to swap chars we could only choose these
                //chars only among the pair(a, b) of indices, here 'connectedIndices'
                smallestStrChrArr[connectedIndices.get(i)] = sortedCharsOfEachIndex.get(i);
            }
        }

        //output
        String smallestStrWithSwaps = String.valueOf(smallestStrChrArr);
        System.out.println("Smallest string with swaps : " + smallestStrWithSwaps);
    }

    public void processRestrictedFriendRequests_Graph(int n, int[][] restrictions, int[][] requests) {
        //https://leetcode.com/problems/process-restricted-friend-requests/description/
        //based on UNION-FIND/ DISJOINT-SET

        class UnionFind {

            int[] friend;
            int[] rank;

            Map<Integer, Set<Integer>> enemies;

            public UnionFind(int V, int[][] restrictions) {

                friend = new int[V];
                rank = new int[V];

                enemies = new HashMap<>();

                for (int person = 0; person < V; person++) {

                    //initially, each person is friend of himself
                    friend[person] = person;

                    //create empty enemy set for each person to cater any future
                    //enemy, if formed because of any friend request
                    enemies.put(person, new HashSet<>());
                }

                //process the restrictions of being friend among the persons
                for (int[] restriction : restrictions) {

                    int personA = restriction[0];
                    int personB = restriction[1];

                    //this means personA can't be friend with personB
                    enemies.get(personA).add(personB);

                    //also, means personB can't be friend with personA
                    enemies.get(personB).add(personA);
                }
            }

            int find(int person) {

                if (person == friend[person]) {
                    return person;
                }
                return friend[person] = find(friend[person]);
            }

            boolean union(int personA, int personB) {

                int friendA = find(personA);
                int friendB = find(personB);

                //if personA and personB are already the part of same friends
                //group in which no one is enemy of each other, hence friend
                //request for personA & personB can be added/union ==> true
                if (friendA == friendB) {
                    return true;
                }

                //personA & personB are not yet part of any existing friends
                //group, here we will check if they are enemy or not AND also
                //if they have friends who are enemy of each other,
                //if yes then personA & personB also can't be friend and friend
                //request will be failed ==> false
                if (areEnemies(friendA, friendB)) {
                    return false;
                }

                //here, personA & personB are neither enemy of each other not
                //they know any friend who are enemy of other's friend
                //means personA & personB can be made friend
                if (rank[friendA] > rank[friendB]) {

                    friend[friendB] = friendA;

                    //here, friendA will be the leader of a friends group and
                    //friendB is added into the group.
                    //now below for loop means leader-friendA is saying to
                    //friendB that if you have any enemy then their leader(==> find(person))
                    //will also be my enemy now
                    //Dost ka dushman ab mera dushman!! ;P
                    for (int person : enemies.get(friendB)) {
                        enemies.get(friendA).add(find(person));
                    }

                } else if (rank[friendA] < rank[friendB]) {

                    friend[friendA] = friendB;

                    //here, friendB will be the leader of a friends group and
                    //friendA is added into the group.
                    //now below for loop means leader-friendB is saying to
                    //friendA that if you have any enemy then their leader(==> find(person))
                    //will also be my enemy now
                    //Dost ka dushman ab mera dushman!! ;P
                    for (int person : enemies.get(friendA)) {
                        enemies.get(friendB).add(find(person));
                    }

                } else {

                    friend[friendB] = friendA;
                    rank[friendA]++;

                    //here, friendA will be the leader of a friends group and
                    //friendB is added into the group.
                    //now below for loop means leader-friendA is saying to
                    //friendB that if you have any enemy then their leader(==> find(person))
                    //will also be my enemy now
                    //Dost ka dushman ab mera dushman!! ;P
                    for (int person : enemies.get(friendB)) {
                        enemies.get(friendA).add(find(person));
                    }
                }

                //since personA & personB made friend, friend request fulfilled ==> true
                return true;
            }

            boolean areEnemies(int personA, int personB) {

                //either personB is enemy of personA
                return enemies.get(personA).contains(personB)
                        //OR personA is enemy of personB
                        || enemies.get(personB).contains(personA);
            }
        }

        UnionFind unionFind = new UnionFind(n, restrictions);

        int req = requests.length;
        boolean[] isFriendshipPossible = new boolean[req];

        for (int i = 0; i < req; i++) {

            int personA = requests[i][0];
            int personB = requests[i][1];

            isFriendshipPossible[i] = unionFind.union(personA, personB);

        }

        //output
        System.out.println("Process restricted friend requests : " + Arrays.toString(isFriendshipPossible));
    }

    public void numberOfIslandsTwo_Graph(int m, int n, int[][] positions) {
        //https://leetcode.com/problems/number-of-islands-ii/description/
        //based on GRAPH, UNION-FIND/ DISJOIN-SET
        int ROW = m;
        int COL = n;

        List<Integer> result = new ArrayList<>();

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        BiPredicate<Integer, Integer> isOutOfBounds
                = (row, col) -> row < 0 || row >= ROW || col < 0 || col >= COL;

        class UnionFind {

            int islands;

            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                islands = 0;
                parent = new int[V];
                rank = new int[V];
                //-1 represents, no land cells has been added yet
                //a default grid where all are water(-1) right now
                Arrays.fill(parent, -1);
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                islands--;
            }

            void addIsland(int landCellIndex) {
                if (parent[landCellIndex] >= 0) {
                    return;
                }
                parent[landCellIndex] = landCellIndex;
                islands++;
            }

            boolean isIsland(int landCellIndex) {
                return (parent[landCellIndex] >= 0);
            }

            int countConnectedIsland() {
                return islands;
            }
        }

        UnionFind unionFind = new UnionFind(ROW * COL);

        for (int[] land : positions) {
            int row = land[0];
            int col = land[1];

            int currLandCellIndex = row * COL + col;

            unionFind.addIsland(currLandCellIndex);

            for (int[] dir : dirs) {

                int newRow = row + dir[0];
                int newCol = col + dir[1];

                if (isOutOfBounds.test(newRow, newCol)) {
                    continue;
                }

                int neighbourLandCellIndex = newRow * COL + newCol;

                if (unionFind.isIsland(neighbourLandCellIndex)) {
                    unionFind.union(currLandCellIndex, neighbourLandCellIndex);
                }
            }

            result.add(unionFind.countConnectedIsland());
        }

        //output
        System.out.println("Number of islands two : " + result);
    }

    private List<String> kSimilarString_Graph_GetPossibleSwaps(String currStr, String str2) {

        //objective is to convert given str1 to str2 by swapping two chars in
        //str1 so that it matches to str2, we will greedily try to do swap that
        //makes currStr as close to str2 as possible without making any
        //unneccessary swaps
        List<String> possibleSwaps = new ArrayList<>();

        char[] currStrArr = currStr.toCharArray();
        int n = currStrArr.length;

        //here, we will find 'index' of the char from currStr that doesn't
        //match with char at 'index' in the target string str2
        //this way we will save unneccessary swaps and only focus on those chars
        //from currStr that needs to be made similar to str2
        //ex:
        //currStr = "abcdel", str2 = "abldec"
        //now, loop breaks at index = 2 where 'c' != 'l'
        //that means inorder to make currStr == str2 we must first make the curr
        //mismatching chars similar so we need to swap 'c' with 'l' and this 'l'
        //should also exist in currStr for swapping to happen
        int index = 0;
        for (; index < n; index++) {
            if (currStrArr[index] != str2.charAt(index)) {
                break;
            }
        }

        //after the above loop breaks, we will have 'index' where char of currStr
        //doesn't match with char of str2
        //now with the below loop, we will locate all the similar char that matches
        //str2.charAt(index) in the currStr at some 'j' index then we will swap
        //those mismatched indexes swap(index, j) so that now the newSwappedString
        //should have char at 'index' similar to char at str2[index]
        //ex:
        //currStr = "abcdel", str2 = "abldec"
        //index will be 2 after above loop breaks as 'c' != 'l' where 'l' is a
        //required char by str2 at 'index' we must locate chars that matches
        //str2[index] = 'l' in currStr
        //here, at j = 5, we will find 'l' in currStr and we will do swap
        //swap(index, j) ==> swap(2, 5) in currStr
        //newSwappedString = abldec
        //currStr = [abldec] matches str2 = [abldec]
        for (int j = index + 1; j < n; j++) {

            if (str2.charAt(index) != currStrArr[j]) {
                continue;
            }

            //swap
            char temp = currStrArr[index];
            currStrArr[index] = currStrArr[j];
            currStrArr[j] = temp;

            //we made j-th index of currStr similar to str2[index] hence the
            //newSwappedString is close to str2 or possibly equal by now!!
            String newSwappedString = String.valueOf(currStrArr);

            possibleSwaps.add(newSwappedString);

            //swap back to retain the actual currStr for further 'j' index swap
            //if any possible
            temp = currStrArr[index];
            currStrArr[index] = currStrArr[j];
            currStrArr[j] = temp;
        }

        return possibleSwaps;
    }

    public int kSimilarString_Graph(String str1, String str2) {
        //https://leetcode.com/problems/k-similar-strings/description/
        //based on GRAPH, BFS, LEVEL-ORDER TRAVERSAL

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        visited.add(str1);
        queue.add(str1);

        //this the steps/level it took to convert str1 to str2
        int kSimilar = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                String currStr = queue.poll();

                if (currStr.equals(str2)) {
                    return kSimilar;
                }

                for (String newSwappedString : kSimilarString_Graph_GetPossibleSwaps(currStr, str2)) {

                    if (visited.contains(newSwappedString)) {
                        continue;
                    }

                    visited.add(newSwappedString);
                    queue.add(newSwappedString);
                }
            }
            kSimilar++;
        }

        //this will never occur, as the given strings str1 and str2 are anagrams
        //of each other
        return -1;
    }

    public void shortestDistanceFromAllBuildings_Graph(int[][] grid) {
        //https://leetcode.com/problems/shortest-distance-from-all-buildings/description/
        //based on BFS
        int ROW = grid.length;
        int COL = grid[0].length;

        BiPredicate<Integer, Integer> isOutOfBounds
                = (row, col) -> row < 0 || row >= ROW || col < 0 || col >= COL;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int BUILDING_CELL = 1;
        int EMPTY_CELL = 0;

        Queue<int[]> buildings = new LinkedList<>();

        //save all building's (row, col) into a list
        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {

                if (grid[row][col] == BUILDING_CELL) {
                    buildings.add(new int[]{row, col});
                }
            }
        }

        int totalBuildings = buildings.size();

        //indexes for distances[][][]
        //for distances[row][col][DISTANCE] array we will add the all dist
        //travelled from each of the buildings to this curr row, col
        int DISTANCE = 0;
        //for distances[row][col][COUNT_BUILDING] array we will count how many
        //buildings have visited this curr row, col
        //this helps in prevent one edge case
        //as per the question, we are asked to find the min dist travelled to
        //empty cell from all the buildings BUT what if some of the buildings
        //are blocked with some obstructions and could not move forward, this
        //count will tell us that the particular row,col has been visited by
        //X number of buildings BUT only valid dist is when X == totalBuildings
        //that means each of the row,col must be visited by all the buildings
        //we also have visited[][] that will stop travelling back to the same
        //row,col twice by any building so this COUNT_BUILDING should be
        //equal to 'totalBuildings', if not that row,col should not be considered
        int COUNT_BUILDING = 1;

        int[][][] distances = new int[ROW][COL][2];

        Queue<int[]> queue = new LinkedList<>();

        //run BFS from each building location to all of its empty cell ==> 0
        //and also store the dist to reach that cell
        while (!buildings.isEmpty()) {

            int[] currBuilding = buildings.poll();

            int row = currBuilding[0];
            int col = currBuilding[1];

            boolean[][] visited = new boolean[ROW][COL];

            //curr building's row, col, dist
            queue.add(new int[]{row, col, 0});

            visited[row][col] = true;

            //actual BFS
            while (!queue.isEmpty()) {

                int[] currCell = queue.poll();

                row = currCell[0];
                col = currCell[1];
                int dist = currCell[2];

                for (int[] dir : dirs) {

                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    //skip, if new row & col 'isOutOfBounds'
                    if (isOutOfBounds.test(newRow, newCol)) {
                        continue;
                    }

                    //skip, if new row & col is already visited
                    if (visited[newRow][newCol]) {
                        continue;
                    }

                    //skip, if new row & col is not an empty cell but it could
                    //be either another building(==> 1) or blocked(==> 2)
                    if (grid[newRow][newCol] != EMPTY_CELL) {
                        continue;
                    }

                    //distance to reach curr empty cell ==> new row & col should
                    //increased as the dist travelled till 'currCell' +1 to reach
                    //this new row & col
                    distances[newRow][newCol][DISTANCE] += dist + 1;

                    //since each building is running its own BFS, and visited[][]
                    //doesn't allow to travel back to same row,col twice that
                    //means COUNT_BUILDING will only be increamented for this
                    //new row & col by a building in its turn of BFS
                    distances[newRow][newCol][COUNT_BUILDING] += 1;

                    visited[newRow][newCol] = true;
                    queue.add(new int[]{newRow, newCol, dist + 1});
                }
            }
        }

        int shortestDist = Integer.MAX_VALUE;

        //check the min dist travelled from all the buildings to an empty cell
        for (int row = 0; row < ROW; row++) {

            for (int col = 0; col < COL; col++) {

                //as in BFS, we have ensured that we will only travel to any
                //empty cell, here, we will just check if all those cells have
                //been travelled by all the 'totalBuildings' consider those
                //row,col only for the shortest dist
                if (distances[row][col][COUNT_BUILDING] == totalBuildings) {

                    shortestDist = Math.min(shortestDist, distances[row][col][DISTANCE]);
                }
            }
        }

        //output
        //if no shortest dist is possible -1 otherwise shortestDist
        shortestDist = shortestDist == Integer.MAX_VALUE ? -1 : shortestDist;
        System.out.println("Shortest distance travelled from all the building : " + shortestDist);
    }

    public int shortestPathToGetFood_Graph(char[][] grid) {
        //https://leetcode.com/problems/shortest-path-to-get-food/description/
        //based GRAPH, BFS, LEVEL-ORDER-BFS TRAVERSAL
        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        char FOOD = '#';
        char OBSTACLE = 'X';
        char START = '*';

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            //level-order BFS traversal
            int findShortestDistToNearestFoodHelper(char[][] grid, int row, int col) {

                Queue<int[]> queue = new LinkedList<>();
                boolean[][] visited = new boolean[ROW][COL];

                queue.add(new int[]{row, col});
                visited[row][col] = true;

                int distance = 0;

                while (!queue.isEmpty()) {

                    int size = queue.size();

                    for (int i = 0; i < size; i++) {

                        int[] currCell = queue.poll();

                        int currRow = currCell[0];
                        int currCol = currCell[1];

                        if (grid[currRow][currCol] == FOOD) {
                            return distance;
                        }

                        for (int[] dir : dirs) {

                            int newRow = currRow + dir[0];
                            int newCol = currCol + dir[1];

                            if (isOutOfBounds(newRow, newCol)) {
                                continue;
                            }

                            if (visited[newRow][newCol]) {
                                continue;
                            }

                            if (grid[newRow][newCol] == OBSTACLE) {
                                continue;
                            }

                            visited[newRow][newCol] = true;

                            queue.add(new int[]{newRow, newCol});
                        }
                    }
                    distance++;
                }

                //if not possible
                return -1;
            }
        }

        Helper helper = new Helper();

        for (int row = 0; row < ROW; row++) {

            for (int col = 0; col < COL; col++) {

                if (grid[row][col] == START) {

                    return helper.findShortestDistToNearestFoodHelper(grid, row, col);
                }
            }
        }
        return -1;
    }

    public void matrix01_Graph(int[][] grid) {
        //https://leetcode.com/problems/01-matrix/description/
        //based on GRAPH, BFS
        /*

        As per the question, we just need to find the nearest 0 to all the 1s
        and simply store the shortest dist to the nearest 0 in the 1's row & col

        ex: grid[][] = [
        [0,0,0],
        [0,1,0],
        [1,1,1]]

        for cell(1,1) ==> nearest 0's are any of these
        cell(0,1), cell(1,0), cell(1,2)
        and dist to any of these 0s are just 1 so cell(1,1) will have 1 as dist

        for cell(1,0) ==> nearest 0's are any of these
        cell(1,)
        and dist to 0 are just 1 so cell(2,0) will have 1 as dist

        for cell(2,2) ==> nearest 0's are any of these
        cell(1,2)
        and dist to 0 are just 1 so cell(2,2) will have 1 as dist

        BUT

        for cell(2,1) ==> nearest 0's are any of these
        cell(1,0), cell(0,1), cell(1,2)
        and dist to any of these 0s is 2 so cell(2,1) will have 2 as dist

        Now, there were 2 approaches to solve this question and both based on
        BFS only

        1. approach : start BFS from every 1 to nearest 0

        whenever you see a 1 in binary grid, start a BFS/Level-order-BFS to
        find the nearest 0, as soon as we seen 0 we will return back the level
        or distance

        BUT this approach will give TLE because of the constraint, grid can be
        as big as ROW = COL = 10^4

        now edge case is, where we have all the 1s in the grid and just one 0
        in some corner of the grid, if we follow this approach to start BFS for
        every 1 everytime we see it, it will be very inefficient and cause TLE

        2. approach : start BFS from every 0 to nearest 1 and update at same time

        this approach is no different from above approach, here we will still be
        performing BFS but from all the 0s at the same time, so inorder to do that
        we will store all 0 cell's row & col with their initial dist == 0

        each time we pop out a cell and move to new row & col we made a +1 to
        that prev dist(==> dist + 1)

        since all the 0s cell is marked visited initailly so we will never
        encounter a 0 cell as visited[][] will skip it, will we only see a cell
        with 1, so every time we add this new row & col we also update the dist
        for that cell(newRow, newCol) belongs to 1

        take the same above ex:
        grid[][] = [
        [0,0,0],
        [0,1,0],
        [1,1,1]]

        //first level of cells starting from 0s with dist = 0
        queue = [{0,0,0}, {0,1,0}, {0,2,0}, {1,0,0}, {1,2,0}]
        visited = {{0,0}, {0,1}, {0,2}, {1,0}, {1,2}}

        //second level of cells starting from 0s with dist = 1
        queue = [{1,1,1}, {2,1,1}, {2,2,1}]
        visited = {{0,0}, {0,1}, {0,2}, {1,0}, {1,2}, {1,1}, {2,1}, {2,2}}

        //thirs level of cells starting from 0s with dist = 2
        queue = [{2,1,2}]
        visited = {{0,0}, {0,1}, {0,2}, {1,0}, {1,2}, {1,1}, {2,1}, {2,2}, {2,1}}

        as we can see above queue states, each cell on a particular BFS level
        have exactly the dist i.e, dist from the nearest 0 to that cell

         */
        int ROW = grid.length;
        int COL = grid[0].length;

        BiPredicate<Integer, Integer> isOutOfBounds
                = (row, col) -> row < 0 || row >= ROW || col < 0 || col >= COL;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        //queue to hold row & col with dist travelled ==> cell(row, col, dist)
        Queue<int[]> queue = new LinkedList<>();

        for (int row = 0; row < ROW; row++) {

            for (int col = 0; col < COL; col++) {

                if (grid[row][col] == 0) {

                    queue.add(new int[]{row, col, 0});
                    visited[row][col] = true;
                }
            }
        }

        //perform BFS from all the '0's in binary grid to all the nearest '1's
        while (!queue.isEmpty()) {

            int[] currCell = queue.poll();

            int currRow = currCell[0];
            int currCol = currCell[1];
            int currDist = currCell[2];

            for (int[] dir : dirs) {

                int newRow = currRow + dir[0];
                int newCol = currCol + dir[1];

                if (isOutOfBounds.test(newRow, newCol)) {
                    continue;
                }

                if (visited[newRow][newCol]) {
                    continue;
                }

                grid[newRow][newCol] = currDist + 1;

                visited[newRow][newCol] = true;

                queue.add(new int[]{newRow, newCol, currDist + 1});

            }
        }

        //output
        System.out.println("01 Matrix : ");
        for (int[] row : grid) {
            System.out.println(Arrays.toString(row));
        }
    }

    public void longestLineOfConsecutiveOneInGrid(int[][] grid) {
        //https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        int HORIZONTAL = 0;
        int VERTICAL = 1;
        int DIAGONAL = 2;
        int ANTI_DIAGONAL = 3;

        //the memo[][][4] represent the memoized value stored for state where
        //we moved to row & col while checking a specific dir as mentioned above
        Integer[][][] memo = new Integer[ROW][COL][4];

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            int horizontalConecutiveOneHelper(int[][] grid, int row, int col) {

                if (isOutOfBounds(row, col)) {
                    return 0;
                }

                if (grid[row][col] == 0) {
                    return 0;
                }

                if (memo[row][col][HORIZONTAL] != null) {
                    return memo[row][col][HORIZONTAL];
                }

                int currLength = 1;

                currLength += horizontalConecutiveOneHelper(grid, row, col + 1);

                return memo[row][col][HORIZONTAL] = currLength;
            }

            int verticalConecutiveOneHelper(int[][] grid, int row, int col) {

                if (isOutOfBounds(row, col)) {
                    return 0;
                }

                if (grid[row][col] == 0) {
                    return 0;
                }

                if (memo[row][col][VERTICAL] != null) {
                    return memo[row][col][VERTICAL];
                }

                int currLength = 1;

                currLength += verticalConecutiveOneHelper(grid, row + 1, col);

                return memo[row][col][VERTICAL] = currLength;
            }

            int diagonalConecutiveOneHelper(int[][] grid, int row, int col) {

                if (isOutOfBounds(row, col)) {
                    return 0;
                }

                if (grid[row][col] == 0) {
                    return 0;
                }

                if (memo[row][col][DIAGONAL] != null) {
                    return memo[row][col][DIAGONAL];
                }

                int currLength = 1;

                currLength += diagonalConecutiveOneHelper(grid, row + 1, col + 1);

                return memo[row][col][DIAGONAL] = currLength;
            }

            int antiDiagonalConecutiveOneHelper(int[][] grid, int row, int col) {

                if (isOutOfBounds(row, col)) {
                    return 0;
                }

                if (grid[row][col] == 0) {
                    return 0;
                }

                if (memo[row][col][ANTI_DIAGONAL] != null) {
                    return memo[row][col][ANTI_DIAGONAL];
                }

                int currLength = 1;

                currLength += antiDiagonalConecutiveOneHelper(grid, row + 1, col - 1);

                return memo[row][col][ANTI_DIAGONAL] = currLength;
            }

        }

        Helper helper = new Helper();

        int longestLength = 0;

        for (int row = 0; row < ROW; row++) {

            for (int col = 0; col < COL; col++) {

                if (grid[row][col] == 1) {

                    //longest line of consecutive 1s in horizontal dir starting from curr grid row & col
                    longestLength = Math.max(longestLength, helper.horizontalConecutiveOneHelper(grid, row, col));

                    //longest line of consecutive 1s in vertical dir starting from curr grid row & col
                    longestLength = Math.max(longestLength, helper.verticalConecutiveOneHelper(grid, row, col));

                    //longest line of consecutive 1s in diagonal dir starting from curr grid row & col
                    longestLength = Math.max(longestLength, helper.diagonalConecutiveOneHelper(grid, row, col));

                    //longest line of consecutive 1s in anti-diagonal dir starting from curr grid row & col
                    longestLength = Math.max(longestLength, helper.antiDiagonalConecutiveOneHelper(grid, row, col));
                }
            }
        }

        //output
        System.out.println("Longest line of consecutive ones : " + longestLength);
    }

    public void findCriticalAndPseudoCriticalEdgesInMST_Graph(int n, int[][] edges) {
        //...............T: O(len * Log(len) + (len ^ 2 * alpha(n)))
        //len * Log(len), for sorting edges[][] of length len
        //(len ^ 2 * alpha(n)), for creating MST using Union-Find for 'len'
        //number of edges on 'n' nodes (==> O(len * alpha(n))) and we will
        //create these MST for each 'ignore' index hence O(len * (len * alpha(n)))
        //https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/

        class UnionFind {

            int connectedGroups;

            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];

                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public boolean union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return false;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }

                connectedGroups--;

                return true;
            }

            public boolean isConnected() {
                return connectedGroups == 1;
            }
        }

        List<List<Integer>> result = new ArrayList<>();

        int len = edges.length;

        int[][] edgesWithIndex = new int[len][4];

        for (int i = 0; i < len; i++) {
            //edgesWithIndex[i] = [index, nodeU, nodeV, weight]
            edgesWithIndex[i] = new int[]{i, edges[i][0], edges[i][1], edges[i][2]};
        }

        //sort the edges based on their weights
        Arrays.sort(edgesWithIndex, (a, b) -> Integer.compare(a[3], b[3]));

        //create minimum spanning tree and find the actual total MST weight
        UnionFind unionFind = new UnionFind(n);

        int mstWeight = 0;

        for (int[] edge : edgesWithIndex) {

            int nodeU = edge[1];
            int nodeV = edge[2];
            int weight = edge[3];

            if (unionFind.union(nodeU, nodeV)) {
                mstWeight += weight;
            }
        }

        int INDEX_CRITICAL_EDGES = 0;
        int INDEX_PSEUDO_CRITICAL_EDGES = 1;

        //list at index = 0 is for critical edge
        result.add(new ArrayList<>());

        //list at index = 1 for pseudo critical edge
        result.add(new ArrayList<>());

        for (int ignore = 0; ignore < len; ignore++) {

            UnionFind unionFindWithIgnoredEdge = new UnionFind(n);

            int mstWeightAfterIgnoringEdge = 0;

            //create MST but don't include edge @ignore index
            for (int index = 0; index < len; index++) {

                //skip, curr 'ignore' index
                if (index == ignore) {
                    continue;
                }

                //make union() of other edges ignoring the edge @ignore index
                int nodeU = edgesWithIndex[index][1];
                int nodeV = edgesWithIndex[index][2];
                int weight = edgesWithIndex[index][3];

                if (unionFindWithIgnoredEdge.union(nodeU, nodeV)) {
                    mstWeightAfterIgnoringEdge += weight;
                }
            }

            //if after ignoring the curr 'ignore' index, 2 possibilities are
            //there with which we can conclude that edge @ignore is critial
            //1. we can't make an MST, where all nodes are connected then it
            //means the edge @ignore index is a critial edge without which
            //even the MST can't be formed
            //2. after ignoring the edge @ignore index, it is possible to
            //make an MST but the total MST weight(==> mstWeightAfterIgnoringEdge)
            //after ignoring this edge is higher than the expected 'mstWeight'
            //so add the actual edge index (==> edgesWithIndex[ignore][0])
            //into critial list if any of the above cond matches
            if (!unionFindWithIgnoredEdge.isConnected() || mstWeightAfterIgnoringEdge > mstWeight) {
                result.get(INDEX_CRITICAL_EDGES).add(edgesWithIndex[ignore][0]);
                continue;
            }

            UnionFind unionFindForcingThisIgnoredEdge = new UnionFind(n);

            //forcefully make union() of the 'ignore' edge and also
            //cosider its weight
            unionFindForcingThisIgnoredEdge.union(edgesWithIndex[ignore][1], edgesWithIndex[ignore][2]);
            int mstWeightForcingIgnoredEdge = edgesWithIndex[ignore][3];

            for (int index = 0; index < len; index++) {

                //skip, curr 'ignore' index as we have already forced that above
                if (index == ignore) {
                    continue;
                }

                //make union() of other edges ignoring the curr 'ignore' index
                int nodeU = edgesWithIndex[index][1];
                int nodeV = edgesWithIndex[index][2];
                int weight = edgesWithIndex[index][3];

                if (unionFindForcingThisIgnoredEdge.union(nodeU, nodeV)) {
                    mstWeightForcingIgnoredEdge += weight;
                }
            }

            if (mstWeightForcingIgnoredEdge == mstWeight) {
                result.get(INDEX_PSEUDO_CRITICAL_EDGES).add(edgesWithIndex[ignore][0]);
            }
        }

        //output
        System.out.println("Find critial and pseudo critical edges : " + result);
    }

    private String smallestCommonRegion_Graph_FindLCA(
            Map<String, Set<String>> graph, String root, String region1, String region2) {

        if (root.equals(region1) || root.equals(region2)) {
            return root;
        }

        String foundRegion1 = null;
        String foundRegion2 = null;

        for (String childRegion : graph.getOrDefault(root, new HashSet<>())) {

            String region = smallestCommonRegion_Graph_FindLCA(graph, childRegion, region1, region2);

            if (foundRegion1 == null) {

                foundRegion1 = region;

            } else if (foundRegion2 == null) {

                foundRegion2 = region;
            }

            if (foundRegion1 != null && foundRegion2 != null) {
                return root;
            }
        }

        return foundRegion1 == null ? foundRegion2 : foundRegion1;
    }

    public void smallestCommonRegion_Graph(String[][] regions, String region1, String region2) {
        //https://leetcode.com/problems/smallest-common-region/description/
        //based on LOWEST ANCESTOR on GRAPH/ N-ary TREE, lowestCommonAncestorOfTree()
        Map<String, Integer> indegree = new HashMap<>();

        Map<String, Set<String>> graph = new HashMap<>();

        for (String[] region : regions) {

            String parentRegion = region[0];

            indegree.put(parentRegion, indegree.getOrDefault(parentRegion, 0) + 1);

            graph.putIfAbsent(parentRegion, new HashSet<>());

            int n = region.length;

            for (int i = 1; i < n; i++) {

                String childRegion = region[i];

                graph.get(parentRegion).add(childRegion);

                indegree.put(childRegion, indegree.getOrDefault(childRegion, 0) - 1);
            }
        }

        //as per this question, regions[0][0] is the root of the graph/N-ary tree
        //represented with regions[][], but still we find the root here
        String rootRegion = "";

        //the indegree map will have root's indegree as 1 leaf's indegree as -1
        //and any intermediate region/node's indegree as 0 as balanced off from
        //its parent -> child and child -> grand child
        for (String region : indegree.keySet()) {
            if (indegree.get(region) == 1) {
                rootRegion = region;
                break;
            }
        }

        //smallestCommonRegion = lowest common ancestor of region1 and region2
        String smallestCommonRegion = smallestCommonRegion_Graph_FindLCA(graph, rootRegion, region1, region2);

        //output
        System.out.println("Smallest common region : " + smallestCommonRegion);
    }

    public void reconstructItinerary_Graph(String[][] tickets) {
        //https://leetcode.com/problems/reconstruct-itinerary/description/
        //using PriorityQueue here, as question asked that itinerary path should
        //be lexicographically smaller and a default PriorityQueue will be minHeap
        //meaning it will sort the strings lexicographically.
        //Instead of PriorityQueue, TreeSet can be thought to use in this case
        //as TreeSet also sort the string lexicographically
        //BUT iterating over TreeSet and sepcifically for this question's logic
        //will throw 'ConcurrentModificationException'
        Map<String, PriorityQueue<String>> graph = new HashMap<>();

        class Helper {

            void itineraryPathDFSHelper(String srcRoot, LinkedList<String> itinerary) {

                PriorityQueue<String> nextDestinations = graph.getOrDefault(srcRoot, new PriorityQueue<>());

                while (!nextDestinations.isEmpty()) {

                    itineraryPathDFSHelper(nextDestinations.poll(), itinerary);

                }

                itinerary.addFirst(srcRoot);
            }
        }

        for (String[] ticket : tickets) {

            String from = ticket[0];
            String to = ticket[1];

            //directed-edge from given src to dest i.e, from --> to
            graph.putIfAbsent(from, new PriorityQueue<>());
            graph.get(from).add(to);
        }

        Helper helper = new Helper();

        LinkedList<String> itinerary = new LinkedList<>();

        String ROOT = "JFK";

        helper.itineraryPathDFSHelper(ROOT, itinerary);

        //output
        System.out.println("Reconstruct Itinerary : " + itinerary);
    }

    public int shortestPathVisitingAllNodes_Graph(int[][] graph) {
        //https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/
        //explanation: https://youtu.be/m73DRkEo8Ko?si=XQa39EgjpikizAJj
        //based on GRAPH-DP with BIT-MASKING
        class Node {

            int vertex;
            int mask;
            int path;

            public Node(int vertex, int mask, int path) {
                this.vertex = vertex;
                this.mask = mask;
                this.path = path;
            }

        }

        int totalNodes = graph.length;

        int totalNodesMaskedValue = (1 << totalNodes) - 1;

        Set<Pair<Integer, Integer>> visited = new HashSet<>();
        Queue<Node> queue = new LinkedList<>();

        for (int vertex = 0; vertex < totalNodes; vertex++) {

            int maskValue = (1 << vertex);

            visited.add(new Pair<>(vertex, maskValue));
            queue.add(new Node(vertex, maskValue, 0));
        }

        while (!queue.isEmpty()) {

            Node currNode = queue.poll();

            if (currNode.mask == totalNodesMaskedValue) {
                return currNode.path;
            }

            for (int childVertex : graph[currNode.vertex]) {

                int bothVisitedMask = currNode.mask | (1 << childVertex);

                if (visited.contains(new Pair<>(childVertex, bothVisitedMask))) {
                    continue;
                }

                visited.add(new Pair<>(childVertex, bothVisitedMask));
                queue.add(new Node(childVertex, bothVisitedMask, currNode.path + 1));
            }
        }

        return -1;
    }

    public void floodFill_Helper(int[][] image, int row, int col,
                                 int srcColor, int newColor, boolean[][] visited) {

        //if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= image.length || col < 0 || col >= image[row].length) {
            return;
        }

        //if curr row & col already visited
        if (visited[row][col]) {
            return;
        }

        //if curr row & col doesn't have the src color the we need to upgrade
        if (image[row][col] != srcColor) {
            return;
        }

        visited[row][col] = true;

        image[row][col] = newColor;

        //UP
        floodFill_Helper(image, row - 1, col, srcColor, newColor, visited);

        //DOWN
        floodFill_Helper(image, row + 1, col, srcColor, newColor, visited);

        //LEFT
        floodFill_Helper(image, row, col - 1, srcColor, newColor, visited);

        //RIGHT
        floodFill_Helper(image, row, col + 1, srcColor, newColor, visited);
    }

    public void floodFill(int[][] image, int srcR, int srcC, int newColor) {
        //https://leetcode.com/problems/flood-fill/
        //actual
        System.out.println();
        for (int[] r : image) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }

        int srcColor = image[srcR][srcC];
        boolean[][] visited = new boolean[image.length][image[0].length];
        floodFill_Helper(image, srcR, srcC, srcColor, newColor, visited);

        //output
        System.out.println("output: ");
        for (int[] r : image) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    public boolean checkIfGivenUndirectedGraphIsBinaryTree(int V, List<List<Integer>> adjList) {

        //two condition for a undirected graph to be tree
        //1. should not have a cycle
        //2. the graph should be connected
        boolean[] visited = new boolean[V];

        //check undriected cycle
        //if all nodes is reachable via vertex 0 without forming a cycle
        //if cycle is present then its not tree and return false
        //it will also mark visited = true all those nodes that are connected to each other
        if (detectCycleInUndirectedGraphDFS_Helper(adjList, 0, -1, visited)) {
            //if all the vertexes are connected and still there is cycle anywhere in the graph
            //it will be detected here. In case if a part of graph is not connected and that contains
            //cycle(which is not detectable), still below isConnected loop will return false as
            //all nodes are not connected. in visited[]
            return false;
        }

        for (boolean isConnected : visited) {
            if (!isConnected) {
                return false;
            }
        }

        return true;
    }

    private void allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
            int[][] graph, int src, int dest, boolean[] visited,
            List<Integer> currPath, List<List<Integer>> paths) {

        if (src == dest) {
            paths.add(new ArrayList<>(currPath));
            return;
        }

        visited[src] = true;

        for (int childVertex : graph[src]) {

            if (visited[childVertex]) {
                continue;
            }

            currPath.add(childVertex);

            allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
                    graph, childVertex, dest, visited, currPath, paths);

            currPath.remove(currPath.size() - 1);
        }

        visited[src] = false;
    }

    public void allPathFromSourceToTargetInDirectedAcyclicGraph(int[][] graph) {
        //https://leetcode.com/problems/all-paths-from-source-to-target/
        //based graph DFS, backtracking
        List<List<Integer>> paths = new ArrayList<>();

        int V = graph.length;

        int source = 0;
        int target = V - 1;

        boolean[] visited = new boolean[V];

        List<Integer> currPath = new ArrayList<>();
        currPath.add(source);

        allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
                graph, source, target, visited, currPath, paths);

        //output:
        System.out.println("All paths from source to destination in DAG: " + paths);
    }

    private boolean checkIfPathExistsFromSourceToDestination_DFS(int[][] grid, int x, int y) {

        if (x < 0 || x >= grid.length || y < 0 || y >= grid[x].length
                || grid[x][y] == 0) {
            return false;
        }

        if (grid[x][y] == 2) {
            return true;
        }

        int original = grid[x][y];
        grid[x][y] = 0;

        boolean anyPathPossible
                = checkIfPathExistsFromSourceToDestination_DFS(grid, x - 1, y)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x + 1, y)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x, y - 1)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x, y + 1);

        grid[x][y] = original;

        return anyPathPossible;
    }

    public boolean checkIfPathExistsFromSourceToDestination(int[][] grid) {

        int r = grid.length;
        int c = grid[0].length;

        for (int x = 0; x < r; x++) {
            for (int y = 0; y < c; y++) {
                if (grid[x][y] == 1 && checkIfPathExistsFromSourceToDestination_DFS(grid, x, y)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean canWeVisitAllTheRooms_Graph(List<List<Integer>> rooms) {
        //problem: https://leetcode.com/problems/keys-and-rooms
        //explanation: https://youtu.be/Rz_-Kx0LN-E
        //based on BFS
        int n = rooms.size();

        int currRoom = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(currRoom);

        boolean[] visited = new boolean[n];
        //curr room is visited as we are starting from this one
        visited[currRoom] = true;

        //do BFS to mark what all rooms we can visit
        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                currRoom = queue.poll();

                for (int childRoom : rooms.get(currRoom)) {
                    if (visited[childRoom]) {
                        continue;
                    }

                    visited[childRoom] = true;
                    queue.add(childRoom);
                }
            }
        }

        //if after traversing all the rooms, there is any room left
        //unvisited then return false;
        for (boolean isRoomVisited : visited) {
            if (!isRoomVisited) {
                return false;
            }
        }

        return true;
    }

    private void vertexWithWeightAllSourceToDestinationPath_Helper(List<List<VertexWithWeight>> adj,
                                                                   int mainSource, int source, int target,
                                                                   int currWeight, boolean[] vis, Map<String, Integer> result) {

        if (source == target) {
            if (!result.containsKey(target + "-" + mainSource)) {
                result.put(mainSource + "-" + target, currWeight);
            }
        }

        vis[source] = true;
        List<VertexWithWeight> childs = adj.get(source);
        for (VertexWithWeight cv : childs) {

            if (vis[cv.vertex] != true) {
                vertexWithWeightAllSourceToDestinationPath_Helper(adj, mainSource, cv.vertex, target, currWeight + cv.weight, vis, result);
            }
        }
        vis[source] = false;
    }

    public void vertexWithWeightAllSourceToDestinationPath(List<List<VertexWithWeight>> adj) {

        int V = adj.size();
        Map<String, Integer> result = new HashMap<>();
        boolean[] vis = new boolean[V];
        for (int u = 0; u < V; u++) {

            for (int v = 0; v < V; v++) {
//                Arrays.fill(vis, false);
                if (u != v) {
                    vertexWithWeightAllSourceToDestinationPath_Helper(adj, u, u, v, 0, vis, result);
                }
            }
        }

        //output:
        result.entrySet()
                .stream()
                .sorted((a, b) -> a.getKey().compareTo(b.getKey()))
                .forEach(e -> System.out.println(e.getKey() + " = " + e.getValue()));

    }

    public void vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(int V, int[][] edges) {

        //https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
        //explanation: https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/discuss/1179313/best-solution
        /*
         all Vertex Through Other Nodes Can Be Reached are those nodes who doesn't have any
         incoming directions to them
         ex: [{0,1},{0,2},{2,5},{3,4},{4,2}]
         0 : [1,2]
         2 : [5]
         3 : [4]
         4 : [2]
         only 0 and 3 are the vertex who doesn't have incoming req
         */
        List<Integer> allVertexThroughOtherNodesCanBeReached = new ArrayList<>();
        int[] incomingRequest = new int[V];
        for (int[] edge : edges) {
            incomingRequest[edge[1]]++;
        }

        for (int i = 0; i < V; i++) {
            if (incomingRequest[i] == 0) {
                allVertexThroughOtherNodesCanBeReached.add(i);
            }
        }

        //output
        System.out.println("Vertexes in DAG through all other vertex can be reached: " + allVertexThroughOtherNodesCanBeReached);
    }

    public boolean checkIfGraphIsBipartite_Graph(int[][] graph) {
        //https://leetcode.com/problems/is-graph-bipartite/
        /*A graph is bipartite if the nodes can be partitioned into two independent
         sets A and B such that every edge in the graph connects a node
         in set A and a node in set B.*/
        int V = graph.length;

        int UNCOLORED = 0;
        int BLUE_COLOR = 1;
        int RED_COLOR = -1;

        //initially all the vertex are UNCOLORED(== 0)
        int[] colors = new int[V];

        Queue<Integer> queue = new LinkedList<>();

        //we will move over all the vertex, incase if our graph is disconnected
        for (int src = 0; src < V; src++) {
            //skip if the curr src vertex was already colored in some previous iterations
            if (colors[src] == BLUE_COLOR || colors[src] == RED_COLOR) {
                continue;
            }

            //mark the inital color of curr src vertex as BLUE, all the child vertex
            //from this curr src are to be colored oppsite of the curr src color
            colors[src] = BLUE_COLOR;
            queue.add(src);

            //BFS
            while (!queue.isEmpty()) {

                int currSrc = queue.poll();

                for (int childVertex : graph[currSrc]) {
                    //if the child vertex of curr src vertex already have the same color
                    //as that of the its parent i.e curr src vertex, that means there
                    //can't be bipartition
                    if (colors[childVertex] == colors[currSrc]) {
                        return false;
                    }

                    //if the child vertex is not already colored, we will color
                    //this child vertex opposite of its parent i.e, curr src
                    if (colors[childVertex] == UNCOLORED) {
                        colors[childVertex] = colors[currSrc] == BLUE_COLOR ? RED_COLOR : BLUE_COLOR;
                        queue.add(childVertex);
                    }
                }
            }
        }
        return true;
    }

    public boolean possibleBipartition_Graph(int n, int[][] dislikes) {
        //https://leetcode.com/problems/possible-bipartition/description/
        //based on graph bipartition, checkIfGraphIsBipartite_Graph()
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] dislike : dislikes) {
            int u = dislike[0];
            int v = dislike[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int UNCOLORED = 0;
        int BLUE_COLOR = 1;
        int RED_COLOR = -1;

        //initially all the vertex are UNCOLORED(== 0)
        int[] colors = new int[n + 1];

        Queue<Integer> queue = new LinkedList<>();

        //we will move over all the vertex, incase if our graph is disconnected
        for (int src = 1; src <= n; src++) {
            //skip if the curr src vertex was already colored in some previous iterations
            if (colors[src] == BLUE_COLOR || colors[src] == RED_COLOR) {
                continue;
            }

            //mark the inital color of curr src vertex as BLUE, all the child vertex
            //from this curr src are to be colored oppsite of the curr src color
            colors[src] = BLUE_COLOR;
            queue.add(src);

            //BFS
            while (!queue.isEmpty()) {

                int currSrc = queue.poll();

                for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {
                    //if the child vertex of curr src vertex already have the same color
                    //as that of the its parent i.e curr src vertex, that means there
                    //can't be bipartition
                    if (colors[childVertex] == colors[currSrc]) {
                        return false;
                    }

                    //if the child vertex is not already colored, we will color
                    //this child vertex opposite of its parent i.e, curr src
                    if (colors[childVertex] == UNCOLORED) {
                        colors[childVertex] = colors[currSrc] == BLUE_COLOR ? RED_COLOR : BLUE_COLOR;
                        queue.add(childVertex);
                    }
                }
            }
        }
        return true;
    }

    private boolean courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
            Map<Integer, List<Integer>> graph, int course,
            boolean[] visited, boolean[] recurStack, List<Integer> courseOrderings) {

        //same as detect cycle in directed graph but with map based graph input
        if (recurStack[course]) {
            return true;
        }

        if (visited[course]) {
            return false;
        }

        recurStack[course] = true;
        visited[course] = true;

        for (int mandateCourse : graph.getOrDefault(course, new ArrayList<>())) {
            if (courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
                    graph, mandateCourse, visited, recurStack, courseOrderings)) {
                //if there is cycle is graph ex: courseSchedule[][] =  [[0, 1], [1, 0]]
                return true;
            }
        }

        courseOrderings.add(course);

        recurStack[course] = false;

        return false;
    }

    public void courseScheduleTwo_Graph(int[][] courseSchedule, int courses) {
        //https://leetcode.com/problems/course-schedule/description/
        //https://leetcode.com/problems/course-schedule-ii/
        //https://leetcode.com/discuss/interview-question/742238/Amazon-or-Student-Order
        //Directed graph
        Map<Integer, List<Integer>> graph = new HashMap<>();
        //check cycle in Directed acyclic graph
        boolean[] visited = new boolean[courses];
        boolean[] recurStack = new boolean[courses];
        //here stack is not used as the natural order will be same in list as we
        //required in the output array
        List<Integer> courseOrderings = new ArrayList<>();

        for (int[] schedule : courseSchedule) {

            int u = schedule[0];
            int v = schedule[1];

            //directed graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        //for all the course from given courses
        for (int course = 0; course < courses; course++) {

            //if a particular course is already visited/ completed for some other
            //previous course, then we need not to visited this course again
            if (visited[course]) {
                continue;
            }

            //we will perform the topo sort on the graph and at the same time
            //we will check if there is a cycle in the graph or not, since the
            //given graph is directed one so we will use detect cycle in directed
            //graph
            if (courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
                    graph, course, visited, recurStack, courseOrderings)) {
                //if there is a cycle in the graph, we can't complete the course
                //hence our result is empty array
                System.out.println("Course schedule two order : " + Arrays.toString(new int[]{}));
                return;
            }
        }

        //output
        //simply, courseOrderings can be printed directly but as question required
        //coverting it to array
        int[] courseOrderingArray = courseOrderings.stream().mapToInt(course -> course).toArray();
        System.out.println("Course schedule two order: " + Arrays.toString(courseOrderingArray));
    }

    private boolean alienDictionary_Graph_TopoSortWithDetectDirectedGraphCycle(
            Map<Character, Set<Character>> graph, char letter,
            boolean[] visited, boolean[] recurStack, StringBuilder letterOrderStack) {

        if (recurStack[letter - 'a']) {
            return true;
        }

        if (visited[letter - 'a']) {
            return false;
        }

        recurStack[letter - 'a'] = true;

        visited[letter - 'a'] = true;

        for (char nextLetter : graph.getOrDefault(letter, new HashSet<>())) {

            if (alienDictionary_Graph_TopoSortWithDetectDirectedGraphCycle(
                    graph, nextLetter, visited, recurStack, letterOrderStack)) {

                return true;
            }
        }

        letterOrderStack.append(letter);

        return recurStack[letter - 'a'] = false;
    }

    public String alienDictionary_Graph(String[] dict) {
        //.............................T: O(N + alphabets)
        //https://leetcode.com/problems/alien-dictionary/description/
        //explanation: https://youtu.be/6kTZYvNNyps
        //based on GRAPH, TOPOLOGICAL SORT
        //prepare input
        Map<Character, Set<Character>> graph = new HashMap<>();

        //put all the chars from all the given words of this alien dict[]
        for (String word : dict) {
            for (char chr : word.toCharArray()) {
                graph.putIfAbsent(chr, new HashSet<>());
            }
        }

        for (int i = 0; i < dict.length - 1; i++) {

            String wordU = dict[i];
            String wordV = dict[i + 1];

            for (int j = 0; j < wordU.length(); j++) {

                //edge case if, the curr wordU has greater length than next wordV
                //ex: wordU = "abcd", wordV = "abc"
                //ideally, in a sorted dictionary order lexicographically sorted
                //word are also sorted with their length as well, meaning
                //lexicographically smaller with smaller length should come first
                //ex: app < apple < applet
                if (j >= wordV.length()) {
                    return "";
                }

                char chrWordU = wordU.charAt(j);
                char chrWordV = wordV.charAt(j);

                //this if will find the first non matching char in both the words
                //ex: wrd1 = "wrt" wrd2 = "wrf" first non matching char be t & f
                if (chrWordU != chrWordV) {

                    //directed edge between two mismatching chars of these words
                    //tells that chrWordU should come before chrWordV, why?
                    //because the given alien dict[] is lexicographically sorted
                    //so if they are sorted in char order then chrWordU must occur
                    //before chrWordV
                    //ex: anklet comes before apple as the first mismatching char
                    //'n' & 'p' have lexicographical order, 'n' comes before 'p'
                    graph.get(chrWordU).add(chrWordV);
                    break;
                }
            }
        }

        //do topo sort
        boolean[] visited = new boolean[26];
        boolean[] recurStack = new boolean[26];

        //letter order will act as topological order stack, hence we need to
        //reverse it later
        StringBuilder letterOrderStack = new StringBuilder();

        for (char key : graph.keySet()) {

            if (alienDictionary_Graph_TopoSortWithDetectDirectedGraphCycle(
                    graph, key, visited, recurStack, letterOrderStack)) {
                //letter order has cycle in it, so no alien letter order can be
                //detected
                return "";
            }
        }

        //output
        String alienLetterOrder = letterOrderStack.reverse().toString();
        return alienLetterOrder;
    }

    public int findTownJudge_Graph(int n, int[][] trusts) {
        //https://leetcode.com/problems/find-the-town-judge/
        //https://leetcode.com/problems/find-the-town-judge/discuss/2106467/Simple-yet-efficient-java-solution
        int[] inDegree = new int[n];
        for (int[] trust : trusts) {
            //0th person(trust[0]) trust 1st person(trust[1])
            //that way trust[1] got inDegree from trust[0]
            //but if later on it is found that trust[1] is also trusting
            //someone else that means we have to reduce its inDegree
            inDegree[trust[1] - 1]++;
            inDegree[trust[0] - 1]--;
        }
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == n - 1) {
                return i + 1;
            }
        }
        return -1;
    }

    private void surroundedRegions_Graph_DFS(char[][] board, int row, int col) {
        if (row < 0 || row >= board.length
                || col < 0 || col >= board[row].length
                || board[row][col] != 'O') {
            return;
        }

        //replace the O at the border regions with temp char T
        board[row][col] = 'T';
        //convert all the other O that are connected with O at the border regions
        surroundedRegions_Graph_DFS(board, row - 1, col);
        surroundedRegions_Graph_DFS(board, row + 1, col);
        surroundedRegions_Graph_DFS(board, row, col - 1);
        surroundedRegions_Graph_DFS(board, row, col + 1);
    }

    public void surroundedRegions_Graph(char[][] board) {
        //https://leetcode.com/problems/surrounded-regions/
        //https://leetcode.com/problems/number-of-enclaves/
        //explanantion: https://youtu.be/9z2BunfoZ5Y

        int row = board.length;
        int col = board[0].length;

        //actual
        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                System.out.print(board[r][c] + " ");
            }
            System.out.println();
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //First convert all the O at the border region and all other O
                //that is connected to these O
                if (board[r][c] == 'O'
                        //border regions ==> row == TOP EDGE || BOTTOM EDGE, col == LEFT EDGE || RIGHT EDGE
                        && ((r == 0 || r == row - 1) || (c == 0 || c == col - 1))) {
                    surroundedRegions_Graph_DFS(board, r, c);
                }
            }
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //once all the Os at the border regions are replaced with temp char T
                //we will be left with those O which are surrounded by X only
                //because only those O were not reachable from above dfs
                //we can easily convert these Os to X as per question
                if (board[r][c] == 'O') {
                    board[r][c] = 'X';
                }
            }
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //once all the Os that were surrounded by X are replaced with X
                //in previous loop, we can replace temp char T back with O again
                if (board[r][c] == 'T') {
                    board[r][c] = 'O';
                }
            }
        }

        //output
        System.out.println("Surrounded regions output: ");
        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                System.out.print(board[r][c] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    private int longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
            int[][] matrix, int row, int col, int prevVal, Integer[][] memo) {

        //return 0, if the curr row & col 'isOutOfBounds'
        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length) {
            return 0;
        }

        //return 0, if curr row & col is not forming any longest incr path because
        //its prevVal is greater or equal to curr matrix[row][col] val
        if (matrix[row][col] <= prevVal) {
            return 0;
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        //for each value in matrix that value itself is a longest incr path
        //atleast of length 1
        int currLongestIncrPath = 1;

        //UP
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row - 1, col, matrix[row][col], memo) + 1);
        //DOWN
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row + 1, col, matrix[row][col], memo) + 1);
        //LEFT
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col - 1, matrix[row][col], memo) + 1);
        //RIGHT
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col + 1, matrix[row][col], memo) + 1);

        return memo[row][col] = currLongestIncrPath;
    }

    public void longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(int[][] matrix) {
        //https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
        //explanation: https://youtu.be/wCc_nd-GiEc
        int ROW = matrix.length;
        int COL = matrix[0].length;

        Integer[][] memo = new Integer[ROW][COL];

        int longestIncrPath = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                longestIncrPath = Math.max(
                        longestIncrPath,
                        longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                                matrix, r, c, -1, memo));
            }
        }
        //output
        System.out.println("Longest increasing path in matrix: " + longestIncrPath);
    }

    private int maxNumberOfMovesInAGrid_Graph_Memoization_HelperDFS(
            int[][] grid, int row, int col, int prevVal, Integer[][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //return 0 as moves, if the curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        //as we need to maintain a STRICTLY INCREASING paths as we move from a cell
        //from prev col to a new cell in the next col
        //now if the curr cell value grid[row][col] is smaller or equal to prev
        //cell value 'prevVal' it is not making a STRICTLY INCREASING path
        //hence return 0 as moves
        if (prevVal >= grid[row][col]) {
            return 0;
        }

        //memo[][] will store the moves count for the curr cell(row, col) that
        //tells from this curr cell, what is the longest STRICTLY INCREASING path
        //and how much is the moves in that path
        if (memo[row][col] != null) {
            return memo[row][col];
        }

        //curr moves that we need to maximize
        int currMoves = 0;

        //allowed movements we have from the curr cell(row, col)
        //TOP-RIGHT CELL (row - 1, col + 1)
        currMoves = Math.max(currMoves,
                1 + maxNumberOfMovesInAGrid_Graph_Memoization_HelperDFS(
                        grid, row - 1, col + 1, grid[row][col], memo));

        //RIGHT CELL (row, col + 1)
        currMoves = Math.max(currMoves,
                1 + maxNumberOfMovesInAGrid_Graph_Memoization_HelperDFS(
                        grid, row, col + 1, grid[row][col], memo));

        //BOTTOM-RIGHT CELL (row + 1, col + 1)
        currMoves = Math.max(currMoves,
                1 + maxNumberOfMovesInAGrid_Graph_Memoization_HelperDFS(
                        grid, row + 1, col + 1, grid[row][col], memo));

        return memo[row][col] = currMoves;
    }

    public void maxNumberOfMovesInAGrid_Graph_Memoization(int[][] grid) {
        //https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/description/
        //based on longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization()
        /*

        here moves or path can be synonymous to each other
        so moves == path length
        which makes it a similar question to above mentioned one

         */
        int ROW = grid.length;
        int COL = grid[0].length;

        Integer[][] memo = new Integer[ROW][COL];

        int maxMoves = 0;

        //checking all the possible values of the curr col i.e, grid[row][0]
        for (int row = 0; row < ROW; row++) {
            maxMoves = Math.max(maxMoves, maxNumberOfMovesInAGrid_Graph_Memoization_HelperDFS(
                    grid, row, 0, -1, memo));
        }

        //output
        //since we started from the col == 0, but moves calculations is actually
        //required from col == 0 + 1 so with above maxMoves we are also calculating
        //the moves for col == 0 hence do -1 to exclude that move
        maxMoves -= 1;
        System.out.println("max number of moves in a grid : " + maxMoves);
    }

    private int numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
            int[][] matrix, int row, int col, int prevVal, Integer[][] memo) {

        int ROW = matrix.length;
        int COL = matrix[0].length;
        int mod = 1000000007;

        //return 0, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        //since we need a strictly incr path, so if the curr matrix[row][col]
        //value is less or equal to prevVal, return 0
        if (matrix[row][col] <= prevVal) {
            return 0;
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        //for each value in matrix that value itself is a longest incr path count
        //atleast of length 1
        int currLongestIncrPathCount = 1;

        //UP
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                matrix, row - 1, col, matrix[row][col], memo)) % mod;
        //DOWN
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                matrix, row + 1, col, matrix[row][col], memo)) % mod;
        //LEFT
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                matrix, row, col - 1, matrix[row][col], memo)) % mod;
        //RIGHT
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                matrix, row, col + 1, matrix[row][col], memo)) % mod;

        //cache the currLongestIncrPathCount at curr row,col
        return memo[row][col] = currLongestIncrPathCount;
    }

    public void numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(int[][] matrix) {
        //...........................T: O(ROW * COL)
        //We used dp as memory to avoid repeated computation, so each cell is
        //only visited and calculated once.
        //...........................S: O(ROW * COL)
        //space taken for memo[][]
        //https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/
        //based on longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization
        int ROW = matrix.length;
        int COL = matrix[0].length;
        int mod = 1000000007;

        //memo[row][col] = currLongestIncrPathCount
        Integer[][] memo = new Integer[ROW][COL];

        int longestIncrPathCount = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                longestIncrPathCount = (longestIncrPathCount
                        + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, r, c, -1, memo)) % mod;
            }
        }
        //output
        System.out.println("Number of longest increasing path in matrix: " + longestIncrPathCount);
    }

    public int swimInRisingWater_Graph(int[][] grid) {
        //https://leetcode.com/problems/swim-in-rising-water/
        //explanation: https://youtu.be/amvrKlMLuGY
        //based on BFS
        class Cell {

            int time;
            int row;
            int col;

            public Cell(int time, int row, int col) {
                this.time = time;
                this.row = row;
                this.col = col;
            }

        }

        //grid[][] is n * n matrix
        int ROW = grid.length;
        int COL = ROW;

        int[][] dirs = {
                {1, 0},
                {-1, 0},
                {0, 1},
                {0, -1}
        };

        int srcRow = 0;
        int srcCol = 0;

        boolean[][] visited = new boolean[ROW][COL];
        PriorityQueue<Cell> minHeapTime = new PriorityQueue<>(
                (a, b) -> a.time - b.time);

        visited[srcRow][srcCol] = true;
        minHeapTime.add(new Cell(grid[srcRow][srcCol], srcRow, srcCol));

        while (!minHeapTime.isEmpty()) {

            Cell currCell = minHeapTime.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.time;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;

                minHeapTime.add(new Cell(
                        Math.max(currCell.time, grid[newRow][newCol]),
                        newRow, newCol));
            }
        }
        return -1;
    }

    public int pathWithMinEffort_Graph(int[][] heights) {
        //https://leetcode.com/problems/path-with-minimum-effort/
        //based on BFS and swimInRisingWater_Graph()
        class Cell {

            int effort;
            int row;
            int col;

            public Cell(int effort, int row, int col) {
                this.effort = effort;
                this.row = row;
                this.col = col;
            }

        }

        int ROW = heights.length;
        int COL = heights[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int srcRow = 0;
        int srcCol = 0;
        int effortToSrc = 0;

        boolean[][] visited = new boolean[ROW][COL];
        PriorityQueue<Cell> minHeapEffort = new PriorityQueue<>(
                (a, b) -> a.effort - b.effort);

        minHeapEffort.add(new Cell(effortToSrc, srcRow, srcCol));

        while (!minHeapEffort.isEmpty()) {

            Cell currCell = minHeapEffort.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.effort;
            }

            //this visited addition should be done here, because if you mark the
            //new row & col visited in below dirs[] loop, then the bottom-right
            //cell(==> ROW - 1 and COL - 1) will be marked visited before even
            //finding the actual answer for any other paths already in the queue
            visited[currCell.row][currCell.col] = true;

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                int nextCellEffort = Math.abs(
                        heights[currCell.row][currCell.col] - heights[newRow][newCol]);

                minHeapEffort.add(new Cell(
                        //choose the max effort of the curr path that follows from
                        //prev (currCell row & col) to next (new row & col)
                        Math.max(currCell.effort, nextCellEffort),
                        newRow,
                        newCol));
            }
        }
        return -1;
    }

    public void minCostToConnectAllPoints_Graph(int[][] points) {
        //https://leetcode.com/problems/min-cost-to-connect-all-points/
        //explanation: https://youtu.be/f7JOBJIC-NA
        //BASED on prim's algo
        int n = points.length;
        //<srcVertex, List<List<dist, destVertex>>>
        Map<Integer, List<List<Integer>>> graph = new HashMap<>();
        for (int node = 0; node < n; node++) {
            graph.put(node, new ArrayList<>());
        }

        //if there are n points in points[][] then each coord is supposed to have
        //an edge with all the other coord points having weight/cost/dist as
        //manhattan dist of these two coord points
        for (int src = 0; src < n; src++) {
            int x1 = points[src][0];
            int y1 = points[src][1];
            for (int dest = src + 1; dest < n; dest++) {
                int x2 = points[dest][0];
                int y2 = points[dest][1];
                //manhattan dist
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);
                graph.get(src).add(Arrays.asList(dist, dest));
                graph.get(dest).add(Arrays.asList(dist, src));
            }
        }

        int totalDist = 0;
        int currSrc = 0;
        int currDist = 0;

        Set<Integer> visited = new HashSet<>();
        //List<dist, destVertex>
        PriorityQueue<List<Integer>> minHeapDist = new PriorityQueue<>(
                (l1, l2) -> l1.get(0) - l2.get(0));

        minHeapDist.add(Arrays.asList(currDist, currSrc));

        while (visited.size() < n) {

            List<Integer> currEdge = minHeapDist.poll();
            currDist = currEdge.get(0);
            currSrc = currEdge.get(1);

            if (visited.contains(currSrc)) {
                continue;
            }

            totalDist += currDist;
            visited.add(currSrc);

            for (List<Integer> childEdge : graph.get(currSrc)) {
                int childVertex = childEdge.get(1);
                if (visited.contains(childVertex)) {
                    continue;
                }
                minHeapDist.add(childEdge);
            }
        }
        //output
        System.out.println("Min cost to connect all points: " + totalDist);
    }

    public void minCostToConnectAllPoints_Graph_UnionFind(int[][] points) {
        //https://leetcode.com/problems/min-cost-to-connect-all-points/
        //BASED on PRIM'S ALGO using DISJOINT SET/ UNION FIND
        /*
        intution here is same as prim's algo
        we will create all the edges with their associated weight and we will put
        it in the heap so that we can fetch the min weighted edges first from heap
        (typical prim's algo logic!!! :D )

        Now that we have all our edges in heap, we will pick out all the edges
        one by one from this heap and try to from minimum spanning tree/graph
        in the process of forming minimum spanning tree/graph, if we ever reach
        an edge that if we add it will form a cycle in it then we should reject
        that edge (parent of nodes src & dest (i & j) should not match because
        if they match that means both the nodes are alredy in the same connected
        graph, hence adding another edge will form a cycle)

         */
        class Edge {

            int src;
            int dest;
            int dist;

            public Edge(int src, int dest, int dist) {
                this.src = src;
                this.dest = dest;
                this.dist = dist;
            }

        }

        class UnionFind {

            int V;
            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                this.V = V;
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        int n = points.length;
        PriorityQueue<Edge> minHeapDist = new PriorityQueue<>(
                (a, b) -> a.dist - b.dist);

        //if there are n points in points[][] then each coord is supposed to have
        //an edge with all the other coord points having weight/cost/dist as
        //manhattan dist of these two coord points
        for (int u = 0; u < n; u++) {

            int x1 = points[u][0];
            int y1 = points[u][1];

            for (int v = u + 1; v < n; v++) {

                int x2 = points[v][0];
                int y2 = points[v][1];
                //manhattan dist
                //dist between coord point[i] and coord point[j]
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);

                minHeapDist.add(new Edge(u, v, dist));
            }
        }

        UnionFind unionFind = new UnionFind(n);
        int totalDist = 0;

        while (!minHeapDist.isEmpty()) {
            Edge currEdge = minHeapDist.poll();

            //if the parents of both src & dest nodes (i & j) are not same then
            //we can add the min weighted edge in the minimum spanning tree/graph
            //and totalDist can upated with this min dist
            //unless, if the parents of both src & dest nodes (i & j) are same
            //then they will form a cycle in the minimum spanning tree/graph
            if (unionFind.find(currEdge.src) != unionFind.find(currEdge.dest)) {
                totalDist += currEdge.dist;
                unionFind.union(currEdge.src, currEdge.dest);
            }
        }
        //output
        System.out.println("Min cost to connect all points: " + totalDist);
    }

    class Coord {

        int row;
        int col;

        public Coord(int row, int col) {
            this.row = row;
            this.col = col;
        }

    }

    private boolean pacificAtlanticWaterFlow_IsOutOfBounds(int row, int col, int ROW, int COL) {
        return row < 0 || row >= ROW || col < 0 || col >= COL;
    }

    private void pacificAtlanticWaterFlow_HelperBFS(int[][] heights, Queue<Coord> queue,
                                                    boolean[][] visited, int[][] dirs, int ROW, int COL) {

        while (!queue.isEmpty()) {

            Coord curr = queue.poll();

            visited[curr.row][curr.col] = true;

            for (int[] dir : dirs) {
                int newRow = curr.row + dir[0];
                int newCol = curr.col + dir[1];

                if (pacificAtlanticWaterFlow_IsOutOfBounds(newRow, newCol, ROW, COL)
                        || visited[newRow][newCol]
                        || heights[newRow][newCol] < heights[curr.row][curr.col]) {
                    continue;
                }
                queue.add(new Coord(newRow, newCol));
            }
        }
    }

    public void pacificAtlanticWaterFlow(int[][] heights) {
        //https://leetcode.com/problems/pacific-atlantic-water-flow/
        //https://www.geeksforgeeks.org/atlantic-pacific-water-flow/

        int ROW = heights.length;
        int COL = heights[0].length;

        List<List<Integer>> result = new ArrayList<>();

        int topEdge = 0;
        int bottomEdge = ROW - 1;
        int leftEdge = 0;
        int rightEdge = COL - 1;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        Queue<Coord> queueAtlantic = new LinkedList<>();
        Queue<Coord> queuePacific = new LinkedList<>();

        boolean[][] visitedAtlantic = new boolean[ROW][COL];
        boolean[][] visitedPacific = new boolean[ROW][COL];

        //save all the top & bottom row edges that are touched by atlantic and pacific ocean
        for (int col = 0; col < COL; col++) {
            queueAtlantic.add(new Coord(bottomEdge, col));
            queuePacific.add(new Coord(topEdge, col));
        }

        //save all the left & right col edges that are touched by atlantic and pacific ocean
        for (int row = 0; row < ROW; row++) {
            queueAtlantic.add(new Coord(row, rightEdge));
            queuePacific.add(new Coord(row, leftEdge));
        }

        //Do BFS from all the atlantic ocean are corrds
        pacificAtlanticWaterFlow_HelperBFS(
                heights, queueAtlantic, visitedAtlantic, dirs, ROW, COL);

        //Do BFS from all the pacific ocean are corrds
        pacificAtlanticWaterFlow_HelperBFS(
                heights, queuePacific, visitedPacific, dirs, ROW, COL);

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                if (visitedAtlantic[row][col] && visitedPacific[row][col]) {
                    result.add(Arrays.asList(row, col));
                }
            }
        }
        //output
        System.out.println("All coordinates form pacific to atlantic ocean water flow: " + result);
    }

    public void minimumCostToFillGivenBag_DP_Memoization(int[] cost, int W) {

        //0-1Knapsack problem
        //problem statement: https://practice.geeksforgeeks.org/problems/minimum-cost-to-fill-given-weight-in-a-bag1956/1
        //create normal data
        List<Integer> value = new ArrayList<>();
        List<Integer> weight = new ArrayList<>();

        int actualSize = 0;
        for (int i = 0; i < cost.length; i++) {
            if (cost[i] != -1) {
                value.add(cost[i]);
                weight.add(i + 1);
                actualSize++;
            }
        }

        int[][] memo = new int[actualSize + 1][W + 1];
        for (int x = 0; x < actualSize + 1; x++) {
            for (int y = 0; y < W + 1; y++) {
                if (x == 0) {
                    memo[x][y] = Integer.MAX_VALUE;
                }
                if (y == 0) {
                    memo[x][y] = 0;
                }
            }
        }

        for (int x = 1; x < actualSize + 1; x++) {
            for (int y = 1; y < W + 1; y++) {
                if (weight.get(x - 1) > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = Math.min(value.get(x - 1) + memo[x][y - weight.get(x - 1)],
                            memo[x - 1][y]);
                }
            }
        }

        //output
        System.out.println("Min cost: " + memo[actualSize][W]);
    }

    private boolean checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
            String s1, int indexI, String s2, int indexJ, String s3, int indexK, Boolean[][][] memo) {

        //here string s1 got ended because we might have used all its chars in s3
        if (indexI >= s1.length()) {
            //remaining part of string s2 from indexJ to s2.length should be equal to
            //remaining part of string s3 from IndexK to s3.length
            return s2.substring(indexJ).equals(s3.substring(indexK));
        }

        //here string s2 got ended because we might have used all its chars in s3
        if (indexJ >= s2.length()) {
            //remaining part of string s1 from indexI to s1.length should be equal to
            //remaining part of string s3 from IndexK to s3.length
            return s1.substring(indexI).equals(s3.substring(indexK));
        }

        if (memo[indexI][indexJ][indexK] != null) {
            return memo[indexI][indexJ][indexK];
        }

        boolean isPossible = false;

        isPossible = isPossible
                || (s1.charAt(indexI) == s3.charAt(indexK) && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
                s1, indexI + 1, s2, indexJ, s3, indexK + 1, memo));

        isPossible = isPossible
                || (s2.charAt(indexJ) == s3.charAt(indexK) && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
                s1, indexI, s2, indexJ + 1, s3, indexK + 1, memo));

        return memo[indexI][indexJ][indexK] = isPossible;
    }

    private boolean checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper2(
            String s1, int indexI, String s2, int indexJ, String s3, Boolean[][] memo) {

        //here string s1 got ended because we might have used all its chars in s3
        if (indexI >= s1.length()) {
            //remaining part of string s2 from indexJ to s2.length should be equal to
            //remaining part of string s3 from IndexK (==> indexI + indexJ) to s3.length
            return s2.substring(indexJ).equals(s3.substring(indexI + indexJ));
        }

        //here string s2 got ended because we might have used all its chars in s3
        if (indexJ >= s2.length()) {
            //remaining part of string s1 from indexI to s1.length should be equal to
            //remaining part of string s3 from IndexK (==> indexI + indexJ) to s3.length
            return s1.substring(indexI).equals(s3.substring(indexI + indexJ));
        }

        if (memo[indexI][indexJ] != null) {
            return memo[indexI][indexJ];
        }

        boolean isPossible = false;

        isPossible |= (s1.charAt(indexI) == s3.charAt(indexI + indexJ)
                && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper2(
                s1, indexI + 1, s2, indexJ, s3, memo));

        isPossible |= (s2.charAt(indexJ) == s3.charAt(indexI + indexJ)
                && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper2(
                s1, indexI, s2, indexJ + 1, s3, memo));

        return memo[indexI][indexJ] = isPossible;
    }

    public boolean checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization(String s1, String s2, String s3) {
        //.............................T: O(M * N) M = a.length(), N = b.length()
        //https://leetcode.com/problems/interleaving-string/
        //explanation: https://youtu.be/3Rw3p9LrgvE
        if (s3.length() != s1.length() + s2.length()) {
            return false;
        }

        //Boolean[][][] memo = new Boolean[s1.length()][s2.length()][s3.length()];
        //boolean isPossible = checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
        //        s1, 0, s2, 0, s3, 0, memo);
        //a slight optimization on 3D memo[][][] to 2D memo[][],
        //observation here is very simple, since we know length of s3 is equal to
        //sum of lengths of s1 & s2 strings, and if s3 is formed from interleaving
        //of s1 & s2 strings then both the index of s1 and s2 i.e, indexI & indexJ
        //their sum is the total index covered in string s3 meaning here
        //indexK = indexI + indexJ hence we can ommit indexK parameter
        Boolean[][] memo = new Boolean[s1.length()][s2.length()];
        boolean isPossible = checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper2(
                s1, 0, s2, 0, s3, memo);

        return isPossible;
    }

    public boolean checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization(String a, String b, String c) {

        //.............................T: O(M * N) M = a.length(), N = b.length()
        //https://leetcode.com/problems/interleaving-string/
        //explanation: https://youtu.be/3Rw3p9LrgvE
        if (c.length() != a.length() + b.length()) {
            return false;
        }

        boolean dp[] = new boolean[b.length() + 1];
        for (int i = 0; i <= a.length(); i++) {
            for (int j = 0; j <= b.length(); j++) {
                if (i == 0 && j == 0) {
                    dp[j] = true;
                } else if (i == 0) {
                    dp[j] = dp[j - 1] && b.charAt(j - 1) == c.charAt(i + j - 1);
                } else if (j == 0) {
                    dp[j] = dp[j] && a.charAt(i - 1) == c.charAt(i + j - 1);
                } else {
                    dp[j] = (dp[j] && a.charAt(i - 1) == c.charAt(i + j - 1))
                            || (dp[j - 1] && b.charAt(j - 1) == c.charAt(i + j - 1));
                }
            }
        }
        return dp[b.length()];
    }

    public void minimumDiffPartition_DP_Memoization(int[] arr) {

        //https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1#
        int sumArr = 0;
        for (int e : arr) {
            sumArr += e;
        }
        int n = arr.length;
        boolean[][] memo = new boolean[n + 1][sumArr + 1];
        for (int x = 0; x < n + 1; x++) {
            for (int y = 0; y < sumArr + 1; y++) {
                if (x == 0) {
                    memo[x][y] = false;
                }
                if (y == 0) {
                    memo[x][y] = true;
                }
            }
        }

        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < sumArr + 1; y++) {
                if (arr[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x - 1][y] || memo[x - 1][y - arr[x - 1]];
                }
            }
        }

        int minDiff = Integer.MAX_VALUE;
        for (int currSum = (sumArr + 1) / 2; currSum >= 0; currSum--) {
            if (memo[n][currSum]) {
                minDiff = Math.abs(Math.min(minDiff, sumArr - 2 * currSum));
            }
        }

        //output
        System.out.println("Min diff between two sum of two partition of the array: " + minDiff);
    }

    public void maximalSquare_DP_Memoization(int[][] matrix) {
        //......................T: O(M*N), M = matrix row, N = matrix col
        //......................S: O(M*N), Using DP[M + 1][N + 1] OR O(1), Without using DP[][]
        //https://leetcode.com/problems/maximal-square/
        //https://practice.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1
        int R = matrix.length;
        int C = matrix[0].length;
        int maxSqrLen = 0;

        //Using extra DP[][] space
//        int[][] memo = new int[R + 1][C + 1];
//        for (int r = 1; r < memo.length; r++) {
//            for (int c = 1; c < memo[r].length; c++) {
//                if (matrix[r - 1][c - 1] == 1) {
//                    memo[r][c] = Math.min(
//                            //diagonal
//                            memo[r - 1][c - 1],
//                            //up, left
//                            Math.min(memo[r - 1][c], memo[r][c - 1])
//                    ) + 1;
//                    maxSqrLen = Math.max(maxSqrLen, memo[r][c]);
//                }
//            }
//        }
        //Wihtout using extra DP[][] space
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {

                if (matrix[r][c] == 1) {

                    if (r == 0 || c == 0) {
                        maxSqrLen = Math.max(maxSqrLen, matrix[r][c]);
                        continue;
                    }

                    matrix[r][c] = Math.min(
                            //diagonal
                            matrix[r - 1][c - 1],
                            Math.min(
                                    //up
                                    matrix[r - 1][c],
                                    //left
                                    matrix[r][c - 1])) + 1;
                    maxSqrLen = Math.max(maxSqrLen, matrix[r][c]);
                }
            }
        }

        //Output:
        System.out.println("Max square in binary matrix: length: " + maxSqrLen + " area: " + (maxSqrLen * maxSqrLen));
    }

    public void countAllSquareWithOneInBinaryMatrix_DP_Memoization(int[][] matrix) {
        //......................T: O(M*N), M = matrix row, N = matrix col
        //......................S: O(M*N), Using DP[M + 1][N + 1] OR O(1), Without using DP[][]
        //https://leetcode.com/problems/count-square-submatrices-with-all-ones
        //explanation: https://youtu.be/Z2h3rkVXPeQ
        int totalSquares = 0;
        int R = matrix.length;
        int C = matrix[0].length;

        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {

                //consider only 1 for our squares
                if (matrix[r][c] == 1) {
                    //first row & col, if they have 1 there, we can simply
                    //add in out total beacuse they at the top & left edge of matrix
                    //they will not be forming any squares
                    if (r == 0 || c == 0) {
                        totalSquares += matrix[r][c]; //basically 1 at the top & left edge
                        continue;
                    }
                    matrix[r][c] = Math.min(
                            //diagonal
                            matrix[r - 1][c - 1],
                            Math.min(
                                    //row above
                                    matrix[r - 1][c],
                                    //left col
                                    matrix[r][c - 1])) + 1;
                    totalSquares += matrix[r][c];
                }
            }
        }
        //output:
        System.out.println("Total squares in given matrix: " + totalSquares);
    }

    public void longestStringChain_DP_Memoization(String[] words) {
        //https://leetcode.com/problems/longest-string-chain/
        //https://leetcode.com/problems/longest-string-chain/discuss/2094249/Java-DP
        //based on LIS LONGEST INCR SUBSEQ
        //map<word, chain>, this map stores the no of chains can be formed by each word
        Map<String, Integer> memo = new HashMap<>();
        for (String word : words) {
            //every single word is in itself is a chain, thats why 1
            memo.put(word, 1);
        }

        //incr order of their lengths
        Arrays.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));

        int longestStringChainLength = 0;

        for (String word : words) {

            //for each word in words[], try to remove one char and
            //check if that new string matches any previous string
            int wordLength = word.length();

            for (int i = 0; i < wordLength; i++) {
                //remove i-th char from current word
                //because question says 'we can insert exactly one letter anywhere
                //in previousWord without changing the order of the other characters
                //to make it equal to curr word'
                String previousWord = word.substring(0, i) + word.substring(i + 1);

                //taking max because
                //forming a chain with curr word may create a longer chain
                //or the previousWord already have the longer chain( with their previous words)
                //+ 1 for this curr word
                int chainLength = Math.max(memo.get(word), memo.get(previousWord) + 1);

                if (memo.containsKey(previousWord)) {
                    memo.put(word, chainLength);
                }
            }

            longestStringChainLength = Math.max(longestStringChainLength, memo.get(word));
        }
        //output
        System.out.println("Max string chain formed: " + longestStringChainLength);
    }

    private int buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
            int[] prices, int k, int day, boolean toBuy, Integer[][][] memo) {

        int n = prices.length;

        //as we are allowed to make 'atmost k' transaction that means [0 to k]
        //i.e, k buy transaction, so if transaction 'k' reaches -1
        //means we exhaust all the allowed transactions limit hence return 0
        //as profit
        if (k <= -1) {
            return 0;
        }

        //return 0 as profit as we reach the end of the given stock's prices[]
        //means there are no more stock prices on 'day' left to choose
        if (day >= n) {
            return 0;
        }

        if (memo[day][k][toBuy ? 0 : 1] != null) {
            return memo[day][k][toBuy ? 0 : 1];
        }

        int maxProfit = Integer.MIN_VALUE;

        //currently, we have are allowed to 'buy' a stock, we will have 2 choices
        if (toBuy) {

            maxProfit = Math.max(
                    //1. we decide to buy the stock on curr @day at price of
                    //prices[day] and since we are buying means we have to pay
                    //the amount so this amount has to be subtracted from all
                    //possible profit coming from the recursive call stack
                    //also, we are making the buy transaction so k is reduced -1
                    //and we move to next day(==> day + 1) possibly to 'sell'(==> toBuy = false)
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k - 1, day + 1, false, memo) - prices[day],
                    //2. we decide not to buy the stock on curr @day hence we move
                    //to next day(==> day + 1) possibly to 'buy'(==> toBuy = true) on
                    //that next day and as we didn't buy here, transaction is not done
                    //so k remains as it is
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, true, memo));
        } //here, we are allowed to 'sell' a stock we bought earlier in some previous
        //call stack, we will 2 choices
        else {

            maxProfit = Math.max(
                    //1. we decide to sell the stock we bought previously currently
                    //@day at a price of prices[day] and as we sell off stock we will
                    //recieve this amount. this amount will we added to possible profit
                    //coming from recursive call stack
                    //also, we move to next day(==> day + 1) possibly to 'buy'(==> toBuy = true)
                    prices[day] + buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, true, memo),
                    //2. we decide not to sell the stock we bought on curr @day so
                    //we move to next day(==> day + 1) possibly to 'sell'(==> toBuy = false) on
                    //that next day
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, false, memo));
        }

        return memo[day][k][toBuy ? 0 : 1] = maxProfit;
    }

    public void buyAndSellStocksAtMostkTimes_Recursive_Memoization(int[] prices, int k) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/2555708/Easy-solution-Explained-oror-Beginner-Friendly-oror-Best-Method
        int n = prices.length;
        Integer[][][] memo = new Integer[n + 1][k + 1][2];
        int maxProfit = buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                prices, k, 0, true, memo);
        //output
        System.out.println("Max profit buy and sell stocks at most k times: " + maxProfit);
    }

    private void minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
            int[] cookies, int[] childrens, int cookieIndex, int maxCookieWithAChild) {

        //we have total of k childrens to distribute the cookies to
        int k = childrens.length;
        //total cookies we can pick
        int n = cookies.length;

        //if we reached the end of cookies[] where we can't pick any more cookes
        //for any of the 'k' chilrens then we can simply store the min unfairness
        if (cookieIndex >= n) {

            //min unfairness is minimizing the cookies alloted to any of the
            //k childrens, so whatever the max cookie a child alloted so far
            //(==> maxCookieWithAChild) we need to minimize this max possible
            //cookie alloted
            minimumUnfairDistributionOfCookiesToKStudent_Result = Math.min(
                    minimumUnfairDistributionOfCookiesToKStudent_Result,
                    maxCookieWithAChild);
            return;
        }

        //this is the curr cookie @cookieIndex of cookies[] that with backtracking
        //approach, we will try to give it to each k-th 'child' below
        //also this is a recursive-backtracking approach we have 'maxCookieWithAChild'
        //which denotes any max cookie alloted to any k-th child in previous call stacks
        //so if in this call stack, when we are simulating giving 'currCookie' to
        //each k-th 'child', we are also checking if the curr k-th 'child' has got
        //some max cookie alloted to him for next call stacks
        int currCookie = cookies[cookieIndex];

        //simulating giving 'currCookie' to each k-th 'child' one by one, where
        //childrens[child] will actually mean:
        //childrens[child-1] = total-cookies-held-till-prev-recursive-calls
        //childrens[child-2] = total-cookies-held-till-prev-recursive-calls
        //so on till k children
        for (int child = 0; child < k; child++) {

            //alloting the 'currCookie' to curr k-th 'child', now childrens[child]
            //actually tells us the total cookie alloted to k-th child in some
            //previous recursive-backtracking calls & add to that this 'currCookie'
            childrens[child] += currCookie;

            minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
                    cookies, childrens,
                    //since we have alloted our 'currCookie' to curr k-th 'child'
                    //we can simply move to next cookie (==> cookieIndex + 1) to
                    //allot it to k childrens in next recursive-backtrack calls
                    cookieIndex + 1,
                    //this 'maxCookieWithAChild' comes in with recursive-backtrack
                    //calls denotes the max cookie already alloted to one of k-th
                    //child till a previous call stack
                    //now in this curr call stack, when curr 'child' alloted
                    //'currCookie' it will get add up to its previous total cookies
                    //held as childrens[child]
                    Math.max(maxCookieWithAChild, childrens[child]));

            //typically backtracking here, we are now deallocating the same 'currCookie'
            //from the curr k-th 'child' so that we can try other possibilities by
            //allocating same 'currCookie' to next k-th 'child'
            childrens[child] -= currCookie;
        }
    }

    private int minimumUnfairDistributionOfCookiesToKStudent_Result;

    public void minimumUnfairDistributionOfCookiesToKStudent_Backtracking(int[] cookies, int k) {
        //https://leetcode.com/problems/fair-distribution-of-cookies/
        //https://leetcode.com/problems/fair-distribution-of-cookies/discuss/2212309/JAVA-oror-SIMPLE-BACKTRACKING

        minimumUnfairDistributionOfCookiesToKStudent_Result = Integer.MAX_VALUE;

        int[] childrens = new int[k];

        minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
                cookies, childrens, 0, 0);

        //output
        System.out.println("Min unfairness in distribution of cookies: "
                + minimumUnfairDistributionOfCookiesToKStudent_Result);
    }

    private boolean partitionToKEqualSumSubset_Backtracking_Helper(int[] nums, int k,
                                                                   int index, int currSubsetSum, int sumPerKSubset, Set<Integer> indexUsed) {

        if (k == 0) {
            return true;
        }

        if (currSubsetSum == sumPerKSubset) {
            return partitionToKEqualSumSubset_Backtracking_Helper(nums, k - 1,
                    0, 0, sumPerKSubset, indexUsed);
        }

        for (int i = index; i < nums.length; i++) {
            if (indexUsed.contains(i)
                    //handle duplicates
                    || (i - 1 >= 0 && nums[i] == nums[i - 1] && !indexUsed.contains(i - 1))
                    //handles case where adding curr nums[i] to currSubsetSum
                    //will not give any solution
                    || currSubsetSum + nums[i] > sumPerKSubset) {
                continue;
            }

            indexUsed.add(i);
            if (partitionToKEqualSumSubset_Backtracking_Helper(
                    nums, k, i + 1, currSubsetSum + nums[i], sumPerKSubset, indexUsed)) {
                return true;
            }
            indexUsed.remove(i);
        }
        return false;
    }

    public boolean partitionToKEqualSumSubset_Backtracking(int[] nums, int k) {
        //.............................T: O(2^(k*N)), N is length of array, we will be
        //trying all possible k subsets by making decision if a index to be used in subset
        //for next time or not.
        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/
        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/2360226/Java-ororBeats-90-oror-Hardcore-expl'n-!!
        //explanation: https://youtu.be/mBk4I0X46oI

        //we cant make k partitions(non-empty subsets) if array element is less than k
        if (k > nums.length) {
            return false;
        }

        int arrSum = 0;
        for (int val : nums) {
            arrSum += val;
        }

        //k subset partition should have equal sum for each subset
        //if the total array sum is not divisible by k then one of the k
        //partition will have more sum than the others
        //ex: nums = [5,5,5,5], k = 4 ==> arrSum = 20 where arrSum % k == 0
        //that means subset = {{5},{5},{5},{5}} all sub set have equal sum of 5
        //ex: nums = [5,5,5,6], k = 4 ==> arrSum = 21 where arrSum % k != 0
        //that means subset = {{5},{5},{5},{6}} all sub set doesn't have equal sum
        if (arrSum % k != 0) {
            return false;
        }
        //sum of each subset
        int sumPerKSubset = arrSum / k;
        Set<Integer> indexUsed = new HashSet<>();
        //sort nums so that we can handle duplicates while making decisions
        Arrays.sort(nums);
        return partitionToKEqualSumSubset_Backtracking_Helper(nums, k, 0, 0, sumPerKSubset, indexUsed);
    }

    private void nQueens_Backtracking_Helper_HashSetCheck(
            char[][] board, int col, int n,
            List<List<String>> queenPlacements, Set<String> previousPlacedQueens) {

        //if we have placed our queens successfully
        //starting from col == 0 to col == n - 1
        //then when col == n is called, we can say the curr placement of queens
        //are valid palcements
        if (col == n) {
            //as per output format, converting each row to string format
            List<String> currPlacement = new ArrayList<>();
            for (char[] row : board) {
                currPlacement.add(String.valueOf(row));
            }
            queenPlacements.add(currPlacement);
            return;
        }

        //for a given col we will try to place our queen in each row
        //of that col, if it is safe to place there we will move to next col
        //to try to place our next queen safely
        for (int row = 0; row < n; row++) {
            //first we will check if it is safe to place our curr queen
            //at a given row and col
            //safety rule:
            //1. no queen should already be there in upper-left diagonal
            //2. no queen should already be there in curr row straight-left col
            //3. no queen should already be there in bottom-left diagonal
            //if a queen is already placed on any of the below locations we don't
            //want to place our curr queen in alignment with previous queen
            if (previousPlacedQueens.contains("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row))
                    || previousPlacedQueens.contains("STRAIGHT-LEFT" + row)
                    || previousPlacedQueens.contains("BOTTOM-LEFT-DIAGONAL" + (row + col))) {
                continue;
            }
            //we will try place our Queen in each row
            //in a given col

            previousPlacedQueens.add("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row));
            previousPlacedQueens.add("STRAIGHT-LEFT" + row);
            previousPlacedQueens.add("BOTTOM-LEFT-DIAGONAL" + (row + col));

            board[row][col] = 'Q';

            nQueens_Backtracking_Helper_HashSetCheck(
                    board, col + 1, n, queenPlacements, previousPlacedQueens);

            board[row][col] = '.';

            previousPlacedQueens.remove("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row));
            previousPlacedQueens.remove("STRAIGHT-LEFT" + row);
            previousPlacedQueens.remove("BOTTOM-LEFT-DIAGONAL" + (row + col));
        }
    }

    private boolean nQueens_Backtracking_IsSafeToPlaceQueen(
            char[][] board, int row, int col, int n) {
        /*
         //since we are moving col wise by placing our queen in curr col
         //and we are moving like [0 <= col < n] therefore from our col there will
         //be no queens placed in right, only before this curr col.
         //so keeping this in mind we will only check all the prev dires from the curr col
         //to check if there were any queen placed in previous itrations or not
         upper-left diagonal
         straight-left col
         bootom-left diagonal
         .\
         ..\
         ...\
         ....\

         ----- [COL]

         ..../
         .../
         ../
         ./

         */
        int currRow = row;
        int currCol = col;

        //upper-left diagonal
        while (currRow >= 0 && currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currRow--;
            currCol--;
        }

        currRow = row;
        currCol = col;
        //same row straight-left col
        while (currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currCol--;
        }

        currRow = row;
        currCol = col;
        //bottom-left diagonal
        while (currRow < n && currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currRow++;
            currCol--;
        }
        return true;
    }

    private void nQueens_Backtracking_Helper(
            char[][] board, int col, int n, List<List<String>> queenPlacements) {

        //here, we have placed all the n queens in the grid starting from col = 0
        //to col = n - 1, now when col ptr moved to n-th index it would mean we
        //successfully placed all queens and are also valid
        if (col == n) {
            //as per output format, converting each row to string format
            List<String> currPlacement = new ArrayList<>();
            for (char[] row : board) {
                currPlacement.add(String.valueOf(row));
            }
            queenPlacements.add(currPlacement);
            return;
        }

        //for a given col we will try to place our queen in each row
        //of that col, if it is safe to place there we will move to next col
        //to try to place our next queen safely
        for (int row = 0; row < n; row++) {
            //first we will check if it is safe to place our curr queen
            //at a given row and col
            //safety rule:
            //1. no queen should already be there in upper-left diagonal
            //2. no queen should already be there in curr row straight-left col
            //3. no queen should already be there in bottom-left diagonal
            if (nQueens_Backtracking_IsSafeToPlaceQueen(board, row, col, n)) {
                //here, we will place our Queen in curr row & col
                board[row][col] = 'Q';
                nQueens_Backtracking_Helper(board, col + 1, n, queenPlacements);
                //typical backrtacking, we will remove curr 'Q' placement at
                //row & col so that we can try another 'Q' placements
                board[row][col] = '.';
            }
        }
    }

    public void nQueens_Backtracking(int n) {
        //https://leetcode.com/problems/n-queens/
        //https://leetcode.com/problems/n-queens-ii/
        //explanation: https://youtu.be/i05Ju7AftcM
        List<List<String>> queenPlacements = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                board[r][c] = '.';
            }
        }
        nQueens_Backtracking_Helper(board, 0, n, queenPlacements);

        //on leetcode this set based checking was slow,
        //keep this approach if in case it was asked
//        Set<String> previousPlacedQueens = new HashSet<>();
//        nQueens_Backtracking_Helper_HashSetCheck(board, 0, n, queenPlacements, previousPlacedQueens);
        //output:
        System.out.println("All possible placement of N-Queens: " + queenPlacements);
    }

    private boolean sudokuSolver_Backtracking_IsValidToPutNum(
            char[][] board, int row, int col, char num) {
        for (int i = 0; i < board.length; i++) {
            //if in row wise dir already have same num as we are tyring to put
            if (board[i][col] == num) {
                return false;
            }
            //if in col wise dir already have same num as we are tyring to put
            if (board[row][i] == num) {
                return false;
            }
            //if the curr 3*3 submatrix already have same num as we are tyring to put
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) {
                return false;
            }
        }
        return true;
    }

    private boolean sudokuSolver_Backtracking_Helper(char[][] board) {

        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                //if the curr spot is empty
                if (board[r][c] == '.') {
                    //with this loop we are trying to put in all the possible num
                    //in the given row and col
                    for (char num = '1'; num <= '9'; num++) {
                        //for curr num we will check if it is valid to place this num
                        //in curr row and col, if it is safe we will put that num into
                        //the curr empty spot and move to new location by recursion
                        if (sudokuSolver_Backtracking_IsValidToPutNum(board, r, c, num)) {

                            board[r][c] = num;
                            //if by recursion we find the sudoku is solved we will return true
                            //if it can't be solved keep the original empty spot in the curr row and col
                            if (sudokuSolver_Backtracking_Helper(board)) {
                                return true;
                            }

                            board[r][c] = '.';
                        }
                    }
                    //if above loop of [1 to 9] doesn't satisfy the sudoku board
                    return false;
                }
            }
        }
        return true;
    }

    public void sudokuSolver_Backtracking(char[][] board) {
        //https://leetcode.com/problems/sudoku-solver
        //explanation: https://youtu.be/FWAIf_EVUKE
        //actual:
        System.out.println("Empty sudoku board");
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }

        sudokuSolver_Backtracking_Helper(board);

        //output
        System.out.println("Solved sudoku");
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
    }

    private void wordBreakTwo_Backtracking_Helper(
            String str, Set<String> wordSet, int startIndex, String currSentence, List<String> result) {

        int n = str.length();

        if (startIndex >= n) {
            result.add(currSentence.trim());
            return;
        }

        for (int endIndex = startIndex; endIndex < n; endIndex++) {
            String word = str.substring(startIndex, endIndex + 1);
            //if the curr word from str as substring[startIndex, endIndex] exists
            //in word dict, we will move inside as this word is a valid word to be
            //used in curr sentence
            if (wordSet.contains(word)) {
                wordBreakTwo_Backtracking_Helper(
                        str, wordSet, endIndex + 1,
                        //pass currSentence as new string object with curr combination
                        //of substr as (currStr + " " + substr)
                        //ex at i = 3 : these are recur combinations
                        //"" + " " + "cat" ==> recur
                        //" cat" + " " + "sand" ==> recur
                        //" cat sand dog" ==> recur then str.length() == 0 (Base Cond)
                        //at i = 4 : these are recur combinations
                        //"" + " " + "cats" ==> recur
                        //" cats" + " " + "and" ==> recur
                        //" cats and dog" ==> recur then str.length() == 0 (Base Cond)
                        String.valueOf(currSentence + " " + word),
                        result);
            }
        }
    }

    public void wordBreakTwo_Backtracking(String str, String[] wordDict) {
        //https://leetcode.com/problems/word-break-ii/
        //based on wordBreak_Recursive
        List<String> result = new ArrayList<>();
        Set<String> wordSet = new HashSet<>();
        wordSet.addAll(Arrays.asList(wordDict));
        wordBreakTwo_Backtracking_Helper(str, wordSet, 0, "", result);
        //output
        System.out.println("Word break all string combinations (Backtracking): " + result);
    }

    private void increasingSubsequences_Backtracking_Helper(int[] nums, int index,
                                                            List<Integer> curr, Set<List<Integer>> setResult) {
        //we will add those curr list that have atleast 2 elements in it
        //Set<List> ensures that each added curr list is unique
        //we are not returning from this if block because we might have
        //more increasing subseq afterwards
        //that why below index == nums.length check is req so that we don't get
        //index out of bounds exceptions
        if (curr.size() >= 2) {
            setResult.add(new ArrayList<>(curr));
        }

        if (index == nums.length) {
            return;
        }

        //2 choices we can make here,
        //1. don't pick curr val @index and move to next index(==> index + 1)
        increasingSubsequences_Backtracking_Helper(nums, index + 1, curr, setResult);

        //2. pick the curr val @index
        //curr.isEmpty() that means we are going to add our first element in the list
        //OR (curr.get(curr.size() - 1) <= nums[i]) if curr is not empty AND the curr
        //nums[index] is greater or equal to last added element in curr list
        //this we will ensure that our curr list will have increasing subseq
        //curr = [i, j, val3, ... valn] where i <= j <= val3 <= ... valn
        if (curr.isEmpty() || (curr.get(curr.size() - 1) <= nums[index])) {

            curr.add(nums[index]);

            increasingSubsequences_Backtracking_Helper(nums, index + 1, curr, setResult);

            curr.remove(curr.size() - 1);
        }
    }

    public void increasingSubsequences_Backtracking(int[] nums) {
        //https://leetcode.com/problems/increasing-subsequences/
        int n = nums.length;
        Set<List<Integer>> setResult = new HashSet<>();
        increasingSubsequences_Backtracking_Helper(nums, 0, new ArrayList<>(), setResult);
        List<List<Integer>> increasingSubseq = new ArrayList<>(setResult);
        //output
        System.out.println("All the increasing subseq in given arr: " + increasingSubseq);
    }

    private void pallindromePartitioning_Backtracking_Helper(String str, int startIndex, int length,
                                                             List<String> currList, List<List<String>> pallindromePartitions) {
        if (startIndex == length) {
            pallindromePartitions.add(new ArrayList<>(currList));
            return;
        }

        for (int endIndex = startIndex; endIndex < length; endIndex++) {
            if (isStringPallindrome(str, startIndex, endIndex)) {
                //req substring is str[startIndex, endIndex] both inclusive
                currList.add(str.substring(startIndex, endIndex + 1));
                pallindromePartitioning_Backtracking_Helper(str, endIndex + 1, length, currList, pallindromePartitions);
                currList.remove(currList.size() - 1);
            }
        }
    }

    public void pallindromePartitioning_Backtracking(String str) {
        //https://leetcode.com/problems/palindrome-partitioning/description/
        int n = str.length();
        List<List<String>> pallindromePartitions = new ArrayList<>();
        pallindromePartitioning_Backtracking_Helper(str, 0, n, new ArrayList<>(), pallindromePartitions);
        //output
        System.out.println("All the possible pallindrome partitions: " + pallindromePartitions);
    }

    private boolean restoreIPAddresses_Backtracking_IsValidSubnet(String subnet) {
        int n = subnet.length();
        //if curr subnet is empty string
        if (n == 0) {
            return false;
        }

        //acc to quest given range for a subnet is (0 to 255) so min length of
        //subnet string can be 1(== "0") & max length can be 3(== "255")
        //so if curr subnet length is more than 3 return false
        if (n >= 4) {
            return false;
        }

        //any subnet with a single 0 is valid ex: 0.0.0.0 but no single subnet
        //should have a preceeding 0 in it
        //ex: "01", "011" their length > 1 but subnet[0] == 0
        if (n > 1 && subnet.charAt(0) == '0') {
            return false;
        }

        //converting into int for just to check if curr subnet is in range of
        //(0 to 255)
        int subnetInt = Integer.parseInt(subnet);
        return subnetInt >= 0 && subnetInt <= 255;
    }

    private void restoreIPAddresses_Backtracking_Helper(
            String str, int startIndex, List<String> subnets, List<String> ipAddresses) {

        int n = str.length();

        //at this point we have we have successfully created 3 valid subnet segment
        //and we just need to create and check the last subnet segment, if that
        //is valid and can be attached to make whole 'ip'
        //ex: subnets = ["192", "1", "23"]
        //initial ip = 192.1.23 and check if last segment if that can be added
        if (subnets.size() == 3) {

            //get the last subnet segment which is the remaining str[startIndex to n]
            String subnet = str.substring(startIndex);

            //check if the last subnet segment is valid or not
            if (!restoreIPAddresses_Backtracking_IsValidSubnet(subnet)) {
                return;
            }

            //join the first 3 subnet segments with '.' and create ip and attach
            //the last subnet segment to ip
            String ip = String.join(".", subnets);

            //add the last subnet segment to the ip
            ip = ip + "." + subnet;

            ipAddresses.add(ip);

            return;
        }

        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //increamently create subnet segment that would start from startIndex
            //and endIndex + 1
            //ex: "1", "19", "192"
            String subnet = str.substring(startIndex, endIndex + 1);

            //this isValidSubent method will keep check on the curr subnet segment
            //like subnet length should [0 to 3] only
            //subnet should be in range [0 to 255]
            //subnet should not have preceeding 0 ex: "01", "011", "092" but
            //as subnet with single 0 is valid "0"
            if (!restoreIPAddresses_Backtracking_IsValidSubnet(subnet)) {
                break;
            }

            //add curr subnet segment
            //like "1", "19", "192"
            subnets.add(subnet);

            restoreIPAddresses_Backtracking_Helper(str, endIndex + 1, subnets, ipAddresses);

            //typical backtracking, remove the last subnet segment added, why?
            //because last segment we considered "1" but later we considered "19"
            //so for that remove "1" and then consider "19" as another subnet
            subnets.remove(subnets.size() - 1);
        }
    }

    public void restoreIPAddresses_Backtracking(String str) {
        //https://leetcode.com/problems/restore-ip-addresses/description/
        List<String> ipAddresses = new ArrayList<>();

        restoreIPAddresses_Backtracking_Helper(str, 0, new ArrayList<>(), ipAddresses);
        //output
        System.out.println("Restore IP addresses: " + ipAddresses);
    }

    private void letterCasePermutation_Backtracking_Helper(char[] chArr, int index, List<String> permutations) {

        int n = chArr.length;

        //save all the intermediate permutations as well that will be formed in
        //between
        permutations.add(String.valueOf(chArr));

        for (int i = index; i < n; i++) {

            if (!Character.isAlphabetic(chArr[i])) {
                continue;
            }

            if (Character.isUpperCase(chArr[i])) {
                char org = chArr[i];
                chArr[i] = Character.toLowerCase(chArr[i]);
                letterCasePermutation_Backtracking_Helper(chArr, i + 1, permutations);
                chArr[i] = org;
            } else {
                char org = chArr[i];
                chArr[i] = Character.toUpperCase(chArr[i]);
                letterCasePermutation_Backtracking_Helper(chArr, i + 1, permutations);
                chArr[i] = org;
            }
        }
    }

    public void letterCasePermutation_Backtracking(String str) {
        //https://leetcode.com/problems/letter-case-permutation/description/
        List<String> permutations = new ArrayList<>();
        letterCasePermutation_Backtracking_Helper(str.toCharArray(), 0, permutations);
        //output
        System.out.println("Letter case permutations: " + permutations);
    }

    private boolean distributeRepeatingIntegers_Backtracking_Helper(
            int[] frequencies, List<Integer> quantities, int qtyIndex) {

        int n = quantities.size();

        if (qtyIndex >= n) {
            return true;
        }

        //in each recursion calls, we will iterate over all the freqs again & again
        //as in each recursive calls we are taking some quantity from freqs[]
        //and moving to next quantity and we when we are coming back we will put
        //back the quantity taken back in freqs[] for further distribution
        for (int i = 0; i < frequencies.length; i++) {

            //skip, if the curr freq is less than the quantities required @qtyIndex
            if (frequencies[i] < quantities.get(qtyIndex)) {
                continue;
            }

            frequencies[i] -= quantities.get(qtyIndex);

            if (distributeRepeatingIntegers_Backtracking_Helper(frequencies, quantities, qtyIndex + 1)) {
                return true;
            }

            frequencies[i] += quantities.get(qtyIndex);
        }
        return false;
    }

    public void distributeRepeatingIntegers_Backtracking(int[] nums, int[] quantity) {
        //https://leetcode.com/problems/distribute-repeating-integers/description/
        Map<Integer, Integer> valFreq = new HashMap<>();
        for (int val : nums) {
            valFreq.put(val, valFreq.getOrDefault(val, 0) + 1);
        }

        //array that will only hold the freqs of each unique val from nums[]
        int[] frequencies = valFreq.values().stream().mapToInt(freq -> freq).toArray();
        //convert the quantity[] to quantities list and also sorted in desc order
        List<Integer> quantities = Arrays
                .stream(quantity)
                .boxed()
                .sorted((a, b) -> b - a)
                .collect(Collectors.toCollection(ArrayList::new));

        //output
        boolean isDistributionPossible = distributeRepeatingIntegers_Backtracking_Helper(
                frequencies, quantities, 0);
        System.out.println("Disribute repeating inteegrs : " + isDistributionPossible);
    }

    private void maxNumberOfAchievableTransferRequest_Backtracking_Helper(
            int[][] requests, int[] buildingPeopleInAndOut, int reqIndex, int requestProcessedCount) {

        int reqLen = requests.length;

        //here, we reached the end of all the requests[][] given means we can't pick
        //any more request that means we will have to check if the
        //'net change in employee transfers is zero'
        if (reqIndex >= reqLen) {
            //here, check if all the buildings has 'net change in employee transfers is zero'
            //means after processing the request, total people moving in & out from the buildings
            //should have been balanced to 0, 0 will means total number of people now in buildings
            //are same after all the requests
            for (int peopleInBuilding : buildingPeopleInAndOut) {
                //if we found, any of the building has people in it (==> peopleInBuilding)
                //is not balanced (==> peopleInBuilding != 0) return, as we can't consider
                //these choices of request processing, we will have to backtrack with different
                //request[index] pick/don't pick choices
                if (peopleInBuilding != 0) {
                    return;
                }
            }

            //otherwise, if people in all buildings are balanced then we should
            //check how many request we processed to achive this balance
            //'net change in employee transfers is zero' as we need to MAXIMIZE
            //our request processed
            maxNumberOfAchievableTransferRequest_MaxRequestProcessed = Math.max(
                    maxNumberOfAchievableTransferRequest_MaxRequestProcessed,
                    requestProcessedCount);
            return;
        }

        //2 choices we can make
        //1. don't consider curr request @reqIndex and move to next index(==> reqIndex + 1)
        //and hence we didn't consider taking the curr request[index] so the requestProcessedCount
        //remains as it is
        maxNumberOfAchievableTransferRequest_Backtracking_Helper(
                requests, buildingPeopleInAndOut, reqIndex + 1, requestProcessedCount);

        //2. consider the curr request @reqIndex so now we need to adjust the
        //people moving out 'from' the building and moving 'to' the building
        //since people are leaving and coming to buildings they can be counted
        //as incoming and outgoing in buildingPeopleInAndOut[] where each
        //requests[reqIndex] = [from, to] both 'from' and 'to' are building indexes
        //for buildingPeopleInAndOut[] and buildingPeopleInAndOut[building] = value
        //this 'value' represents no of people moving in or out as +ve or -ve values
        //respectively
        int[] request = requests[reqIndex];
        int from = request[0];
        int to = request[1];

        //people moving out 'from' building is considered as people reduced from that
        //building
        buildingPeopleInAndOut[from]--;
        //people moving in 'to' building is considered as people increased in that
        //building
        buildingPeopleInAndOut[to]++;

        //move to next request index(==> reqIndex + 1) and since we considered this
        //'request' @reqIndex then 'requestProcessedCount' has to be increamented by 1
        maxNumberOfAchievableTransferRequest_Backtracking_Helper(
                requests, buildingPeopleInAndOut, reqIndex + 1, requestProcessedCount + 1);

        //typically backtracking, so we readjust the people count as they were before
        //considering this 'request'
        buildingPeopleInAndOut[from]++;
        buildingPeopleInAndOut[to]--;
    }

    private int maxNumberOfAchievableTransferRequest_MaxRequestProcessed;

    public void maxNumberOfAchievableTransferRequest_Backtracking(int n, int[][] requests) {
        //...............T: O((2 ^ R) * n)
        //where R denotes the total request we have, since in each recusion we have 2 choices
        //to make that is either to consider i-th request or not, so that makes O(2 ^ R)
        //In the base case we will need to iterate over all the 'n' buildings to check if it is
        //balanced as 'net change in employee transfers is zero' or not
        //...............S: O(n + R)
        //'n' is space considered for buildingPeopleInAndOut[]
        //'R' is the max height of the recursion tree that will stay in the recursion call stack
        //as base case is reqIndex >= reqLen so starting from reqIndex = 0 we can go upto reqLen == R
        //https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/description/
        maxNumberOfAchievableTransferRequest_MaxRequestProcessed = 0;
        int[] buildingPeopleInAndOut = new int[n];
        maxNumberOfAchievableTransferRequest_Backtracking_Helper(requests, buildingPeopleInAndOut, 0, 0);
        //output
        System.out.println("Max number of achievable transfer request : "
                + maxNumberOfAchievableTransferRequest_MaxRequestProcessed);
    }

    private int pathWithMaxGold_Backtracking_Helper(int[][] grid, int[][] dirs, int row, int col) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //return gold collected as 0, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        //return gold collected as 0, if there are no golds(grid[row][col] = 0)
        //in curr grid[][] mine of curr row & col
        if (grid[row][col] == 0) {
            return 0;
        }

        //need to maximize the golds collected from all the 4-dirs from curr row & col
        int maxGoldCollected = 0;

        //simulating that, we picked all the gold from curr mine at grid[row][col]
        int currGoldPicked = grid[row][col];
        //hence this mine at grid[row][col] is empty(grid[row][col] = 0)
        //this also prevents recursion to traverse back to same cell
        grid[row][col] = 0;

        //move in all 4-dirs from curr row & col
        for (int[] dir : dirs) {

            int newRow = row + dir[0];
            int newCol = col + dir[1];

            maxGoldCollected = Math.max(
                    maxGoldCollected,
                    //as we have picked all the gold at curr row & col in 'currGoldPicked'
                    //now from recursive calls we will check all the possible paths and
                    //also get the 'maxGoldCollected' from those recursive calls and should
                    //be added to 'currGoldPicked'
                    currGoldPicked + pathWithMaxGold_Backtracking_Helper(grid, dirs, newRow, newCol));

        }

        //puting back the 'currGoldPicked' from mine at curr grid[row][col] as we
        //have already processed one path to collect gold but there are other possibilties
        //of paths that could get us more gold collected so in order to try those
        //paths that could go via this grid[row][col], reset the gold mine with its
        //actual gold capacity value
        grid[row][col] = currGoldPicked;

        return maxGoldCollected;
    }

    public void pathWithMaxGold_Backtracking(int[][] grid) {
        //https://leetcode.com/problems/path-with-maximum-gold/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
                {-1, 0},
                {1, 0},
                {0, -1},
                {0, 1}
        };

        int maxGoldCollected = 0;

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {

                if (grid[row][col] != 0) {
                    maxGoldCollected = Math.max(
                            maxGoldCollected,
                            pathWithMaxGold_Backtracking_Helper(grid, dirs, row, col));
                }
            }
        }

        //output
        System.out.println("Path with max gold : " + maxGoldCollected);
    }

    public void braceExpansion_Backtracking(String str) {
        //https://leetcode.com/problems/brace-expansion/description/

        List<String> braceExpansionPermutations = new ArrayList<>();

        class Helper {

            //whats this method process
            //given a complex string like "{a,b}c{d,e}f"
            //break it into list of options where chars under brackets '{}'
            //provides multiple options individually like {a,b} ==> ["a", "b"]
            //whereas single char or continous set of chars(not under brackets)
            //are single option string like ["c"], ["f"]
            //so altogether we will process this as
            //options = [["a", b], ["c"], ["d", "e"], ["f"]]
            List<List<String>> preProcessStringAsAvailableOptions(String str) {

                int n = str.length();
                List<List<String>> options = new ArrayList<>();

                StringBuilder singleOption = new StringBuilder();

                int index = 0;
                while (index < n) {

                    //if a bracket starts, we need to take care of two things
                    if (str.charAt(index) == '{') {

                        //1. set of chars that are not part of any sub-options
                        //are the single option and they are one single string to
                        //be considered
                        //ex: str = {..}axxy{...}
                        //here, axxy is single option string but when we will add
                        //this in option?
                        //we will add this in options when there is a start of sub
                        //options '{}' that means once we see an opening bracket
                        //check before that if have any single option string then
                        //add in options list
                        //isEmpty() check why?
                        //because for ex: str = "{a,b,c}" is a valid string and
                        //also doesn't contains any single option string but we
                        //do have an opening bracket '{' but at this time single
                        //option string is empty only hence we need to check before
                        //adding
                        if (!singleOption.isEmpty()) {
                            options.add(Arrays.asList(singleOption.toString()));
                            singleOption.setLength(0);
                        }

                        //2. here we need to process the sub-options and create
                        //a separate list that holds all the chars of this sub-options
                        //as list of string
                        List<String> subOptions = new ArrayList<>();

                        //loop until we reach the closing bracket for the curr
                        //opening bracket
                        while (index < n && str.charAt(index) != '}') {

                            //the structure of sub-options in the given string
                            //is like "{a,b,c}" so here will create a list of
                            //strings ==> subOptions ==> ["a", "b", "c"] for
                            //that we only consider chars and not ','
                            if (Character.isAlphabetic(str.charAt(index))) {
                                subOptions.add(String.valueOf(str.charAt(index)));
                            }

                            //the loop will break when index is at '}' and for next
                            //iteration we need not to consider it, but that is
                            //already taken care with later index++ below
                            index++;
                        }

                        //if we have some chars in subOptions then only add this
                        //in main options list
                        if (!subOptions.isEmpty()) {
                            options.add(subOptions);
                        }

                    } else {
                        //here we will process the part of string that is a
                        //single option
                        //single option string are those which don't covered in
                        //'{}' brackets but instead it possibly starts after a
                        //closing bracket till it sees a next opening bracket
                        //or single option string doesn't exists at all
                        singleOption.append(str.charAt(index));
                    }

                    //this moves to next single option char and also skips the
                    // '}' bracket
                    index++;
                }

                //a final check, if there exist any singleOption string later in
                //the string str that we processed in above loop but could not
                //add as the loop ended, so just check here if singleOption string
                //is not empty
                if (!singleOption.isEmpty()) {
                    options.add(Arrays.asList(singleOption.toString()));
                    singleOption.setLength(0);
                }

                return options;
            }

            //backtracking helper
            void braceExpansionHelper(List<List<String>> options, int index, String currExpansion) {

                int n = options.size();

                if (index >= n) {
                    braceExpansionPermutations.add(currExpansion);
                    return;
                }

                //use every permutation of 'option' string into currExpansion
                for (String option : options.get(index)) {
                    braceExpansionHelper(options, index + 1, currExpansion + option);
                }
            }
        }

        Helper helper = new Helper();
        List<List<String>> options = helper.preProcessStringAsAvailableOptions(str);
        helper.braceExpansionHelper(options, 0, "");

        //as per question, all the permutations should be in sorted order
        Collections.sort(braceExpansionPermutations);

        //output
        System.out.println(braceExpansionPermutations);
    }

    public void pallindromePermutationsTwo_Backtracking(String str) {
        //https://leetcode.com/problems/palindrome-permutation/description/
        //https://leetcode.com/problems/palindrome-permutation-ii/description/
        //simple BRUTE FORCE to generate permutations and checking a valid
        //pallindrome permutation is straight forward but will give TLE
        //here, we will use some smartness

        Set<String> uniquePallindromePermutations = new HashSet<>();

        class Helper {

            boolean canGeneratePallindrome(String str, int[] freqs) {

                if ("".equals(str)) {
                    return false;
                }

                for (char chr : str.toCharArray()) {
                    freqs[chr - 'a']++;
                }

                int countCharWithOddFreq = 0;

                //in the given string str, there can only be either 0 or 1 char
                //that is occuring odd number of times
                //ex: str = "abcecba" char 'e' occurs only 1 time so it can be
                //placed in middle of the whole pallindrome string
                //similarly, ex: "abccba", there are no chars that is occuring
                //odd number of time, also notice all the remaining chars are
                //occuring equal and even number of times
                for (char chr = 'a'; chr <= 'z'; chr++) {

                    if (freqs[chr - 'a'] % 2 == 1) {
                        countCharWithOddFreq++;
                    }
                }

                //if there are more than 1 chars that are occuring odd number of
                //times then the pallidrome for that string can't be formed
                //ex: str = "abcefgcba", chr 'e', 'f', 'g' are 3 different chars
                //and all are occuring odd number of time hence using such chars
                //it is impossible to from any pallindrome(or its any pallindrome
                //permutations as well)
                return countCharWithOddFreq <= 1;
            }

            void pallindromePermutationsHelper(char[] halfStrChrArr, String middleOddChar, int index) {

                int n = halfStrChrArr.length;

                if (index >= n) {

                    //generated the first half permutation of the 'str' using
                    //half string
                    String halfStrPermutation = String.valueOf(halfStrChrArr);

                    //pallindrome = firstHalfPermutation
                    //+ (middle odd char, if exists else "")
                    //+ reverse(firstHalfPermutation)
                    String pallindromeStr = halfStrPermutation
                            + middleOddChar
                            + new StringBuilder(halfStrPermutation).reverse().toString();

                    uniquePallindromePermutations.add(pallindromeStr);

                    return;
                }

                for (int i = index; i < n; i++) {

                    //swap
                    char temp = halfStrChrArr[index];
                    halfStrChrArr[index] = halfStrChrArr[i];
                    halfStrChrArr[i] = temp;

                    pallindromePermutationsHelper(halfStrChrArr, middleOddChar, index + 1);

                    //swap back the chars to generate different permutations
                    temp = halfStrChrArr[index];
                    halfStrChrArr[index] = halfStrChrArr[i];
                    halfStrChrArr[i] = temp;
                }
            }

        }

        Helper helper = new Helper();

        int n = str.length();

        int[] freqs = new int[26];

        if (!helper.canGeneratePallindrome(str, freqs)) {
            System.out.println("Pallindrome permutations two : " + Collections.emptyList());
            //return Collections.emptyList();
            return;
        }

        //as we know, in any pallindrome there can be either 0 or 1 char with
        //odd freqs, firstly will find that otherwise default ==> '.'
        char charWithOddFreqs = '.';

        String halfStr = "";

        for (char chr = 'a'; chr <= 'z'; chr++) {

            //skip, if char 'chr' doesn't exist in given 'str'
            if (freqs[chr - 'a'] == 0) {
                continue;
            }

            //find that one char, occuring odd number of times
            //since this particular char will be occuring only 0 or 1 times
            //below for() will not consider it in 'halfStr'
            //as if chr occured 0 time then 0 / 2 = 0 also 1 / 2 = 0
            if (freqs[chr - 'a'] % 2 == 1) {
                charWithOddFreqs = chr;
            }

            //here we are using a smarter way of generating the
            //'pallindrome permutations', generate the half string, from the
            //given 'str'
            //ex: str = "abccba",
            //with BRUTE FORCE we would be generating the permutations of this
            //str using all the chars
            //some of them are pallindromic like "baccab", "cabbac"...others
            //BUT OBSERVE here,
            //each of the pallindrome permutations can be divided into 2 halfs
            //ex: str = "abccba" & char freqs[] = [a = 2, b = 2, c = 2]
            //take an ex of pallindrome permutaions = "baccab"
            //first half = "bac", second half = "cab"
            //pattern here is we only need to consider ALL CHARS of given
            //'str' BUT ONLY HALF OF THEIR FREQS and should generate
            //permutations from that half string while the other half is reverse
            //of the first half and total occurenecs will be same as given str
            //with the below for() loop, we are considring all the valid chars
            //in the given 'str' but forming the 'halfStr' by taking only half
            //of this char 'chr' occurences meaning
            //str = "abccba" & char freqs[] = [a = 2, b = 2, c = 2]
            //halfStr = a / 2 ==> 2 / 2 == 1 ==> halfStr = a
            //halfStr = b / 2 ==> 2 / 2 == 1 ==> halfStr = ab
            //halfStr = c / 2 ==> 2 / 2 == 1 ==> halfStr = abc
            for (int i = 0; i < freqs[chr - 'a'] / 2; i++) {
                halfStr += chr;
            }
        }

        helper.pallindromePermutationsHelper(
                //generate permutation for only half of the 'str' and use the
                //other half as reverse of first half
                halfStr.toCharArray(),
                //if there exist a char with odd freq just put char char in
                //middle otherwise empty string ""
                //ex: "abccba" no char with odd freq use middleOddChar as ""
                //ex: "abcecba", char 'e' with odd freq use middleOddChar as "e"
                charWithOddFreqs == '.' ? "" : String.valueOf(charWithOddFreqs),
                0);

        //output
        System.out.println("Pallindrome permutations two : " + uniquePallindromePermutations);
    }

    public void LRUCacheDesignImpl(List<String> operations, List<List<Integer>> inputs) {

        LRUCacheDesign lruObj = null;
        for (int i = 0; i < operations.size(); i++) {
            String operation = operations.get(i);
            switch (operation) {
                case "LRUCache":
                    int capacity = inputs.get(i).get(0);
                    lruObj = new LRUCacheDesign(capacity);
                    System.out.println("Object created:" + operation);
                    break;
                case "put":
                    int key = inputs.get(i).get(0);
                    int value = inputs.get(i).get(1);
                    lruObj.put(key, value);
                    System.out.println("Put: " + key + " " + value);
                    break;
                case "get":
                    key = inputs.get(i).get(0);
                    System.out.println("Get: " + lruObj.get(key));
                    break;
            }
        }
    }

    //MY AMAZON ONLINE ASSESSMENT
    public boolean robotRodeo(String command) {
        //https://leetcode.com/problems/robot-bounded-in-circle/
        //https://leetcode.com/problems/path-crossing/
        //initial state of robot
        int x = 0;
        int y = 0;
        int dir = 0; //0 = North, 1 = East, 2 = South, 3 = West (in clockwise direction of actual N-E-S-W dir)
        for (char move : command.toCharArray()) {

            if (move == 'R') {
                //for a given curr dir, R would be on +1 side in clockwise way
                //where %4 will bound our dir upto 4 actual dir(N-E-S-W dir)
                dir = (dir + 1) % 4;
            } else if (move == 'L') {
                //for a given curr dir, L would be on +3 side in clockwise way
                //where %4 will bound our dir upto 4 actual dir(N-E-S-W dir)
                dir = (dir + 3) % 4;
            } else {
                //now move = G
                if (dir == 0) {
                    //North and G, move robot to vertical up(or to north) from given (row,col)
                    y++;
                } else if (dir == 1) {
                    //East and G, move robot to horizontal right(or to east side) from given (row,col)
                    x++;
                } else if (dir == 2) {
                    //South and G, move robot to vertical down(or to south side) from given (row,col)
                    y--;
                } else { //dir == 3
                    //West and G, move robot to horizontal left(or to west side) from given (row,col)
                    x--;
                }
            }
        }

        //if the robot returned to same inital (row,col) = (0,0) after all moves in given command
        //that means there exists a cycle
        return dir != 0 || (x == 0 && y == 0);
    }

    public int swapsRequiredToSortArray(int[] arr) {

        //https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/
        int result = 0;
        Map<Integer, Integer> index = new HashMap<>();
        int[] sortedArr = arr.clone();

        for (int i = 0; i < arr.length; i++) {
            index.put(arr[i], i);
        }

        Arrays.sort(sortedArr);
        for (int i = 0; i < arr.length; i++) {

            if (arr[i] != sortedArr[i]) {
                result++;
                int init = arr[i];

                //swap
                swapIntArray(arr, i, index.get(sortedArr[i]));
                //adjust the indexes after swapping
                index.put(init, index.get(sortedArr[i]));
                index.put(sortedArr[i], i);
            }
        }

        return result;
    }

    public void checkBinaryNumberStreamIsDivisibleByN(int[] binaryStream, int N) {

        //explanation: https://www.geeksforgeeks.org/check-divisibility-binary-stream/
        //see method 2
        /*

         formula:
         if bit is 1 new decimal = 2 * prevDecimal + 1
         if bit is 0 new decimal = 2 * prevDecimal

         Ex:
         binaryStream = [1,0,1,0,1]
         prevDecimal = 0
         binaryFormed = ""
         i = 0
         bit = 1 -> binaryFormed.append(bit) = "1" == actualDecimal(binaryFormed) = 1
         if bit == 1: prevDecimal = (2 * prevDecimal) + 1
         ---> prevDecimal = 2 * 0 + 1 = 1

         i = 1
         bit = 0 -> binaryFormed.append(bit) = "10" == actualDecimal(binaryFormed) = 2
         if bit == 0: prevDecimal = (2 * prevDecimal)
         ---> prevDecimal = 2 * 1 = 2

         i = 2
         bit = 1 -> binaryFormed.append(bit) = "101" == actualDecimal(binaryFormed) = 5
         if bit == 1: prevDecimal = (2 * prevDecimal) + 1
         ---> prevDecimal = 2 * 2 + 1= 5

         so on...
         */
        int remainder = 0;
        int decimal = 0;
        StringBuilder sb = new StringBuilder(); //just for output purpose, not necessary to use
        for (int bit : binaryStream) {

            if (bit == 0) {
                remainder = (2 * remainder) % N;
                decimal = 2 * decimal;
            } else if (bit == 1) {
                remainder = (2 * remainder + 1) % N;
                decimal = 2 * decimal + 1;
            }

            sb.append(bit);
            if (remainder == 0) { //another way if(decimal % N) but TLE
                System.out.println("Binary formed: " + sb.toString() + " dec(" + decimal + ") is divisible by " + N);
            } else {
                System.out.println("Binary formed: " + sb.toString() + " dec(" + decimal + ") is not divisible by " + N);
            }
        }
    }

    private String convertNumberToWords_Helper(int n, String suff) {

        // Strings at index 0 is not used, it is to make array
        // indexing simple
        String one[] = {"", "one ", "two ", "three ", "four ",
                "five ", "six ", "seven ", "eight ",
                "nine ", "ten ", "eleven ", "twelve ",
                "thirteen ", "fourteen ", "fifteen ",
                "sixteen ", "seventeen ", "eighteen ",
                "nineteen "};

        // Strings at index 0 and 1 are not used, they is to
        // make array indexing simple
        String ten[] = {"", "", "twenty ", "thirty ", "forty ",
                "fifty ", "sixty ", "seventy ", "eighty ",
                "ninety "};

        String str = "";
        // if n is more than 19, divide it
        if (n > 19) {
            str += ten[n / 10] + one[n % 10];
        } else {
            str += one[n];
        }

        // if n is non-zero
        if (n != 0) {
            str += suff;
        }

        return str;
    }

    public void convertNumberToWords(long n) {

        //https://www.geeksforgeeks.org/program-to-convert-a-given-number-to-words-set-2/
        StringBuilder sb = new StringBuilder();

        // handles digits at ten millions and hundred
        // millions places (if any)
        sb.append(convertNumberToWords_Helper((int) (n / 1000_000_0) % 100, "crore "));

        // handles digits at hundred thousands and one
        // millions places (if any)
        sb.append(convertNumberToWords_Helper((int) ((n / 100_000) % 100), "lakh "));

        // handles digits at thousands and tens thousands
        // places (if any)
        sb.append(convertNumberToWords_Helper((int) ((n / 1000) % 100), "thousand "));

        // handles digit at hundreds places (if any)
        sb.append(convertNumberToWords_Helper((int) ((n / 100) % 10), "hundred "));

        if (n > 100 && n % 100 > 0) {
            sb.append("and ");
        }

        // handles digits at ones and tens places (if any)
        sb.append(convertNumberToWords_Helper((int) (n % 100), ""));

        //output
        System.out.println("In words: \n" + (sb.toString().equals("") ? "zero" : sb.toString()));
    }

    public void printPascalTriangle_SimpleAddition(int rows) {
        //https://leetcode.com/problems/pascals-triangle/
        //explanation: https://youtu.be/bR7mQgwQ_o8
        List<List<Integer>> triangle = new ArrayList<>();

        if (rows == 0) {
            return;
        }

        triangle.add(new ArrayList<>());
        triangle.get(0).add(1); //base

        for (int r = 1; r < rows; r++) {
            List<Integer> currRow = new ArrayList<>();
            List<Integer> prevRow = triangle.get(r - 1);

            currRow.add(1); //first 1 of the row
            for (int c = 1; c < r; c++) {

                currRow.add(prevRow.get(c - 1) + prevRow.get(c));
            }
            currRow.add(1); //last 1 of the row
            triangle.add(currRow);
        }

        //output
        System.out.println("Pascal tiangle: " + triangle);
    }

    public int printPascalTriangleValueAtGivenRowAndCol(int n, int r) {
        //........................T: O(r)
        //........................S: O(1)
        //explanation: https://youtu.be/bR7mQgwQ_o8
        /*
        Binomial coefficient
        nCr = n! / (r! * (n - r)!)

        but calculations above factorials will be time consuming tasks

        simplification
        ex: to calculate nCr of 7C2
        ==> 7! / (2! * (7 - 2)!)

        ==> 7! / (2! * 5!)

        ==> 7 * 5 * 6 * 4 * 3 * 2 * 1
            ------------------------------
            (2 * 1) * (5 * 4 * 3 * 2 * 1)

        ==> 7 * 6 * (5 * 4 * 3 * 2 * 1)
            -----------------------------
            (2 * 1) * (5 * 4 * 3 * 2 * 1)

        ==> cancle out 5! from numerator and denominator

        ==> 7 * 6
            ------
            2 * 1

        pattern here for simplification is:
        the product of numerator (n) should be calculated uptill length of (r)

        so as per code
        i = 0 to i < r
        numerator = (n - i), denominator = (i + 1)

        because we can write the above eqn as

        ==> 7 * 6
            ------
            1 * 2

        ==> (7 - 0)   (7 - 1)
            ------- * -------- and so on....
            (1 + 0)   (1 + 1)

        ==> (7 - i0)   (7 - i1)
            ------- * -------- and so on....
            (1 + i0)   (1 + i1)

        we will use this logic to find the pascal triangle's value at given
        row == n & col == r using (n)C(r)

         */

        int value = 1;
        for (int i = 0; i < r; i++) {
            value *= (n - i);
            value /= (1 + i);
        }
        //output
        return value;
    }

    public List<Integer> printNthRowOfPascalTriangle(int n) {
        //explanation: https://youtu.be/bR7mQgwQ_o8
        /*
        Binomial coefficient
        nCr = n! / (r! * (n - r)!)

        fact that nCn == nC0 is 1
        ==> n! / (0! * (n - 0)!)
        ==> n! / 1 * n! ==> cancel numerator/ denominator ==> 1

        Pascal tiangle:
        0: [[1]
        1: [1, 1]
        2: [1, 2, 1]
        3: [1, 3, 3, 1]
        4: [1, 4, 6, 4, 1]
        5: [1, 5, 10, 10, 5, 1]]

        for any given row we have (row + 1) elements in its row
        ex: row = 5: elements = (row + 1) == 6 = [1, 5, 10, 10, 5, 1]

        col = 0 to col < (row + 1)

        col0, col1, col2, col3, col4, col5
        [1, 5, 10, 10, 5, 1]

        from above fact: nCr
        here is n = 5
        if col = r = 0 ==> nC0 = 5C0 = 1
        if col = r = 1 ==> nC1 = 5C1 = 5
        if col = r = 2 ==> nC2 = 5C2 = 10
        if col = r = 3 ==> nC1 = 5C3 = 10
        if col = r = 4 ==> nC1 = 5C4 = 5
        if col = r = 5 ==> nC1 = 5C5 = 1

        pattern here is:

        [1, 5, 10, 10, 5, 1] ==> [5C0, 5C1, 5C2, 5C3, 5C4, 5C5] ==> [1, 5C1, 5C2, 5C3, 5C4, 1]

        see from 5C1 = 5 / 1
        ==> 5
            --
            1

        see from 5C2 = 5 * 4 / 2 * 1
        ==> 5    4
            -- * --
            1    2

        see from 5C3 = 5 * 4 * 3 / 3 * 2 * 1
        ==> 5    4    3
            -- * -- * --
            1    2    3

         */

        List<Integer> row = new ArrayList<>();
        //as nC0 is always 1
        row.add(1);

        int value = 1;
        for (int col = 0; col < n; col++) {
            value *= (n - col);
            value /= (1 + col);
            row.add(value);
        }
        return row;
    }

    public void printPascalTriangle(int n) {
        //https://leetcode.com/problems/pascals-triangle/
        //https://www.geeksforgeeks.org/pascal-triangle/
        //explanation: https://youtu.be/bR7mQgwQ_o8
        List<List<Integer>> pascalTriangle = new ArrayList<>();
        //n = 1-based
        if (n == 0) {
            return;
        }

        for (int row = 0; row < n; row++) {
            pascalTriangle.add(printNthRowOfPascalTriangle(row));
        }

        //output
        System.out.println("Pascal tiangle: " + pascalTriangle);
    }

    private boolean findCelebrityInNPepole_knows(int a, int b) {
        //if i knows j then its 1 else 0
        //for N * N people matrix
        int[][] whoKnowsWhom = {
                {0, 0, 1, 0},
                {0, 0, 1, 0},
                {0, 0, 0, 0},
                {0, 0, 1, 0}}; //SHOULD BE GLOBAL
        return whoKnowsWhom[a][b] == 1;
    }

    public int findCelebrityInNPepole(int N) {
        //......................T: O(N * N)
        //......................S: O(N), indegree[]
        //https://leetcode.com/problems/find-the-celebrity/description/
        //https://www.geeksforgeeks.org/the-celebrity-problem/
        int[] indegree = new int[N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (findCelebrityInNPepole_knows(i, j)) {
                    indegree[j]++;
                    indegree[i]--;
                }
            }
        }

        for (int i = 0; i < N; i++) {
            if (indegree[i] == N - 1) {
                return i;
            }
        }
        return -1;
    }

    public int findCelebrityInNPepole2(int N) {
        //......................T: O(N)
        //......................S: O(1)
        //https://leetcode.com/problems/find-the-celebrity/description/
        //https://www.geeksforgeeks.org/the-celebrity-problem/
        //OPTIMISED, TWO POINTER APPROACH
        int personA = 0;
        int personB = N - 1;

        //until personB and personA becomes equal
        while (personB > personA) {

            if (findCelebrityInNPepole_knows(personA, personB)) {
                personA++;
            } else {
                personB--;
            }
        }

        //above loop ends when personA == personB & considered to be a
        //candidate for celebrity
        int celebrityCandiate = personA;

        for (int person = 0; person < N; person++) {
            // If any person doesn't
            // know 'celebrityCandiate' or 'celebrityCandiate' doesn't
            // know any person, return -1
            if (person != celebrityCandiate
                    //if celebrity know any person then he can't be celebrity
                    && (findCelebrityInNPepole_knows(celebrityCandiate, person)
                    //if any person doesn't know celebrity then he can't be celebrity
                    || !findCelebrityInNPepole_knows(person, celebrityCandiate))) {

                return -1;
            }
        }

        return celebrityCandiate;
    }

    private int maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(int currX, int currY,
                                                                       int currDir, int dist, Set<String> obstacles) {

        //for col dir can either be 0 = N OR 2 = S
        if (currDir == 0) { //y + dist
            for (int i = 0; i < dist; i++) {
                currY++;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step back, and return as we can't move further
                    currY--;
                    return currY;
                }
            }
        } else { //y - dist
            for (int i = 0; i < dist; i++) {
                currY--;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step ahead, and return as we can't move further
                    currY++;
                    return currY;
                }
            }
        }
        return currY;
    }

    private int maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(int currX, int currY,
                                                                       int currDir, int dist, Set<String> obstacles) {

        //for row dir can either be 1 = E OR 3 = W
        if (currDir == 1) { //x + dist
            for (int i = 0; i < dist; i++) {
                currX++;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step back, and return as we can't move further
                    currX--;
                    return currX;
                }
            }
        } else { //x - dist
            for (int i = 0; i < dist; i++) {
                currX--;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step ahead, and return as we can't move further
                    currX++;
                    return currX;
                }
            }
        }
        return currX;
    }

    public void maximumDistanceCoveredInRobotWalkingSimulation(int[] commands, int[][] obstacles) {

        //https://leetcode.com/problems/walking-robot-simulation/
        Set<String> set = new HashSet<>();
        for (int[] obstacle : obstacles) {
            set.add(obstacle[0] + "-" + obstacle[1]);
        }

        //max distance covered in commands
        int maxDistCoveredFromOrigin = 0;

        //initial position
        int x = 0;
        int y = 0;

        //initial dir
        int dir = 0; // 0 = N, 1 = E, 2 = S, 3 = W

        for (int move : commands) {

            if (move == -1) { // -1 == TURN RIGHT
                dir = (dir + 1) % 4;
            } else if (move == -2) { // -2 == TURN LEFT
                dir = (dir + 3) % 4;
            } else { // MAKE STEPS AHEAD, BUT KEEP CHECK ON OBSTACLES
                if (dir == 0) { // NORTH col++
                    y = maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(x, y, dir, move, set);
                } else if (dir == 1) { // EAST row++
                    x = maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(x, y, dir, move, set);
                } else if (dir == 2) { // SOUTH col--
                    y = maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(x, y, dir, move, set);
                } else { // WEST row--
                    x = maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(x, y, dir, move, set);
                }

                //calculate distance
                //robot's curr position(row,col) is the farthest then update maxDistCoveredFromOrigin
                maxDistCoveredFromOrigin = Math.max(maxDistCoveredFromOrigin,
                        (x * x + y * y)); //x^2 + col^2
            }
        }

        //output
        System.out.println("Max distance covered by robot from origin : " + maxDistCoveredFromOrigin);
    }

    public void brokenCalculatorMakeXEqualToY(int x, int y) {

        //............................T: O(LogY)
        //https://leetcode.com/problems/broken-calculator/
        //explanation: https://leetcode.com/problems/broken-calculator/solution/
        //Work backwards
        int res = 0;
        while (y > x) {
            res++;
            if (y % 2 == 1) {
                y++;
            } else {
                y /= 2;
            }
        }

        //output
        System.out.println("Min operations on X make equal to Y: " + (res + x - y));
    }

    public boolean rectangleOverlappingAndArea(int[] rec1, int[] rec2) {
        //explanation: https://youtu.be/zGv3hOORxh0
        //https://leetcode.com/problems/rectangle-overlap/
        //https://leetcode.com/problems/rectangle-area/
        //input format:
        //rec[4] = bottm-left coordinate(row, col) = rec[0], rec[1] & top-right coordinate(row, col) = rec[2], rec[3]

        /*
         ::::::::::R1-----------
         ::::::::::::|         |
         ::::::::::::|         |
         :::::R2----------     |
         :::::::|    |=O=|     |
         :::::::|    -----------
         :::::::|        |
         :::::::|        |
         ::::::::---------
         */
        //overlapped rectangle's bottom-left(row, col)
        int bottomLeftX = Math.max(rec1[0], rec2[0]);
        int bottomLeftY = Math.max(rec1[1], rec2[1]);

        //overlapped rectangle's top-right(row, col)
        int topRightX = Math.min(rec1[2], rec2[2]);
        int topRightY = Math.max(rec1[3], rec2[3]);

        int lengthX = topRightX - bottomLeftX;
        int lengthY = topRightY - bottomLeftY;

        //if rec1 & rec2 are not overlapping case
        if (lengthX < 0 || lengthY < 0) {
            return false;
        }
        //given 2 rectangles, if they are connected by any
        //one corner or edge they are not overlapped.
        //area = length * bredth
        int area = lengthX * lengthY;
        System.out.println("Area of overlapped rectangle: " + area);
        return area > 0;
    }

    public void addTwoNumsWithoutPlusOrMinus(int a, int b) {
        //https://leetcode.com/problems/sum-of-two-integers
        //explanation: https://youtu.be/gIlZOcZHtlQ
        //^ = XOR
        int sum = a ^ b;
        //& = AND
        int carry = a & b;
        while (carry != 0) {
            carry = carry << 1;
            int tempSum = sum ^ carry;
            int tempCarry = sum & carry;
            sum = tempSum;
            carry = tempCarry;
        }
        //output
        System.out.println("Adding two nums: " + a + " " + b + " without + or - : " + sum);
    }

    public void threeConsecutiveNumberThatSumsToGivenNumber(int num) {
        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/
        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/discuss/2164778/the-three-integers-will-be-in-arithmetic-progression
        if (num % 3 == 0) {
            int first = (num / 3) - 1;
            int second = (num / 3);
            int third = (num / 3) + 1;
            System.out.println("Three consecutive number that sums to " + num + " : "
                    + first + ", " + second + ", " + third);
            return;
        }
        System.out.println("Three consecutive number that sums to " + num + " : Not possible");
    }

    public void detectSquares(List<int[]> points, List<int[]> queryPoints) {
        //Input is little bit modified from the actual question
        //https://leetcode.com/problems/detect-squares/
        //explanation: https://youtu.be/bahebearrDc
        //<"row,col", freq>
        Map<String, Integer> pointMap = new HashMap<>();
        for (int[] point : points) {
            int x = point[0];
            int y = point[1];
            String key = x + "," + y;
            pointMap.put(key, pointMap.getOrDefault(key, 0) + 1);
        }

        for (int[] query : queryPoints) {
            int qX = query[0];
            int qY = query[1];
            int sqauresDetectedFromCurrQueryPoint = 0;
            for (int[] point : points) {
                int x = point[0];
                int y = point[1];

                //if curr point[row, col] is not forming a diagonal with query[qX, qY]
                // or any of the curr row, col is same as qX, qY then they can't form diagnal
                //with query[qX, qY]
                boolean isDiagonal = Math.abs(x - qX) == Math.abs(y - qY);
                if (!isDiagonal || x == qX || y == qY) {
                    continue;
                }

                //otherwise now here find two coord points
                //top-left such a way that its coord [row, qY]
                //bottom-right such a way that its coord [qX, col]
                //if they exists in out pointMap in some freq that much freq
                //will form sqaures
                String topLeftKey = x + "," + qY;
                String bottomRightKey = qX + "," + y;

                sqauresDetectedFromCurrQueryPoint
                        += pointMap.getOrDefault(topLeftKey, 0) * pointMap.getOrDefault(bottomRightKey, 0);
            }
            System.out.println("Squares detected from query[qX, qY]: [" + qX + ", " + qY + "] : "
                    + sqauresDetectedFromCurrQueryPoint);
        }
    }

    public void serverAllocationToTasks(int[] servers, int[] tasks) {
        //https://leetcode.com/problems/process-tasks-using-servers
        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
        class Server {

            int index;
            int weight;
            //taskArrivalTime + taskProcessingTime
            int bookedTime;

            public Server(int index, int weight) {
                this.index = index;
                this.weight = weight;
            }
        }

        int serverLen = servers.length;
        int taskLen = tasks.length;

        int[] serverIdxAllotedPerTask = new int[taskLen];

        PriorityQueue<Server> freeServer = new PriorityQueue<>(
                //choose server with lowest weight, if weights are same
                //choose server with lowest index value
                (s1, s2) -> s1.weight == s2.weight
                        ? s1.index - s2.index
                        : s1.weight - s2.weight
        );

        PriorityQueue<Server> busyServer = new PriorityQueue<>(
                //server's booked time(booked time == taskArrivalTime + taskProcessiingTime) are same
                (s1, s2) -> s1.bookedTime == s2.bookedTime
                        //choose server with lowest weight, if weights are same
                        //choose server with lowest index value
                        ? (s1.weight == s2.weight
                        ? s1.index - s2.index
                        : s1.weight - s2.weight)
                        //if booked time was not same choose the lowest bookedtime
                        //(i.e whoose task will finish early)
                        : s1.bookedTime - s2.bookedTime
        );

        for (int idx = 0; idx < serverLen; idx++) {
            freeServer.add(new Server(idx, servers[idx]));
        }

        for (int time = 0; time < taskLen; time++) {

            int processTime = tasks[time];

            //at any time 'time' if we have some busy servers that can finish their task
            //before this 'time' that means it will get free by time 'time' comes.
            //add it back to free server heap, so that we can utilize it later
            while (!busyServer.isEmpty() && busyServer.peek().bookedTime <= time) {
                freeServer.add(busyServer.poll());
            }

            if (freeServer.isEmpty()) {
                //if there are no free servers, we have to use the most optimal
                //busy server (i.e, either that currBusyServer has lowest bookedTime
                //and if bookedTime are same then it should have
                //lowest weight and if weights are same then it should have lowest index)
                //purpose of taking the optimal busy server is, it will finish early
                //and when it will finish, we want to assign curr processTime to it.
                //that's why (currBusyServer.bookedTime += processTime) this simulates
                //this curr task[time] will be immediately be assigned to it.
                Server currBusyServer = busyServer.poll();
                currBusyServer.bookedTime += processTime;
                //add in our currBusyServer back to all busy servers
                busyServer.add(currBusyServer);
                //we need to tell that this curr task[time] is assigned
                //to which server(based on its index), so task at time 'time' is assigned
                //currBusyServer.index server
                serverIdxAllotedPerTask[time] = currBusyServer.index;
                continue;
            }

            //if we have free servers available, take the optimal currFreeServer
            //book this server's bookedTime upto total time of time + processTime
            //since we have used one free server that means it is busy now
            Server currFreeServer = freeServer.poll();
            currFreeServer.bookedTime = time + processTime;
            //so move our currFreeServer to busy server
            busyServer.add(currFreeServer);
            //as our result we need to tell which curr task[time] is assigned
            //to which server(based on its index), so task at time 'time' is assigned
            //currFreeServer.index server
            serverIdxAllotedPerTask[time] = currFreeServer.index;
        }
        //output:
        for (int i = 0; i < taskLen; i++) {
            System.out.println("For task: " + tasks[i] + " alloted server with index: " + serverIdxAllotedPerTask[i]);
        }
    }

    public void serversThatHandledMostRequests(int k, int[] arrival, int[] loads) {
        //https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/
        //based on serverAllocationToTasks()
        class Server {

            int id;
            int bookedTime;

            public Server(int id) {
                this.id = id;
            }

        }

        List<Integer> serverIdHandledMostRequest = new ArrayList<>();

        int nRequest = arrival.length;
        int[] serverUsage = new int[k];

        TreeSet<Integer> freeServerId = new TreeSet<>();
        for (int id = 0; id < k; id++) {
            freeServerId.add(id);
        }

        PriorityQueue<Server> busyServer = new PriorityQueue<>((a, b) -> a.bookedTime - b.bookedTime);

        for (int i = 0; i < nRequest; i++) {

            int time = arrival[i];
            int taskLoad = loads[i];

            while (!busyServer.isEmpty() && busyServer.peek().bookedTime <= time) {
                freeServerId.add(busyServer.poll().id);
            }

            //since a single can only handle 1 request at a time so the request
            //will get DROPPED if there is no free server to handle it.
            if (freeServerId.isEmpty()) {
                continue;
            }

            //acc to question the the curr ith request will be assigned to
            //i % k th server if in case, that is not available we will pick
            //(i + 1) % k th server and so on if that is also not available
            //ceiling(ID) will give the value greater than or equal to given ID
            Integer nextAvailableFreeServerId = freeServerId.ceiling(i % k);
            //incase the 'next available free server' is not available ( == null)
            //that means will wrap around to the get first available free server
            //thats why first()
            nextAvailableFreeServerId = nextAvailableFreeServerId == null
                    ? freeServerId.first() : nextAvailableFreeServerId;

            //each time we get the free server id that means we make use of it
            //for our current incoming request
            serverUsage[nextAvailableFreeServerId]++;

            //now this server with nextAvailableFreeServerId is going to be busy
            //with the curr ith request
            Server createBusyServer = new Server(nextAvailableFreeServerId);
            createBusyServer.bookedTime = time + taskLoad;

            //now a free server is made busy we must remove this nextAvailableFreeServerId
            //from freeServerId
            busyServer.add(createBusyServer);
            freeServerId.remove(nextAvailableFreeServerId);
        }

        int maxUsage = 0;
        for (int usage : serverUsage) {
            maxUsage = Math.max(maxUsage, usage);
        }

        //get all those server ids that have exactly maxUasge
        for (int id = 0; id < k; id++) {
            if (maxUsage == serverUsage[id]) {
                serverIdHandledMostRequest.add(id);
            }
        }
        //output
        System.out.println("Server Ids that handled most request: " + serverIdHandledMostRequest);
    }

    public void meetingRoomsThree(int rooms, int[][] meetings) {
        //https://leetcode.com/problems/meeting-rooms-iii/
        //based on serverAllocationToTasks()
        class Room {

            int roomId;
            int endTime;
            int usage;

            public Room(int roomId) {
                this.roomId = roomId;
            }

        }
//if just one room is given then that room is the only busiest one
        if (rooms == 1) {
            System.out.println("Busiest room no. that handled most meetings: 0");
            return;
        }

        int m = meetings.length;

        //sort the meetings array by their start times
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);

        //a free room heap, room with min room id at top
        PriorityQueue<Room> freeRooms = new PriorityQueue<>(
                (a, b) -> a.roomId - b.roomId);

        //creating all free rooms with their id
        for (int id = 0; id < rooms; id++) {
            freeRooms.add(new Room(id));
        }

        //a busy room heap
        PriorityQueue<Room> busyRooms = new PriorityQueue<>(
                //if endTimes are same, sort by smaller roomId
                //else sort by smaller endTime
                (a, b) -> a.endTime == b.endTime
                        ? a.roomId - b.roomId
                        : a.endTime - b.endTime);

        for (int i = 0; i < m; i++) {

            int startTime = meetings[i][0];
            int endTime = meetings[i][1];

            //if any previously occupied room's endTime is samller than or equal
            //to curr meetings startTime that means, this busy room will get free
            //for the curr meeting so put this busy room back to freeRooms
            while (!busyRooms.isEmpty() && busyRooms.peek().endTime <= startTime) {
                freeRooms.add(busyRooms.poll());
            }

            //if none of the occupied rooms is free
            if (freeRooms.isEmpty()) {
                //get the busy room with smaller endTime or smaller roomId
                Room currBusyRoom = busyRooms.poll();
                //calculate the delay time between the curr meeting's startTime
                //and curr busy room's endTime, why?
                //beacuse the busyRooms heap is sorting the meetings that is going
                //to end soon (min heap endTime) (in other words, a room that will
                //get free soon) but still how much time is still required for it
                //to be free, that is delay time and due to this our curr meeting
                //will get delayed by (delayedTimeForCurrMeeting + endTime) time
                int delayedTimeForCurrMeeting = currBusyRoom.endTime - startTime;
                currBusyRoom.endTime = delayedTimeForCurrMeeting + endTime;
                //since we assined the curr meeting to this busy room but delayed
                //but we still used this room, so increase the usage count
                currBusyRoom.usage++;
                //and put it back in the busyRooms
                busyRooms.add(currBusyRoom);
                continue;
            }

            //if we have some free rooms, get the room with smaller roomId
            //set the endTime for this room that is our curr meeting's endtTime
            //and also update its usage count since it is being used here
            //and put is back in busyRooms
            Room currFreeRoom = freeRooms.poll();
            currFreeRoom.endTime = endTime;
            currFreeRoom.usage++;
            busyRooms.add(currFreeRoom);
        }

        List<Room> allRooms = new ArrayList<>();
        allRooms.addAll(freeRooms);
        allRooms.addAll(busyRooms);
        //sort all the rooms by max usage if usage are same get the smaller id
        //of the max usage
        Collections.sort(allRooms, (a, b) -> a.usage == b.usage
                ? a.roomId - b.roomId
                : b.usage - a.usage);

        //output
        System.out.println("Busiest room no. that handled most meetings: " + allRooms.get(0).roomId);
    }

    public void maxPatientTreatedInGivenInAnyNRoom(int[][] patients, int totalRooms) {
        //https://leetcode.com/problems/process-tasks-using-servers
        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
        //approach simmilar to serverAllocationToTasks() & meetingRoomsThree()
        class Room {

            int roomNo;
            int patientTreated;
            int bookedTime;

            public Room(int roomNo) {
                this.roomNo = roomNo;
            }
        }

        int maxPatientTreated = 0;
        int roomNoOfMaxpatientTreated = -1;

        PriorityQueue<Room> filledRoomMinHeap = new PriorityQueue<>(
                (r1, r2) -> r1.bookedTime - r2.bookedTime);
        PriorityQueue<Room> freeRoomMinHeap = new PriorityQueue<>(
                (r1, r2) -> r1.roomNo - r2.roomNo);

        for (int roomNo = 1; roomNo <= totalRooms; roomNo++) {
            freeRoomMinHeap.add(new Room(roomNo));
        }

        for (int[] patient : patients) {

            int entry = patient[0];
            int duration = patient[1];

            while (!filledRoomMinHeap.isEmpty() && filledRoomMinHeap.peek().bookedTime < entry) {
                freeRoomMinHeap.add(filledRoomMinHeap.poll());
            }

            if (freeRoomMinHeap.isEmpty()) {
                continue;
            }

            Room currFreeRoom = freeRoomMinHeap.poll();
            currFreeRoom.patientTreated++;
            currFreeRoom.bookedTime = entry + duration;

            filledRoomMinHeap.add(currFreeRoom);

            if (currFreeRoom.patientTreated > maxPatientTreated) {
                maxPatientTreated = currFreeRoom.patientTreated;
                roomNoOfMaxpatientTreated = currFreeRoom.roomNo;
            }
        }
        //output
        System.out.println("Room no in which max patient treated : "
                + roomNoOfMaxpatientTreated + " max patient : " + maxPatientTreated);

    }

    class SkylineProblemBuildingCoord {

        int x;
        int height;

        public SkylineProblemBuildingCoord(int x, int height) {
            this.x = x;
            this.height = height;
        }

    }

    private List<SkylineProblemBuildingCoord> skylineProblem_BreakBuildingInCoords(
            int[][] buildings) {

        List<SkylineProblemBuildingCoord> coords = new ArrayList<>();
        for (int[] building : buildings) {

            int start = building[0];
            int end = building[1];
            int height = building[2];

            //all start points have height -ve
            coords.add(new SkylineProblemBuildingCoord(start, -height));

            //all end points have height +ve
            coords.add(new SkylineProblemBuildingCoord(end, height));
        }

        Collections.sort(coords, (c1, c2)
                -> c1.x == c2.x
                //if two buildiings have same base x-axis
                //sort the buildings in the incr order of heights
                //as we have added heights for 'start' x-axis as -ve value
                //and 'end' x-axis as +ve value, this will help here, how?
                //ex: consider c1.height = -5 and c2.height as -1 so
                //in sorted form -5 < -1 but if we see |height| ==> 5 > 1
                //meaning building with height 5 will overshadow building
                //with height 1 when both of them have same x-axis
                //this overshadowing is required for this question
                ? c1.height - c2.height
                //if two buildings have different x-axis, sort in incr
                //order of x-axis
                : c1.x - c2.x);
        return coords;
    }

    public void skylineProblem(int[][] buildings) {
        //https://leetcode.com/problems/the-skyline-problem/
        //https://leetcode.com/problems/the-skyline-problem/discuss/2257654/With-Algorithm-Java-Solution-O(NlogN)
        //explanation: https://youtu.be/GSBLe8cKu0s
        List<List<Integer>> skylinePoints = new ArrayList<>();
        List<SkylineProblemBuildingCoord> coords = skylineProblem_BreakBuildingInCoords(buildings);

        PriorityQueue<Integer> maxHeapHeights = new PriorityQueue<>(Collections.reverseOrder());
        maxHeapHeights.add(0); // default building height

        int prevMaxHeight = 0;

        for (SkylineProblemBuildingCoord coord : coords) {
            //System.out.println(coord.row + " " + coord.height + " " + maxHeapHeights.peek());
            //if curr height is -ve that means its a start point
            //so put that height in maxHeap heights as original == abs(height)
            if (coord.height < 0) {
                //height of building start point which we made -ve
                maxHeapHeights.add(Math.abs(coord.height));
            } else {
                //removing object from PriorityQueue
                //takes O(N) time as it search for the object first
                //if the height is here that means its a end point
                //any time we reach the end point we will remove the height
                //associated with this end point
                maxHeapHeights.remove(coord.height);
            }
            //after adding or removing the heights from maxHeap heights
            //we will have a new max height
            int currMaxHeight = maxHeapHeights.peek();

            if (currMaxHeight == prevMaxHeight) {
                continue;
            }

            skylinePoints.add(Arrays.asList(coord.x, currMaxHeight));
            prevMaxHeight = currMaxHeight;
        }
        //output;
        System.out.println("Skyline coordinates of the given buildings: " + skylinePoints);
    }

    public void skylineProblem_TreeMap(int[][] buildings) {
        //..........................T: O(LogN), as treemap supports all operations in LogN time
        //OPTIMIZED much faster as compared to above priority queue approach,
        //as priority queue remove operation is O(N) time
        //https://leetcode.com/problems/the-skyline-problem/
        //https://leetcode.com/problems/the-skyline-problem/discuss/2257654/With-Algorithm-Java-Solution-O(NlogN)
        //explanation: https://youtu.be/GSBLe8cKu0s
        List<List<Integer>> skylinePoints = new ArrayList<>();
        List<SkylineProblemBuildingCoord> coords = skylineProblem_BreakBuildingInCoords(buildings);

        //<height, freq> = will store keys in maxHeap way, that means max heights on root
        //freq is required because there may be multiple buildings with same height
        TreeMap<Integer, Integer> maxHeapHeights = new TreeMap<>(Collections.reverseOrder());
        maxHeapHeights.put(0, 1); // default building height and its freq

        int prevMaxHeight = 0;

        for (SkylineProblemBuildingCoord coord : coords) {
            //System.out.println(coord.row + " " + coord.height + " " + maxHeapHeights.firstKey());
            //if curr height is -ve that means its a start point
            //so put that height in maxHeap heights as original == abs(height)
            if (coord.height < 0) {
                //height of building start point which we made -ve
                int startHeight = Math.abs(coord.height);
                //each time we see same height just increase freq if already exist
                maxHeapHeights.put(startHeight, maxHeapHeights.getOrDefault(startHeight, 0) + 1);
            } else {
                //if the height is here that means its a end point
                //any time we reach the end point we will remove the height
                //associated with this end point
                maxHeapHeights.put(coord.height, maxHeapHeights.getOrDefault(coord.height, 0) - 1);
                if (maxHeapHeights.get(coord.height) <= 0) {
                    maxHeapHeights.remove(coord.height);
                }
            }
            //after adding or removing the heights to maxHeapHeights
            //we will have a new max height
            int currMaxHeight = maxHeapHeights.firstKey();

            if (currMaxHeight == prevMaxHeight) {
                continue;
            }

            skylinePoints.add(Arrays.asList(coord.x, currMaxHeight));
            prevMaxHeight = currMaxHeight;
        }
        //output;
        System.out.println("Skyline coordinates of the given buildings: " + skylinePoints);
    }

    public void minAngleBetweeHourAndMinuteHands(int hour, int min) {
        //https://leetcode.com/problems/angle-between-hands-of-a-clock/
        /*
         In 12 hour, hour hand make 360deg
         12hr = 360deg
         1hr = 360/12deg = 30deg
         1hr = 60min
         60min = 30deg
         1min = 30/60deg = 0.5deg
         ..........
         To complete 1hr, min hand makes 360deg
         1hr = 60min = 360deg
         1min = 360/60deg = 6deg
         */

        double hourAngle = (30 * hour) + (0.5 * min);
        double minuteAngle = (0 * hour) + (6 * min);
        double angle = Math.abs(hourAngle - minuteAngle);
        double minAngle = angle < 180 ? angle : 360.0 - angle;
        //output
        System.out.println("Min angle between hour and min hands: " + minAngle);

    }

    class ColorNumber {

        String color;
        int number;

        public ColorNumber(String color, int number) {
            this.color = color;
            this.number = number;
        }
    }

    public boolean cardOf12_Helper(List<ColorNumber> colorNumbers) {
        Map<String, List<Integer>> allNumbersOfSameCardMap = new HashMap<>();

        for (ColorNumber colorNumber : colorNumbers) {

            String color = colorNumber.color;
            int cardNum = colorNumber.number;
            allNumbersOfSameCardMap.putIfAbsent(color, new ArrayList<>());
            allNumbersOfSameCardMap.get(color).add(cardNum);
        }

        for (String color : allNumbersOfSameCardMap.keySet()) {
            if (allNumbersOfSameCardMap.get(color).size() % 3 != 0) {
                return false;
            }
            Collections.sort(allNumbersOfSameCardMap.get(color));
        }

        for (String color : allNumbersOfSameCardMap.keySet()) {
            List<Integer> cards = allNumbersOfSameCardMap.get(color);
            for (int i = 0; i < cards.size(); i += 3) {
                int cardNum1 = cards.get(i);
                int cardNum2 = cards.get(i + 1);
                int cardNum3 = cards.get(i + 2);

                //either 3 cards that picked up
                //1. of same num i.e, 1,1,1
                //OR 2. are consecutive (1,2,3)
                //cNum1 + 1 == cNum2 ==> 1 + 1 == 2 && cNum1 + 2 == cNum3 ==> 1 + 2 == 3
                boolean hasPassed = (cardNum1 == cardNum2 && cardNum2 == cardNum3)
                        || (cardNum1 + 1 == cardNum2 && cardNum1 + 2 == cardNum3);
                if (!hasPassed) {
                    return false;
                }
            }
        }
        return true;
    }

    public void cardOf12() {
        //https://leetcode.com/discuss/interview-experience/2279548/Google-or-Phone-Screen-or-Question-or-India
        //generating input to the question here
        List<ColorNumber> colorNumbers = Arrays.asList(
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4)
        );

        System.out.println("3 group of cards possible from given 12 cards: "
                + cardOf12_Helper(colorNumbers));

        colorNumbers = Arrays.asList(
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 2),
                new ColorNumber("RED", 2),
                new ColorNumber("RED", 2),
                new ColorNumber("BLUE", 1),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 3),
                new ColorNumber("GREEN", 5),
                new ColorNumber("GREEN", 5),
                new ColorNumber("GREEN", 5)
        );

        System.out.println("3 group of cards possible from given 12 cards: "
                + cardOf12_Helper(colorNumbers));
    }

    public void implementIncreamentalStack() {
        //explanation: https://youtu.be/L8tY9gSfHz4
        ImplementIncreamentalStack stack = new ImplementIncreamentalStack();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.print();
        System.out.println("POP: " + stack.pop());
        System.out.println("PEEK: " + stack.peek());
        stack.print();
        stack.increament(2, 10);
        stack.push(5);
        stack.push(6);
        stack.push(7);
        stack.increament(5, 100);
        stack.print();
        while (!stack.isEmpty()) {
            System.out.println("POP: " + stack.pop());
        }
        stack.print();
    }

    public void minPathCostRobotMovingStartToHomePos(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {
        //https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/
        int minPathCost = 0;

        int startRow = startPos[0];
        int startCol = startPos[1];

        int destRow = homePos[0];
        int destCol = homePos[1];

        int minRowFrom = Math.min(startRow, destRow);
        int maxRowTo = Math.max(startRow, destRow);

        for (int i = minRowFrom + 1; i < maxRowTo; i++) {
            minPathCost += rowCosts[i];
        }

        int minColFrom = Math.min(startCol, destCol);
        int maxColTo = Math.max(startCol, destCol);

        for (int i = minColFrom + 1; i < maxColTo; i++) {
            minPathCost += colCosts[i];
        }

        if (startRow != destRow) {
            minPathCost += rowCosts[destRow];
        }

        if (startCol != destCol) {
            minPathCost += colCosts[destCol];
        }

        //output
        System.out.println("Min path cost for robot moving from startPos to homePos: " + minPathCost);
    }

    private boolean kThSmallestNumberInMultiplicationTable_Enough(int x, int m, int n, int k) {
        int count = 0;
        for (int i = 1; i <= m; i++) {
            count += Math.min(x / i, n);
        }
        return count >= k;
    }

    public void kThSmallestNumberInMultiplicationTable(int m, int n, int k) {
        //https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/
        int start = 1;
        int end = m * n;
        while (end > start) {
            int mid = start + (end - start) / 2;
            if (kThSmallestNumberInMultiplicationTable_Enough(mid, m, n, k)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        System.out.println("kTh smallest number in multiplication table: " + start);
    }

    public int maxLineToRepresentLineChart(int[][] points) {
        //https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/
        //https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/
        int n = points.length;
        int X = 0;
        int Y = 1;
        if (n == 1) {
            return 0;
        }
        //sort the points[] on X axis
        Arrays.sort(points, (a, b) -> a[X] - b[X]);
        int lines = 1;
        int lastDy = points[1][Y] - points[0][Y];
        int lastDx = points[1][X] - points[0][X];

        for (int i = 2; i < n; i++) {
            int currDy = points[i][Y] - points[i - 1][Y];
            int currDx = points[i][X] - points[i - 1][X];

            //if any points lie in same line, then they must have the same slope
            //value which is (slope: (y2 - y1) / (x2 - x1)). If pointA, pointB, pointC
            //lie in same line then slopeAB == slopeBC, if they are not same then
            //there separate lines passing through these points hence lines++
            //slopeAB ==> (yB - yA) / (xB - xA) in our case one slope
            //is lastDy / lastDx
            //slopeBC ==> (yC - yB) / (xC - xB) in our case one slope
            //is currDy / currDx
            //hence (lastDy / lastDx) == (currDy / currDx) simplify
            //currDx * lastDy == lastDx * currDy, if these slopes are not same they
            //are separate lines
            if (currDx * lastDy != lastDx * currDy) {
                lines++;
                lastDy = currDy;
                lastDx = currDx;
            }
        }
        return lines;
    }

    private double maxPointsOnLine_CalculateSlope(int[] point1, int[] point2) {
        double x1 = point1[0];
        double y1 = point1[1];

        double x2 = point2[0];
        double y2 = point2[1];

        //if two points lie on same row coord p1=[1, 3], p2=[1,6], then the slope
        //between these two points will be perpendicular to X-Axis and is infinity
        if (x1 == x2) {
            return Double.MAX_VALUE;
        }

        //if two points have on same col coord p1=[1, 3], p2=[2,3], then these points
        //are parallel to each other and hence the slope between these two points are 0
        if (y1 == y2) {
            return 0.0;
        }

        return (y2 - y1) / (x2 - x1);
    }

    public void maxPointsOnLine(int[][] points) {
        //https://leetcode.com/problems/max-points-on-a-line/description/
        int n = points.length;

        if (n == 1) {
            System.out.println("Max points on line: " + 1);
            return;
        }

        int maxPointsInLine = 0;
        for (int i = 0; i < n; i++) {

            Map<Double, Integer> slopes = new HashMap<>();

            for (int j = i + 1; j < n; j++) {

                double slope = maxPointsOnLine_CalculateSlope(points[i], points[j]);

                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);

                maxPointsInLine = Math.max(maxPointsInLine, slopes.get(slope));
            }
        }
        //output
        System.out.println("Max points on line: " + maxPointsInLine);
    }

    public void countPrimes(int n) {
        //https://leetcode.com/problems/count-primes/
        //explanation: https://www.geeksforgeeks.org/sieve-of-eratosthenes/
        boolean[] primes = new boolean[n];
        //initially considering all 0 to n - 1 nums to be prime, then we will
        //filter out what all num are not primes
        Arrays.fill(primes, true);
        //since we are trying out all the num under n whose sqr is there in primes[]
        //why? because a prime num is someone who is not divisible by any other num
        //but sqr(num) is divisible
        for (int num = 2; num * num < n; num++) {
            if (primes[num]) {
                //all sqrs of num(basically multiple of primes num)
                //ex num = 2 is prime but 2 * 2 = 4; i += num = 2 + 2 = 4
                for (int i = num * num; i < n; i += num) {
                    primes[i] = false;
                }
            }
        }
        int totalPrimes = 0;
        for (int num = 2; num < n; num++) {
            if (primes[num]) {
                System.out.print(num + " ");
                totalPrimes++;
            }
        }
        //output
        System.out.println("Count primes: " + totalPrimes);
    }

    public void myCalendarOne() {
        //https://leetcode.com/problems/my-calendar-i/
        //based on SEGMENT TREES BUT modifed it to use TREEMAP behaving as SEGMENT TREE
        //somewhat similar to amountToPaintTheArea()
        class MyCalendarOne {

            TreeMap<Integer, Integer> timeRange;

            public MyCalendarOne() {
                timeRange = new TreeMap<>();
            }

            public boolean book(int start, int end) {

                //here end - 1 being used because acc to question end time is
                //non-inclusive
                //floorKey(KEY) will give a key which will be
                //less than or equal to our KEY if not present then null
                //thats why using Integer beacuse primitive int can't store null
                //here it will return first lower start time than given start key
                Integer firstLowerTime = timeRange.floorKey(start);
                //higherKey(KEY) will give a key which will be
                //greater than or equal to our KEY if not present then null
                //thats why using Integer beacuse primitive int can't store null
                //here it will return first higher start time than given start key
                Integer firstHigherTime = timeRange.higherKey(start);

                if (firstLowerTime != null) {
                    //ex: [15, 20], [15, 17]
                    if (firstLowerTime == start) {
                        return false;
                    }
                    //ex: [10, 20], [15, 17] ==> 15 lying in range of [10 to 20 - 1]
                    if (start <= timeRange.get(firstLowerTime)) {
                        return false;
                    }
                }

                if (firstHigherTime != null) {
                    //ex: [15, 20], [15, 17]
                    if (firstHigherTime == start) {
                        return false;
                    }
                    //ex: [17, 25], [15, 18] ==> 15's end that is 18 lying beyond
                    //firstHigherTime range's start time that it 17
                    if (end - 1 >= firstHigherTime) {
                        return false;
                    }
                }

                timeRange.put(start, end - 1);
                return true;
            }
        }

//input 1
        System.out.println("Input 1");
        MyCalendarOne calendar = new MyCalendarOne();
        int[][] bookings = new int[][]{{10, 20}, {50, 60}, {10, 40}, {5, 15}, {5, 10}, {25, 55}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }

        //input 2
        System.out.println("Input 2");
        calendar = new MyCalendarOne();
        bookings = new int[][]{{10, 20}, {15, 25}, {20, 30}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }
    }

    public void myCalendarThree() {
        //https://leetcode.com/problems/my-calendar-iii/
        class MyCalendarThree {

            TreeMap<Integer, Integer> diffs;

            public MyCalendarThree() {
                diffs = new TreeMap<>();
            }

            public int book(int start, int end) {
                diffs.put(start, diffs.getOrDefault(start, 0) + 1);
                diffs.put(end, diffs.getOrDefault(end, 0) - 1);
                int result = 0;
                int curr = 0;
                for (int diff : diffs.values()) {
                    curr += diff;
                    result = Math.max(result, curr);
                }

                return result;
            }
        }

//input 1
        System.out.println("Input 1");
        MyCalendarThree calendar = new MyCalendarThree();
        int[][] bookings = new int[][]{{10, 20}, {50, 60}, {10, 40}, {5, 15}, {5, 10}, {25, 55}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }

        //input 2
        System.out.println("Input 2");
        calendar = new MyCalendarThree();
        bookings = new int[][]{{10, 20}, {15, 25}, {20, 30}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }
    }

    public void implementMaxFreqStack() {
        //https://leetcode.com/problems/maximum-frequency-stack/
        //https://leetcode.com/problems/maximum-frequency-stack/solution/
        ImplementMaxFreqStack stack = new ImplementMaxFreqStack();
        stack.push(5);
        stack.push(7);
        stack.push(5);
        stack.push(7);
        stack.push(4);
        stack.push(5);
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
    }

    public void executionOfAllInstructionsStayingInGrid(int n, int[] startPos, String commands) {
        //https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/description/
        //based on simulation
        class Helper {

            boolean isOutOfBounds(int row, int col, int n) {
                return row < 0 || row >= n || col < 0 || col >= n;
            }

            int helperSimulateCommands(int n, int[] startPos, String commands) {

                int len = commands.length();
                int row = startPos[0];
                int col = startPos[1];
                int steps = 0;
                int index = 0;

                while (index < len) {

                    char command = commands.charAt(index++);
                    steps++;

                    switch (command) {
                        case 'U':
                            row--;
                            break;
                        case 'D':
                            row++;
                            break;
                        case 'R':
                            col++;
                            break;
                        case 'L':
                            col--;
                            break;
                    }

                    //if the row & col going 'isOutOfBounds' then take a step back
                    //(==> step - 1) and return
                    if (isOutOfBounds(row, col, n)) {
                        return steps - 1;
                    }

                }
                return steps;
            }
        }

        Helper helper = new Helper();

        int len = commands.length();
        int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            String command = commands.substring(i);
            result[i] = helper.helperSimulateCommands(n, startPos, command);
        }
        //output
        System.out.println("Execute instructions for staying in grid : " + Arrays.toString(result));
    }

    public void designHitCounter(List<String> commands, List<Integer> values) {

        class Hit {

            int timestamp;
            int hit;

            public Hit(int timestamp, int hit) {
                this.timestamp = timestamp;
                this.hit = hit;
            }

        }

        class HitCounter {

            private final int LAST_FIVE_MIN_IN_SECONDS;

            int totalHits;
            Deque<Hit> queue;

            public HitCounter() {
                LAST_FIVE_MIN_IN_SECONDS = 300;
                totalHits = 0;
                queue = new LinkedList<>();
            }

            public void hit(int timestamp) {
                if (!queue.isEmpty() && queue.peekLast().timestamp == timestamp) {
                    queue.peekLast().hit++;
                } else {
                    queue.add(new Hit(timestamp, 1));
                }

                totalHits++;
            }

            public int getHits(int timestamp) {
                while (!queue.isEmpty() && timestamp - queue.peekFirst().timestamp >= LAST_FIVE_MIN_IN_SECONDS) {
                    totalHits -= queue.pollFirst().hit;
                }
                return totalHits;
            }

        }

        HitCounter hitCounter = new HitCounter();

        int size = commands.size();

        for (int i = 0; i < size; i++) {

            String command = commands.get(i);
            int timestamp = values.get(i);

            if ("hit".equals(command)) {
                hitCounter.hit(timestamp);
            } else {
                System.out.println("Total hit in last 5 mins from : " + timestamp + " : " + hitCounter.getHits(timestamp));
            }
        }
    }

    public void designRangeFrequencyQuery(List<List<Integer>> values) {

        class RangeFreqQuery {

            Map<Integer, TreeMap<Integer, Integer>> valToIndexWiseFreqs;

            public RangeFreqQuery(int[] arr) {
                int n = arr.length;
                valToIndexWiseFreqs = new HashMap<>();

                for (int i = 0; i < n; i++) {

                    int val = arr[i];
                    valToIndexWiseFreqs.putIfAbsent(val, new TreeMap<>());
                    valToIndexWiseFreqs.get(val).put(i, valToIndexWiseFreqs.get(val).size());
                }
            }

            public int query(int left, int right, int value) {

                if (!valToIndexWiseFreqs.containsKey(value)) {
                    return 0;
                }

                Map.Entry<Integer, Integer> leftBound = valToIndexWiseFreqs.get(value).ceilingEntry(left);
                Map.Entry<Integer, Integer> rightBound = valToIndexWiseFreqs.get(value).floorEntry(right);

                if (leftBound == null || rightBound == null) {
                    return 0;
                }

                return rightBound.getValue() - leftBound.getValue() + 1;
            }
        }

        RangeFreqQuery rangeFreqQuery = new RangeFreqQuery(values.get(0).stream()
                .mapToInt(val -> val)
                .toArray());

        int size = values.size();

        for (int i = 1; i < size; i++) {

            List<Integer> value = values.get(i);
            int left = value.get(0);
            int right = value.get(1);
            int queryVal = value.get(2);

            System.out.println(queryVal + " freqs between "
                    + left
                    + " & "
                    + right
                    + " : "
                    + rangeFreqQuery.query(left, right, queryVal));
        }
    }

    public void designFileSystem(List<String> commands, List<List<String>> values) {
        //https://leetcode.com/problems/design-file-system/description/

        class TrieNode {

            Map<String, TrieNode> nodes;
            String content;
            boolean isAlreadyPath;

            public TrieNode() {
                nodes = new HashMap<>();
                content = "-1";
                isAlreadyPath = false;
            }
        }

        class FileSystem {

            TrieNode ROOT;

            public FileSystem(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            public boolean createPath(String path, String content) {
                return addToTrie(path, content);
            }

            public String get(String path) {
                return getContent(path);
            }

            //Trie utils methods
            //here, rather than saving char based nodes for trie, we will save
            //string based nodes, where each string will be the dir of the given
            //path
            //ex: path = "/path/to/some/where"
            //nodes ==> dir ==> ["path", "to", "some", "where"]
            boolean addToTrie(String path, String value) {

                TrieNode currRoot = ROOT;

                //breaking path into list of directories, where each 'dir'
                //will become the trie node
                String[] dirs = path.split("/");

                int length = dirs.length;

                for (int i = 0; i < length; i++) {

                    String dir = dirs[i];
                    boolean lastDirOfPath = i == length - 1;

                    //since we split() on '/' the first dir will be ""
                    //path = "/somePath" ==> split() ==> ["", "somePath"]
                    //so just avoid any empty "" string
                    if ("".equals(dir)) {
                        continue;
                    }

                    if (currRoot.nodes.containsKey(dir)) {

                        currRoot = currRoot.nodes.get(dir);

                    } else if (lastDirOfPath) {
                        //as per question,
                        //'Creates a new path and associates a value to it if
                        //possible and returns true. Returns false if the path
                        //already exists or its parent path doesn't exist.'
                        //with this if block we prevent this case:
                        //'its parent path doesn't exist'
                        //so this means we can only create a new dir in the trie
                        //if that new dir is the very last dir of the path
                        //and all its parent directories should already existed
                        //ex: path = "/path/to/dont_exist"
                        //now this dir = "dont_exist" is the last dir of the path
                        //i.e, "dont_exist" == (i == length - 1)
                        //BUT for ex: path = "/path/dont_exist/but/create"
                        //here we want to create this whole path but the dir
                        //named "dont_exist" is not present which is actually
                        //the parent dir/path for dir like, ["but", "create"]
                        //now the i-th dir ==> "dont_exist" is not the last
                        //dir of the path means "dont_exist" == (i != length - 1)
                        //hence this if() will fall to its else{} case and return
                        //false from there meaning the whole given path can't be
                        //created
                        TrieNode node = new TrieNode();
                        currRoot.nodes.put(dir, node);
                        currRoot = node;

                    } else {

                        return false;
                    }
                }

                //this prevents 'if the path already exists'
                if (currRoot.isAlreadyPath) {
                    return false;
                }

                //otherwise, the given path is valid and the got created
                //successfully so we can write the content to the location
                //and mark this path as 'isAlreadyPath' for future ref
                currRoot.content = value;
                return currRoot.isAlreadyPath = true;
            }

            //Trie utils methods
            String getContent(String path) {

                TrieNode currRoot = ROOT;

                String[] dirs = path.split("/");

                for (String dir : dirs) {

                    if ("".equals(dir)) {
                        continue;
                    }

                    if (currRoot.nodes.containsKey(dir)) {
                        currRoot = currRoot.nodes.get(dir);
                    } else {
                        //if the given path is invalid and a dir dont exist in
                        //the given path
                        return "-1";
                    }
                }

                return currRoot.content;
            }
        }

        TrieNode ROOT = new TrieNode();
        FileSystem fileSystem = new FileSystem(ROOT);

        int size = commands.size();

        for (int i = 0; i < size; i++) {

            String command = commands.get(i);

            switch (command) {

                case "createPath": {

                    String path = values.get(i).get(0);
                    String content = values.get(i).get(1);

                    System.out.println(path + " Path with content " + content + " created : "
                            + fileSystem.createPath(path, content));
                }
                break;

                case "get": {

                    String path = values.get(i).get(0);

                    System.out.println("Content from path " + path + " fetched : "
                            + fileSystem.get(path));
                }
                break;
            }
        }
    }

    public void designPhoneDirectory(List<String> commands, List<List<Integer>> values) {
        //https://leetcode.com/problems/design-phone-directory/description/

        class PhoneDirectory {
            // Queue to store all available slots.

            private Queue<Integer> slotsAvailableQueue;

            // Array to mark if a slot is available.
            private boolean[] isSlotAvailable;

            public PhoneDirectory(int maxNumbers) {

                slotsAvailableQueue = new ArrayDeque<>(maxNumbers);

                isSlotAvailable = new boolean[maxNumbers];

                for (int i = 0; i < maxNumbers; ++i) {

                    slotsAvailableQueue.offer(i);

                    // Initially, all slots are available.
                    isSlotAvailable[i] = true;
                }
            }

            public int get() {

                // If the queue is empty it means no slot is available.
                if (slotsAvailableQueue.isEmpty()) {
                    return -1;
                }

                // Otherwise, poll the first element from the queue,
                // mark that slot as not available and return the slot.
                int slot = slotsAvailableQueue.poll();
                isSlotAvailable[slot] = false;

                return slot;
            }

            public boolean check(int number) {

                // Check if the slot at index 'number' is available or not.
                return isSlotAvailable[number];
            }

            public void release(int number) {

                // If the slot is already present in the queue, we don't do anything.
                if (isSlotAvailable[number]) {
                    return;
                }

                // Otherwise, mark the slot 'number' as available.
                slotsAvailableQueue.offer(number);
                isSlotAvailable[number] = true;
            }
        }

        int size = commands.size();

        PhoneDirectory phoneDirectory = null;

        for (int i = 0; i < size; i++) {

            String command = commands.get(i);

            switch (command) {

                case "PhoneDirectory": {

                    int maxNumbers = values.get(i).get(0);

                    phoneDirectory = new PhoneDirectory(maxNumbers);

                }
                break;

                case "get": {
                    System.out.println("get : " + phoneDirectory.get());
                }
                break;

                case "check": {

                    int number = values.get(i).get(0);

                    System.out.println("check : " + phoneDirectory.check(number));
                }
                break;

                case "release": {

                    int number = values.get(i).get(0);

                    System.out.println("release : " + number);

                    phoneDirectory.release(number);
                }
                break;
            }
        }
    }

    public static void main(String[] args) {

        //Object to access method
        DSA450Questions obj = new DSA450Questions();

        //......................................................................
//        Row: 6
//        System.out.println("Reverse array");
//        int[] a1 = {1, 2, 3, 4, 5};
//        obj.reverseArray(a1);
//        int[] a2 = {1, 2, 3, 4};
//        obj.reverseArray(a2);
        //......................................................................
//        Row: 56
//        System.out.println("Reverse string");
//        String str1 = "Sangeet";
//        obj.reverseString(str1);
//        String str2 = "ABCD";
//        obj.reverseString(str2);
        //......................................................................
//        Row: 57
//        System.out.println("Is string pallindrome");
//        String str3 = "Sangeet";
//        System.out.println(str3+" "+obj.isStringPallindrome(str3));
//        System.out.println(str3+": is pallindrome by two pointer: "+obj.isStringPallindrome(str3, 0, str3.length() - 1));
//        String str4 = "ABBA";
//        System.out.println(str4+" "+obj.isStringPallindrome(str4));
//        System.out.println(str4+": is pallindrome by two pointer: "+obj.isStringPallindrome(str4, 0, str4.length() - 1));
        //......................................................................
//        Row: 58
//        System.out.println("Print duplicates char in string");
//        String str5 = "AABBCDD";
//        obj.printDuplicatesCharInString(str5);
//        String str6 = "XYZPQRS";
//        obj.printDuplicatesCharInString(str6);
        //......................................................................
//        Row: 139
//        System.out.println("Reverse a linked list iterative/recursive");
//        Node<Integer> node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        obj.reverseLinkedList_Iterative(node1);
//        Node<Integer> node2 = new Node<>(1);
//        node2.setNext(new Node<>(2));
//        node2.getNext().setNext(new Node<>(3));
//        node2.getNext().getNext().setNext(new Node<>(4));
//        node2.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.reverseLinkedList_Recursive(node2);
        //......................................................................
//        Row: 177
//        System.out.println("Level order traversal of tree iterative & recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.levelOrderTraversal_Iterative(root1);
//        obj.levelOrderTraversal_Iterative2(root1); //size based approach
//        obj.levelOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 179
//        System.out.println("Height of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        System.out.println(obj.heightOfTree(root1));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode(2));
//        System.out.println(obj.heightOfTree(root2));
        //......................................................................
//        Row: 181
//        System.out.println("Invert/mirror of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        obj.mirrorOfTree(root1);
//        System.out.println();
//        //output
//        bt = new BinaryTree<>(root1);
//        bt.treeBFS();
        //......................................................................
//        Row: 299
//        System.out.println("Middle element in the stack");
//        Stack<Integer> stack = new Stack<>();
//        stack.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
//        obj.middleElementInStack(stack);
//        stack.clear();
//        stack.addAll(Arrays.asList(1, 2, 3, 4));
//        obj.middleElementInStack(stack);
//        stack.clear();
//        //empty stack!!
//        obj.middleElementInStack(stack);
        //......................................................................
//        Row: 182
//        System.out.println("Inorder traversal of tree Iterative/recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.inOrderTraversal_Iterative(root1);
//        obj.inOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 183
//        System.out.println("Preorder traversal of tree Iterative/recursive");
//        //https://leetcode.com/problems/binary-tree-preorder-traversal/description/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.preOrderTraversal_Iterative(root1);
//        obj.preOrderTraversal_Iterative2(root1);
//        obj.preOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 184
//        System.out.println("Postsorder traversal of tree Iterative/recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.postOrderTraversal_Iterative(root1);
//        obj.postOrderTraversal_recursive(root1);
        //......................................................................
//        Row: 148
//        System.out.println("Add two numbers represented by linked list");
//        Node<Integer> n1 = new Node<>(4);
//        n1.setNext(new Node<>(5));
//        Node<Integer> n2 = new Node<>(3);
//        n2.setNext(new Node<>(4));
//        n2.getNext().setNext(new Node<>(5));
//        obj.sumOfNumbersAsLinkedList_ByStack(n1, n2);
//        obj.sumOfNumbersAsLinkedList_ByReversingList(n1, n2);
        //......................................................................
//        Row: 178
//        System.out.println("Reverse level order traversal");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.reverseLevelOrderTraversal(root1);
        //......................................................................
//        Row: 185
//        System.out.println("Left view of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.leftViewOfTree(root1);
//        obj.leftViewOfTreeWithoutExtraSpace(root1);
        //......................................................................
//        Row: 186
//        System.out.println("Right view of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.rightViewOfTree(root1);
//        obj.rightViewOfTreeWithoutExtraSpace(root1);
        //......................................................................
//        Row: 187
//        System.out.println("Top view of tree/ Vertical order traversal of tree");
//        //https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
//        //https://leetcode.com/problems/binary-tree-vertical-order-traversal/description/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.topViewOfTree(root1);
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.verticalOrderTraversalOfBinaryTree(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode(1));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(2));
//        root1.setRight(new TreeNode(4));
//        root1.getRight().setLeft(new TreeNode(2));
//        obj.verticalOrderTraversalOfBinaryTree(root1);
        //......................................................................
//        Row: 188
//        System.out.println("Bottom view of tree");
//        //https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1
//        TreeNode<Integer> root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.bottomViewOfTree(root1);
        //......................................................................
//        Row: 189
//        System.out.println("Zig zag traversal of tree");
//        //https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.zigZagTreeTraversal(root1, true);
//        root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.zigZagTreeTraversal(root1, false);
        //......................................................................
//        Row: 30
//        System.out.println("All the element from array[N] and given K that occurs more than N/K times");
//        obj.arrayElementMoreThan_NDivK(new int[]{3, 1, 2, 2, 1, 2, 3, 3}, 4);
        //......................................................................
//        Row: 81
//        System.out.println("Roman numeral string to decimal");
//        //https://leetcode.com/problems/roman-to-integer/
//        obj.romanStringToDecimal("III");
//        obj.romanStringToDecimal("CI");
//        obj.romanStringToDecimal("IM");
//        obj.romanStringToDecimal("V");
//        obj.romanStringToDecimal("XI");
//        obj.romanStringToDecimal("IX");
//        obj.romanStringToDecimal("IV");
//        obj.integerToRomanString(100);
//        obj.integerToRomanString(101);
//        obj.integerToRomanString(4999);
        //......................................................................
//        Row: 86
//        System.out.println("Longest common subsequence");
//        obj.longestCommonSubsequence("ababcba", "ababcba");
//        obj.longestCommonSubsequence("abxayzbcpqba", "kgxyhgtzpnlerq");
//        obj.longestCommonSubsequence("abcd", "pqrs");
//        obj.longestCommonSubsequence("abcd", "");
//        obj.longestCommonSubsequence("", "pqrs");
        //......................................................................
//        Row: 144
//        System.out.println("Remove duplicates from sorted linked list");
//        Node<Integer> node1 = new Node<>(1);
//        node1.setNext(new Node<>(1));
//        node1.getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.removeDuplicateFromSortedLinkedList(node1);
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.removeDuplicateFromSortedLinkedList(node1);
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().setNext(new Node<>(5));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicateFromSortedLinkedList(node1);
        //......................................................................
//        Row: 194
//        System.out.println("Convert tree to doubly linked list");
//        //https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/description/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.treeToDoublyLinkedList(root1);
//        root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.treeToDoublyLinkedList(root1);
        //......................................................................
//        Row: 199
//        System.out.println("Check if all the leaf nodes of tree are at same level");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.checkIfAllLeafNodeOfTreeAtSameLevel(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(2));
//        root1.setRight(new TreeNode(3));
//        obj.checkIfAllLeafNodeOfTreeAtSameLevel(root1);
        //......................................................................
//        Row: 216
//        System.out.println("Min & max in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.minAndMaxInBST(root1);
        //......................................................................
//        Row: 218
//        System.out.println("Check if a tree is BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeBST(root1);
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(10)); //BST break cond.
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeBST(root1);
        //......................................................................
//        Row: 225
//        System.out.println("Kth largest node in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.kTHLargestNodeInBST(root1, 4);
//        obj.kTHLargestNodeInBSTWithoutHeap(root1, 4);
//        obj.kTHLargestNodeInBST(root1, 21);
//        obj.kTHLargestNodeInBSTWithoutHeap(root1, 21);
        //......................................................................
//        Row: 226
//        System.out.println("Kth smallest node in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.kTHSmallestNodeInBST(root1, 4);
//        obj.kTHSmallestNodeInBST(root1, 1);
//        obj.kTHSmallestNodeInBST(root1, 21);
        //......................................................................
//        Row: 169
//        System.out.println("Merge K sorted linked lists");
//        //https://leetcode.com/problems/merge-k-sorted-lists/
//        Node<Integer> n1 = new Node<>(1);
//        n1.setNext(new Node<>(2));
//        n1.getNext().setNext(new Node<>(3));
//        Node<Integer> n2 = new Node<>(4);
//        n2.setNext(new Node<>(10));
//        n2.getNext().setNext(new Node<>(15));
//        Node<Integer> n3 = new Node<>(3);
//        n3.setNext(new Node<>(9));
//        n3.getNext().setNext(new Node<>(27));
//        int K = 3;
//        Node<Integer>[] nodes = new Node[K];
//        nodes[0] = n1;
//        nodes[1] = n2;
//        nodes[2] = n3;
//        obj.mergeKSortedLinkedList(nodes);
        //......................................................................
//        Row: 173
//        System.out.println("Print the Kth node from the end of a linked list 3 approaches");
//        //https://leetcode.com/problems/remove-nth-node-from-end-of-list/
//        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
//        //https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
//        Node<Integer> n1 = new Node<>(1);
//        n1.setNext(new Node<>(2));
//        n1.getNext().setNext(new Node<>(3));
//        n1.getNext().getNext().setNext(new Node<>(5));
//        n1.getNext().getNext().getNext().setNext(new Node<>(9));
//        n1.getNext().getNext().getNext().getNext().setNext(new Node<>(15));
//        obj.kThNodeFromEndOfLinkedList_1(n1, 3);
//        obj.kThNodeFromEndOfLinkedList_2(n1, 3);
//        obj.kThNodeFromEndOfLinkedList_3(n1, 3); //OPTIMISED O(N)
//        obj.kThNodeFromEndOfLinkedList_3(n1, 6); //OPTIMISED O(N)
//        obj.kThNodeFromEndOfLinkedList_3(n1, 8); //OPTIMISED O(N)
        //......................................................................
//        Row: 190
//        System.out.println("Check if a tree is height balanced or not");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeHeightBalanced(root1);
//        root1 = new TreeNode<>(1); //SKEWED TREE
//        root1.setLeft(new TreeNode(10));
//        root1.getLeft().setLeft(new TreeNode(15));
//        obj.isTreeHeightBalanced(root1);
        //......................................................................
//        Row: 201
//        System.out.println("Check if 2 trees are mirror or not");
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        System.out.println("2 tree are mirror: "+obj.checkTwoTreeAreMirror(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(2)); //SAME
//        root2.setRight(new TreeNode<>(3)); //SAME
//        System.out.println("2 tree are mirror: "+obj.checkTwoTreeAreMirror(root1, root2));
        //......................................................................
//        Row: 333
//        System.out.println("Next smaller element to right / left in array");
//        obj.nextSmallerElementToRightInArray(new int[]{4, 8, 5, 2, 25});
//        obj.nextSmallerElementToLeftInArray(new int[]{4, 8, 5, 2, 25});
        //......................................................................
//        Row: 304
//        System.out.println("Next greater element to right / left in array");
//        obj.nextGreaterElementToRightInArray(new int[]{1,3,2,4});
//        obj.nextGreaterElementToRightInArray(new int[]{1,2,3,4,5}); //STACK WILL HOLD N ELEMENT S: O(N)
//        obj.nextGreaterElementToRightInArray(new int[]{5,4,3,2,1}); //STACK WILL NOT HOLD N ELEMENT S: O(1)
//        obj.nextGreaterElementToLeftInArray(new int[]{1,3,2,4});
//        obj.nextGreaterElementToLeftInArray(new int[]{1,2,3,4,5});
//        obj.nextGreaterElementToLeftInArray(new int[]{5,4,3,2,1});
        //......................................................................
//        Row: 309
//        System.out.println("Reverse a stack using recursion");
//        Stack<Integer> stack = new Stack<>();
//        stack.addAll(Arrays.asList(1, 2, 3, 4, 5));
//        obj.reverseStack(stack);
        //......................................................................
//        Row: 7
//        System.out.println("Min & max in array");
//        obj.minMaxInArray_1(new int[]{1000, 11, 445, 1, 330, 3000});
//        obj.minMaxInArray_2(new int[]{1000, 11, 445, 1, 330, 3000});
        //......................................................................
//        Row: 8
//        System.out.println("Kth smallest and largest element in array");
//        //https://leetcode.com/problems/query-kth-smallest-trimmed-number/
//        obj.kThSmallestElementInArray(new int[]{7, 10, 4, 3, 20, 15}, 3);
//        obj.kThSmallestTrimmedNumber(new String[]{"102", "473", "251", "814"},
//                new int[][]{{1, 1}, {2, 3}, {4, 2}, {1, 2}});
//        obj.kThLargestElementInArray(new int[]{7, 10, 4, 3, 20, 15}, 3);
        //......................................................................
//        Row: 9
//        System.out.println("Sort the array containing elements 0, 1, 2");
//        //https://leetcode.com/problems/sort-colors/
//        obj.sortArrayOf012_1(new int[]{0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1});
//        obj.sortArrayOf012_2(new int[]{0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1}); //DUTCH NATIONAL FLAG ALGO
        //......................................................................
//        Row: 51
//        System.out.println("Rotate a matrix 90 degrees clockwise/anticlockwise");
//        //https://leetcode.com/problems/rotate-image
//        int[][] mat = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
//        obj.rotateMatrixClockWise90Deg(mat);
//        mat = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
//        obj.rotateMatrixAntiClockWise90Deg(mat);
        //......................................................................
//        Row: 62
//        System.out.println("Count and say");
//        //https://leetcode.com/problems/count-and-say/
//        obj.countAndSay(1);
//        obj.countAndSay(2);
//        obj.countAndSay(3);
//        obj.countAndSay(10);
        //......................................................................
//        Row: 93
//        System.out.println("Remove consecutive duplicate char in string");
//        obj.removeConsecutiveDuplicateInString("aababbccd");
//        obj.removeConsecutiveDuplicateInString("aaabbbcccbbbbaaaa");
//        obj.removeConsecutiveDuplicateInString("xyzpqrs");
//        obj.removeConsecutiveDuplicateInString("abcppqrspplmn");
//        obj.removeConsecutiveDuplicateInString("abcdlllllmmmmm");
//        obj.removeConsecutiveDuplicateInString("aaaaaaaaaaaa");
        //......................................................................
//        Row: 108
//        System.out.println("Majority Element");
//        //https://leetcode.com/problems/majority-element/
//        //https://leetcode.com/problems/majority-element-ii/
//        obj.majorityElement_1(new int[] { 1, 3, 3, 1, 2 });
//        obj.majorityElement_1(new int[] { 1, 3, 3, 3, 2 });
//        obj.majorityElement_2(new int[] { 1, 3, 3, 1, 2 }); //MOORE'S VOTING ALGO
//        obj.majorityElement_2(new int[] { 1, 3, 3, 3, 2 }); //MOORE'S VOTING ALGO
        //......................................................................
//        Row: 195
//        System.out.println("Convert tree to its sum tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.convertTreeToSumTree(root1); //EXTRA QUEUE SPACE IS USED
//        //reset root
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.convertTreeToSumTree_Recursion(root1); //NO EXTRA QUEUE SPACE IS USED - OPTIMISED
        //......................................................................
//        Row: 206
//        System.out.println("K sum path from any node top to down");
//        //https://leetcode.com/problems/path-sum-iii/
//        //https://leetcode.com/problems/path-sum-ii/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(3));
//        root1.getLeft().setLeft(new TreeNode(2));
//        root1.getLeft().setRight(new TreeNode(1));
//        root1.getLeft().getRight().setLeft(new TreeNode(1));
//        root1.setRight(new TreeNode(-1));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().getLeft().setLeft(new TreeNode(1));
//        root1.getRight().getLeft().setRight(new TreeNode(2));
//        root1.getRight().setRight(new TreeNode(5));
//        root1.getRight().getRight().setRight(new TreeNode(6));
//        obj.printKSumPathAnyNodeTopToDown(root1, 5);
        //......................................................................
//        Row: 349, 269
//        System.out.println("Min cost to combine ropes of diff lengths into one big rope");
//        obj.minCostOfRope(new int[]{4, 3, 2, 6});
        //......................................................................
//        Row: 344, 89, 271
//        System.out.println("Reorganise string");
//        //https://leetcode.com/problems/reorganize-string/
//        System.out.println("Reorganise string output: "+obj.reorganizeString("aab"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("aaab"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("bbbbb"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("geeksforgeeks"));
        //......................................................................
//        Row: 98
//        System.out.println("Print all sentences that can be formed from list/array of words");
//        String[][] arr = {{"you", "we", ""},
//        {"have", "are", ""},
//        {"sleep", "eat", "drink"}};
//        obj.printSentencesFromCollectionOfWords(arr); //GRAPH LIKE DFS
        //......................................................................
//        Row: 74
//        System.out.println("KMP pattern matching algo");
//        //https://leetcode.com/problems/implement-strstr/
//        obj.KMP_PatternMatching_Algorithm("ABABDABACDABABCABAB", "ABABCABAB");
//        obj.KMP_PatternMatching_Algorithm("sangeeangt", "ang");
//        obj.KMP_PatternMatching_Algorithm("sangeeangt", "xyz");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("abab");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("aaaa");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("aabcavefaabca");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("abcdef");
        //......................................................................
//        Row: 82
//        System.out.println("Longest common prefix in list of strings");
//        //https://leetcode.com/problems/longest-common-prefix/
//        obj.longestCommonPrefix(new String[]{"flower", "flow", "flight"});
//        obj.longestCommonPrefix(new String[]{"flower", "flower", "flower"});
//        obj.longestCommonPrefix(new String[]{"dog", "racecar", "car"});
//        obj.longestCommonPrefix(new String[]{"a"});
//        obj.longestCommonPrefix(new String[]{"abc", "abcdef", "abcdlmno"});
        //......................................................................
//        Row: 114
//        System.out.println("Merge 2 sorted arrays without using extra space");
//        //https://practice.geeksforgeeks.org/problems/merge-two-sorted-arrays-1587115620/1
//        obj.mergeTwoSortedArraysWithoutExtraSpace(new int[]{1}, new int[]{0});
//        obj.mergeTwoSortedArraysWithoutExtraSpace(new int[]{1, 5, 9, 10, 15, 20}, new int[]{2, 3, 8, 13});
//        obj.mergeTwoSortedArraysWithoutExtraSpace(new int[]{1, 3, 5, 7}, new int[]{0, 2, 6, 8, 9});
        //......................................................................
//        Row: 140
//        System.out.println("Swap Linked List Nodes In Pairs");
//        //https://leetcode.com/problems/swap-nodes-in-pairs/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<>(obj.swapLinkedListNodesInPair(node)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(8));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        new LinkedListUtil<>(obj.swapLinkedListNodesInPair(node)).print();
        //......................................................................
//        Row: 140
//        System.out.println("Reverse a linked list in K groups");
//        //https://leetcode.com/problems/reverse-nodes-in-k-group/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<>(obj.reverseLinkedListInKGroups(node, 3)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(8));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        new LinkedListUtil<>(obj.reverseLinkedListInKGroups(node, 4)).print();
        //......................................................................
//        Row: 207, 220
//        System.out.println("Lowest common ancestor of two given node/ node values for binary tree and binary search tree both");
//        //https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/
//        //https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/description/
//        TreeNode<Integer> root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        obj.lowestCommonAncestorOfTree(root1, 3, 4);
//        root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(6));
//        obj.lowestCommonAncestorOfTree(root1, 3, 6);
//        //CASE OF BST
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.lowestCommonAncestorOfTree(root1, 0, 5);
//        root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(4));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode(6));
//        root1.getRight().setRight(new TreeNode(7));
//        root1.getRight().getRight().setRight(new TreeNode(8));
//        obj.lowestCommonAncestorOfTree(root1, 7, 8);
        //......................................................................
//        Row: 69, 416
//        System.out.println("Edit distance recursion/ DP memoization");
//        //https://leetcode.com/problems/edit-distance/description/
//        String s1 = "sunday";
//        String s2 = "saturday";
//        System.out.println("Edit distance recursion: "+obj.editDistance_Recursion(s1, s2, s1.length(), s2.length()));
//        System.out.println("Edit distance dp memoization: "+obj.editDistance_DP_Memoization(s1, s2));
        //......................................................................
//        Row: 84
//        System.out.println("Second most occuring word in list");
//        obj.secondMostOccuringWordInStringList(new String[]{"aaa", "bbb", "ccc", "bbb", "aaa", "aaa"});
        //......................................................................
//        Row: 101
//        System.out.println("Find first and last occurence of K in sorted array");
//        //https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
//        //https://leetcode.com/problems/find-target-indices-after-sorting-array/
//        obj.findFirstAndLastOccurenceOfTargetInSortedArray(new int[]{1, 3, 5, 5, 5, 5, 67, 123, 125}, 5);
//        obj.findFirstAndLastOccurenceOfTargetInSortedArray(new int[]{1, 3, 5, 5, 5, 5, 67, 123, 125}, 9);
//        obj.findFirstAndLastOccurenceOfTargetInSortedArray(new int[]{1, 3, 5, 67, 123, 125}, 5);
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Longest Subsequence With Limited Sum");
//        //https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/
//        obj.longestSubsequenceWithLimitedSum(new int[]{4, 5, 2, 1}, new int[]{3, 10, 21});
//        obj.longestSubsequenceWithLimitedSum(new int[]{2, 3, 4, 5}, new int[]{1});
        //......................................................................
//        Row: 141, 143
//        System.out.println("Detect and print starting node of a loop cycle in linked list 2 approaches");
//        //https://leetcode.com/problems/linked-list-cycle/description/
//        //https://leetcode.com/problems/happy-number/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_HashBased(node));
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_Iterative(node)); //T: O(N), S: O(1) //OPTIMISED
//        node = new Node<>(3);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(-4));
//        node.getNext().getNext().getNext().setNext(node.getNext());
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_HashBased(node));
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_Iterative(node)); //T: O(N), S: O(1) //OPTIMISED
        //......................................................................
//        Row: 142
//        System.out.println("Detect and remove loop cycle in linked list 2 approaches");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        obj.detectAndRemoveLoopCycleInLinkedList_HashBased(node);
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        obj.detectAndRemoveLoopCycleInLinkedList_Iterative(node); //OPTIMISED
        //......................................................................
//        Row: 145
//        System.out.println("Remove Duplicates From an Unsorted Linked List");
//        //https://leetcode.com/problems/remove-duplicates-from-an-unsorted-linked-list/description/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(2));
//        obj.removeDuplicatesFromUnSortedLinkedList(node);
//        node = new Node<>(2);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(1));
//        node.getNext().getNext().setNext(new Node<>(2));
//        obj.removeDuplicatesFromUnSortedLinkedList(node);
//        node = new Node<>(3);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(2));
//        node.getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.removeDuplicatesFromUnSortedLinkedList(node);
//        //other versions
//        System.out.println("Remove duplicates element in unsorted linked list 2 different outputs");
//        node = new Node<>(3);
//        node.setNext(new Node<>(4));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicatesFromUnSortedLinkedListOnlyConsecutive(node);
//        node = new Node<>(3);
//        node.setNext(new Node<>(4));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicatesFromUnSortedLinkedListAllExtraOccuernce(node);
        //......................................................................
//        Row: 153
//        System.out.println("Find the middle element of the linked list");
//        Node<Integer> node = new Node<>(3);
//        node.setNext(new Node<>(5));
//        node.getNext().setNext(new Node<>(2));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        System.out.println("Middle element: "+obj.findMiddleNodeOfLinkedList(node).getData());
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        System.out.println("Middle element: "+obj.findMiddleNodeOfLinkedList(node).getData());
        //......................................................................
//        Row: 151
//        System.out.println("Sort linked list using merge sort");
//        //https://leetcode.com/problems/sort-an-array/description/
//        //https://leetcode.com/problems/sort-linked-list-already-sorted-using-absolute-values/description/
//        Node<Integer> node = new Node<>(3);
//        node.setNext(new Node<>(5));
//        node.getNext().setNext(new Node<>(2));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        new LinkedListUtil<Integer>(obj.mergeSortDivideAndMerge(node)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(3));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<Integer>(obj.mergeSortDivideAndMerge(node)).print();
        //......................................................................
//        Row: 151
//        System.out.println("Sort Linked List Already Sorted Using Absolute Values");
//        //https://leetcode.com/problems/sort-linked-list-already-sorted-using-absolute-values/description/
//        //linked list nodes are sortedly arranged based on the abs(node.val)
//        Node<Integer> node = new Node<>(0);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(-5));
//        node.getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().setNext(new Node<>(10));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(-10));
//        new LinkedListUtil<Integer>(obj.sortLinkedListAlreadySortedAsAbsoluteValue(node)).print();
//        node = new Node<>(0);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(2));
//        new LinkedListUtil<Integer>(obj.sortLinkedListAlreadySortedAsAbsoluteValue(node)).print();
//        node = new Node<>(-1);
//        node.setNext(new Node<>(-2));
//        node.getNext().setNext(new Node<>(-3));
//        new LinkedListUtil<Integer>(obj.sortLinkedListAlreadySortedAsAbsoluteValue(node)).print();
        //......................................................................
//        Row: 198
//        System.out.println("Check if a tree is sum tree");
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(20));
//        root.getLeft().setLeft(new TreeNode<>(10));
//        root.getLeft().setRight(new TreeNode<>(10));
//        root.setRight(new TreeNode<>(30)); //NOT A SUM TREE
//        obj.checkTreeIsSumTree(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(1)); //SUM TREE
//        obj.checkTreeIsSumTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Coin Change/ Min number of coins to make change in unlimited supply of coins");
//        //https://leetcode.com/problems/coin-change/description/
//        //https://practice.geeksforgeeks.org/problems/number-of-coins1824/1
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{25, 10, 5}, 30);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{1, 2, 5}, 11);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{2}, 3);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{1}, 0);
//        obj.coinChange_DP_Memoization(new int[]{25, 10, 5}, 30);
//        obj.coinChange_DP_Memoization(new int[]{1, 2, 5}, 11);
//        obj.coinChange_DP_Memoization(new int[]{2}, 3);
//        obj.coinChange_DP_Memoization(new int[]{1}, 0);
        //......................................................................
//        Row: 410
//        System.out.println("Coin change with infinite supply of coins");
//        //https://leetcode.com/problems/coin-change-2/
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{1, 2, 5}, 5);
//        obj.coinChangeTwo_DP_Memoization(new int[]{1, 2, 5}, 5);
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{2}, 3);
//        obj.coinChangeTwo_DP_Memoization(new int[]{2}, 3);
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{1, 2, 3}, 9);
//        obj.coinChangeTwo_DP_Memoization(new int[]{1, 2, 3}, 9);
        //......................................................................
//        Row: 411
//        System.out.println("0-1 knap sack");
//        obj.knapSack01_Recursive_Memoization(new int[]{4, 5, 1}, new int[]{1, 2, 3}, 4);
//        obj.knapSack01_DP_Memoization(new int[]{4, 5, 1}, new int[]{1, 2, 3}, 4);
//        obj.knapSack01_Recursive_Memoization(new int[]{4, 5, 6}, new int[]{1, 2, 3}, 3);
//        obj.knapSack01_DP_Memoization(new int[]{4, 5, 6}, new int[]{1, 2, 3}, 3);
        //......................................................................
//        Row: 417, 282
//        System.out.println("Subset sum");
//        obj.subsetSum_Recursive_Memoization(new int[]{1, 5, 5, 11}, 11);
//        obj.subsetSum_Recursive_Memoization(new int[]{1, 5, 5, 12}, 14);
//        obj.subsetSum_DP_Memoization(new int[]{1, 5, 5, 11}, 11);
//        obj.subsetSum_DP_Memoization(new int[]{1, 5, 5, 12}, 14);
//        System.out.println("Partition Equal Subset Sum");
//        //https://leetcode.com/problems/partition-equal-subset-sum/
//        obj.equalsSumPartition_SubsetSum(new int[]{1, 5, 5, 11});
//        obj.equalsSumPartition_SubsetSum(new int[]{1, 5, 5, 12});
        //......................................................................
//        Row: 423
//        System.out.println("Longest common sub sequence of 2 strings DP problem");
//        //https://leetcode.com/problems/longest-common-subsequence
//        String s1 = "ABCDGH";
//        String s2 = "AEDFHR";
//        obj.longestCommonSubsequence_Recursive_Memoization("ABCDGH", "AEDFHR");
//        obj.longestCommonSubsequence_DP_Memoization(s1, s2, s1.length(), s2.length());
//        s1 = "ABCDGH";
//        s2 = "";
//        obj.longestCommonSubsequence_Recursive_Memoization("ABCDGH", "");
//        obj.longestCommonSubsequence_DP_Memoization(s1, s2, s1.length(), s2.length());
//        System.out.println("Uncrossed Lines / Longest common sub sequence of 2 int arrays DP problem");
//        //https://leetcode.com/problems/uncrossed-lines/
//        obj.uncrossedLines_DP_Memoization(new int[]{1,4,2}, new int[]{1,2,4});
//        obj.uncrossedLines_DP_Memoization(new int[]{2,5,1,2,5}, new int[]{10,5,2,1,5,2});
//        obj.uncrossedLines_DP_Memoization(new int[]{1,3,7,1,7,5}, new int[]{1,9,2,5,1});
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Longest Pallindromic Subsequence DP problem");
//        //https://leetcode.com/problems/longest-palindromic-subsequence
//        obj.longestPallindromicSubsequence_Recursive_Memoization("bbbab");
//        obj.longestPallindromicSubsequence_Recursive_Memoization("cbbs");
//        obj.longestPallindromicSubsequence_DP_Memoization("bbbab");
//        obj.longestPallindromicSubsequence_DP_Memoization("cbbs");
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Maximize Palindrome Length From Subsequences");
//        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/description/
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("cacb", "cbba");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("ab", "ab");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("aa", "bb");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("xyz", "cbba");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("cfe", "ef");
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Delete Operation for Two Strings DP problem");
//        //https://leetcode.com/problems/delete-operation-for-two-strings/
//        // delete s from sea ==> "ea" insert t to "ea"  ==> eat
//        obj.deleteOperationOfTwoStrings_DP_Memoization("sea", "eat");
//        obj.deleteOperationOfTwoStrings_DP_Memoization("leetcode", "etco");
        //......................................................................
//        Row: 97
//        System.out.println("Check two strings are isomorphic or not");
//        //https://leetcode.com/problems/word-pattern/
//        //https://leetcode.com/problems/find-and-replace-pattern/
//        //https://www.geeksforgeeks.org/check-if-two-given-strings-are-isomorphic-to-each-other/
//        String s1 = "aab";
//        String s2 = "xxy";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
//        s1 = "aab";
//        s2 = "xyz";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
//        s1 = "13";
//        s2 = "42";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
        //......................................................................
//        Row: 96
//        System.out.println("Transform one string to another with min given no of operations");
//        //https://www.geeksforgeeks.org/transform-one-string-to-another-using-minimum-number-of-given-operation/
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACBD", "EABCD"));
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACBD", "EACBD"));
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACCD", "EABCD"));
        //......................................................................
//        Row: 154
//        System.out.println("Check if a linked list is circular linked list");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(node); //CIRCULAR 6 -> 1
//        System.out.println("Check if given linked list is circular linked list: " + obj.checkIfLinkedListIsCircularLinkedList(node));
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6)); //NOT CIRCULAR 6 -> NULL
//        System.out.println("Check if given linked list is circular linked list: " + obj.checkIfLinkedListIsCircularLinkedList(node));
        //......................................................................
//        Row: 152
//        System.out.println("Quick sort in linked list");
//        //https://www.geeksforgeeks.org/quick-sort/
//        Node<Integer> node = new Node<>(10);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.quickSortInLinkedList(node);
        //......................................................................
//        Row: 339
//        System.out.println("K-th largest element in array");
//        obj.kLargestElementInArray(new int[]{12, 5, 787, 1, 23}, 2);
//        obj.kLargestElementInArray(new int[]{1, 23, 12, 9, 30, 2, 50}, 3);
//        System.out.println("Find the Kth Largest Integer in the String Nums Array");
//        //https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/description/
//        obj.kLargestElementInStringNumsArray(new String[]{"3", "6", "7", "10"}, 4);
//        obj.kLargestElementInStringNumsArray(new String[]{"2", "21", "12", "1"}, 3);
//        obj.kLargestElementInStringNumsArray(new String[]{"0", "0"}, 2);
//        obj.kLargestElementInStringNumsArray(new String[]{"300", "601", "70", "1"}, 4);
//        obj.kLargestElementInStringNumsArray(new String[]{"301", "302", "303", "300", "0", "0"}, 3);
        //......................................................................
//        Row: 20, 70
//        System.out.println("Next permutation");
//        //https://leetcode.com/problems/next-permutation
//        obj.nextPermutation(new int[]{1,2,3});
//        obj.nextPermutation(new int[]{4,3,2,1});
//        obj.nextPermutation(new int[]{1,3,1,4,7,6,2});
//        obj.nextPermutation(new int[]{2,7,4,3,2});
//        obj.nextPermutation(new int[]{1, 2, 3, 6, 5, 4});
        //......................................................................
//        Row: 27
//        System.out.println("Factorial of large number");
//        //https://www.geeksforgeeks.org/factorial-large-number/
//        obj.factorialLargeNumber(1);
//        obj.factorialLargeNumber(5);
//        obj.factorialLargeNumber(10);
//        obj.factorialLargeNumber(897);
        //......................................................................
//        Row: 103
//        System.out.println("Search in rotated sorted array");
//        //https://leetcode.com/problems/search-in-rotated-sorted-array
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 0));
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 4));
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 3));
//        //https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{1,0,1,1,1}, 0));
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{2,5,6,0,0,1,2}, 0));
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{2,5,6,0,0,1,2}, 3));
        //......................................................................
//        Row: 146
//        System.out.println("Move last node of linked list to front");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.moveLastNodeToFrontOfLinkedList(node);
        //......................................................................
//        Row: 147
//        System.out.println("Plus One Linked List");
//        //https://leetcode.com/problems/plus-one-linked-list/description/
//        //https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/description/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        obj.addOneToLinkedList(node);
//        node = new Node<>(9); //COND WHEN METHOD WILL CREATE NEWHEAD TO STORE EXTRA CARRY IN THE SUM RECURSION
//        node.setNext(new Node<>(9));
//        node.getNext().setNext(new Node<>(9));
//        node.getNext().getNext().setNext(new Node<>(9));
//        obj.addOneToLinkedList(node);
        //......................................................................
//        Row: 167
//        System.out.println("Sort linked list of 0s, 1s, 2s using 2 approaches");
//        //https://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/
//        Node<Integer> node = new Node<>(0);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        new LinkedListUtil<>(obj.mergeSortDivideAndMerge(node)).print(); //SIMPLE MERGE SORT APPROACH T: O(N.LogN)
//        node = new Node<>(0);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        obj.sortLinkedListOf012_2(node); //SIMPLE MANIPULATION OF NODE T: O(N)
        //......................................................................
//        Row: 202
//        System.out.println("Sum of node on the longest path of tree from root to leaf");
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.getLeft().getRight().setLeft(new TreeNode<>(6)); //LONGEST PATH
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(3));
//        obj.longestPathNodeSum(root);
        //......................................................................
//        Row: 34
//        System.out.println("Rain water trapping 2 approaches");
//        //https://leetcode.com/problems/trapping-rain-water/
//        obj.rainWaterTrappingUsingStack(new int[]{3,0,0,2,0,4});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{3,0,0,2,0,4});
//        obj.rainWaterTrappingUsingStack(new int[]{6,9,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{6,9,9});
//        obj.rainWaterTrappingUsingStack(new int[]{7,4,0,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{7,4,0,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{3,4,1});
        //......................................................................
//        Row: 28
//        System.out.println("Find maximum product subarray");
//        //https://leetcode.com/problems/maximum-product-subarray/
//        obj.findMaximumProductSubarray(new int[]{2,3,-2,4});
//        obj.findMaximumProductSubarray(new int[]{-2,0,-1});
//        obj.findMaximumProductSubarray(new int[]{-1,8});
//        obj.findMaximumProductSubarray(new int[]{-1,-8});
        //......................................................................
//        Row: 217
//        System.out.println("Find predecessor and successor of given node in BST");
//        //https://leetcode.com/problems/inorder-successor-in-bst/description/
//        //https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/
//        //predecessors and successor can be found when we do the inorder traversal of tree
//        //inorder traversal of BST is sorted list of node data
//        //for below BST inorder list [0,2,3,4,5,6,7,8,9]
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.findPredecessorAndSuccessorInBST(root1, 6);
//        obj.findPredecessorAndSuccessorInBST(root1, 2);
//        obj.findPredecessorAndSuccessorInBST(root1, 5);
//        obj.findPredecessorAndSuccessorInBST(root1, 10); //ONLY PREDECESSOR IS POSSIBLE
//        obj.findPredecessorAndSuccessorInBST(root1, -1); //ONLY SUCCESSOR IS POSSIBLE
        //......................................................................
//        Row: 424, 64
//        System.out.println("Longest Repeating Subsequence DP problem");
//        System.out.println("Longest repeating subsequence: "+obj.longestRepeatingSubsequence_Recursion("axxxy", 5)); //xx, xx
//        obj.longestRepeatingSubsequence_DP_Memoization("axxxy"); //xx, xx
        //......................................................................
//        Row: 441
//        System.out.println("Longest common substring DP problem");
//        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
//        obj.longestCommonSubstring_DP_Memoization("ABCDGH", "ACDGHR");
        //......................................................................
//        Row: 441
//        System.out.println("Maximum length of pair chain 2 approaches");
//        //https://leetcode.com/problems/maximum-length-of-pair-chain/
//        System.out.println("maximum length of pair chain DP approach: "+
//                obj.maximumLengthOfPairChain_DP_Approach(new int[][]{
//                    {1,2},
//                    {3,4},
//                    {2,3}}));
//        System.out.println("maximum length of pair chain Greedy approach: "+
//                obj.maximumLengthOfPairChain_Greedy_Approach(new int[][]{
//                    {1,2},
//                    {3,4},
//                    {2,3}}));
        //......................................................................
//        Row: 412
//        System.out.println("Binomial coefficient DP problem");
//        //https://www.geeksforgeeks.org/binomial-coefficient-dp-9/
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 2));
//        obj.findBinomialCoefficient_DP_Memoization(5, 2);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 6));
//        obj.findBinomialCoefficient_DP_Memoization(5, 6);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 5));
//        obj.findBinomialCoefficient_DP_Memoization(5, 5);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 0));
//        obj.findBinomialCoefficient_DP_Memoization(5, 0);
        //......................................................................
//        Row: 229
//        System.out.println("Count BST nodes that lie in the given range");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.countNodesThatLieInGivenRange(root1, 1, 4);
//        obj.countNodesThatLieInGivenRange(root1, 6, 9);
        //......................................................................
//        Row: 235
//        System.out.println("Flatten BST to linked list (skewed tree)");
//        //https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
//        //https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.flattenBSTToLinkedList(root1);
//        //obj.flattenBSTToLinkedList_Recursion(root1);
        //......................................................................
//        Row: 158
//        System.out.println("Reverse a doubly linked list");
//        Node<Integer> node = new Node<>(3);
//        Node<Integer> next = new Node<>(4);
//        node.setNext(next);
//        next.setPrevious(node);
//        Node<Integer> nextToNext = new Node<>(5);
//        next.setNext(nextToNext);
//        nextToNext.setPrevious(next);
//        obj.reverseDoublyLinkedList(node);
        //......................................................................
//        Row: 18, 13
//        System.out.println("Kaden's algorithm approaches");
//        //https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
//        int[] a = new int[]{-2, -3, 4, -1, -2, 1, 5, -3};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{-1, -2, -3, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{-1, -2, 0, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{1, 2, -3, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
        //......................................................................
//        Row: 10
//        System.out.println("Move all negative elements to one side of array");
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-12, 11, -13, -5, 6, -7, 5, -3, -6});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-1, 2, -3, 4, 5, 6, -7, 8, 9});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-1, -2, -3, -1, -10, -7});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{1, 2, 3, 1, 10, 7});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{1, -2, -3, -1, -10, -7});
        //......................................................................
//        Row: 11
//        System.out.println("Find union and intersection of two arrays");
//        obj.findUnionAndIntersectionOfTwoArrays(new int[]{1,2,3,4,5}, new int[]{1,2,3});
//        obj.findUnionAndIntersectionOfTwoArrays(new int[]{4,9,5}, new int[]{9,4,9,8,4});
        //......................................................................
//        Row: 12
//        System.out.println("Cyclically rotate element in array by 1");
//        //https://leetcode.com/problems/rotate-array/
//        obj.rotateArrayByK_BruteForce(new int[]{1, 2, 3, 4, 5}, 1);
//        obj.rotateArrayByK_BruteForce(new int[]{1, 2, 3, 4, 5}, 4);
//        obj.rotateArrayByK(new int[]{1, 2, 3, 4, 5}, 1);
//        obj.rotateArrayByK(new int[]{1, 2, 3, 4, 5}, 4);
        //......................................................................
//        Row: 14
//        System.out.println("Minimize the difference between the heights");
//        //https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/
//        obj.minimizeDifferenceBetweenHeights(new int[]{1, 5, 8, 10}, 2);
//        obj.minimizeDifferenceBetweenHeights(new int[]{4, 6}, 10);
        //......................................................................
//        Row: 191
//        System.out.println("Diagonal traversal of tree");
//        //https://www.geeksforgeeks.org/diagonal-traversal-of-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.diagonalTraversalOfTree(root1);
        //......................................................................
//        Row: 180
//        System.out.println("Diameter of tree DP on tree problem");
//        //https://leetcode.com/problems/diameter-of-binary-tree/
//        //https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/
//        //https://practice.geeksforgeeks.org/problems/diameter-of-binary-tree/1/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.diameterOfTree(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.getLeft().getRight().setRight(new TreeNode<>(5));
//        obj.diameterOfTree(root1);
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("N meeting in a room/ Activity selection");
//        //https://practice.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1
//        obj.nMeetingRooms_Greedy(new int[]{1, 3, 0, 5, 8, 5}, new int[]{2, 4, 6, 7, 9, 9});
//        System.out.println("Meeting Rooms");
//        //https://leetcode.com/problems/meeting-rooms/description/
//        System.out.println("Meeting rooms, Can take all meetings ? : "
//                + obj.meetingRooms_Greedy(new int[][]{}));
//        System.out.println("Meeting rooms, Can take all meetings ? : "
//                + obj.meetingRooms_Greedy(new int[][]{{0, 30}, {5, 10}, {15, 20}}));
//        System.out.println("Meeting rooms, Can take all meetings ? : "
//                + obj.meetingRooms_Greedy(new int[][]{{7, 10}, {2, 4}}));
//        System.out.println("Meeting rooms, Can take all meetings ? : "
//                + obj.meetingRooms_Greedy(new int[][]{{1, 13}, {13, 15}}));
//        System.out.println("Meeting Rooms II");
//        //https://leetcode.com/problems/meeting-rooms-ii/description/
//        obj.meetingRoomTwo_Greedy(new int[][]{{0, 30}, {5, 10}, {15, 20}});
//        obj.meetingRoomTwo_Greedy(new int[][]{{7, 10}, {2, 4}});
//        obj.meetingRoomTwo_Greedy(new int[][]{{26, 29}, {19, 26}, {19, 28}, {4, 19}, {4, 25}});
        //......................................................................
//        Row: 357, 358
//        System.out.println("BFS/DFS directed graph");
//        //https://leetcode.com/problems/employee-importance/
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList());
//        adjList.add(2, Arrays.asList(4));
//        adjList.add(3, Arrays.asList());
//        adjList.add(4, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(5));
//        adjList.add(2, Arrays.asList(4));
//        adjList.add(3, Arrays.asList());
//        adjList.add(4, Arrays.asList(3));
//        adjList.add(5, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList(3));
//        adjList.add(3, Arrays.asList(4));
//        adjList.add(4, Arrays.asList(5));
//        adjList.add(5, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
        //......................................................................
//        Row: 361, 275
//        System.out.println("Search in maze");
//        int[][] maze = new int[][]{
//            {1, 0, 0, 0},
//            {1, 1, 0, 1},
//            {1, 1, 0, 0},
//            {0, 1, 1, 1}
//        };
//        obj.findPathRatInMaze_Graph(maze, maze.length);
//        maze = new int[][]{
//            {1, 0, 0, 0},
//            {1, 1, 0, 1},
//            {1, 1, 0, 0},
//            {0, 1, 1, 0}
//        };
//        obj.findPathRatInMaze_Graph(maze, maze.length);
        //......................................................................
//        Row: 371
//        System.out.println("No. of Island");
//        //https://leetcode.com/problems/number-of-islands
//        //https://leetcode.com/problems/battleships-in-a-board/
//        //https://leetcode.com/problems/max-area-of-island/
//        //https://leetcode.com/problems/number-of-enclaves/
//        int[][] grid = {
//            {0, 1, 1, 1, 0, 0, 0},
//            {0, 0, 1, 1, 0, 1, 0}};
//        obj.numberOfIslands_Graph(grid);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Closed Islands");
//        //https://leetcode.com/problems/number-of-closed-islands/description/
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {1, 1, 1, 1, 1, 1, 1, 0},
//            {1, 0, 0, 0, 0, 1, 1, 0},
//            {1, 0, 1, 0, 1, 1, 1, 0},
//            {1, 0, 0, 0, 0, 1, 0, 1},
//            {1, 1, 1, 1, 1, 1, 1, 0}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {0, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 1, 1, 1, 0}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {1, 1, 1, 1, 1, 1, 1},
//            {1, 0, 0, 0, 0, 0, 1},
//            {1, 0, 1, 1, 1, 0, 1},
//            {1, 0, 1, 0, 1, 0, 1},
//            {1, 0, 1, 1, 1, 0, 1},
//            {1, 0, 0, 0, 0, 0, 1},
//            {1, 1, 1, 1, 1, 1, 1}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {0, 1, 1, 1, 1, 1, 1, 1},
//            {1, 0, 1, 0, 0, 0, 0, 1},
//            {1, 0, 0, 0, 0, 1, 0, 1},
//            {0, 1, 0, 0, 0, 1, 0, 1},
//            {1, 0, 0, 1, 0, 1, 0, 1},
//            {1, 1, 1, 1, 0, 0, 1, 1},
//            {1, 0, 0, 0, 0, 0, 1, 1},
//            {0, 1, 1, 1, 1, 1, 1, 1}});
        //......................................................................
//        Row: 348
//        System.out.println("Check if binary tree is heap (max heap)");
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(4));
//        obj.checkIfBinaryTreeIsMaxHeap(root);
//        root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(9));
//        obj.checkIfBinaryTreeIsMaxHeap(root);
//        root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(4));
//        root.getRight().setRight(new TreeNode<>(3));
//        obj.checkIfBinaryTreeIsMaxHeap(root);
        //......................................................................
//        Row: 91
//        System.out.println("Arrange all anagrams together");
//        obj.arrangeAllWordsAsTheirAnagrams(Arrays.asList("act", "god", "cat", "dog", "tac"));
        //......................................................................
//        Row: 90
//        System.out.println("Minimum character added at front of string to make it pallindrome/ Shortest pallindrome");
//        //https://leetcode.com/problems/shortest-palindrome
//        //https://leetcode.com/problems/longest-happy-prefix/
//        obj.characterAddedAtFrontToMakeStringPallindrome("ABC"); // 2 char = B,C (ex CBABC)
//        obj.characterAddedAtFrontToMakeStringPallindrome("ABA"); // 0 char already pallindrome
//        obj.shortestPallindrome("a");
//        obj.shortestPallindrome("aacecaaa");
//        obj.shortestPallindrome("abcd");
//        obj.shortestPallindrome("aaaa");
        //......................................................................
//        Row: 360
//        System.out.println("Detect cycle in undirected graph DFS");
//        //https://www.geeksforgeeks.org/detect-cycle-undirected-graph/
//        List<List<Integer>> adjList = new ArrayList<>(); //CYCLE //0 <--> 1 <--> 2 <--> 0
//        adjList.add(0, Arrays.asList(1, 2));
//        adjList.add(1, Arrays.asList(0, 2));
//        adjList.add(2, Arrays.asList(0, 1));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //NO CYCLE 0 <--> 1 <--> 2
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(0, 2));
//        adjList.add(2, Arrays.asList(1));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE //FAIL CASE // 0 <--> 1 //CASE OF DIRECTED GRAPH
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(0));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
        //......................................................................
//        Row: 368
//        System.out.println("Topological sort graph");
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList());
//        adjList.add(1, Arrays.asList());
//        adjList.add(2, Arrays.asList(3));
//        adjList.add(3, Arrays.asList(1));
//        adjList.add(4, Arrays.asList(0,1));
//        adjList.add(5, Arrays.asList(0,2));
//        obj.topologicalSort_Graph(adjList.size(), adjList);
        //......................................................................
//        Row: 439
//        System.out.println("Minimum cost to fill the given bag");
//        //https://www.geeksforgeeks.org/minimum-cost-to-fill-given-weight-in-a-bag/
//        obj.minimumCostToFillGivenBag_DP_Memoization(new int[]{20, 10, 4, 50, 100}, 5);
//        obj.minimumCostToFillGivenBag_DP_Memoization(new int[]{-1, -1, 4, 3, -1}, 5);
        //......................................................................
//        Row: 22
//        System.out.println("Best time to buy and sell stock");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
//        obj.bestProfitToBuySellStock(new int[]{7,1,5,3,6,4});
//        obj.bestProfitToBuySellStock(new int[]{7,6,4,3,1});
        //......................................................................
//        System.out.println("Maximum profit by buying seling stocks,"
//                + "can hold stock atmost one but can buy/sell same stock in same day");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{2, 30, 15, 10, 8, 25, 80});
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{2, 30, 80, 10, 8, 25, 60});
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{3, 3, 5, 0, 0, 3, 1, 4});
        //......................................................................
//        Row: 31
//        System.out.println("Maximum profit by buying seling stocks atmost twice");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{2, 30, 15, 10, 8, 25, 80});
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{2, 30, 80, 10, 8, 25, 60});
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{3, 3, 5, 0, 0, 3, 1, 4});
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock IV");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
//        obj.buyAndSellStocksAtMostkTimes_Recursive_Memoization(new int[]{2, 4, 1}, 2);
//        obj.buyAndSellStocksAtMostkTimes_Recursive_Memoization(new int[]{3, 2, 6, 5, 0, 3}, 2);
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock with Cooldown");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
//        obj.buySellStocksWithCooldown_Recursive_Memoization(new int[]{1, 2, 3, 0, 2});
//        obj.buySellStocksWithCooldown_Recursive_Memoization(new int[]{1});
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock with Transaction Fee");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
//        obj.buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(new int[]{1, 3, 2, 8, 4, 9}, 2);
//        obj.buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(new int[]{1, 3, 7, 5, 10, 3}, 3);
//        obj.buySellStocksWithTransactionFeeOnSell_DP_Memoization(new int[]{1, 3, 2, 8, 4, 9}, 2);
//        obj.buySellStocksWithTransactionFeeOnSell_DP_Memoization(new int[]{1, 3, 7, 5, 10, 3}, 3);
        //......................................................................
//        Row: 23
//        System.out.println("Find all pairs in array whose sum is given to K");
//        //https://www.geeksforgeeks.org/count-pairs-with-given-sum/
//        obj.countAllPairsInArrayThatSumIsK(new int[]{1, 5, 7, 1}, 6);
//        obj.countAllPairsInArrayThatSumIsK(new int[]{1, 1, 1, 1}, 2);
        //......................................................................
//        Row: 60
//        System.out.println("Check if one string is rotation of other string");
//        //https://www.geeksforgeeks.org/a-program-to-check-if-strings-are-rotations-of-each-other/
//        System.out.println("Check if one string is rotation: "+obj.checkIfOneStringRotationOfOtherString("AACD", "ACDA"));
        //......................................................................
//        Row: 312
//        System.out.println("Largest area of histogram");
//        //https://leetcode.com/problems/largest-rectangle-in-histogram
//        //https://www.geeksforgeeks.org/largest-rectangle-under-histogram/
//        obj.largestAreaInHistogram(new int[]{6, 2, 5, 4, 5, 1, 6});
//        obj.largestAreaInHistogram(new int[]{6,9,8});
        //......................................................................
//        Row: 418
//        System.out.println("Friends pairing DP problem");
//        //https://www.geeksforgeeks.org/friends-pairing-problem/
//        System.out.println("No. of ways friends can be paired recursion: "+obj.friendsPairingProblem_Recursion(4));
//        obj.friendsPairingProblem_DP_Memoization(4);
//        obj.friendsPairingProblem(4);
        //......................................................................
//        Row: 341
//        System.out.println("Merge k sorted arrays (heap)");
//        int[][] arr = new int[][]{
//            {1,2,3},
//            {4,5,6},
//            {7,8,9}
//        };
//        obj.mergeKSortedArrays_1(arr);
//        obj.mergeKSortedArrays_2(arr);
        //......................................................................
//        Row: 343
//        System.out.println("Kth largest sum from contigous subarray");
//        //https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/
//        obj.kThLargestSumFromContigousSubarray(new int[]{10, -10, 20, -40}, 6);
//        obj.kThLargestSumFromContigousSubarray(new int[]{20, -5, -1}, 3);
        //......................................................................
//        Row: 329
//        System.out.println("Check if all levels in two trees are anagrams of each other");
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(7));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(2));
//        root2.setRight(new TreeNode<>(3));
//        root2.getRight().setLeft(new TreeNode<>(4));
//        root2.getRight().setRight(new TreeNode<>(5));
//        root2.getRight().getRight().setLeft(new TreeNode<>(6));
//        root2.getRight().getRight().setRight(new TreeNode<>(7));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
        //......................................................................
//        Row: 149
//        System.out.println("Intersection of two sorted linked list");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        Node<Integer> node2 = new Node<>(2);
//        node2.setNext(new Node<>(4));
//        node2.getNext().setNext(new Node<>(4));
//        node2.getNext().getNext().setNext(new Node<>(6));
//        node2.getNext().getNext().getNext().setNext(new Node<>(7));
//        obj.intersectionOfTwoSortedLinkedList(node, node2);
        //......................................................................
//        Row: 26
//        System.out.println("Check if any sub array with sum 0 is present or not");
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{4, 2, -3, 1, 6}));
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{2, -3, 1}));
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{4, 2, 0, -1}));
        //......................................................................
//        Row: 107, 16
//        System.out.println("Find repeating and missing in unsorted array");
//        //https://leetcode.com/problems/set-mismatch/
//        //https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/
//        //https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
//        obj.findRepeatingAndMissingInUnsortedArray_1(new int[]{7, 3, 4, 5, 5, 6, 2 });
//        obj.findRepeatingAndMissingInUnsortedArray_1(new int[]{3,1,3});
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{7, 3, 4, 5, 5, 6, 2 });
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{3,1,3});
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{4,3,2,7,8,2,3,1});
        //......................................................................
//        Row: 110
//        System.out.println("Check if any pair possible in an array having given difference");
//        System.out.println("Check if any pair is possible in the array having given diff: "+
//                obj.checkIfPairPossibleInArrayHavingGivenDiff(new int[]{5, 20, 3, 2, 5, 80}, 78));
//        System.out.println("Check if any pair is possible in the array having given diff: "+
//                obj.checkIfPairPossibleInArrayHavingGivenDiff(new int[]{90, 70, 20, 80, 50}, 45));
        //......................................................................
//        Row: 150
//        System.out.println("Intersection point in two given linked list (by ref linkage) 2 approach");
//        //https://leetcode.com/problems/intersection-of-two-linked-lists
//        Node<Integer> common = new Node<>(15);
//        common.setNext(new Node<>(30));
//        Node<Integer> node1 = new Node<>(3);
//        node1.setNext(new Node<>(9));
//        node1.getNext().setNext(new Node<>(6));
//        node1.getNext().getNext().setNext(common);
//        Node<Integer> node2 = new Node<>(10);
//        node2.setNext(common);
//        obj.intersectionPointOfTwoLinkedListByRef(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_HashBased(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_Iterative(node1, node2);
//        common = new Node<>(4);
//        common.setNext(new Node<>(5));
//        common.getNext().setNext(new Node<>(6));
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().setNext(common);
//        node2 = new Node<>(10);
//        node2.setNext(new Node<>(20));
//        node2.getNext().setNext(common);
//        obj.intersectionPointOfTwoLinkedListByRef(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_HashBased(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_Iterative(node1, node2);
        //......................................................................
//        Row: 359
//        System.out.println("Detect cycle in directed graph using DFS");
//        //https://www.geeksforgeeks.org/detect-cycle-in-a-graph/
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1)); //CYCLE 0 --> 1 --> 2 --> 0
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList(0));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //NO CYCLE // 0 --> 1 --> 2
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList());
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE // 0 --> 1 --> 0
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(0));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE // disjoint graph 0 --> 1 --> 2 | 3 --> 4 --> 5 --> 3
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList());
//        adjList.add(3, Arrays.asList(4));
//        adjList.add(4, Arrays.asList(5));
//        adjList.add(5, Arrays.asList(3));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
        //......................................................................
//        Row: 363
//        System.out.println("Flood fill");
//        //https://leetcode.com/problems/flood-fill/
//        int[][] image = new int[][]{
//            {1,1,1},
//            {1,1,0},
//            {1,0,1}
//        };
//        obj.floodFill(image, 1, 1, 2);
//        image = new int[][]{
//            {0,0,0},
//            {0,0,0}
//        };
//        obj.floodFill(image, 0, 0, 2);
//        image = new int[][]{
//            {0,0,0,0,0},
//            {0,1,1,1,0},
//            {0,1,1,1,0},
//            {0,1,1,1,0},
//            {0,0,0,0,0},
//        };
//        obj.floodFill(image, 2, 2, 3);
//        image = new int[][]{
//            {0,0,0},
//            {0,1,1},
//        };
//        obj.floodFill(image, 1, 1, 1); //Edge case could have caused StackOverflowError, visited[][] helped
        //......................................................................
//        Row: 49
//        System.out.println("Maximum size of rectangle in binary matrix");
//        //https://leetcode.com/problems/maximal-rectangle
//        int[][] mat = new int[][]{
//            {0, 1, 1, 0},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 0, 0},};
//        obj.maxAreaOfRectangleInBinaryMatrix(mat);
//        mat = new int[][]{
//            {0, 0, 0, 0},
//            {0, 1, 1, 0},
//            {0, 1, 1, 0},
//            {0, 0, 0, 0},};
//        obj.maxAreaOfRectangleInBinaryMatrix(mat);
        //......................................................................
//        Row: 19
//        System.out.println("Merge intervals");
//        //https://leetcode.com/problems/merge-intervals/
//        obj.mergeIntervals1(new int[][]{{1, 3}, {2, 6}, {8, 10}, {15, 18}});
//        obj.mergeIntervals2(new int[][]{{1, 3}, {2, 6}, {8, 10}, {15, 18}});
//        obj.mergeIntervals1(new int[][]{{1, 4}, {4, 5}});
//        obj.mergeIntervals2(new int[][]{{1, 4}, {4, 5}});
//        obj.mergeIntervals1(new int[][]{{1, 4}, {0, 4}});
//        obj.mergeIntervals2(new int[][]{{1, 4}, {0, 4}});
//        obj.mergeIntervals1(new int[][]{{1, 7}, {2, 5}});
//        obj.mergeIntervals2(new int[][]{{1, 7}, {2, 5}});
//        System.out.println("Non-overlapping Intervals");
//        //https://leetcode.com/problems/non-overlapping-intervals/
//        obj.nonOverlappingIntervals(new int[][]{{1, 2}, {2, 3}, {3, 4}, {1, 3}});
//        obj.nonOverlappingIntervals(new int[][]{{1, 2}, {1, 2}, {1, 2}});
//        obj.nonOverlappingIntervals(new int[][]{{1, 2}, {2, 3}});
//        obj.nonOverlappingIntervals(new int[][]{{1, 10}, {2, 3}, {3, 4}, {4, 7}});
        //......................................................................
//        Row: 47
//        System.out.println("Row with maximum 1s in the matrix");
//        //https://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/
//        int[][] mat = new int[][]{
//            {0, 1, 1, 1},
//            {0, 0, 1, 1},
//            {1, 1, 1, 1},
//            {0, 0, 0, 0}
//        };
//        obj.maximumOnesInRowOfABinarySortedMatrix_1(mat);
//        obj.maximumOnesInRowOfABinarySortedMatrix_2(mat); //OPTIMISED
//        mat = new int[][]{
//            {0, 0, 0, 0}
//        };
//        obj.maximumOnesInRowOfABinarySortedMatrix_1(mat);
//        obj.maximumOnesInRowOfABinarySortedMatrix_2(mat); //OPTIMISED
        //......................................................................
//        Row: 45
//        System.out.println("Find a value in row wise sorted matrix");
//        //https://leetcode.com/problems/search-a-2d-matrix-ii/
//        int[][] mat = new int[][]{
//            {1, 3, 5, 7},
//            {10, 11, 16, 20},
//            {23, 30, 34, 60}
//        };
//        obj.findAValueInRowWiseSortedMatrix(mat, 13);
//        mat = new int[][]{
//            {1, 3, 5, 7},
//            {10, 11, 16, 20},
//            {23, 30, 34, 60}
//        };
//        obj.findAValueInRowWiseSortedMatrix(mat, 11);
        //......................................................................
//        Row: 65
//        System.out.println("Print all subsequences of the given string");
//        //https://www.geeksforgeeks.org/print-subsequences-string/
//        obj.printAllSubSequencesOfAString("abc");
//        obj.printAllSubSequencesOfAString("aaaa");
        //......................................................................
//        Row: 44
//        System.out.println("Spiral matrix traversal");
//        //https://leetcode.com/problems/spiral-matrix/description/
//        //https://leetcode.com/problems/spiral-matrix-ii/description/
//        //https://leetcode.com/problems/spiral-matrix-iv/description/
//        int[][] mat = new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12},
//            {13, 14, 15, 16}
//        };
//        obj.spiralMatrixTraversal(mat);
//        mat = new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12}
//        };
//        obj.spiralMatrixTraversal(mat);
//        System.out.println("Spiral matrix traversal three");
//        //https://leetcode.com/problems/spiral-matrix-iii/description/
//        obj.spriralMatrixTraversalThree(1, 4, 0, 0);
//        obj.spriralMatrixTraversalThree(5, 6, 1, 4);
        //......................................................................
//        Row: 156
//        System.out.println("Check singly linked list is pallindrome or not");
//        //https://leetcode.com/problems/palindrome-linked-list
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(1));
//        System.out.println("Is linked list pallindrome: "+obj.checkIfLinkedListPallindrome_1(node));
//        System.out.println("Is linked list pallindrome OPTIMISED: "+obj.checkIfLinkedListPallindrome_2(node));
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        System.out.println("Is linked list pallindrome: "+obj.checkIfLinkedListPallindrome_1(node));
//        System.out.println("Is linked list pallindrome OPTIMISED: "+obj.checkIfLinkedListPallindrome_2(node));
        //......................................................................
//        Row: 71, 301
//        System.out.println("Balanced parenthesis evaluation");
//        //https://leetcode.com/problems/valid-parentheses/
//        System.out.println(obj.balancedParenthesisEvaluation("()"));
//        System.out.println(obj.balancedParenthesisEvaluation("({[]})"));
//        System.out.println(obj.balancedParenthesisEvaluation(")}]"));
//        System.out.println(obj.balancedParenthesisEvaluation("({)}"));
        //......................................................................
//        Row: 104
//        System.out.println("Square root of a number");
//        //https://leetcode.com/problems/sqrtx/
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(4));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(1));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(3));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(1.5));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(4));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(1));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(3));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(2));
        //......................................................................
//        Row: 211
//        System.out.println("Tree isomorphic (Flip Equivalent Binary Trees)");
//        //https://leetcode.com/problems/flip-equivalent-binary-trees/
//        //https://www.geeksforgeeks.org/tree-isomorphism-problem/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.getLeft().setLeft(new TreeNode<>(4));
//        root2.setRight(new TreeNode<>(2));
//        System.out.println("Are two tres isomorphic: "+obj.areTwoTreeIsoMorphic(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Are two tres isomorphic: "+obj.areTwoTreeIsoMorphic(root1, root2));
        //......................................................................
//        Row: 210
//        System.out.println("Duplicate subtrees in a tree");
//        //https://leetcode.com/problems/find-duplicate-subtrees
//        //https://leetcode.com/problems/construct-string-from-binary-tree/
//        //https://www.geeksforgeeks.org/find-duplicate-subtrees/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(4));
//        obj.findDuplicateSubtreeInAGivenTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all the nodes that are at K distance from the target node");
//        //https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
//        //https://leetcode.com/problems/closest-leaf-in-a-binary-tree/description/
//        //https://practice.geeksforgeeks.org/problems/kth-ancestor-in-a-tree/1
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(5));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setLeft(new TreeNode<>(0));
//        root1.getRight().setRight(new TreeNode<>(8));
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 5, 2);
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 3, 3);
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 6, 3);
        //......................................................................
//        Row: 39
//        System.out.println("Minimum no of operations required to make an array pallindrome");
//        obj.minOperationsToMakeArrayPallindrome(new int[]{10, 15, 10});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 4, 5, 9, 1});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 2, 3, 4});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 2});
        //......................................................................
//        Row: 112
//        System.out.println("maximum sum such that no 2 elements are adjacent / Stickler thief DP problem");
//        //https://leetcode.com/problems/house-robber
//        int[] houses = new int[]{5, 5, 10, 100, 10, 5};
//        obj.sticklerThief_Recursive_Memoization(houses);
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        houses = new int[]{1, 2, 3};
//        obj.sticklerThief_Recursive_Memoization(houses);
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        houses = new int[]{5};
//        obj.sticklerThief_Recursive_Memoization(houses);
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        //https://leetcode.com/problems/house-robber-ii
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{2, 3, 2});
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{1, 2, 3});
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{1, 2, 3, 1});
//        //https://leetcode.com/problems/house-robber-iii/
//        TreeNode<Integer> root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(1));
//        obj.sticklerThiefThree_DP_Memoization(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(1));
//        obj.sticklerThiefThree_DP_Memoization(root);
        //......................................................................
//        Row: 203
//        System.out.println("Check if given undirected graph is a binary tree or not");
//        //https://www.geeksforgeeks.org/check-given-graph-tree/#:~:text=Since%20the%20graph%20is%20undirected,graph%20is%20connected%2C%20otherwise%20not.
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0, 2)); // CYCLE 0 <--> 1 <--> 2
//        adjList.add(2, Arrays.asList(0, 1));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3, 5, 6)); // CYCLE 4 <--> 5 <--> 6 but not starting with 0
//        adjList.add(5, Arrays.asList(4, 6));
//        adjList.add(6, Arrays.asList(4, 5));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0));
//        adjList.add(4, Arrays.asList(5, 6)); // CYCLE 4 <--> 5 <--> 6 but 3 <--> 4 not connected
//        adjList.add(5, Arrays.asList(4, 6));
//        adjList.add(6, Arrays.asList(4, 5));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0));
//        adjList.add(4, Arrays.asList()); // vertex 4 is not connected(3 <--> 4 not connected)
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
        //......................................................................
//        Row: 174
//        System.out.println("First non repeating character from the stream of character");
//        obj.firstNonRepeatingCharacterFromStream("geeksforgeeksandgeeksquizfor");
//        obj.firstNonRepeatingCharacterFromStream("aaaaa");
//        obj.firstNonRepeatingCharacterFromStream("abcd");
//        obj.firstNonRepeatingCharacterFromStream("aabbccdd");
        //......................................................................
//        Row: 425
//        System.out.println("Longest increasing subsequence");
//        //https://leetcode.com/problems/longest-increasing-subsequence
//        //https://leetcode.com/problems/number-of-longest-increasing-subsequence
//        //https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/
//        int[] arr = new int[]{10, 22, 9, 33, 21, 50, 41, 60}; //LONGEST INC SEQ 10, 22, 33, 50, 60: length = 5
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
//        arr = new int[]{3, 10, 2, 1, 20};
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
//        arr = new int[]{3, 2};
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
//        arr = new int[]{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}; //LONGEST INC SEQ 0, 2, 6, 9, 13, 15: length 6
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
//        arr = new int[]{5,8,7,1,9}; //LONGEST INC SEQ 5,8,9 or 5,7,9
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
//        arr = new int[]{5};
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        obj.longestIncreasingSubsequence2_DP_Memoization(arr, arr.length);
        //......................................................................
//        Row: 425
//        System.out.println("Maximum sum increasing subsequence");
//        //https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/
//        //Max sum & also Incr subseq: [1,2,4,100] = 106
//        obj.maxSumIncreasingSubsequence_DP_Memoization(new int[]{1, 101, 2, 3, 100, 4, 5});
//        //Max sum & also Incr subseq: [3,10,20] = 33
//        obj.maxSumIncreasingSubsequence_DP_Memoization(new int[]{3, 10, 2, 1, 20});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pair of movie watching during a flight");
//        //problem: https://www.geeksforgeeks.org/amazon-interview-experience-sde-2-10/
//        //solution: https://leetcode.com/discuss/interview-question/313719/Amazon-Online-Assessment-2019-Tho-sum-closest/291502
//        obj.pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(new int[]{90, 85, 75, 60, 120, 150, 125}, 250);
//        obj.pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(new int[]{27, 1,10, 39, 12, 52, 32, 67, 76}, 77);
        //......................................................................
//        Row: 261
//        System.out.println("Choclate distributions");
//        //https://www.geeksforgeeks.org/chocolate-distribution-problem/
//        System.out.println("Min diff in distribution of choclates among the students: "
//                +obj.choclateDistribution_Greedy(new int[]{12, 4, 7, 9, 2, 23,
//                    25, 41, 30, 40, 28,
//                    42, 30, 44, 48, 43,
//                   50}, 7));
//        System.out.println("Min diff in distribution of choclates among the students: "
//                +obj.choclateDistribution_Greedy(new int[]{7, 3, 2, 4, 9, 12, 56}, 3));
        //......................................................................
//        Row: 123
//        System.out.println("Kth element in 2 sorted array 2 approaches");
//        //https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/
//        obj.kThElementInTwoSortedArrays_1(new int[]{2, 3, 6, 7, 9 }, new int[]{1, 4, 8, 10}, 5);
//        obj.kThElementInTwoSortedArrays_2(new int[]{2, 3, 6, 7, 9 }, new int[]{1, 4, 8, 10}, 5); //OPTIMISED
        //......................................................................
//        Row: 72
//        System.out.println("Word break 1 and 2");
//        //https://leetcode.com/problems/word-break/
//        Set<String> set = new HashSet<>();
//        set.addAll(Arrays.asList("mobile","samsung","sam","sung","man","mango","icecream","and",
//                            "go","i","like","ice","cream"));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilikesamsung", set));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilike", set));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilikedhokhla", set));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("andicecreamhill", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilikesamsung", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilike", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilikedhokhla", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("andicecreamhill", set));
//        //https://leetcode.com/problems/word-break-ii/
//        obj.wordBreakTwo_Backtracking("catsanddog", new String[]{"cat","cats","and","sand","dog"});
//        //one 'd' is missing here
//        obj.wordBreakTwo_Backtracking("catsandog", new String[]{"cats","dog","sand","and","cat"});
//        obj.wordBreakTwo_Backtracking("aaaaaaa", new String[]{"aaaa","aa","a"});
        //......................................................................
//        Row: 245
//        System.out.println("Minimum platform needed");
//        //https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/
//        obj.minimumPlatformNeeded_BruteForce(new int[]{900, 940, 950, 1100, 1500, 1800},
//                new int[]{910, 1200, 1120, 1130, 1900, 2000});
//        obj.minimumPlatformNeeded_Greedy(new int[]{900, 940, 950, 1100, 1500, 1800},
//                new int[]{910, 1200, 1120, 1130, 1900, 2000});
        //......................................................................
//        Row: 242
//        System.out.println("Fractional knapsack");
//        //https://www.geeksforgeeks.org/fractional-knapsack-problem/
//        obj.fractionalKnapsack(new int[]{10,20,30}, new int[]{60, 100, 120}, 50);
//        obj.fractionalKnapsack(new int[]{10,20}, new int[]{60, 100}, 50);
//        obj.fractionalKnapsack(new int[]{60,70}, new int[]{60, 100}, 50);
        //......................................................................
//        Row: 326
//        System.out.println("Rotten oranges");
//        //https://leetcode.com/problems/rotting-oranges/
//        //Hash BASED: this approach rot all those oranges that are adjacent to a rotten orange in 1 unit of time
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {2, 1, 1}, {1, 1, 0}, {0, 1, 1}}));
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {2, 1, 1}, {0, 1, 1}, {1, 0, 1}}));
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {0, 2}}));
//        //DFS BASED: this approach rot all the oranges that are connected to a rotten orange
//        //this follows flood fill way
//        obj.rottenOranges_DFS(new int[][]{
//            {2, 1, 1}, {1, 1, 0}, {0, 1, 1}});
//        obj.rottenOranges_DFS(new int[][]{
//            {2, 1, 1}, {0, 1, 1}, {1, 0, 1}});
//        obj.rottenOranges_DFS(new int[][]{
//            {0, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT : MY AMAZON ONLINE ASSESSMENT
//        System.out.println("Robot rodeo/ Robot bounded in the circle");
//        //https://leetcode.com/problems/robot-bounded-in-circle/
//        //https://leetcode.com/problems/path-crossing/
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GGLLGG"));
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GG"));
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GL"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT : MY AMAZON ONLINE ASSESSMENT
//        System.out.println("Swaps required to sort the array");
//        //https://leetcode.com/discuss/interview-question/346621/Google-or-Phone-Screen-or-Min-swaps-to-sort-array
//        //https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{1, 5, 4, 3, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{7, 1, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{5, 1, 3, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{1, 2, 3, 4}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All path from source to target in directed acyclic graph");
//        //https://leetcode.com/problems/all-paths-from-source-to-target/
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {1, 2}, {3}, {3}, {}});
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {4, 3, 1}, {3, 2, 4}, {3}, {4}, {}});
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {2}, {}, {1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest substring without repeating characters");
//        //https://leetcode.com/problems/longest-substring-without-repeating-characters/
//        obj.longestSubstringWithoutRepeatingChar("abcabcbb");
//        obj.longestSubstringWithoutRepeatingChar("bbbbb");
//        obj.longestSubstringWithoutRepeatingChar("pwwkew");
//        obj.longestSubstringWithoutRepeatingChar("");
//        System.out.println("Count substring without repeating characters");
//        //https://leetcode.com/problems/count-substrings-without-repeating-character/description/
//        obj.countSubstringsWithoutRepeatingChar("abcd");
//        obj.countSubstringsWithoutRepeatingChar("ooo");
//        obj.countSubstringsWithoutRepeatingChar("abab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum window substring containing all the character of string t in string s");
//        //https://leetcode.com/problems/minimum-window-substring/
//        obj.minimumWindowSubstring("", "");
//        obj.minimumWindowSubstring("ADOBECODEBANC", "ABC");
//        obj.minimumWindowSubstring("a", "a");
//        obj.minimumWindowSubstring("aa", "aa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete tree nodes and return forest");
//        //https://leetcode.com/problems/delete-nodes-and-return-forest/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().setRight(new TreeNode<>(4));
//        obj.deleteTreeNodesAndReturnForest(root1, new int[]{8, 1, 6});
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        obj.deleteTreeNodesAndReturnForest(root1, new int[]{3, 2});
        //......................................................................
//        Row: 321
//        System.out.println("LRU cache design");
//        List<String> operations = Arrays.asList("LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get");
//        List<List<Integer>> inputs = Arrays.asList(
//                Arrays.asList(2),
//                Arrays.asList(1, 1),
//                Arrays.asList(2, 2),
//                Arrays.asList(1),
//                Arrays.asList(3, 3),
//                Arrays.asList(2),
//                Arrays.asList(4, 4),
//                Arrays.asList(1),
//                Arrays.asList(3),
//                Arrays.asList(4)
//        );
//        obj.LRUCacheDesignImpl(operations, inputs);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Product of array excluding element itself");
//        obj.productOfArrayExcludingElementItself_BruteForce(new int[]{1, 2, 3, 4});
//        obj.productOfArrayExcludingElementItself_Optimised1(new int[]{1, 2, 3, 4});
//        obj.productOfArrayExcludingElementItself_Optimised2(new int[]{1, 2, 3, 4}); //TIME & SPACE OPTIMISED
        //......................................................................
//        Row: 196
//        System.out.println("Construct binary tree from inorder and preorder/ postorder");
//        //https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
//        //https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
//        obj.constructBinaryTreeFromInorderPreorderArray(new int[]{9, 3, 15, 20, 7}, new int[]{3, 9, 20, 15, 7});
//        obj.constructBinaryTreeFromInorderPostorderArray(new int[]{9, 3, 15, 20, 7}, new int[]{9,15,7,20,3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Construct BST from given preorder/postorder array");
//        //https://practice.geeksforgeeks.org/problems/preorder-to-postorder4423/1/
//        //PREORDER ARRAY
//        obj.constructBinarySearchTreeFromPreorderArray(new int[]{40, 30, 35, 80, 100});
//        obj.constructBinarySearchTreeFromPreorderArray(new int[]{40, 30, 32, 35, 80, 90, 100, 120});
//        //POSTORDER ARRAY
//        obj.constructBinarySearchTreeFromPostorderArray(new int[]{35, 30, 100, 80, 40});
//        obj.constructBinarySearchTreeFromPostorderArray(new int[]{35, 32, 30, 120, 100, 90, 80, 40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count all the occurences of anagrams of given pattern in the text SLIDING WINDOW");
//        //https://www.geeksforgeeks.org/amazon-interview-experience-set-324-sde2/
//        //https://leetcode.com/problems/permutation-in-string/
//        //https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
//        obj.countAllOccurencesOfPatternInGivenString("forxxorfxdofr", "for");
//        obj.countAllOccurencesOfPatternInGivenString("foorxxorfxdofr", "for");
//        obj.countAllOccurencesOfPatternInGivenString("aabaabaa", "aaba");
//        obj.countAllOccurencesOfPatternInGivenString("aabaabaa", "xyz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert all the leaves of tree to DLL and remove leaves from tree");
//        //https://practice.geeksforgeeks.org/problems/leaves-to-dll/1/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
//        root = new TreeNode<>(1); //EDGE CASE
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum of all subarray in size of K");
//        //https://leetcode.com/problems/sliding-window-maximum/
//        //https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/
//        //https://practice.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1/
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{1, 2, 3, 1, 4, 5, 2, 3, 6}, 3);
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{8, 5, 10, 7, 9, 4, 15, 12, 90, 13}, 4);
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{1, 3, 1, 2, 0, 5}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check two N-ary trees are mirror image of each other");
//        //https://youtu.be/UGzXSDZv-SY
//        List<List<Integer>> tree1 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        List<List<Integer>> tree2 = Arrays.asList(
//                Arrays.asList(4, 3, 2, 1), //0
//                Arrays.asList(6, 5), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        System.out.println("Check if two N-ary trees are mirror of each other: "
//                + obj.checkIfTwoNAryTreeAreMirror(tree1, tree2));
//        tree1 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        //BOTH TREE ARE SAME NOW THIS SHOULD GIVE FALSE
//        tree2 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        System.out.println("Check if two N-ary trees are mirror of each other: "
//                + obj.checkIfTwoNAryTreeAreMirror(tree1, tree2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find minimum in rotated sorted array I/ II");
//        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{3, 4, 5, 1, 2}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{0, 1, 2, 3, 4, 5}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{4, 6, 8, 10, 1, 3}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{5, 4, 3, 2, 1}));
//        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{1, 3, 5}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{2, 2, 2, 0, 1}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{3, 3, 1, 3}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{
//            3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 2, 2, 2, 2}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Deepest leaves sum in the tree");
//        //https://leetcode.com/problems/deepest-leaves-sum/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(6));
//        root.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.deepestLeavesSumOfTree_Iterative(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Average waiting time");
//        //https://leetcode.com/problems/average-waiting-time/
//        obj.averageWaitingTime(new int[][]{{1, 2}, {2, 5}, {4, 3}});
//        obj.averageWaitingTime(new int[][]{{5, 2}, {5, 4}, {10, 3}, {20, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition labels");
//        //https://leetcode.com/problems/partition-labels/
//        obj.partitionLabels("ababcbacadefegdehijhklij");
//        obj.partitionLabels("aabbaaccddcc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest repeating character replacement (SLIDING WINDOW)");
//        //https://leetcode.com/problems/longest-repeating-character-replacement/
//        obj.longestRepeatingCharacterByKReplacement("ABAB", 2);
//        obj.longestRepeatingCharacterByKReplacement("AABABBA", 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Recolors to Get K Consecutive Black Blocks");
//        //https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBBWWBBWBW", 7);
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBWBBBW", 2);
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBWW", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize the Confusion of an Exam");
//        //https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
//        obj.maximizeConfusionInExam("TTFF", 2);
//        obj.maximizeConfusionInExam("TFFT", 1);
//        obj.maximizeConfusionInExam("TTFTTFTT", 1);
//        obj.maximizeConfusionInExam2("TTFF", 2);
//        obj.maximizeConfusionInExam2("TFFT", 1);
//        obj.maximizeConfusionInExam2("TTFTTFTT", 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum time differenec");
//        //https://leetcode.com/problems/minimum-time-difference/
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("23:59","00:00")));
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("15:45","16:00")));
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("00:00","23:59","00:00")));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Length of contigous array (subarray with equal no of 0 and 1)");
//        //https://leetcode.com/problems/contiguous-array/
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{0,1});
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{0,1,0,1,0});
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{1,0,0,1,0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Generate balanced parenthesis");
//        //https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/
//        //https://leetcode.com/problems/generate-parentheses/
//        obj.generateBalancedParenthesis(1);
//        obj.generateBalancedParenthesis(2);
//        obj.generateBalancedParenthesis(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find whether path exists");
//        //https://practice.geeksforgeeks.org/problems/find-whether-path-exist5238/1
//        System.out.println("Path exists: " + obj.checkIfPathExistsFromSourceToDestination(new int[][]{
//            {1, 3},
//            {3, 2}
//        }));
//        System.out.println("Path exists: " + obj.checkIfPathExistsFromSourceToDestination(new int[][]{
//            {3, 0, 3, 0, 0}, {3, 0, 0, 0, 3}, {3, 3, 3, 3, 3}, {0, 2, 3, 0, 0}, {3, 0, 0, 1, 3}
//        }));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Linked list in K groups alternatively");
//        //https://www.interviewbit.com/problems/reverse-alternate-k-nodes/
//        Node<Integer> head = new Node<>(3);
//        head.setNext(new Node<>(4));
//        head.getNext().setNext(new Node<>(7));
//        head.getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(15));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(61));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(16));
//        new LinkedListUtil<Integer>(obj.reverseLinkedListInKGroupsAlternatively(head, 3)).print();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest String in a tree starting from leaf to root");
//        //https://leetcode.com/problems/smallest-string-starting-from-leaf/
//        TreeNode<Integer> root = new TreeNode<>(0);
//        root.setLeft(new TreeNode<>(1));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.smallestStringInTreeFromLeafToRoot(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print the sum where each root-to-leaf path of tree represent a number");
//        //https://leetcode.com/problems/sum-root-to-leaf-numbers/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        obj.printSumWhereRootToLeafPathIsANumber(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(6));
//        root.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.printSumWhereRootToLeafPathIsANumber(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max sum path in two sorted arrays");
//        //https://www.geeksforgeeks.org/maximum-sum-path-across-two-arrays/
//        obj.maxSumPathInTwoSortedArrays(new int[]{2, 3, 7, 10, 12}, new int[]{1, 5, 7, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Asteroid collision");
//        //https://leetcode.com/problems/asteroid-collision/
//        obj.asteroidCollision(new int[] {5,10,-5});
//        obj.asteroidCollision(new int[] {8, -8});
//        obj.asteroidCollision(new int[] {10,2,-5});
//        obj.asteroidCollision(new int[] {3,2,1,-10});
//        //......................................................................
////        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Collisions on a Road");
//        //https://leetcode.com/problems/count-collisions-on-a-road/description/
//        obj.countCollisionsOnRoad("RLRSLL");
//        obj.countCollisionsOnRoad("LLRR");
//        obj.countCollisionsOnRoad("RRRSLLL");
//        obj.countCollisionsOnRoad("LLRLRLLSLRLLSLSSSS");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest pallindromic substring");
//        //https://leetcode.com/problems/longest-palindromic-substring/
//        //https://leetcode.com/problems/palindromic-substrings/
//        obj.longestPallindromicSubstring("racecar");
//        obj.longestPallindromicSubstring("babccaa");
//        obj.longestPallindromicSubstring("aabbaa");
//        obj.longestPallindromicSubstring("cbb");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Non-overlapping Palindrome Substrings");
//        //https://leetcode.com/problems/maximum-number-of-non-overlapping-palindrome-substrings/description/
//        obj.maxNumberOfNonOverlappingPallindromeSubstrings("abaccdbbd", 3);
//        obj.maxNumberOfNonOverlappingPallindromeSubstrings("adbcda", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Next greater element 2 (consider array to cyclic)");
//        //https://leetcode.com/problems/next-greater-element-ii/
//        obj.nextGreaterElement2_CyclicArray(new int[]{1, 2, 1});
//        obj.nextGreaterElement2_CyclicArray(new int[]{5, 4, 3, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Valid sudoku");
//        //https://leetcode.com/problems/valid-sudoku/
//        //https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/
//        obj.validSudoku(new String[][]{
//            {"5", "3", ".", ".", "7", ".", ".", ".", "."},
//            {"6", ".", ".", "1", "9", "5", ".", ".", "."},
//            {".", "9", "8", ".", ".", ".", ".", "6", "."},
//            {"8", ".", ".", ".", "6", ".", ".", ".", "3"},
//            {"4", ".", ".", "8", ".", "3", ".", ".", "1"},
//            {"7", ".", ".", ".", "2", ".", ".", ".", "6"},
//            {".", "6", ".", ".", ".", ".", "2", "8", "."},
//            {".", ".", ".", "4", "1", "9", ".", ".", "5"},
//            {".", ".", ".", ".", "8", ".", ".", "7", "9"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Diagonal matrix traversal");
//        //https://www.geeksforgeeks.org/print-matrix-diagonal-pattern/
//        obj.diagonalMatrixTraversal(new int[][]{
//            {1, 2, 3},
//            {4, 5, 6},
//            {7, 8, 9}});
//        obj.diagonalMatrixTraversal(new int[][]{
//            {1, 2, 3},
//            {4, 5, 6}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Score of parenthesis");
//        //https://leetcode.com/problems/score-of-parentheses
//        obj.scoreOfParenthesis("()");
//        obj.scoreOfParenthesis("()()");
//        obj.scoreOfParenthesis("(())");
//        obj.scoreOfParenthesis("(()())");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("minimun remove of character to make valid parenthesis");
//        //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
//        obj.minimumCharRemovalToMakeValidParenthesis("lee(t(c)o)de)");
//        obj.minimumCharRemovalToMakeValidParenthesis("a)b(c)d");
//        obj.minimumCharRemovalToMakeValidParenthesis(")))(((");
//        obj.minimumCharRemovalToMakeValidParenthesis("()()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Repeated substring pattern");
//        //https://leetcode.com/problems/repeated-substring-pattern/
//        System.out.println("Repeated substring pattern possible: "+obj.repeatedSubstringPattern("abab"));
//        System.out.println("Repeated substring pattern possible: "+obj.repeatedSubstringPattern("aba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find median in data stream");
//        //https://leetcode.com/problems/find-median-from-data-stream/
//        obj.findMedianInDataStream(new int[] {5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Median of Two Sorted Arrays");
//        //https://leetcode.com/problems/median-of-two-sorted-arrays/
//        obj.medianOfTwoSortedArrays(new int[]{1,3}, new int[]{2});
//        obj.medianOfTwoSortedArrays(new int[]{1,3}, new int[]{2,4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pairs of Songs With Total Durations Divisible by 60");
//        //https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
//        obj.numPairsDivisibleBy60(new int[]{30,20,150,100,40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count inversion in the arrays (using modified merge sort)");
//        obj.countInversion(new int[]{1, 20, 6, 4, 5});
//        obj.countInversion(new int[]{1, 3, 2});
//        obj.countInversion(new int[]{7,1,2});
//        obj.countInversion(new int[]{5,3,2,4,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum window length where subarray is greater OR equal to target sum");
//        //https://leetcode.com/problems/minimum-size-subarray-sum/
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {2,3,1,2,4,3}, 7);
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {1,4,4}, 4);
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {1,1,1,1,1,1,1,1}, 11);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length of repeated subarray (DP PROBLEM)");
//        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
//        obj.maximumLengthOfRepeatedSubarray_DP_Memoization(new int[]{1,2,3,2,1}, new int[]{3,2,1,4,7});
//        obj.maximumLengthOfRepeatedSubarray_DP_Memoization(new int[]{0,1,1,1,1,1}, new int[]{0,1,0,1,0,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fix two swapped nodes of the BST");
//        //https://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/
//        //https://leetcode.com/problems/recover-binary-search-tree/
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(20)); //FIRST
//        root.setRight(new TreeNode<>(8)); //LAST
//        obj.fixTwoSwappedNodesInBST(root);
//        root = new TreeNode<>(3); //MID
//        root.setLeft(new TreeNode<>(5)); //FIRST
//        obj.fixTwoSwappedNodesInBST(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(5)); //FIRST
//        root.setRight(new TreeNode<>(1)); //LAST
//        obj.fixTwoSwappedNodesInBST(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge two binary trees");
//        //https://leetcode.com/problems/merge-two-binary-trees/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(2));
//        TreeNode<Integer> root2 = new TreeNode<>(2);
//        root2.setLeft(new TreeNode<>(1));
//        root2.getLeft().setRight(new TreeNode<>(4));
//        root2.setRight(new TreeNode<>(3));
//        root2.getRight().setRight(new TreeNode<>(7));
//        obj.mergeTwoBinaryTree(root1, root2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Flip M 0s in binary array and find maximum length of consecutive 1s");
//        //https://leetcode.com/problems/max-consecutive-ones-iii/
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{1, 0, 1}, 1);
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{1, 0, 0, 1, 1, 0, 1, 0, 1, 1}, 3);
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{0,0,0,}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Local minima and local maxima(Peak element) (BINARY SEARCH)");
//        //https://www.geeksforgeeks.org/find-local-minima-array/
//        //https://leetcode.com/problems/peak-index-in-a-mountain-array/description/
//        //https://leetcode.com/problems/find-peak-element/
//        obj.findLocalMinima(new int[]{1, 2, 3});
//        obj.findLocalMinima(new int[]{23, 8, 15, 2, 3});
//        obj.findLocalMinima(new int[]{9, 6, 3, 14, 5, 7, 4});
//        obj.findLocalMinima(new int[]{3, 2, 1});
//        //MAXIMA OR PEAK ELEMENT
//        obj.findLocalMaxima(new int[]{3, 2, 1});
//        obj.findLocalMaxima(new int[]{1, 2, 3});
//        obj.findLocalMaxima(new int[]{9, 6, 3, 14, 5, 7, 4});
//        obj.findLocalMaxima(new int[]{23, 8, 15, 2, 3});
//        obj.findLocalMaxima(new int[]{23, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find in Mountain Array");
//        //https://leetcode.com/problems/find-in-mountain-array/description/
//        System.out.println("Find in mountain array (API) : "
//                + obj.findInMountainArray(new int[]{1, 2, 3, 4, 5, 3, 1}, 3));
//        System.out.println("Find in mountain array (API) : "
//                + obj.findInMountainArray(new int[]{0, 1, 2, 4, 2, 1}, 3));
//        System.out.println("Find in mountain array (API) : "
//                + obj.findInMountainArray(new int[]{1, 5, 2}, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reorder linked list");
//        //https://leetcode.com/problems/reorder-list/
//        Node<Integer> head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.reorderLinkedList(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove K digits and create the smallest num");
//        //https://leetcode.com/problems/remove-k-digits/
//        obj.removeKDigitsToCreateSmallestNumber("1432219", 3);
//        obj.removeKDigitsToCreateSmallestNumber("10", 2);
//        obj.removeKDigitsToCreateSmallestNumber("10200", 1);
//        obj.removeKDigitsToCreateSmallestNumber("4321", 2);
//        obj.removeKDigitsToCreateSmallestNumber("1234", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the most competetive subsequence of length K in the given array");
//        //https://leetcode.com/problems/find-the-most-competitive-subsequence/
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{3,5,2,6}, 2);
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{2,4,3,3,5,4,9,6}, 4);
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{5,4,3,2,1}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Odd even linked list");
//        //https://leetcode.com/problems/odd-even-linked-list/
//        Node<Integer> head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(head);
//        head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of ways to create BST and BT with given N (req info: Catalan number series)");
//        //https://leetcode.com/problems/unique-binary-search-trees/
//        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
//        obj.numberOfWaysToCreateBSTAndBTWithGivenN(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if binary tree is complete binary tree or not");
//        //https://leetcode.com/problems/check-completeness-of-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6)); //COMPLETE BINARY TREE
//        System.out.println("Is tree complete binary tree: "+obj.checkIfBinaryTreeIsCompleteOrNot(root1));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(7)); //NOT-COMPLETE BINARY TREE
//        System.out.println("Is tree complete binary tree: "+obj.checkIfBinaryTreeIsCompleteOrNot(root1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("maximum width of binary tree");
//        //https://leetcode.com/problems/maximum-width-of-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.getLeft().setRight(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setRight(new TreeNode<>(9));
//        obj.maximumWidthOfBinaryTree(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(6));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setRight(new TreeNode<>(9));
//        root1.getRight().getRight().setRight(new TreeNode<>(7));
//        obj.maximumWidthOfBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of elements in matrix except given row and col");
//        //https://www.geeksforgeeks.org/find-sum-of-all-elements-in-a-matrix-except-the-elements-in-given-row-andor-column-2/
//        int[][] rowAndCol = new int[][]{
//            {0, 0},
//            {1, 1},
//            {0, 1}
//        };
//        int[][] matrix = new int[][]{
//            {1, 1, 2},
//            {3, 4, 6},
//            {5, 3, 2}
//        };
//        obj.sumOfElementsInMatrixExceptGivenRowAndCol(matrix, rowAndCol);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count number elements from second array less than or equal to element in first array");
//        //https://www.geeksforgeeks.org/element-1st-array-count-elements-less-equal-2nd-array/
//        obj.countElementsFromSecondArrayLessOrEqualToElementInFirstArray(
//                new int[]{1, 2, 3, 4, 7, 9},
//                new int[]{0, 1, 2, 1, 1, 4});
//        obj.countElementsFromSecondArrayLessOrEqualToElementInFirstArray(
//                new int[]{5, 10, 2, 6, 1, 8, 6, 12},
//                new int[]{6, 5, 11, 4, 2, 3, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if input binary number stream is divisible by N");
//        //https://leetcode.com/problems/binary-prefix-divisible-by-5/
//        //https://www.geeksforgeeks.org/check-divisibility-binary-stream/
//        obj.checkBinaryNumberStreamIsDivisibleByN(new int[]{1,0,1,0,1}, 3);
//        obj.checkBinaryNumberStreamIsDivisibleByN(new int[]{1,0,1}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert number to words");
//        //https://www.geeksforgeeks.org/program-to-convert-a-given-number-to-words-set-2/
//        obj.convertNumberToWords(438237764);
//        obj.convertNumberToWords(0);
//        obj.convertNumberToWords(101);
//        obj.convertNumberToWords(1000);
//        obj.convertNumberToWords(222);
//        obj.convertNumberToWords(999999999);
//        obj.convertNumberToWords(1234567891);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum swaps to form greater number by swaping 2 digit atmost ");
//        //https://leetcode.com/problems/maximum-swap/
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(2736);
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(9973);
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(1002);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String comparision after processing backspace character");
//        //https://leetcode.com/problems/backspace-string-compare/
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("ab#c", "ad#c"));
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("a#c", "b"));
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("a#", "b#"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find negative number in window size of K from the array");
//        //https://practice.geeksforgeeks.org/problems/first-negative-integer-in-every-window-of-size-k/0
//        obj.firstNegativeNumberInWindowKFromArray(new int[]{-8, 2, 3, -6, 10}, 2);
//        obj.firstNegativeNumberInWindowKFromArray(new int[]{12, -1, -7, 8, -15, 30, 16, 28}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String zig zag");
//        //https://leetcode.com/problems/zigzag-conversion/
//        obj.stringZigZag("PAYPALISHIRING", 3);
//        obj.stringZigZag("PAYPALISHIRING", 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Can we divide the given array into consecutive sequence of length W");
//        //https://leetcode.com/problems/hand-of-straights/
//        //https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers
//        System.out.println("Given array can be divided into consecutive groups of length W: "
//                +obj.handOfStraight(new int[]{1,2,3,6,2,3,4,7,8}, 3));
//        System.out.println("Given array can be divided into consecutive groups of length W: "
//                + obj.handOfStraight(new int[]{1,2,3,4,5}, 4));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Can we visit all the rooms");
//        //https://leetcode.com/problems/keys-and-rooms/
//        List<List<Integer>> rooms = Arrays.asList(
//                Arrays.asList(1),
//                Arrays.asList(2),
//                Arrays.asList(3),
//                Arrays.asList()
//        );
//        System.out.println("Can we visit all the rooms: "+obj.canWeVisitAllTheRooms_Graph(rooms));
//        rooms = Arrays.asList(
//                Arrays.asList(1, 3),
//                Arrays.asList(3, 0, 1),
//                Arrays.asList(2),
//                Arrays.asList(0)
//        );
//        System.out.println("Can we visit all the rooms: "+obj.canWeVisitAllTheRooms_Graph(rooms));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("number of Steps taken to Open the lock");
//        //https://leetcode.com/problems/open-the-lock/
//        String[] deadends = new String[]{"0201", "0101", "0102", "1212", "2002"};
//        String target = "0202";
//        System.out.println("Steps required: " + obj.stepsToOpenTheLock(deadends, target));
//        deadends = new String[]{"8887", "8889", "8878", "8898", "8788", "8988", "7888", "9888"};
//        target = "8888";
//        System.out.println("Steps required: " + obj.stepsToOpenTheLock(deadends, target));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Squares of sorted array");
//        //https://leetcode.com/problems/squares-of-a-sorted-array/
//        obj.sortedSquaresOfSortedArray_1(new int[]{-4, -1, 0, 3, 10});
//        obj.sortedSquaresOfSortedArray_2(new int[]{-4, -1, 0, 3, 10}); //OPTIMISED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Move zeros to end");
//        //https://leetcode.com/problems/move-zeroes/
//        obj.moveZeroesToEnd(new int[]{0, 1, 0, 3, 12});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distribute coins in binary tree");
//        //https://leetcode.com/problems/distribute-coins-in-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(0));
//        root.setRight(new TreeNode<>(0));
//        obj.distributeCoinsInBinaryTree(root);
//        root = new TreeNode<>(0);
//        root.setLeft(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(0));
//        obj.distributeCoinsInBinaryTree(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(0));
//        root.setRight(new TreeNode<>(2));
//        obj.distributeCoinsInBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Container with most water");
//        //https://leetcode.com/problems/container-with-most-water/
//        obj.containerWithMostWater(new int[]{1,8,6,2,5,4,8,3,7});
//        obj.containerWithMostWater(new int[]{5,6,8,9,8,6,5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if binary tree is odd-even binary tree");
//        //https://leetcode.com/problems/even-odd-tree
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(10));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(7));
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(11)); //LEVEL - 1 (ODD) data == ODD which is FALSE
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(7));
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(10));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(3)); //LEVEL - 2 (EVEN) nodes at this level should be strictly incr but level 2[3,3, 9] FALSE
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Substring With K Unique Characters (SLIDING WINDOW)");
//        //https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/
//        //https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description/
//        //https://practice.geeksforgeeks.org/problems/longest-k-unique-characters-substring0853/1
//        obj.longestSubstringWithKUniqueCharacter("aabacbebebe", 3);
//        obj.longestSubstringWithKUniqueCharacter("aabcaccbeb", 3);
//        obj.longestSubstringWithKUniqueCharacter("aaaa", 2);
//        obj.longestSubstringWithKUniqueCharacter("hq", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest Substring With K Unique Characters (SLIDING WINDOW)");
//        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
//        obj.smallestSubstringWithKUniqueCharacter("aabacbebebe", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aabcaccbeb", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aaaa", 2);
//        obj.smallestSubstringWithKUniqueCharacter("hq", 2);
//        obj.smallestSubstringWithKUniqueCharacter("aabab", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aaabbbccc", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest Subarray With K Distinct Elements (SLIDING WINDOW)");
//        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
//        obj.smallestSubarrayWithKDistinctElements(new int[]{1, 1, 2, 1, 2}, 3);
//        obj.smallestSubarrayWithKDistinctElements(new int[]{4, 2, 2, 2, 3, 4, 4, 3}, 3);
//        obj.smallestSubarrayWithKDistinctElements(new int[]{1,1,1,2,2,2,3,3,3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest missing positive missing number");
//        //https://practice.geeksforgeeks.org/problems/smallest-positive-missing-number-1587115621/1#
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{1, 2, 3, 4, 5}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{0, -10, 1, 3, -20}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{-2,2,7,1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sort the matrix diaonally");
//        //https://leetcode.com/problems/sort-the-matrix-diagonally
//        int[][] mat = new int[][]{{3, 3, 1, 1}, {2, 2, 1, 2}, {1, 1, 1, 2}};
//        obj.sortTheMatrixDiagonally(mat);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray sum equals K");
//        //https://leetcode.com/problems/subarray-sum-equals-k/
//        obj.subarraySumEqualsK(new int[]{1, 1, 1}, 2);
//        obj.subarraySumEqualsK(new int[]{1, 2, 3}, 3);
//        obj.subarraySumEqualsK(new int[]{1}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Sub-Array with Sum K");
//        //https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/description/
//        //https://leetcode.ca/all/325.html
//        //https://www.geeksforgeeks.org/longest-sub-array-sum-k/
//        //https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1
//        obj.longestSubarrayWithSumEqualsK(new int[]{10, 5, 2, 7, 1, 9}, 15);
//        obj.longestSubarrayWithSumEqualsK(new int[]{-1, 2, 3}, 6);
//        obj.longestSubarrayWithSumEqualsK(new int[]{1, 1, 1}, 3);
//        obj.longestSubarrayWithSumEqualsK(new int[]{-13, 0, 6, 15, 16, 2, 15, -12, 17, -16, 0, -3, 19, -3, 2, -9, -6}, 15);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Continuous Subarray Sum");
//        //https://leetcode.com/problems/continuous-subarray-sum/
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 4, 6, 7}, 6));
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 6, 4, 7}, 6));
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 6, 4, 7}, 13));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Nice Pairs in an Array");
//        //https://leetcode.com/problems/count-nice-pairs-in-an-array/
//        obj.countNicePairsInArray(new int[]{42, 11, 1, 97});
//        obj.countNicePairsInArray(new int[]{13, 10, 35, 24, 76});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Bad Pairs");
//        //https://leetcode.com/problems/count-number-of-bad-pairs/
//        obj.countNumberOfBadPairs(new int[]{4, 1, 3, 3});
//        obj.countNumberOfBadPairs(new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Pairs of Interchangeable Rectangles");
//        //https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/
//        obj.numberOfPairsOfInterchangeableRectangles(new int[][]{{4, 8}, {3, 6}, {10, 20}, {15, 30}});
//        obj.numberOfPairsOfInterchangeableRectangles(new int[][]{{4, 5}, {7, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Nice Subarrays");
//        //https://leetcode.com/problems/count-number-of-nice-subarrays/
//        obj.numberOfSubarraysWithKOddNums(new int[]{1, 1, 2, 1, 1}, 3);
//        obj.numberOfSubarraysWithKOddNums(new int[]{2, 4, 6}, 1);
//        obj.numberOfSubarraysWithKOddNums(new int[]{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray sum divisible by K");
//        //https://leetcode.com/problems/subarray-sums-divisible-by-k/
//        obj.subarraySumDivisibleByK(new int[]{4, 5, 0, -2, -3, 1}, 5);
//        obj.subarraySumDivisibleByK(new int[]{-1,2,9}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest subarray with sum divisible by K");
//        //https://practice.geeksforgeeks.org/problems/longest-subarray-with-sum-divisible-by-k1259/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article
//        obj.longestSubarraySumDivisibleByK(new int[]{2, 7, 6, 1, 4, 5}, 3);
//        obj.longestSubarraySumDivisibleByK(new int[]{-2, 2, -5, 12, -11, -1, 7}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray product less than K (SLIDING WINDOW)");
//        //https://leetcode.com/problems/subarray-product-less-than-k/
//        obj.subarrayProductLessThanK(new int[]{10, 5, 2, 6}, 100);
//        obj.subarrayProductLessThanK(new int[]{1, 2, 3}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Make Sum Divisible by k");
//        //https://leetcode.com/problems/make-sum-divisible-by-p/description/
//        obj.makeSumDivisibleByK(new int[]{3, 1, 4, 2}, 6);
//        obj.makeSumDivisibleByK(new int[]{6, 3, 5, 2}, 9);
//        obj.makeSumDivisibleByK(new int[]{1, 2, 3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked list component");
//        //https://leetcode.com/problems/linked-list-components/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        head.getNext().getNext().setNext(new Node<>(3));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.linkedListComponent(head, new int[]{0,3,1,4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked list partition list");
//        //https://leetcode.com/problems/partition-list
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(4));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        obj.partitionList(head, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max sum in any path of the tree");
//        //https://leetcode.com/problems/binary-tree-maximum-path-sum/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        obj.maxSumInAnyPathOfTree(root);
//        root = new TreeNode<>(42);
//        root.setLeft(new TreeNode<>(-2));
//        root.setRight(new TreeNode<>(2));
//        obj.maxSumInAnyPathOfTree(root);
//        root = new TreeNode<>(-10);
//        root.setLeft(new TreeNode<>(9));
//        root.setRight(new TreeNode<>(20));
//        root.getRight().setLeft(new TreeNode<>(15));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.maxSumInAnyPathOfTree(root); //MAX SUM accross path: 15<->20<->7
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("longest length of edge between tree nodes having same values");
//        //https://leetcode.com/problems/longest-univalue-path/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(5));
//        obj.longestEdgeLengthBetweenTreeNodesWithSameValue(root); //EDGE b/w 4<->4<->4
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Global and local inversions");
//        //https://leetcode.com/problems/global-and-local-inversions/
//        System.out.println("Are counts for global and local inversion are equal: "
//                + obj.globalAndLocalInversionCountAreEqual(new int[]{1, 0, 2}));
//        System.out.println("Are counts for global and local inversion are equal: "
//                + obj.globalAndLocalInversionCountAreEqual(new int[]{1, 2, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pascal triangle");
//        //https://leetcode.com/problems/pascals-triangle/
//        //based on addition
//        obj.printPascalTriangle_SimpleAddition(6);
//        //based on binomial coefficient
//        System.out.println("Value of pascal triangle at given row and col : "
//                + obj.printPascalTriangleValueAtGivenRowAndCol(1, 1));
//        System.out.println("Value of pascal triangle at given row and col : "
//                + obj.printPascalTriangleValueAtGivenRowAndCol(5, 3));
//        System.out.println("N-th row of pascal triangle: " + obj.printNthRowOfPascalTriangle(0));
//        System.out.println("N-th row of pascal triangle: " + obj.printNthRowOfPascalTriangle(1));
//        System.out.println("N-th row of pascal triangle: " + obj.printNthRowOfPascalTriangle(2));
//        System.out.println("N-th row of pascal triangle: " + obj.printNthRowOfPascalTriangle(5));
//        //here n is 1-based index/rows
//        obj.printPascalTriangle(0); //invalid
//        obj.printPascalTriangle(1); //0-th row
//        obj.printPascalTriangle(2); //1-st row
//        obj.printPascalTriangle(6); //5-th row
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest number from the given set of number/ Smallest Value of the Rearranged Number");
//        //https://leetcode.com/problems/largest-number/
//        obj.largestNumberFromSetOfNumbers(new String[]{"3", "30", "34", "5", "9"});
//        obj.largestNumberFromSetOfNumbers(new String[]{"54", "546", "548", "60"});
//        obj.largestNumberFromSetOfNumbers(new String[]{"0", "0"});
//        //https://leetcode.com/problems/smallest-value-of-the-rearranged-number
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(310));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(-7650));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(-12345));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(54321));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(54321000));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String compression");
//        //https://leetcode.com/problems/string-compression/
//        obj.stringCompression(new char[]{'a', 'a', 'b', 'b', 'c', 'c'});
//        obj.stringCompression(new char[]{'a'});
//        obj.stringCompression(new char[]{'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rotate linked list K times");
//        //https://leetcode.com/problems/rotate-list/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        obj.rotateLinkedListKTimes(head, 4);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rotateLinkedListKTimes(head, 2);
//        //same linked list approach 2
//        head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        obj.rotateLinkedListKTimes2(head, 4);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rotateLinkedListKTimes2(head, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sort the linked list in relative order of the given arr");
//        //https://leetcode.com/problems/relative-sort-array/
//        //https://www.geeksforgeeks.org/sort-linked-list-order-elements-appearing-array/
//        Node<Integer> head = new Node<>(3);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(5));
//        head.getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        obj.sortLinkedListInRelativeOrderOfArr(head, new int[]{5, 1, 3, 2, 8});
//        head = new Node<>(3);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(5));
//        head.getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(19)); //EXTRA NOT IN arr[]
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(7)); //EXTRA NOT IN arr[]
//        obj.sortLinkedListInRelativeOrderOfArr(head, new int[]{5, 1, 3, 2, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count nodes in complete binary tree");
//        //https://leetcode.com/problems/count-complete-tree-nodes/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Nnumber of nodes in complete binary tree: " + obj.countNodesInCompleteBinaryTree(root1));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        System.out.println("Nnumber of nodes in complete binary tree: " + obj.countNodesInCompleteBinaryTree(root1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All source to destination path with weight sum in N-Ary tree ");
//        //https://www.geeksforgeeks.org/amazon-interview-experience-set-424-sde-2/
//        List<List<VertexWithWeight>> adjList = Arrays.asList(
//                /*0*/Arrays.asList(new VertexWithWeight(1, 10),
//                        new VertexWithWeight(2, 50),
//                        new VertexWithWeight(3, 20)),
//                /*1*/ Arrays.asList(new VertexWithWeight(0, 10),
//                        new VertexWithWeight(4, 30),
//                        new VertexWithWeight(5, 40)),
//                /*2*/ Arrays.asList(new VertexWithWeight(0, 50)),
//                /*3*/ Arrays.asList(new VertexWithWeight(0, 20)),
//                /*4*/ Arrays.asList(new VertexWithWeight(1, 30)),
//                /*5*/ Arrays.asList(new VertexWithWeight(1, 40))
//        );
//        obj.vertexWithWeightAllSourceToDestinationPath(adjList);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count good nodes in binary tree");
//        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().setRight(new TreeNode<>(5));
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
//        root1 = new TreeNode<>(1);
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min distance between 2 nodes in given binary tree");
//        //https://www.geeksforgeeks.org/find-distance-between-two-nodes-of-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 2, 3);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 3, 3);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().setRight(new TreeNode<>(7));
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 4, 5);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 4, 6);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 3, 4);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 2, 4);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 8, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the Celebrity");
//        //https://leetcode.com/problems/find-the-celebrity/description/
//        //https://www.geeksforgeeks.org/the-celebrity-problem/
//        System.out.println("Id of celebrity person: " + obj.findCelebrityInNPepole(4));
//        System.out.println("Id of celebrity person (approach TWO POINTER): " + obj.findCelebrityInNPepole2(4));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max product in splitted binary tree");
//        //https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        obj.maxProductIfBinaryTreeIsSplitIntoTwo(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest consecutive sequenece");
//        //https://leetcode.com/problems/longest-consecutive-sequence/
//        //https://practice.geeksforgeeks.org/problems/longest-consecutive-subsequence2449/1
//        System.out.println("Longest consecutive seq: " + obj.longestConsecutiveSequence(new int[]{2, 6, 1, 9, 4, 5, 3}));
//        System.out.println("Longest consecutive seq: "
//                + obj.longestConsecutiveSequence(new int[]{2, 2, 4, 5, 1, 1, 1, 3, 4, 5, 6, 7, 8, 9, 9}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max difference of indexes");
//        //https://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/
//        obj.maxDifferenceOfIndexes(new int[]{34, 8, 10, 3, 2, 80, 30, 33, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete nodes from binary search tree");
//        //https://leetcode.com/problems/delete-node-in-a-bst/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 3)).treeBFS(); //DELETE ROOT OF TREE
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 1)).treeBFS(); //DELETE LEAF
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 0)).treeBFS(); //DELETE ROOT HAS ONE CHILD (RIGHT)
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 2)).treeBFS(); //DELETE ROOT HAS ONE CHILD (LEFT)
//        System.out.println();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete nodes from binary search tree that are not in range");
//        //https://leetcode.com/problems/trim-a-binary-search-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        obj.deleteTreeNodeFromBinarySearchTreeNotInRange(root1, 1, 3);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(4));
//        obj.deleteTreeNodeFromBinarySearchTreeNotInRange(root1, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rearrange array elements");
//        //https://www.geeksforgeeks.org/rearrange-given-array-place/
//        obj.rearrangeArrayElements(new int[]{4, 0, 2, 1, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum range that contains atleast one element from K sorted List");
//        //https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/
//        //https://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/
//        obj.minimumRangeContainingAtleastOneElementFromKSortedList(new int[][]{
//            {1, 3, 5, 7, 9},
//            {0, 2, 4, 6, 8},
//            {2, 3, 5, 7, 11}
//        });
//        obj.minimumRangeContainingAtleastOneElementFromKSortedList(new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Tuples with same product");
//        //https://leetcode.com/problems/tuple-with-same-product/
//        obj.tupleWithSameProduct(new int[]{2, 3, 4, 6});
//        obj.tupleWithSameProduct(new int[]{2, 3, 5, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if two nodes are cousin of each other");
//        //https://leetcode.com/problems/cousins-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        obj.checkIfTwoTreeNodesAreCousin(root1, 4, 3);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 3);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(5));
//        obj.checkIfTwoTreeNodesAreCousin(root1, 4, 5);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 5);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 6); //6 don't exist
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cousins in Binary Tree II");
//        //https://leetcode.com/problems/cousins-in-binary-tree-ii/description/
//        TreeNode<Integer> root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setLeft(new TreeNode<>(1));
//        root1.getLeft().setRight(new TreeNode<>(10));
//        root1.setRight(new TreeNode<>(9));
//        root1.getRight().setRight(new TreeNode<>(7));
//        obj.cousinsInBinaryTreeTwo(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(2));
//        obj.cousinsInBinaryTreeTwo(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Connect all nodes at same level in a tree by the random pointer (Recursive/ Iterative)");
//        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
//        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
//        TreeNode<Integer> root1 = new TreeNode<>(10);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(5));
//        root1.getRight().setRight(new TreeNode<>(2));
//        obj.connectTreeNodesAtSameLevel_Recursive(root1);
//        obj.connectTreeNodesAtSameLevel_Iterative(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K - diff pairs in array");
//        //https://leetcode.com/problems/k-diff-pairs-in-an-array/
//        //https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/
//        obj.kDiffPairsInArray(new int[]{3, 1, 4, 1, 5}, 2);
//        obj.kDiffPairsInArray(new int[]{-1, -2, -3}, 1);
//        obj.kDiffPairsInArray(new int[]{1, 3, 1, 5, 4}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Least number of unique integers left after K removals");
//        //https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{5, 5, 4}, 1);
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{4, 3, 1, 1, 3, 3, 2}, 3);
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{4, 3, 1, 1, 3, 3, 2}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Long pressed names");
//        //https://leetcode.com/problems/long-pressed-name/
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("alex", "aaleex"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("laex", "aaleex"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("saeed", "ssaaedd"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("leelee", "lgeelege"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary search tree to greater sum tree");
//        //https://leetcode.com/problems/convert-bst-to-greater-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(4);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setRight(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(6));
//        root1.getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().setRight(new TreeNode<>(7));
//        root1.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.binarySearchTreeToGreaterSumTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all interleavings of given two strings");
//        //https://www.geeksforgeeks.org/print-all-interleavings-of-given-two-strings/
//        obj.interleavingOfTwoStrings("AB", "CD");
//        obj.interleavingOfTwoStrings("ABC", "DEF");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if String C is interleaving of String A & B");
//        //https://leetcode.com/problems/interleaving-string/
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "ACBG"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "ACDB"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "AC"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("aabcc", "dbbca", "aadbbcbcac"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "ACBG"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "ACDB"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "AC"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("aabcc", "dbbca", "aadbbcbcac"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all permutation of distinct char in string");
//        //https://leetcode.com/problems/permutations/
//        //https://leetcode.com/problems/permutations-ii/
//        obj.printAllPermutationOfDistinctCharInString("ABC");
//        obj.printAllPermutationOfDistinctCharInString("ABCD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all permutation of a distinct integer");
//        //https://leetcode.com/problems/permutations/
//        //https://leetcode.com/problems/permutations-ii/
//        obj.printAllPermutationOfDistinctIntegerArray(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max distance covered by robot walking simulation");
//        //https://leetcode.com/problems/walking-robot-simulation/
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{4, -1, 4, -2, 4},
//                new int[][]{{2, 4}});
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{4, -1, 3},
//                new int[][]{});
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{2, -1, 2 - 1, 2},
//                new int[][]{});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest substring having all vowels in order");
//        //https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/
//        obj.longestSubstringHavingAllVowelsInOrder("aeiaaioaaaaeiiiiouuuooaauuaeiu");
//        obj.longestSubstringHavingAllVowelsInOrder("aeeeiiiioooauuuaeiou");
//        obj.longestSubstringHavingAllVowelsInOrder("a");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Evaluate arithematic expression(Basic calculator)");
//        //https://leetcode.com/problems/basic-calculator-ii/
//        obj.arithematicExpressionEvaluationBasicCalculator(" 3/2 ");
//        obj.arithematicExpressionEvaluationBasicCalculator(" 35 + 5 / 4 ");
//        obj.arithematicExpressionEvaluationBasicCalculator(" 3 + 5 / 4*2");
//        //https://leetcode.com/problems/basic-calculator/
//        obj.basicCalculator("1 + 1");
//        obj.basicCalculator(" 2-1 + 2 ");
//        obj.basicCalculator("(1+(4+5+2)-3)+(6+8)");
//        obj.basicCalculator("1 + (1 + 1) - (1 - 3)");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Single threaded CPU Greedy");
//        //https://leetcode.com/problems/single-threaded-cpu/
//        obj.singleThreadedCPU_Greedy(new int[][]{
//            {1, 2}, {2, 4}, {3, 2}, {4, 1}
//        });
//        obj.singleThreadedCPU_Greedy(new int[][]{
//            {7, 10}, {7, 12}, {7, 5}, {7, 4}, {7, 2}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Replace bracket pattern with given value in list");
//        //https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/
//        List<List<String>> keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("name", "bob"));
//        keyReplacement.add(Arrays.asList("age", "two"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("(name)is(age)yearsold",
//                keyReplacement);
//        keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("a", "b"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("hi(name)",
//                keyReplacement);
//        keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("a", "yes"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("(a)(a)(a)aaa",
//                keyReplacement);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All phone digits letter combinations");
//        //https://leetcode.com/problems/letter-combinations-of-a-phone-number
//        obj.allPhoneDigitLetterCombinations("2");
//        obj.allPhoneDigitLetterCombinations("23");
//        obj.allPhoneDigitLetterCombinations("7979");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Combination sum 1 and 3");
//        //https://leetcode.com/problems/combination-sum
//        //https://leetcode.com/problems/combinations/
//        obj.combinationSum_1(new int[]{1}, 2);
//        obj.combinationSum_1(new int[]{2}, 1); //No Combinations Possible
//        obj.combinationSum_1(new int[]{2, 3, 5}, 8);
//        //https://leetcode.com/problems/combination-sum-iii/
//        obj.combinationSum_3(3, 7);
//        obj.combinationSum_3(3, 9);
//        obj.combinationSum_3(4, 1);
//        obj.combinationSum_3(9, 60);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Combination sum-2");
//        //https://leetcode.com/problems/combination-sum-ii/
//        obj.combinationSum_2(new int[]{10, 1, 2, 7, 6, 1, 5}, 8);
//        obj.combinationSum_2(new int[]{2, 5, 2, 1, 2}, 5);
//        obj.combinationSum_2(new int[]{1}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest unsorted contigous subarray");
//        //https://leetcode.com/problems/shortest-unsorted-continuous-subarray
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{2, 6, 4, 8, 10, 9, 15}));
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{1, 2, 3, 4})); //ALREADY SORTED
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{4})); //ALREADY SORTED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum operations to make array increasing");
//        //https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
//        obj.minimumOperationsToMakeArrayStrictlyIncr(new int[]{1, 1, 1});
//        obj.minimumOperationsToMakeArrayStrictlyIncr(new int[]{4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Broken calculator (make X equal to Y with decreament Or Multiplication oprn on X)");
//        //https://leetcode.com/problems/broken-calculator/
//        obj.brokenCalculatorMakeXEqualToY(2, 3);
//        obj.brokenCalculatorMakeXEqualToY(3, 10);
//        obj.brokenCalculatorMakeXEqualToY(1024, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Vertices to Reach All Nodes");
//        //https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
//        obj.vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(6, new int[][]{
//            {0, 1}, {0, 2}, {2, 5}, {3, 4}, {4, 2}
//        });
//        obj.vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(5, new int[][]{
//            {0, 1}, {2, 1}, {3, 1}, {4, 1}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if atmost one char swap make strings equal");
//        //https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("bank", "kanb"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("kelb", "kelb"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("abcd", "dcba"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("attack", "defend"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Substring Between Two Equal Characters");
//        //https://leetcode.com/problems/largest-substring-between-two-equal-characters/
//        obj.largestSubstringBetweenTwoSameChar("aa");
//        obj.largestSubstringBetweenTwoSameChar("cbzxy");
//        obj.largestSubstringBetweenTwoSameChar("cabbac");
//        obj.largestSubstringBetweenTwoSameChar("abca");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest subtree with all the deepest nodes in a tree");
//        //https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
//        //https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(5));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setLeft(new TreeNode<>(0));
//        root1.getRight().setRight(new TreeNode<>(8));
//        obj.subtreeWithAllDeepestNodes(root1); //DEEP LEAF = 7,4 subtree = [2,7,4]
//        root1 = new TreeNode<>(0);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        obj.subtreeWithAllDeepestNodes(root1); //DEEP LEAF = 2 subtree = [2]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Determine if two strings are close");
//        //https://leetcode.com/problems/determine-if-two-strings-are-close/
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("a", "aa"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("abc", "cba"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("cabbba", "abbccc"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("cabbba", "aabbss"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum char required to make string t anagram of string s");
//        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/
//        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("bab", "aba");
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("leetcode", "practice");
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("xxyyzz", "xxyyzz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum char removed to make string t & s anagram");
//        //https://practice.geeksforgeeks.org/problems/anagram-of-string
//        //https://www.geeksforgeeks.org/remove-minimum-number-characters-two-strings-become-anagram/
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("bcadeh", "hea"); //remove b,c,d from S
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("bcadeh", "heaz"); //remove b,c,d from S, z from T
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("cddgk", "gcd"); //remove k,d from S
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if graph is bipartite");
//        //https://leetcode.com/problems/is-graph-bipartite/
//        System.out.println("Graph is bipartite: "
//                + obj.checkIfGraphIsBipartite_Graph(new int[][]{{1, 3}, {0, 2}, {1, 3}, {0, 2}}));
//        System.out.println("Graph is bipartite: "
//                + obj.checkIfGraphIsBipartite_Graph(new int[][]{{1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2}}));
//        System.out.println("Possible Bipartition");
//        //https://leetcode.com/problems/possible-bipartition/description/
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(4, new int[][]{{1, 2}, {1, 3}, {2, 4}}));
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(3, new int[][]{{1, 2}, {1, 3}, {2, 3}}));
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(5, new int[][]{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 5}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pseudo-Palindromic Paths in a Binary Tree");
//        //https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(2);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setRight(new TreeNode<>(1));
//        obj.pseudoPallindromicPathInBinaryTree(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(1));
//        obj.pseudoPallindromicPathInBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Split linked list in K parts");
//        //https://leetcode.com/problems/split-linked-list-in-parts/
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        obj.splitLinkedListInKParts(head, 5);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(9));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(10));
//        obj.splitLinkedListInKParts(head, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove given value from linked list");
//        //https://leetcode.com/problems/remove-linked-list-elements
//        Node<Integer> head = new Node<>(6);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        head.getNext().getNext().setNext(new Node<>(3));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
//        head = new Node<>(6);
//        head.setNext(new Node<>(6));
//        head.getNext().setNext(new Node<>(6));
//        head.getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
//        head = new Node<>(6);
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum difference of sum of two partition of the array DP Problem");
//        //https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1#
//        obj.minimumDiffPartition_DP_Memoization(new int[]{1, 6, 11, 5});
//        obj.minimumDiffPartition_DP_Memoization(new int[]{1, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest subarray of consecutive ones after deleting one element in the binary array");
//        //https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{0,0,0});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{1,1,1,1});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{1,1,0,1});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{0,1,1,1,0,1,1,0,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count subarray with odd sum");
//        //https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum
//        obj.countSubarrayWithOddSum(new int[]{1, 3, 5});
//        obj.countSubarrayWithOddSum(new int[]{2, 4, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge new interval in between");
//        //https://leetcode.com/problems/insert-interval/
//        obj.mergeNewInterval(new int[][]{{1, 3}, {6, 9}}, new int[]{2, 5});
//        obj.mergeNewInterval(new int[][]{{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}}, new int[]{4, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count the number of turns in between two nodes of a tree");
//        //https://www.geeksforgeeks.org/number-turns-reach-one-node-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(8));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(9));
//        root1.getRight().getLeft().setRight(new TreeNode<>(10));
//        root1.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 9, 10));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 5, 6));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 1, 4));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 5, 10));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest zig zag path in the binary tree");
//        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(5));
//        root1.getLeft().getRight().getLeft().setRight(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(6));
//        root1.setRight(new TreeNode<>(3));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1);
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1);
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(4));
//        root1.getRight().getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().getRight().getLeft().setRight(new TreeNode<>(7));
//        root1.getRight().getRight().getLeft().getRight().setRight(new TreeNode<>(8));
//        root1.getRight().getRight().setRight(new TreeNode<>(6));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1); //SKEWED
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(4));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Duplicate zero in-place");
//        //https://leetcode.com/problems/duplicate-zeros/
//        obj.duplicateZeroInArray(new int[]{1, 0, 2, 3, 0, 4, 5, 0});
//        obj.duplicateZeroInArray(new int[]{1, 0, 0, 3, 0, 4, 5, 0});
//        obj.duplicateZeroInArray(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Array Nesting");
//        //https://leetcode.com/problems/array-nesting/
//        obj.arrayNesting(new int[]{5, 4, 0, 3, 1, 6, 2});
//        obj.arrayNesting(new int[]{0, 1, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Escaping ghost");
//        //https://leetcode.com/problems/escape-the-ghosts/
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{1, 0}, {0, 3}}, new int[]{0, 1}));
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{1, 0}}, new int[]{2, 0})); //GHOST is in between user and target
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{2, 0}}, new int[]{1, 0})); //GHOST and user reach target at same time
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove duplicate from sorted array 2 (elements can occur at most twice)");
//        //https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
//        obj.removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(new int[]{1, 1, 1, 2, 2, 3});
//        obj.removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(new int[]{0, 0, 1, 1, 1, 1, 2, 3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Calculate power(row, n)");
//        //https://leetcode.com/problems/powx-n/
//        obj.nPowerOfX(5.0, 0); //5 ^ 0 = 1
//        obj.nPowerOfX(5.0, 1); //5 ^ 1 = 5
//        obj.nPowerOfX(2.0, 10);
//        obj.nPowerOfX(2.0, -3);
//        obj.nPowerOfX(-2.0, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert postfix exprssion to infix expression");
//        //https://www.geeksforgeeks.org/postfix-to-infix/
//        obj.convertPostfixToInfixExpression("abc++");
//        obj.convertPostfixToInfixExpression("52*5+");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert infix exprssion to postfix expression");
//        //https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/
//        //https://leetcode.com/problems/basic-calculator/
//        obj.convertInfixToPostfixExpression("a*b+c/d");
//        obj.convertInfixToPostfixExpression("a+b*c/d-e");
//        obj.convertInfixToPostfixExpression("(a*b)+(c/d)-(e^f)");
//        obj.convertInfixToPostfixExpression("a+b*(c^d-e)^(f+g*h)-i");
//        obj.convertInfixToPostfixExpression("(1+(4+5+2)-3)+(6+8)");
        //......................................................................
//        Row: 307
//        System.out.println("Postfix expression evaluation");
//        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
//        //https://leetcode.com/problems/basic-calculator/
//        obj.postfixExpressionEvaluation_SingleDigit("23+");
//        obj.postfixExpressionEvaluation_SingleDigit("231*+9-");
//        obj.postfixExpressionEvaluation_MultipleDigit("10 20 +");
//        obj.postfixExpressionEvaluation_MultipleDigit("100 200 * 10 /");
//        obj.postfixExpressionEvaluation_MultipleDigit("100 200 + 10 / 1000 +");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Course Schedule 2");
//        //https://leetcode.com/problems/course-schedule/description/
//        //https://leetcode.com/problems/course-schedule-ii/
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}}, 2);
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}, {0, 1}}, 2); //CYCLE
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}, {2, 0}, {3, 1}, {3, 2}}, 4);
//        obj.courseScheduleTwo_Graph(new int[][]{}, 1);
//        /*
//         //https://leetcode.com/discuss/interview-question/742238/Amazon-or-Student-Order
//         Given a result of a competition among all the students of a class,
//         write a program to make students stand in a order such that every
//         student must have lost to the student in his/her immediate left and
//         won against the student to his/her immediate right.
//
//         // student[][] = {{0,1},{1,2}} Here 0 lost to 1, 1 lost to 2
//         output of above:  2 1 0
//         0 loses to 1 so 1 is on left of 0
//         1 0
//         1 loses to 2 so 2 is on left of 1
//         2 1 0
//         */
//        obj.courseScheduleTwo_Graph(new int[][]{{0, 1}, {1, 2}}, 3); //3 is total student
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Course Schedule 3");
//        //https://leetcode.com/problems/course-schedule-iii/
//        obj.courseSchedule_3_Greedy(new int[][]{{100, 200}, {200, 1300}, {1000, 1250}, {2000, 3200}});
//        obj.courseSchedule_3_Greedy(new int[][]{{1, 2}});
//        obj.courseSchedule_3_Greedy(new int[][]{{3, 2}, {4, 3}});
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Boats to Save People/ Efficient janitor");
//        //https://leetcode.com/problems/boats-to-save-people/
//        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
//        //both the approaches works for boats-to-save-people & efficient janitor
//        obj.efficientJanitor_Greedy(new double[]{1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7});
//        obj.efficientJanitor_Greedy(new double[]{1.01, 1.991, 1.32, 1.4});
//        obj.efficientJanitor2_Greedy(new double[]{1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7});
//        obj.efficientJanitor2_Greedy(new double[]{1.01, 1.991, 1.32, 1.4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Flip string to monotone increase");
//        //https://leetcode.com/problems/flip-string-to-monotone-increasing/
//        obj.flipStringToMonotoneIncrease("00110");
//        obj.flipStringToMonotoneIncrease("00110000");
//        obj.flipStringToMonotoneIncrease("00000011"); //ALREADY MONOTONE
//        obj.flipStringToMonotoneIncrease("000000"); //ALREADY MONOTONE
//        obj.flipStringToMonotoneIncrease("11111111"); //ALREADY MONOTONE
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Gas station");
//        //https://leetcode.com/problems/gas-station/
//        obj.gasStationCompleteCircuit(new int[]{1, 2, 3, 4, 5}, new int[]{3, 4, 5, 1, 2});
//        obj.gasStationCompleteCircuit(new int[]{2, 3, 4}, new int[]{3, 4, 3});
//        obj.gasStationCompleteCircuit(new int[]{3, 1, 1}, new int[]{1, 2, 2});
//        obj.gasStationCompleteCircuit2(new int[]{1, 2, 3, 4, 5}, new int[]{3, 4, 5, 1, 2});
//        obj.gasStationCompleteCircuit2(new int[]{2, 3, 4}, new int[]{3, 4, 3});
//        obj.gasStationCompleteCircuit2(new int[]{3, 1, 1}, new int[]{1, 2, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum deletion cost to avoid repeating charracters");
//        //https://leetcode.com/problems/minimum-time-to-make-rope-colorful/
//        //https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/
//        obj.minDeletionCostToAvoidRepeatingChar("abaac", new int[]{1, 2, 3, 4, 5});
//        obj.minDeletionCostToAvoidRepeatingChar("abc", new int[]{1, 2, 3});
//        obj.minDeletionCostToAvoidRepeatingChar("aabaa", new int[]{1, 2, 3, 4, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Alien Dictionary");
//        //https://leetcode.com/problems/alien-dictionary/description/
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"wrt", "wrf", "er", "ett", "rftt"}));
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"z", "x"}));
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"z", "x", "z"}));
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"z", "z"}));
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"ab", "adc"}));
//        System.out.println("Alien Dictionary letter order : "
//                + obj.alienDictionary_Graph(new String[]{"abcd", "abc"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range update and get queries");
//        //https://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/
//        obj.rangeUpdateAndPointQueries(new int[]{0, 0, 0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove all adjacent duplicate K chars in the strings and print remaining");
//        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string
//        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/
//        obj.removeAdjacentDuplicateKCharInString("pbbcggttciiippooaais", 2);
//        obj.removeAdjacentDuplicateKCharInString("abcd", 2);
//        obj.removeAdjacentDuplicateKCharInString("deeedbbcccbdaa", 3);
//        obj.removeAdjacentDuplicateKCharInString("XABCDFFDCBA", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Swaps to Make the Binary String Alternating");
//        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("111000")); //101010
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("00")); //Not Possible
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("1110")); //Not Possible
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("010")); //Already alternate
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("1")); //Already alternate
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rectangle overlapping");
//        //https://leetcode.com/problems/rectangle-overlap/
//        //https://leetcode.com/problems/rectangle-area/
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{0, 0, 2, 2}, new int[]{1, 1, 3, 3})); //overlapping
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{-2, 0, 0, 2}, new int[]{-3, 1, -1, 3})); //Other quadrant
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{0, 0, 1, 1}, new int[]{2, 2, 2, 3})); //No overlapping
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{1, 1, 2, 2}, new int[]{2, 1, 3, 2})); //Only edge touching
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All common element in 3 sorted arrays");
//        //https://practice.geeksforgeeks.org/problems/common-elements1132/1
//        obj.allCommonElementIn3SortedArray(
//                new int[]{1, 5, 10, 20, 40, 80},
//                new int[]{6, 7, 20, 80, 100},
//                new int[]{3, 4, 15, 20, 30, 70, 80, 120});
//        obj.allCommonElementIn3SortedArray(
//                new int[]{3, 3, 3, 3},
//                new int[]{3, 3, 3, 3},
//                new int[]{3, 3, 3, 3});
//        System.out.println("All common element in k unsorted arrays");
//        //https://leetcode.com/problems/intersection-of-multiple-arrays/
//        //https://www.codingninjas.com/codestudio/problems/common-elements-present-in-all-rows-of-a-matrix_1118111
//        obj.allCommonElementInKUnsortedArray(new int[][]{
//            {1, 4, 5, 6}, {3, 4, 5, 6}, {5, 6, 7, 6}});
//        obj.allCommonElementInKUnsortedArray(new int[][]{
//            {1, 2, 3}, {2, 2, 3}, {2, 3, 1}, {2, 3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rearrage elements of array randomly but in-place & in O(N)");
//        //https://leetcode.com/problems/shuffle-an-array/
//        obj.randomlyRearrangeElementsOfArray(new int[]{1, 0, 7, 2, 10});
//        obj.randomlyRearrangeElementsOfArray2(new int[]{1, 0, 7, 2, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Time Needed to Inform All Employees");
//        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
//        obj.timeNeededToInformAllEmployee_NAryTree(1, 0, new int[]{-1}, new int[]{0});
//        obj.timeNeededToInformAllEmployee_NAryTree(6, 2, new int[]{2, 2, -1, 2, 2, 2}, new int[]{0, 0, 1, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_NAryTree(15, 0,
//                new int[]{-1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6},
//                new int[]{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_DFS(1, 0, new int[]{-1}, new int[]{0});
//        obj.timeNeededToInformAllEmployee_DFS(6, 2, new int[]{2, 2, -1, 2, 2, 2}, new int[]{0, 0, 1, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_DFS(15, 0,
//                new int[]{-1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6},
//                new int[]{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Index Sum of Two Lists");
//        //https://leetcode.com/problems/minimum-index-sum-of-two-lists/
//        obj.minimumIndexSumOfTwoStringArray(new String[]{"Shogun", "Tapioca Express", "Burger King", "KFC"},
//                new String[]{"KFC", "Burger King", "Tapioca Express", "Shogun"});
//        obj.minimumIndexSumOfTwoStringArray(new String[]{"Shogun", "Tapioca Express", "Burger King", "KFC"},
//                new String[]{"Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximal square DP");
//        //https://leetcode.com/problems/maximal-square/
//        //https://practice.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {1, 0, 1, 0, 0},
//            {1, 0, 1, 1, 1},
//            {1, 1, 1, 1, 1},
//            {1, 0, 0, 1, 0},}); //SQR: mat[1][2] to mat[2][3]
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {0, 0, 0, 0},
//            {0, 0, 1, 0},
//            {0, 0, 0, 0},}); //SQR: mat[1][2]
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {0}}); //SQR: 0
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},}); //SQR: mat[N][N]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count all squares with one in binary matrix/ maximal squares approach");
//        //https://leetcode.com/problems/count-square-submatrices-with-all-ones
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {0, 0, 0, 0},
//            {0, 0, 1, 0},
//            {0, 0, 0, 0},});
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {0, 1, 1, 1},
//            {1, 1, 1, 1},
//            {0, 1, 1, 1},});
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {1, 1, 0, 0},
//            {1, 1, 0, 0},
//            {0, 0, 0, 0},});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Teemo attacking ashee");
//        //https://leetcode.com/problems/teemo-attacking
//        //https://leetcode.com/discuss/interview-question/280433/Google-or-Phone-screen-or-Program-scheduling
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 4}, 2));
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 2}, 2));
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 10}, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min operation to make array equal of size n");
//        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/
//        obj.minOperationToMakeArrayOfSizeNEqual(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("First Unique Character in a String");
//        //https://leetcode.com/problems/first-unique-character-in-a-string/
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("aabbcc"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("leetcode"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("loveleetcode"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("aaaa"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Pivot Index");
//        //https://leetcode.com/problems/find-pivot-index/
//        //https://leetcode.com/problems/find-the-middle-index-in-array
//        //https://leetcode.com/problems/number-of-ways-to-split-array
//        //https://leetcode.com/problems/left-and-right-sum-differences/description/
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{1, 7, 3, 6, 5, 6}));
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{1, 2, 3}));
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{2, 1, -1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the Distinct Difference Array");
//        //https://leetcode.com/problems/find-the-distinct-difference-array/description/
//        obj.findDistinctDiffArray(new int[]{1, 2, 3, 4, 5});
//        obj.findDistinctDiffArray(new int[]{3, 2, 3, 4, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum subarray sum with unique elements/ Maximum Erasure Value");
//        //https://leetcode.com/problems/maximum-erasure-value/
//        obj.maximumSubarraySumWithUniqueElements(new int[]{4, 2, 4, 5, 6}); //sunarr: [2,4,5,6]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{5, 2, 1, 2, 5, 2, 1, 2, 5}); //sunarr: [5,2,1] or [1,2,5]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 1, 1, 1}); //subarr: [1]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 2, 3, 4}); //subarr: [1,2,3,4]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 1, 2, 2, 3, 3, 4, 4}); //subarr: [3,4]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum path sum in grid(top-left to bottom-right)");
//        //https://leetcode.com/problems/minimum-path-sum/
//        obj.minimumPathSumInGrid(new int[][]{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}});
//        obj.minimumPathSumInGrid(new int[][]{{1, 2, 3}, {4, 5, 6}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array Into Three Parts With Equal Sum");
//        //https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/
//        System.out.println("Pratition possible: "
//                + obj.partitionArrayIntoThreePartsWithEqualSum(new int[]{0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1}));
//        System.out.println("Pratition possible: "
//                + obj.partitionArrayIntoThreePartsWithEqualSum(new int[]{0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Substring with Concatenation of All Words");
//        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/
//        obj.substringWithConcatenationsOfGivenWords("barfoothefoobarman",
//                new String[]{"foo", "bar"});
//        obj.substringWithConcatenationsOfGivenWords("wordgoodgoodgoodbestword",
//                new String[]{"word", "good", "best", "word"});
//        obj.substringWithConcatenationsOfGivenWords("barfoofoobarthefoobarman",
//                new String[]{"bar", "foo", "the"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove all sequences of consecutive linked list node sum to zero");
//        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(-2));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(1));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(0);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(0));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Add two nums without usiing + or -");
//        //https://leetcode.com/problems/sum-of-two-integers
//        obj.addTwoNumsWithoutPlusOrMinus(4, 6);
//        obj.addTwoNumsWithoutPlusOrMinus(4, -6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Top k frequent elements in an array");
//        //https://leetcode.com/problems/top-k-frequent-elements/
//        obj.topKFrequentElements(new int[]{1, 1, 1, 2, 2, 3}, 2);
//        obj.topKFrequentElements(new int[]{1}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum words that you can type");
//        //https://leetcode.com/problems/maximum-number-of-words-you-can-type/
//        obj.maximumWordsThatYouCanType("hello world", "ad"); //hello can be typed, world is broken on char d
//        obj.maximumWordsThatYouCanType("world world", "ad"); //no words can be typed, world is broken on char d
//        obj.maximumWordsThatYouCanType("leet code", "lt"); //code can be typed, leet is broken on char l(even one char can make it broken)
//        obj.maximumWordsThatYouCanType("hello world", "xy"); //hello, world both can be typed, no words contains broken chars row & col
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length AP in binary tree");
//        //https://www.geeksforgeeks.org/longest-path-to-the-bottom-of-a-binary-tree-forming-an-arithmetic-progression/
//        //https://www.geeksforgeeks.org/longest-arithmetic-progression-path-in-given-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setRight(new TreeNode<>(9)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().getRight().setRight(new TreeNode<>(15)); //common diff from prev node is 3
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(6);
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(6);
//        root1.setRight(new TreeNode<>(9));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(15);
//        root1.setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(9)); //common diff from prev node is 3
//        root1.getRight().getRight().setRight(new TreeNode<>(6)); //common diff from prev node is 3
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(15);
//        root1.setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(11)); //common diff from prev node is NOT 3, hence breaking AP, maxLen - 15 -> 12 = 2
//        root1.getRight().getRight().setRight(new TreeNode<>(9));
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest string chain");
//        //https://leetcode.com/problems/longest-string-chain/
//        obj.longestStringChain_DP_Memoization(new String[]{"a", "abc", "ab", "abcd"}); //4
//        obj.longestStringChain_DP_Memoization(new String[]{"a", "b", "ba", "bca", "bda", "bdca"});
//        obj.longestStringChain_DP_Memoization(new String[]{"l", "mn", "op", "qrst"}); //any string can be a single lengthed chain = 1
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Sum Circular Subarray");
//        //https://leetcode.com/problems/maximum-sum-circular-subarray
//        obj.maximumSumCircularSubarray(new int[]{5, -1, -2, 5});
//        obj.maximumSumCircularSubarray(new int[]{-1, 5, 5, -2});
//        obj.maximumSumCircularSubarray(new int[]{-4, -3, -2, -1});
//        System.out.println("Maximum Absolute Sum of Any Subarray");
//        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
//        obj.maxAbsoluteSumOfAnySubarray(new int[]{1, -3, 2, 3, -4});
//        obj.maxAbsoluteSumOfAnySubarray(new int[]{2, -5, 1, -4, 3, -2});
//        obj.maxAbsoluteSumOfAnySubarray2(new int[]{1, -3, 2, 3, -4});
//        obj.maxAbsoluteSumOfAnySubarray2(new int[]{2, -5, 1, -4, 3, -2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find town judge Graph");
//        //https://leetcode.com/problems/find-the-town-judge/
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(2, new int[][]{{1, 2}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(3, new int[][]{{1, 3}, {2, 3}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(3, new int[][]{{1, 3}, {2, 3}, {3, 1}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(4, new int[][]{{1, 2}, {2, 3}, {3, 4}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if a Parentheses String Can Be Valid");
//        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid("))()))", "010100"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid(")))(((", "001100"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid("()()", "0000"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid(")", "0"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Odd Number in String");
//        //https://leetcode.com/problems/largest-odd-number-in-string/
//        obj.largestOddNumInGivenNumString("52");
//        obj.largestOddNumInGivenNumString("4206");
//        obj.largestOddNumInGivenNumString("864278642");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Non-decreasing Array");
//        //https://leetcode.com/problems/non-decreasing-array/
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2, 3}));
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2}));
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Surrounded Regions");
//        //https://leetcode.com/problems/surrounded-regions/
//        //https://leetcode.com/problems/number-of-enclaves/
//        obj.surroundedRegions_Graph(new char[][]{
//            {'X', 'X', 'X', 'X'},
//            {'X', 'O', 'O', 'X'},
//            {'X', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'X'}});
//        obj.surroundedRegions_Graph(new char[][]{
//            {'X', 'O', 'X', 'X', 'X'},
//            {'X', 'O', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'X', 'X'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Increasing Path in a Matrix");
//        //https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
//        obj.longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(
//                new int[][]{{9, 9, 4}, {6, 6, 8}, {2, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Moves in a Grid");
//        //https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/description/
//        obj.maxNumberOfMovesInAGrid_Graph_Memoization(
//                new int[][]{{2, 4, 3, 5}, {5, 4, 9, 3}, {3, 4, 2, 11}, {10, 9, 13, 15}});
//        obj.maxNumberOfMovesInAGrid_Graph_Memoization(
//                new int[][]{{3, 2, 4}, {2, 1, 9}, {1, 1, 7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Increasing Paths In A Matrix");
//        //https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/
//        obj.numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(new int[][]{{1, 1}, {3, 4}});
//        obj.numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(new int[][]{{1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Two Sum/ Two Sum II - Input Array Is Sorted/ Four Sum");
//        //https://leetcode.com/problems/two-sum/
//        //https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
//        //on similar pattern
//        //https://leetcode.com/problems/find-maximum-number-of-string-pairs/description/
//        obj.twoSum_UnsortedArray(new int[]{2, 7, 11, 15}, 9);
//        obj.twoSum_UnsortedArray(new int[]{3, 2, 4}, 6);
//        obj.twoSum2_SortedArray(new int[]{2, 7, 11, 15}, 9);
//        obj.twoSum2_SortedArray(new int[]{-1, 0}, -1);
//        System.out.println("3Sum");
//        //https://leetcode.com/problems/3sum/
//        obj.threeSum(new int[]{-1, 0, 1, 2, -1, -4});
//        obj.threeSum(new int[]{0, 1, 1});
//        obj.threeSum(new int[]{0, 0, 0});
//        obj.threeSum(new int[]{0}); //no trplet sum is possible
//        obj.threeSum(new int[]{});
//        System.out.println("3Sum Closest");
//        //https://leetcode.com/problems/3sum-closest/
//        System.out.println("3Sum closest diff to target: " + obj.threeSumClosest(new int[]{-1, 2, 1, -4}, 1));
//        System.out.println("3Sum closest diff to target: " + obj.threeSumClosest(new int[]{0, 0, 0}, 1));
//        System.out.println("Four Sum");
//        //https://leetcode.com/problems/4sum/
//        obj.fourSum(new int[]{1, 0, -1, 0, -2, 2}, 0);
//        obj.fourSum(new int[]{2, 2, 2, 2, 2}, 8);
//        obj.fourSum_WithThreeSumApproach(new int[]{1, 0, -1, 0, -2, 2}, 0);
//        obj.fourSum_WithThreeSumApproach(new int[]{2, 2, 2, 2, 2}, 8);
//        obj.fourSum_WithThreeSumApproach(new int[]{1000000000, 1000000000, 1000000000, 1000000000}, -294967296);
//        System.out.println("Four Sum II");
//        //https://leetcode.com/problems/4sum-ii/description/
//        obj.fourSumTwo(new int[]{1, 2}, new int[]{-2, -1}, new int[]{-1, 2}, new int[]{0, 2});
//        obj.fourSumTwo(new int[]{0}, new int[]{0}, new int[]{0}, new int[]{0});
//        obj.fourSumTwo(new int[]{-1, -1}, new int[]{-1, 1}, new int[]{-1, 1}, new int[]{1, -1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest String With A Given Numeric Value");
//        //https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/
//        obj.smallestStringWithGivenLengthNAndCharSumValueK(3, 27);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Replace All ?'s to Avoid Consecutive Repeating Characters");
//        //https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("?zs");
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("ubv?w");
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("?z?a?");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Simplify Path");
//        //https://leetcode.com/problems/simplify-path/
//        //https://leetcode.com/problems/crawler-log-folder/
//        System.out.println("Canonical path: " + obj.simplifyPath("/home/"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/../"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/home///foo/./bar/zoo/./../"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/a//b////c/d//././/.."));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Length of Subarray With Positive Product");
//        //https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{1, -2, -3, 4}); //lenght = 4 as 1 * -2 * -3 * 4 > 0
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{0, 1, -2, -3, -4});
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{-1, 8, 8, -2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Swim in Rising Water");
//        //https://leetcode.com/problems/swim-in-rising-water/
//        System.out.println("Time taken to swim in rising water to bottom-right corner: "
//                + obj.swimInRisingWater_Graph(new int[][]{
//            {0, 2}, {1, 3}}));
//        System.out.println("Time taken to swim in rising water to bottom-right corner: "
//                + obj.swimInRisingWater_Graph(new int[][]{
//            {0, 1, 2, 3, 4},
//            {24, 23, 22, 21, 5},
//            {12, 13, 14, 15, 16},
//            {11, 17, 18, 19, 20},
//            {10, 9, 8, 7, 6}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Path With Minimum Effort");
//        //https://leetcode.com/problems/path-with-minimum-effort/
//        System.out.println("Path with min efforts: "
//                + obj.pathWithMinEffort_Graph(new int[][]{{1, 2, 2}, {3, 8, 2}, {5, 3, 5}}));
//        System.out.println("Path with min efforts: "
//                + obj.pathWithMinEffort_Graph(new int[][]{
//            {1, 2, 1, 1, 1},
//            {1, 2, 1, 2, 1},
//            {1, 2, 1, 2, 1},
//            {1, 2, 1, 2, 1},
//            {1, 1, 1, 2, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Common Characters");
//        //https://leetcode.com/problems/find-common-characters/
//        //https://leetcode.com/problems/intersection-of-two-arrays-ii/
//        //https://leetcode.com/problems/find-the-difference-of-two-arrays/
//        obj.findCommonCharacters(new String[]{"bella", "label", "roller"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Word Subsets");
//        //https://leetcode.com/problems/word-subsets/
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"e", "o"});
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"e", "l"});
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"ama", "o"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Interval to Include Each Query");
//        //https://leetcode.com/problems/minimum-interval-to-include-each-query/
//        obj.minimumIntervalToIncludeEachQuery(new int[][]{
//            {1, 4}, {2, 4}, {3, 6}, {4, 4}}, new int[]{2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Three Consecutive Integers That Sum to a Given Number");
//        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/
//        obj.threeConsecutiveNumberThatSumsToGivenNumber(33);
//        obj.threeConsecutiveNumberThatSumsToGivenNumber(4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge Nodes in Between Zeros");
//        //https://leetcode.com/problems/merge-nodes-in-between-zeros/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(3));
//        head.getNext().setNext(new Node<>(1));
//        head.getNext().getNext().setNext(new Node<>(0));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(0));
//        obj.mergeNodesInBetweenZeros(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Search Suggestions System");
//        //https://leetcode.com/problems/search-suggestions-system/
//        obj.searchSuggestionSystem(new String[]{"mobile", "mouse", "moneypot", "monitor", "mousepad"}, "mouse");
//        //https://practice.geeksforgeeks.org/problems/phone-directory4628/1
//        obj.searchSuggestionSystem_TrieBased(new String[]{"mobile", "mouse", "moneypot", "monitor", "mousepad"}, "mouse");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length prefix of one string that occurs as subsequence in another");
//        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
//        obj.maximumLengthOfSubstringThatExistsAsSubseqInOtherString("biggerdiagram", "digger");
//        obj.maximumLengthOfSubstringThatExistsAsSubseqInOtherString("abcdef", "xyz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Is Subsequence");
//        //https://leetcode.com/problems/is-subsequence/
//        //https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/
//        //https://practice.geeksforgeeks.org/problems/find-patterns0606/1
//        System.out.println("Is string curr exists as any subseq in main: "
//                + obj.isSubsequence("ahbgdc", "abc"));
//        //whole digger string doesn't exists as any subseq in main string
//        System.out.println("Is string curr exists as any subseq in main: "
//                + obj.isSubsequence("biggerdiagram", "digger"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Make String a Subsequence Using Cyclic Increments");
//        //https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/description/
//        System.out.println("Is subsequence using cyclic increaments : "
//                + obj.isSubsequenceUsingCyclicIncreaments("abc", "ad"));
//        System.out.println("Is subsequence using cyclic increaments : "
//                + obj.isSubsequenceUsingCyclicIncreaments("zc", "ad"));
//        System.out.println("Is subsequence using cyclic increaments : "
//                + obj.isSubsequenceUsingCyclicIncreaments("ab", "d"));
//        System.out.println("Is subsequence using cyclic increaments : "
//                + obj.isSubsequenceUsingCyclicIncreaments("zab", "zbc"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT MY GOOGLE INTERVIEW QUESTION
//        System.out.println("Shortest Way to Form String");
//        //https://leetcode.com/problems/shortest-way-to-form-string/description/
//        //https://leetcode.ca/all/1055.html
//        System.out.println("Shortest way to form a string : " + obj.shortestWayToFormAString("aaaabbc", "aacbbabc"));
//        System.out.println("Shortest way to form a string : " + obj.shortestWayToFormAString("aaaabbc", "lmno"));
//        System.out.println("Shortest way to form a string : " + obj.shortestWayToFormAString("aaaabbc", "abcbbabc"));
//        obj.shortestWayToFormAString2("aaaabbc", "aacbbabc");
//        obj.shortestWayToFormAString2("aaaabbc", "lmno");
//        obj.shortestWayToFormAString2("aaaabbc", "abcbbabc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Matching Subsequences");
//        //https://leetcode.com/problems/number-of-matching-subsequences/
//        obj.numberOfMatchingSubseq("abcde", new String[]{"a", "bb", "acd", "ace"});
//        obj.numberOfMatchingSubseq2("abcde", new String[]{"a", "bb", "acd", "ace"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Append Characters to String to Make Subsequence");
//        //https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/
//        obj.appendCharsToMakeStringSubseq("coaching", "coding");
//        obj.appendCharsToMakeStringSubseq("abcde", "a");
//        obj.appendCharsToMakeStringSubseq("z", "abcde");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary Tree Cameras");
//        //https://leetcode.com/problems/binary-tree-cameras/
//        TreeNode<Integer> root1 = new TreeNode<>(0);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(0));
//        obj.binaryTreeCameras(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert Sorted Array to Height Balanced Binary Search Tree");
//        //https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
//        obj.convertSortedArrayToHeightBalancedBinarySearchTree(new int[]{-10, -3, 0, 5, 9});
//        obj.convertSortedArrayToHeightBalancedBinarySearchTree(new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Arrows to Burst Balloons");
//        //https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {1, 6}, {7, 12}});
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {10, 16}, {2, 8}, {1, 6}, {7, 12}});
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {1, 2}, {3, 4}, {5, 6}, {7, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Triangle - minimum path sum from top to bottom");
//        //https://leetcode.com/problems/triangle/
//        List<List<Integer>> triangle = new ArrayList<>();
//        triangle.add(Arrays.asList(2));
//        triangle.add(Arrays.asList(3, 4));
//        triangle.add(Arrays.asList(6, 5, 7));
//        triangle.add(Arrays.asList(4, 1, 8, 3));
//        System.out.println("Min path sum top to bottom in triangle 2d matrix: "
//                + obj.triangleMinPathSumTopToBottom(triangle));
//        triangle = new ArrayList<>();
//        triangle.add(Arrays.asList(2));
//        System.out.println("Min path sum top to bottom in triangle 2d matrix: "
//                + obj.triangleMinPathSumTopToBottom(triangle));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Path Sum In The Matrix - From Any Value In First Row To Any Col In Last Row");
//        //https://www.codingninjas.com/codestudio/problems/maximum-path-sum-in-the-matrix_797998?leftPanelTab=0
//        System.out.println("Max path sum in matrix from any col in top row to any col in last row: "
//                + obj.maxPathSumInMatrixFromFirstRowToLastRow(new int[][]{
//            {1, 2, 10, 4},
//            {100, 3, 2, 1},
//            {1, 1, 20, 2},
//            {1, 2, 2, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Candy Distribution");
//        //https://leetcode.com/problems/candy/
//        obj.candyDistributionToNStudent(new int[]{1, 0, 2}); //EASY UNDERSTANDING
//        obj.candyDistributionToNStudent2(new int[]{1, 0, 2}); //SPACE OPTIMISED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array Such That Maximum Difference Is K");
//        //https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/
//        obj.partitionArrSuchThatMaxDiffIsK_Greedy(new int[]{3, 6, 1, 2, 5}, 2);
//        obj.partitionArrSuchThatMaxDiffIsK_Greedy(new int[]{2, 2, 4, 5}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Triangular Sum of an Array");
//        //https://leetcode.com/problems/find-triangular-sum-of-an-array/
//        //https://leetcode.com/problems/min-max-game/
//        obj.findTriangularSumOfArray(new int[]{1, 2, 3, 4, 5});
//        obj.findTriangularSumOfArray(new int[]{5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fair Distribution of Cookies");
//        //https://leetcode.com/problems/fair-distribution-of-cookies/
//        obj.minimumUnfairDistributionOfCookiesToKStudent_Backtracking(new int[]{8, 15, 10, 20, 8}, 2);
//        obj.minimumUnfairDistributionOfCookiesToKStudent_Backtracking(new int[]{6, 1, 3, 2, 2, 4, 1, 2}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("132 Pattern");
//        //https://leetcode.com/problems/132-pattern/
//        System.out.println("132 Pattern: " + obj.has132Pattern(new int[]{1, 2, 3, 4}));
//        System.out.println("132 Pattern: " + obj.has132Pattern(new int[]{3, 1, 4, 2}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Swaps to Make the String Balanced");
//        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
//        obj.minimumSwapsToMakeParenthesisStringBalanced("][][");
//        obj.minimumSwapsToMakeParenthesisStringBalanced("]]][[[");
//        obj.minimumSwapsToMakeParenthesisStringBalanced("[[]][]");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Add to Make Parentheses Valid");
//        //https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
//        obj.minimumAdditionsToMakeParenthesisStringValid("())");
//        obj.minimumAdditionsToMakeParenthesisStringValid("(())");
//        obj.minimumAdditionsToMakeParenthesisStringValid(")))(((");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Furthest Building You Can Reach");
//        //https://leetcode.com/problems/furthest-building-you-can-reach/
//        System.out.println("Index of the farthest building we can reach: "
//                + obj.farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(new int[]{4, 2, 7, 6, 9, 14, 12}, 5, 1));
//        System.out.println("Index of the farthest building we can reach: "
//                + obj.farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(new int[]{1, 5, 1, 2, 3, 4, 10000}, 4, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Verifying an Alien Dictionary");
//        //https://leetcode.com/problems/verifying-an-alien-dictionary/
//        System.out.println("Alien word dict are sorted acc to alien aplhabet: "
//                + obj.areAlienWordsSorted(new String[]{"hello", "leetcode"}, "hlabcdefgijkmnopqrstuvwxyz"));
//        System.out.println("Alien word dict are sorted acc to alien aplhabet: "
//                + obj.areAlienWordsSorted(new String[]{"apple", "app"}, "abcdefghijklmnopqrstuvwxyz"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Detect Squares");
//        //https://leetcode.com/problems/detect-squares/
//        List<int[]> points = Arrays.asList(
//                new int[]{3, 10},
//                new int[]{11, 2},
//                new int[]{3, 2}
//        );
//        List<int[]> queryPoints = Arrays.asList(
//                new int[]{11, 10},
//                new int[]{14, 8}
//        );
//        obj.detectSquares(points, queryPoints);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Amount To Paint The Area");
//        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
//        //https://algo.monster/liteproblems/2158
//        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
//        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
//        obj.amountToPaintTheArea(new int[][]{
//            {4, 10}, {7, 13}, {16, 20}, {1, 40}});
//        obj.amountToPaintTheArea2(new int[][]{
//            {4, 10}, {7, 13}, {16, 20}, {1, 40}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Process Tasks Using Servers / Find Servers That Handled Most Number of Requests");
//        //https://leetcode.com/problems/process-tasks-using-servers
//        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
//        //https://leetcode.com/discuss/interview-question/2072047/Google-or-Onsite-or-Banglore-or-May-2022-or-Patient-Queue
//        obj.serverAllocationToTasks(new int[]{3, 3, 2}, new int[]{1, 2, 3, 2, 1, 2});
//        //https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3, 4, 5}, new int[]{5, 2, 3, 3, 3});
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3, 4}, new int[]{1, 2, 1, 2});
//        obj.serversThatHandledMostRequests(2, new int[]{1, 2, 3, 4}, new int[]{1, 2, 1, 2});
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3}, new int[]{10, 12, 11});
//        System.out.println("Meeting Room Three / Find Max Patient Treated In Any Given N Rooms");
//        //https://leetcode.com/problems/meeting-rooms-iii/
//        obj.meetingRoomsThree(2, new int[][]{{0, 10}, {1, 5}, {2, 7}, {3, 4}});
//        obj.meetingRoomsThree(3, new int[][]{{1, 20}, {2, 10}, {3, 5}, {4, 9}, {6, 8}});
//        // room 2 as (1,2) will be alloted first and will go first then (6,4) will be alloted
//        obj.maxPatientTreatedInGivenInAnyNRoom(new int[][]{
//            {1, 8}, {1, 2}, {6, 4}}, 2);
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("DI String Match/ Construct Smallest Number From DI String");
//        //https://leetcode.com/problems/di-string-match/
//        obj.generateNumberFollowingPattern("D");
//        obj.generateNumberFollowingPattern("IIDDD");
//        obj.generateNumberFollowingPattern("IDID");
//        obj.generateNumberFollowingPattern("III");
//        obj.generateNumberFollowingPattern("DDI");
//        //https://leetcode.com/problems/construct-smallest-number-from-di-string/
//        obj.generateSmallestNumberFromDIString("D");
//        obj.generateSmallestNumberFromDIString("IIIDIDDD");
//        obj.generateSmallestNumberFromDIString("DDD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pacific Atlantic Water Flow");
//        //https://leetcode.com/problems/pacific-atlantic-water-flow/
//        obj.pacificAtlanticWaterFlow(new int[][]{
//            {1, 2, 2, 3, 5},
//            {3, 2, 3, 4, 4},
//            {2, 4, 5, 3, 1},
//            {6, 7, 1, 4, 5},
//            {5, 1, 1, 2, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Mth Element After K Array Rotation");
//        //https://www.geeksforgeeks.org/cpp-program-to-find-the-mth-element-of-the-array-after-k-left-rotations/
//        obj.mThElementAfterKArrayRotation(new int[]{1, 2, 3, 4, 5}, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("The Skyline Problem");
//        //https://leetcode.com/problems/the-skyline-problem/
//        obj.skylineProblem(new int[][]{
//            {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
//        });
//        //OPTIMIZED with tree map
//        obj.skylineProblem_TreeMap(new int[][]{
//            {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Angle Between Hands of a Clock");
//        //https://leetcode.com/problems/angle-between-hands-of-a-clock/
//        obj.minAngleBetweeHourAndMinuteHands(12, 30);
//        obj.minAngleBetweeHourAndMinuteHands(2, 60); // 3:00
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Inserts/ Deletes To Make String Pallindrome");
//        //https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
//        //https://www.geeksforgeeks.org/java-program-to-find-minimum-insertions-to-form-a-palindrome-dp-28/
//        obj.minInsertsToMakeStringPallindrome_DP_Memoization("abcda"); //insert d,b like this abdcdba
//        obj.minInsertsToMakeStringPallindrome_DP_Memoization("aba");
//        obj.minDeletesToMakeStringPallindrome_DP_Memoization("abcda"); //deletes d,b like this aca
//        obj.minDeletesToMakeStringPallindrome_DP_Memoization("aba");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize sum of given array after removing valleys");
//        //https://www.geeksforgeeks.org/maximize-sum-of-given-array-after-removing-valleys/
//        obj.maximizeSumAfterRemovingValleys(new int[]{5, 1, 8}); //valley removed [1,1,8] = 10
//        obj.maximizeSumAfterRemovingValleys(new int[]{8, 1, 10, 1, 8}); // valley removed [1,1,10,1,1] = 14
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Moves to Make Palindrome");
//        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/
//        // a_swap(a,b)_b ==> abab ==> swap(a,b)_ab ==> baab == pallindrome in 2 swaps
//        obj.minMovesToMakeStringPallindrome("aabb");
//        obj.minMovesToMakeStringPallindrome("zzazz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest 3-Same-Digit Number in String");
//        //https://leetcode.com/problems/largest-3-same-digit-number-in-string/
//        obj.largestThreeSameDigitNumInString("6777133339");
//        obj.largestThreeSameDigitNumInString("2300019");
//        obj.largestThreeSameDigitNumInString("42352338");
//        obj.largestThreeSameDigitNumInString("00042352338");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Visible People in a Queue");
//        //https://leetcode.com/problems/number-of-visible-people-in-a-queue/
//        obj.numberOfVisiblePeopleInQueue(new int[]{10, 6, 8, 5, 11, 9});
//        obj.numberOfVisiblePeopleInQueue(new int[]{5, 1, 2, 3, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min Cost to Connect All Points/ Prim's Algo Based");
//        //https://leetcode.com/problems/min-cost-to-connect-all-points/
//        obj.minCostToConnectAllPoints_Graph(new int[][]{
//            {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}});
//        obj.minCostToConnectAllPoints_Graph(new int[][]{
//            {3, 12}, {-2, 5}, {-4, 1}});
//        obj.minCostToConnectAllPoints_Graph_UnionFind(new int[][]{
//            {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}});
//        obj.minCostToConnectAllPoints_Graph_UnionFind(new int[][]{
//            {3, 12}, {-2, 5}, {-4, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Split Array Largest Sum");
//        //https://leetcode.com/problems/split-array-largest-sum/
//        obj.splitArrayInLargestSum(new int[]{7, 2, 5, 10, 8}, 2);
//        obj.splitArrayInLargestSum(new int[]{1, 2, 3, 4, 5}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Capacity To Ship Packages Within D Days");
//        //https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
//        //https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store
//        obj.shipWeightsWithinGivenDays(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1);
//        obj.shipWeightsWithinGivenDays(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5);
//        obj.shipWeightsWithinGivenDays(new int[]{3, 2, 2, 4, 1, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize Page Allocations To Students");
//        //https://www.interviewbit.com/problems/allocate-books/
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 2);
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 1);
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Koko Eating Bananas");
//        //https://leetcode.com/problems/koko-eating-bananas/
//        obj.kokoEatingBananas(new int[]{3, 6, 7, 11}, 8);
//        obj.kokoEatingBananas(new int[]{30, 11, 23, 4, 20}, 5);
//        obj.kokoEatingBananas(new int[]{30, 11, 23, 4, 20}, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Time to Complete Trips");
//        //https://leetcode.com/problems/minimum-time-to-complete-trips/description/
//        obj.minTimeToCompleteTrips(new int[]{1, 2, 3}, 5);
//        obj.minTimeToCompleteTrips(new int[]{2}, 1);
//        obj.minTimeToCompleteTrips(new int[]{100}, 10000000);
//        obj.minTimeToCompleteTrips(new int[]{1000}, 10000000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Speed to Arrive on Time");
//        //https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/
//        obj.minSpeedToArriveOnTime(new int[]{1, 3, 2}, 6);
//        obj.minSpeedToArriveOnTime(new int[]{1, 3, 2}, 2.7);
//        obj.minSpeedToArriveOnTime(new int[]{1, 3, 2}, 1.9);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Running Time of N Computers");
//        //https://leetcode.com/problems/maximum-running-time-of-n-computers/description/
//        obj.maxRunningTimeOfNComputers(2, new int[]{3, 3, 3});
//        obj.maxRunningTimeOfNComputers(2, new int[]{1, 1, 1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize the Maximum Difference of Pairs");
//        //https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/
//        obj.minimizeMaxDiffOfPairs(new int[]{10, 1, 2, 7, 1, 3}, 2);
//        obj.minimizeMaxDiffOfPairs(new int[]{4, 2, 1, 2}, 1);
//        obj.minimizeMaxDiffOfPairs(new int[]{3, 3, 5, 1, 0, 5, 6, 6}, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cutting Ribbons");
//        //https://leetcode.com/problems/cutting-ribbons/description/
//        obj.cuttingRibbons(new int[]{9, 7, 5}, 3);
//        obj.cuttingRibbons(new int[]{9, 7, 5}, 4);
//        obj.cuttingRibbons(new int[]{9, 7, 5}, 22);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cake Distribution Problem");
//        //https://practice.geeksforgeeks.org/problems/0a7c7f1089932257071f9fa076f25d353f91e0fd/1
//        obj.cakeDistributionMaxSweetnessAmongKFriends(new int[]{6, 3, 2, 8, 7, 5}, 2);
//        obj.cakeDistributionMaxSweetnessAmongKFriends(new int[]{1, 2, 4, 7, 3, 6, 9}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Subsequence of Length K With the Largest Sum");
//        //https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/
//        obj.subseqOfLengthKWithLargestSum(new int[]{2, 1, 3, 3}, 2);
//        obj.subseqOfLengthKWithLargestSum(new int[]{-1, -2, 3, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Flips to Make the Binary String Alternating");
//        //https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
//        obj.minFlipsToMakeBinaryStringAlternating("111000");
//        obj.minFlipsToMakeBinaryStringAlternating("010");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("12 Color Card Possible");
//        //https://leetcode.com/discuss/interview-experience/2279548/Google-or-Phone-Screen-or-Question-or-India
//        obj.cardOf12();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Paint Fence");
//        //https://leetcode.com/problems/paint-fence/description/
//        //https://www.geeksforgeeks.org/painting-fence-algorithm/
//        obj.paintFence_DP_Memoization(1, 2);
//        obj.paintFence_DP_Memoization(2, 2);
//        obj.paintFence_DP_Memoization(3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range Addition II");
//        //https://leetcode.com/problems/range-addition-ii/
//        obj.rangeAdditionTwo(3, 3, new int[][]{});
//        obj.rangeAdditionTwo(3, 3, new int[][]{{2,2},{3,3}});
//        System.out.println("Smallest Rectangle Enclosing Black Pixels");
//        //https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/
//        obj.smallestRectangleEnclosingBlackPixels(new int[][]{
//            {0, 0, 1, 0}, {0, 1, 1, 0}, {0, 1, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Jump game(s)");
//        //https://leetcode.com/problems/jump-game/
//        obj.jumpGame(new int[]{2, 3, 1, 1, 4});
//        obj.jumpGame(new int[]{3, 2, 1, 0, 4});
//        obj.jumpGame(new int[]{1});
//        obj.jumpGame(new int[]{0});
//        //https://leetcode.com/problems/jump-game-ii/description/
//        obj.jumpGameTwo(new int[]{2, 3, 1, 1, 4});
//        obj.jumpGameTwo(new int[]{2, 3, 0, 1, 4});
//        //https://leetcode.com/problems/jump-game-iii/
//        obj.jumpGameThree(new int[]{4, 2, 3, 0, 3, 1, 2}, 5);
//        obj.jumpGameThree(new int[]{3, 0, 2, 1, 2}, 2);
//        //https://leetcode.com/problems/jump-game-iv/
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{100, -23, -23, 404, 100, 23, 23, 23, 3, 404}));
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{7}));
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{7, 6, 9, 6, 9, 6, 9, 7}));
//        //https://leetcode.com/problems/jump-game-vii/
//        System.out.println("Can we reach end of str: " + obj.jumpGameSeven("011010", 2, 3));
//        System.out.println("Can we reach end of str: " + obj.jumpGameSeven("01101110", 2, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Frog jump");
//        //https://leetcode.com/problems/frog-jump/
//        obj.frogJump_Recursive_Memoization(new int[]{0, 1, 3, 5, 6, 8, 12, 17});
//        obj.frogJump_Recursive_Memoization(new int[]{0, 1, 2, 3, 4, 8, 9, 11});
//        System.out.println("Frog can reach the end of river: " + obj.frogJump(new int[]{0, 1, 3, 5, 6, 8, 12, 17}));
//        System.out.println("Frog can reach the end of river: " + obj.frogJump(new int[]{0, 1, 2, 3, 4, 8, 9, 11}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Djikstra Algorithm Graph");
//        obj.djikstraAlgorithm_Graph();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Network Delay Time");
//        //https://leetcode.com/problems/network-delay-time/
//        obj.networkTimeDelay_Graph(new int[][]{{2, 1, 1}, {2, 3, 1}, {3, 4, 1}}, 4, 2);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}}, 2, 1);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}}, 2, 2);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}, {2, 1, 1}}, 2, 1);
//        //max network delay is 100 because max time it will take from 1 to 2
//        //and other nodes will take 1 unit time each
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 100}, {1, 3, 1}, {3, 4, 1}, {4, 5, 1}, {5, 6, 1}}, 6, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Task Schedular");
//        //https://leetcode.com/problems/task-scheduler/
//        obj.taskSchedular_Greedy(new char[]{'A', 'A', 'A', 'B', 'B', 'B'}, 2);
//        obj.taskSchedular_Greedy(new char[]{'A', 'A', 'A', 'B', 'B', 'B'}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If A Move Is Legal");
//        //https://leetcode.com/problems/check-if-move-is-legal/
//        obj.checkIfMoveIsLegal(
//                new String[][]{
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {"W", "B", "B", ".", "W", "W", "W", "B"},
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."}
//                }, 4, 3, "B"
//        );
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Island Perimeter");
//        //https://leetcode.com/problems/island-perimeter/
//        obj.islandPerimeter(new int[][]{{0, 1, 0}, {0, 1, 0}});
//        obj.islandPerimeter(new int[][]{{1, 1, 0}});
//        obj.islandPerimeter(new int[][]{
//            {0, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Decode String");
//        //https://leetcode.com/problems/decode-string/
//        obj.decodedString("3[a]2[bc]");
//        obj.decodedString("3[a2[c]]");
//        obj.decodedString("2[abc]3[cd]ef");
//        obj.decodedString("20[abc]3[cd]ef");
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Substrings Between Each Pair of Parentheses");
//        //https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
//        obj.reverseSubstringsBetweenParenthesis("(abcd)");
//        obj.reverseSubstringsBetweenParenthesis("(i(love)i)");
//        obj.reverseSubstringsBetweenParenthesis("(ed(et(oc))el)");
//        obj.reverseSubstringsBetweenParenthesis("a(bcdefghijkl(mno)p)q");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Valid Palindrome II");
//        //https://leetcode.com/problems/valid-palindrome-ii/
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("abc"));
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("aba"));
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("abca"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Decode Ways DP Problem");
//        //https://leetcode.com/problems/decode-ways/
//        obj.decodeWays_Recursive_Memoization("12");
//        obj.decodeWays_Recursive_Memoization("226");
//        obj.decodeWays_Recursive_Memoization("06");
//        obj.decodeWays_Recursive_Memoization("11106");
//        obj.decodeWays_DP_Memoization("12");
//        obj.decodeWays_DP_Memoization("226");
//        obj.decodeWays_DP_Memoization("06");
//        obj.decodeWays_DP_Memoization("11106");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Two City Scheduling");
//        //https://leetcode.com/problems/two-city-scheduling/
//        obj.twoCityScheduling_Greedy(new int[][]{
//            {10, 20}, {30, 200}, {400, 50}, {30, 20}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT MY GOOGLE ONSITE INTERVIEW
//        System.out.println("Filling Bookcase Shelves");
//        //https://leetcode.com/problems/filling-bookcase-shelves/
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 1}, {3, 1}}, 4);
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 1}, {2, 3}, {2, 3}, {1, 1}, {1, 1}, {1, 1}, {1, 2}}, 4);
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 3}, {2, 4}, {3, 2}}, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Perfect Squares");
//        //https://leetcode.com/problems/perfect-squares
//        //possible perfect sqrs that sum upto 12
//        //1. sqr(3) + sqr(1) + sqr(1) + sqr(1) ==> 9 + 1 + 1 + 1 == 12
//        //2. sqr(2) + sqr(2) + sqr(2) ==> 4 + 4 + 4 == 12 also this is MIN hence our result
//        obj.perfectSquares_DP_Recursive_Memoization(12);
//        obj.perfectSquares_DP_Recursive_Memoization(13);
//        obj.perfectSquares_DP_Recursive_Memoization(1);
//        //TLE on leetcode
//        obj.perfectSquares_DP_Memoization(12);
//        obj.perfectSquares_DP_Memoization(13);
//        obj.perfectSquares_DP_Memoization(1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Out of Boundary Paths");
//        //https://leetcode.com/problems/out-of-boundary-paths/
//        obj.outOfBoundaryPaths_DP_Recursive_Memoization(2, 2, 2, 0, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range Sum Query (1D/ 2D) - Immutable");
//        //https://leetcode.com/problems/range-sum-query-immutable/
//        //https://leetcode.com/problems/range-sum-query-2d-immutable/
//        obj.rangeSumQueries_BruteForce(
//                new int[]{-2, 0, 3, -5, 2, -1},
//                new int[][]{{0, 2}, {2, 5}, {0, 5}});
//        obj.rangeSumQueries(
//                new int[]{-2, 0, 3, -5, 2, -1},
//                new int[][]{{0, 2}, {2, 5}, {0, 5}});
//        obj.rangeSumQuery2D(
//                new int[][]{
//                    {3, 0, 1, 4, 2},
//                    {5, 6, 3, 2, 1},
//                    {1, 2, 0, 1, 5},
//                    {4, 1, 0, 1, 7},
//                    {1, 0, 3, 0, 5}},
//                new int[][]{
//                    {0, 0, 4, 4},
//                    {2, 1, 4, 3},
//                    {1, 1, 2, 2},
//                    {1, 2, 2, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary Search Tree Iterator");
//        //https://leetcode.com/problems/binary-search-tree-iterator
//        TreeNode<Integer> root1 = new TreeNode<>(2);
//        root1.setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(3));
//        obj.binarySearchTreeIterator(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition to K Equal Sum Subsets");
//        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/
//        System.out.println("Partition to K equal subset sum possible: "
//                + obj.partitionToKEqualSumSubset_Backtracking(new int[]{4, 3, 2, 3, 5, 2, 1}, 4));
//        System.out.println("Partition to K equal subset sum possible: "
//                + obj.partitionToKEqualSumSubset_Backtracking(new int[]{1, 2, 3, 4}, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Implement Increamental Stack");
//        obj.implementIncreamentalStack();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("N-Queens");
//        //https://leetcode.com/problems/n-queens/
//        //https://leetcode.com/problems/n-queens-ii/
//        obj.nQueens_Backtracking(1);
//        obj.nQueens_Backtracking(4);
//        obj.nQueens_Backtracking(9);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sudoku Solver");
//        //https://leetcode.com/problems/sudoku-solver
//        obj.sudokuSolver_Backtracking(new char[][]{
//            {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
//            {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
//            {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
//            {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
//            {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
//            {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
//            {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
//            {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
//            {'.', '.', '.', '.', '8', '.', '.', '7', '9'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked List in Binary Tree");
//        //https://leetcode.com/problems/linked-list-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().getLeft().getRight().setRight(new TreeNode<>(3));
//        Node<Integer> head = new Node<>(4);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(8));
//        obj.linkedListInBinaryTree(head, root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Text Justification");
//        //https://leetcode.com/problems/text-justification/
//        //https://leetcode.com/problems/rearrange-spaces-between-words/description/
//        obj.textJustification(new String[]{"This", "is", "an", "example", "of", "text", "justification."}, 16);
//        obj.textJustification(new String[]{"What", "must", "be", "acknowledgment", "shall", "be"}, 16);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Positions of Large Groups");
//        //https://leetcode.com/problems/positions-of-large-groups/
//        obj.positionsOfLargeGroups("abbxxxxzzy");
//        obj.positionsOfLargeGroups("aaa");
//        obj.positionsOfLargeGroups("abc");
//        obj.positionsOfLargeGroups("nnnhaaannnm");
//        obj.positionsOfLargeGroups2("abbxxxxzzy");
//        obj.positionsOfLargeGroups2("aaa");
//        obj.positionsOfLargeGroups2("abc");
//        obj.positionsOfLargeGroups2("nnnhaaannnm");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Frog Jump DP Problem");
//        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
//        obj.frogJump_Recursive_And_Memoization(new int[]{10, 20, 30, 10});
//        obj.frogJump_DP_Memoization(new int[]{10, 20, 30, 10});
//        obj.frogJump_DP_Memoization_SpaceOptimization(new int[]{10, 20, 30, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Ninjas Training");
//        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
//        obj.ninjaTraining_Recursive_And_Memoization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_Recursive_And_Memoization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
//        obj.ninjaTraining_DP_Memoization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_DP_Memoization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
//        obj.ninjaTraining_DP_Memoization_SpaceOptimization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_DP_Memoization_SpaceOptimization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array According to Given Pivot");
//        //https://leetcode.com/problems/partition-array-according-to-given-pivot/
//        obj.partitionArrayOnGivenPivot(new int[]{9, 12, 5, 10, 14, 3, 10}, 10);
//        obj.partitionArrayOnGivenPivot(new int[]{-3, 4, 3, 2}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rearrange Array Elements by Sign");
//        //https://leetcode.com/problems/rearrange-array-elements-by-sign
//        obj.rearrangeArrayElementsBySign(new int[]{3, 1, -2, -5, 2, -4});
//        obj.rearrangeArrayElementsBySign(new int[]{-1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print Binary Tree In String Array Format");
//        //https://leetcode.com/problems/print-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().getLeft().getRight().setRight(new TreeNode<>(3));
//        obj.printBinaryTreeInStringMatrixFormat(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Eventual Safe States Graph Problem");
//        //https://leetcode.com/problems/find-eventual-safe-states/
//        obj.findEventualSafeNodes_Graph(new int[][]{{1, 2}, {2, 3}, {5}, {0}, {5}, {}, {}});
//        obj.findEventualSafeNodes_Graph(new int[][]{{1, 2, 3, 4}, {1, 2}, {3, 4}, {0, 4}, {}});
//        obj.findEventualSafeNodes_Graph2(new int[][]{{1, 2}, {2, 3}, {5}, {0}, {5}, {}, {}});
//        obj.findEventualSafeNodes_Graph2(new int[][]{{1, 2, 3, 4}, {1, 2}, {3, 4}, {0, 4}, {}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Provinces");
//        //https://leetcode.com/problems/number-of-provinces/
//        obj.numberOfProvince_Graph(new int[][]{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph(new int[][]{{1, 0, 1}, {0, 1, 0}, {1, 0, 1}});
//        obj.numberOfProvince_Graph(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 0, 1}, {0, 1, 0}, {1, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Most Stones Removed with Same Row or Column");
//        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}, {0, 1}, {1, 0}, {1, 2}, {2, 1}, {2, 2}});
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}, {0, 2}, {1, 1}, {2, 0}, {2, 2}});
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distant Barcodes");
//        //https://leetcode.com/problems/distant-barcodes/
//        obj.distinctBarcodes(new int[]{1, 1, 1, 2, 2, 2});
//        obj.distinctBarcodes(new int[]{1, 1, 1, 1, 2, 2, 3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Super Washing Machines (Greedy Problem)");
//        //https://leetcode.com/problems/super-washing-machines/
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{1, 0, 5}));
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{0, 3, 0}));
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{0, 2, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K Radius Subarray Averages");
//        //https://leetcode.com/problems/k-radius-subarray-averages/
//        //https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-effort/
//        obj.kRadiusSubarrayAverages(new int[]{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3);
//        obj.kRadiusSubarrayAverages(new int[]{100000}, 0);
//        obj.kRadiusSubarrayAverages(new int[]{8}, 100000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Time to Type Word Using Special Typewriter");
//        //https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/
//        obj.minTimeToType("abc");
//        obj.minTimeToType("bza");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reorder Routes to Make All Paths Lead to the City Zero");
//        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(6, new int[][]{{0, 1}, {1, 3}, {2, 3}, {4, 0}, {4, 5}});
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(5, new int[][]{{1, 0}, {1, 2}, {3, 2}, {3, 4}});
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(3, new int[][]{{1, 0}, {2, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Next warmer day in the given weather recordings (Next greater element to right)");
//        //https://youtu.be/0mcAy91rPzE
//        //https://leetcode.com/problems/daily-temperatures/
//        obj.nextWarmerDayInTheGivenWeatherRecordings(new int[]{60, 90, 76, 80, 100, 62, 90});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Steps to Make Array Non-decreasing");
//        //https://leetcode.com/problems/steps-to-make-array-non-decreasing/
//        obj.stepsToMakeArrayNonDecreasing(new int[]{5, 3, 4, 4, 7, 3, 6, 11, 8, 5, 11});
//        obj.stepsToMakeArrayNonDecreasing(new int[]{4, 5, 7, 7, 13});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Online Stock Span");
//        //https://leetcode.com/problems/online-stock-span/
//        obj.onlineStockSpan(new int[]{100, 80, 60, 70, 60, 75, 85});
//        obj.onlineStockSpan(new int[]{4, 2, 3, 3, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Obstacle Removal to Reach Corner");
//        //https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/
//        obj.minObstaclesRemovalToReachBottomRightCorner_Graph(new int[][]{
//            {0, 1, 1}, {1, 1, 0}, {1, 1, 0}});
//        obj.minObstaclesRemovalToReachBottomRightCorner_Graph(new int[][]{
//            {0, 1, 0, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 0, 1, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Path in a Grid with Obstacles Elimination");
//        //https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
//        obj.shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
//                new int[][]{{0, 0, 0}, {1, 1, 0}, {0, 0, 0}, {0, 1, 1}, {0, 0, 0}}, 1);
//        obj.shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
//                new int[][]{{0, 1, 1}, {1, 1, 1}, {1, 0, 0}}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Height Trees");
//        //https://leetcode.com/problems/minimum-height-trees/
//        obj.minHeightTrees_Graph_BruteForce(4, new int[][]{{1, 0}, {1, 2}, {1, 3}});
//        obj.minHeightTrees_Graph_BruteForce(6, new int[][]{{3, 0}, {3, 1}, {3, 2}, {3, 4}, {5, 4}});
//        obj.minHeightTrees_Graph(4, new int[][]{{1, 0}, {1, 2}, {1, 3}});
//        obj.minHeightTrees_Graph(6, new int[][]{{3, 0}, {3, 1}, {3, 2}, {3, 4}, {5, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Vowels in a Substring of Given Length");
//        //https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
//        obj.maxVowelCountInSubstringOfKLength("abciiidef", 3);
//        //any subtring of size k == 2 will contain 2 vowels since the str is only vowels
//        obj.maxVowelCountInSubstringOfKLength("aeiou", 2);
//        //for k == 3, substring: "lee" contains vowels 2 (e, e) same for substring: "ode" 2(o ,e)
//        obj.maxVowelCountInSubstringOfKLength("leetcode", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Points You Can Obtain from Cards");
//        //https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/
//        obj.maxPointsObtainFromCards(new int[]{1, 2, 3, 4, 5, 6, 1}, 3);
//        obj.maxPointsObtainFromCards(new int[]{2, 2, 2}, 2);
//        obj.maxPointsObtainFromCards(new int[]{9, 7, 7, 9, 7, 7, 9}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Removing Minimum and Maximum From Array");
//        //https://leetcode.com/problems/removing-minimum-and-maximum-from-array/
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{2, 10, 7, 5, 4, 1, 8, 6});
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{0, -4, 19, 1, 8, -2, -3, 5});
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{101});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Make Array Empty");
//        //https://leetcode.com/problems/make-array-empty/description/
//        obj.makeArrayEmpty(new int[]{3, 4, -1});
//        obj.makeArrayEmpty(new int[]{1, 2, 4, 3});
//        obj.makeArrayEmpty(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Consecutive Floors Without Special Floors");
//        //https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
//        obj.maxConsecutiveFloorsWithoutIncludingSpecialFloors(2, 9, new int[]{4, 6});
//        obj.maxConsecutiveFloorsWithoutIncludingSpecialFloors(6, 8, new int[]{7, 6, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Amount of Time to Collect Garbage");
//        //https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
//        obj.minAmountOfTimeToCollectGarbage(new String[]{"G", "P", "GP", "GG"}, new int[]{2, 4, 3});
//        obj.minAmountOfTimeToCollectGarbage(new String[]{"MMM", "PGM", "GP"}, new int[]{3, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Cost Homecoming of a Robot in a Grid");
//        //https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/
//        obj.minPathCostRobotMovingStartToHomePos(new int[]{1, 0}, new int[]{2, 3},
//                new int[]{5, 4, 3}, new int[]{8, 2, 6, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Good Days to Rob the Bank");
//        //https://leetcode.com/problems/find-good-days-to-rob-the-bank/
//        obj.findGoodDayToRobBank(new int[]{5, 3, 3, 3, 5, 6, 2}, 2);
//        obj.findGoodDayToRobBank(new int[]{1, 1, 1, 1, 1}, 0);
//        obj.findGoodDayToRobBank(new int[]{1, 2, 3, 4, 5, 6}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Valid Mountain Array");
//        //https://leetcode.com/problems/valid-mountain-array/description/
//        System.out.println("Validate mountain array : " + obj.validateMountainArray(new int[]{2, 1}));
//        System.out.println("Validate mountain array : " + obj.validateMountainArray(new int[]{3, 5, 5}));
//        System.out.println("Validate mountain array : " + obj.validateMountainArray(new int[]{0, 3, 2, 1}));
//        //peek at index = 0, no uphill elements on left of peek index 0
//        System.out.println("Validate mountain array : " + obj.validateMountainArray(new int[]{5, 4, 3, 2, 1}));
//        //peek at index = n - 1, no downhill elements after right of peek index n - 1
//        System.out.println("Validate mountain array : " + obj.validateMountainArray(new int[]{1, 2, 3, 4, 5}));
//        System.out.println("Longest Mountain in Array");
//        //https://leetcode.com/problems/longest-mountain-in-array/
//        obj.longestMountainInArray(new int[]{2, 1, 4, 7, 3, 2, 5});
//        obj.longestMountainInArray(new int[]{2, 2, 2, 2});
//        obj.longestMountainInArray(new int[]{1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Removals to Make Mountain Array");
//        //https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{1, 3, 1});
//        //one possible mountain after 3 elements removal [1,5,6,3,1]
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{2, 1, 1, 5, 6, 2, 3, 1});
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{4, 3, 2, 1, 1, 2, 3, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Smallest Element in a Sorted Matrix");
//        //https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
//        System.out.println("K th smallest in sorted matrix: " + obj.kThSmallestElementInSortedMatrix(new int[][]{
//            {1, 5, 9}, {10, 11, 13}, {12, 13, 15}}, 8));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Smallest Number in Multiplication Table");
//        //https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/
//        obj.kThSmallestNumberInMultiplicationTable(2, 3, 6);
//        obj.kThSmallestNumberInMultiplicationTable(3, 3, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Increasing Triplet Subsequence");
//        //https://leetcode.com/problems/increasing-triplet-subsequence/
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{1, 2, 3, 4, 5}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{5, 4, 3, 2, 1}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{2, 1, 5, 0, 4, 6}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{7, -9, 8, -10, 9, -11}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Suffix Flips");
//        //https://leetcode.com/problems/minimum-suffix-flips/
//        obj.minSuffixFlipInBinaryString("10111");
//        obj.minSuffixFlipInBinaryString("101");
//        obj.minSuffixFlipInBinaryString("0000000");
//        obj.minSuffixFlipInBinaryString("1111111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reveal Cards In Increasing Order");
//        //https://leetcode.com/problems/reveal-cards-in-increasing-order/
//        obj.deckRevealedIncreasing(new int[]{17, 13, 11, 2, 3, 5, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Insufficient Nodes in Root to Leaf Paths");
//        //https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(11));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(17));
//        root.getRight().setRight(new TreeNode<>(4));
//        root.getRight().getRight().setLeft(new TreeNode<>(5));
//        root.getRight().getRight().setRight(new TreeNode<>(3));
//        obj.insufficientNodesInRootToLeafPath(root, 22);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Subarray Minimums");
//        //https://leetcode.com/problems/sum-of-subarray-minimums/
//        obj.sumOfSubarrayMins(new int[]{3, 1, 2, 4});
//        obj.sumOfSubarrayMins(new int[]{11, 81, 94, 43, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts");
//        //https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
//        obj.maxAreaOfPieceOfCake(5, 4, new int[]{1, 2, 4}, new int[]{3, 1});
//        obj.maxAreaOfPieceOfCake(5, 4, new int[]{3}, new int[]{3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Frequency of the Most Frequent Element");
//        //https://leetcode.com/problems/frequency-of-the-most-frequent-element/
//        obj.freqOfMostFrequentElement(new int[]{1, 2, 4}, 5);
//        obj.freqOfMostFrequentElement(new int[]{1, 4, 8, 13}, 5);
//        obj.freqOfMostFrequentElement(new int[]{3, 9, 6}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find All Lonely Numbers in the Array");
//        //https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
//        obj.findAllLonelyNumberInArray(new int[]{10, 6, 5, 8});
//        obj.findAllLonelyNumberInArray(new int[]{1, 3, 5, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Word in Dictionary");
//        //https://leetcode.com/problems/longest-word-in-dictionary/
//        //https://leetcode.com/problems/longest-word-with-all-prefixes/description/
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary(new String[]{"w", "wo", "wor", "worl", "world"}));
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary(new String[]{"a", "banana", "app", "appl", "ap", "apply", "apple"}));
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary_Trie(new String[]{"w", "wo", "wor", "worl", "world"}));
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary_Trie(new String[]{"a", "banana", "app", "appl", "ap", "apply", "apple"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("The Number of Weak Characters in the Game");
//        //https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{5, 5}, {6, 3}, {3, 6}});
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{2, 2}, {3, 3}});
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{1, 5}, {10, 4}, {4, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Unique Paths I/ II/ III");
//        //https://leetcode.com/problems/unique-paths/
//        //https://leetcode.com/problems/unique-paths-ii/
//        obj.uniquePaths_Graph_Memoization(3, 7);
//        //https://leetcode.com/problems/unique-paths-iii/description/
//        obj.uniquePathsThree_Graph(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,2,-1}});
//        obj.uniquePathsThree_Graph(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,0,2}});
//        obj.uniquePathsThree_Graph(new int[][]{{0,1},{2,0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Insertions to Balance a Parentheses String");
//        //https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
//        obj.minInsertionsToBalanceAParenthesisString("(()))");
//        obj.minInsertionsToBalanceAParenthesisString("())");
//        obj.minInsertionsToBalanceAParenthesisString("))())(");
//        obj.minInsertionsToBalanceAParenthesisString("(()))(()))()())))");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Zero-Filled Subarrays");
//        //https://leetcode.com/problems/number-of-zero-filled-subarrays/
//        obj.numberOfSubarraysFilledWithZeros(new int[]{1, 3, 0, 0, 2, 0, 0, 4});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{0, 0, 0, 2, 0, 0});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{-1, 1});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{-1, 0, -2, 0, -3, 0, -4, 0, 1, 0, 2, 0, 3, 0, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Bag of Tokens");
//        //https://leetcode.com/problems/bag-of-tokens/
//        obj.bagOfTokens_Greedy(new int[]{100}, 5);
//        obj.bagOfTokens_Greedy(new int[]{100, 200}, 150);
//        obj.bagOfTokens_Greedy(new int[]{100, 200, 300, 400}, 200);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Parallel Courses III");
//        //https://leetcode.com/problems/parallel-courses-iii/
//        obj.parallelCourseThree_Graph(3, new int[][]{{1, 3}, {2, 3}}, new int[]{3, 2, 5});
//        obj.parallelCourseThree_Graph(5, new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}},
//                new int[]{1, 2, 3, 4, 5});
//        obj.parallelCourseThree_Graph_TopologicalSort(3, new int[][]{{1, 3}, {2, 3}}, new int[]{3, 2, 5});
//        obj.parallelCourseThree_Graph_TopologicalSort(5, new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}},
//                new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Product of the Last K Numbers");
//        //https://leetcode.com/problems/product-of-the-last-k-numbers/
//        obj.productOfTheLastKNumbers();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Groups Entering a Competition");
//        //https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
//        System.out.println("Max Number of groups formed : "
//                + obj.maxNumberOfGroupsEnteringCompetition_Greedy(new int[]{10, 6, 12, 7, 3, 5}));
//        System.out.println("Max Number of groups formed : "
//                + obj.maxNumberOfGroupsEnteringCompetition_Greedy(new int[]{8, 8}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Last Stone Weight II");
//        //https://leetcode.com/problems/last-stone-weight-ii/
//        obj.lastStoneWeightTwo_DP_Memoization(new int[]{2, 7, 4, 1, 8, 1});
//        obj.lastStoneWeightTwo_DP_Memoization(new int[]{31, 26, 33, 21, 40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Original Array From Doubled Array");
//        //https://leetcode.com/problems/find-original-array-from-doubled-array/
//        //https://leetcode.com/problems/array-of-doubled-pairs/
//        obj.findOriginalArrayFromDoubledArray(new int[]{0, 0, 0, 0});
//        obj.findOriginalArrayFromDoubledArray(new int[]{1, 3, 4, 2, 6, 8});
//        obj.findOriginalArrayFromDoubledArray(new int[]{6, 3, 0, 1});
//        obj.findOriginalArrayFromDoubledArray(new int[]{1});
//        obj.findOriginalArrayFromDoubledArray(new int[]{0, 3, 2, 4, 6, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shifting Letters II");
//        //https://leetcode.com/problems/shifting-letters-ii/
//        obj.shiftingLetterTwo_BruteForce("abc", new int[][]{{0, 1, 0}, {1, 2, 1}, {0, 2, 1}});
//        obj.shiftingLetterTwo_BruteForce("dztz", new int[][]{{0, 0, 0}, {1, 1, 1}});
//        obj.shiftingLetterTwo("abc", new int[][]{{0, 1, 0}, {1, 2, 1}, {0, 2, 1}});
//        obj.shiftingLetterTwo("dztz", new int[][]{{0, 0, 0}, {1, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K-Concatenation Maximum Sum");
//        //https://leetcode.com/problems/k-concatenation-maximum-sum/
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{1, 2}, 3));
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{1, -2, 1}, 5));
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{-1, -2}, 7));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximal Score After Applying K Operations");
//        //https://leetcode.com/problems/maximal-score-after-applying-k-operations/description/
//        obj.maxScoreAfterApplyingKOperations_Greedy(new int[]{10, 10, 10, 10, 10}, 5);
//        obj.maxScoreAfterApplyingKOperations_Greedy(new int[]{1, 10, 3, 3, 3}, 3);
//        obj.maxScoreAfterApplyingKOperations_Greedy(new int[]{1, 1, 1, 1, 1, 1, 1}, 10);
//        obj.maxScoreAfterApplyingKOperations_Greedy(new int[]{1000000000, 1000000000, 1000000000}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove Stones to Minimize the Total");
//        //https://leetcode.com/problems/remove-stones-to-minimize-the-total/
//        //https://leetcode.com/problems/take-gifts-from-the-richest-pile/description/
//        obj.removeStonesToMinimizeTotal_Greedy(new int[]{5, 4, 9}, 2);
//        obj.removeStonesToMinimizeTotal_Greedy(new int[]{4, 3, 6, 7}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Operations to Halve Array Sum");
//        //https://leetcode.com/problems/minimum-operations-to-halve-array-sum/
//        obj.minOperationToHalveTheArraySum_Greedy(new int[]{5, 19, 8, 1});
//        obj.minOperationToHalveTheArraySum_Greedy(new int[]{3, 8, 20});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reduce Array Size to The Half");
//        //https://leetcode.com/problems/reduce-array-size-to-the-half/
//        obj.reduceArraySizeTohalf_Greedy(new int[]{3, 3, 3, 3, 5, 5, 5, 2, 2, 7});
//        obj.reduceArraySizeTohalf_Greedy(new int[]{7, 7, 7, 7, 7, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Palindrome Pairs");
//        //https://leetcode.com/problems/palindrome-pairs/
//        obj.pallindromePairs(new String[]{"abcd", "dcba", "lls", "s", "sssll"});
//        obj.pallindromePairs(new String[]{"bat", "tab", "cat"});
//        obj.pallindromePairs(new String[]{"a", ""});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Palindrome by Concatenating Two Letter Words");
//        //https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"lc", "cl", "gg"});
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"ab", "ty", "yt", "lc", "cl", "ab"});
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"cc", "ll", "xx"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find And Replace in String");
//        //https://leetcode.com/problems/find-and-replace-in-string/
//        obj.findAndReplaceInString("abcd", new int[]{0, 2}, new String[]{"a", "cd"}, new String[]{"eee", "ffff"});
//        obj.findAndReplaceInString("abcd", new int[]{0, 2}, new String[]{"ab", "ec"}, new String[]{"eee", "ffff"});
//        obj.findAndReplaceInString("abcde", new int[]{2, 2}, new String[]{"cdef", "bc"}, new String[]{"f", "fe"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Removing Stars From a String");
//        //https://leetcode.com/problems/removing-stars-from-a-string/
//        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
//        obj.removeStarsFromString("leet**cod*e");
//        obj.removeStarsFromString("erase*****");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distinct Echo Substrings");
//        //https://leetcode.com/problems/distinct-echo-substrings/
//        obj.distinctEchoSubstrings("abcabcabc");
//        obj.distinctEchoSubstrings("leetcodeleetcode");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Duplicate File in System");
//        //https://leetcode.com/problems/find-duplicate-file-in-system/
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"});
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)"});
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efsfgh)", "root/c 3.txt(abdfcd)", "root/c/d 4.txt(efggdfh)"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Lines to Represent a Line Chart");
//        //https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/
//        //https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/
//        System.out.println("Max lines covering points: "
//                + obj.maxLineToRepresentLineChart(new int[][]{{1, 7}, {2, 6}, {3, 5},
//        {4, 4}, {5, 4}, {6, 3}, {7, 2}, {8, 1}}));
//        System.out.println("Max lines covering points: "
//                + obj.maxLineToRepresentLineChart(new int[][]{{3, 4}, {1, 2}, {7, 8}, {2, 3}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Points on a Line");
//        //https://leetcode.com/problems/max-points-on-a-line/description/
//        obj.maxPointsOnLine(new int[][]{{1, 1}, {2, 2}, {3, 3}});
//        obj.maxPointsOnLine(new int[][]{{1, 1}, {3, 2}, {5, 3}, {4, 1}, {2, 3}, {1, 4}});
//        obj.maxPointsOnLine(new int[][]{{1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Even Numbers After Queries");
//        //https://leetcode.com/problems/sum-of-even-numbers-after-queries/
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{1, 2, 3, 4}, new int[][]{{1, 0}, {-3, 1}, {-4, 0}, {2, 3}});
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{-1, -2, -3, -4},
//                new int[][]{{1, 0}, {-3, 1}, {-4, 0}, {2, 3}});
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{1}, new int[][]{{4, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize Maximum Pair Sum in Array");
//        //https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/
//        obj.minimizeMaxPairSumInArray_Greedy(new int[]{3, 5, 2, 3});
//        obj.minimizeMaxPairSumInArray_Greedy(new int[]{3, 5, 4, 2, 4, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Equal Row and Column Pairs");
//        //https://leetcode.com/problems/equal-row-and-column-pairs/
//        obj.equalRowAndColPairs(new int[][]{{3, 2, 1}, {1, 7, 6}, {2, 7, 7}});
//        obj.equalRowAndColPairs(new int[][]{{3, 1, 2, 2}, {1, 4, 4, 5}, {2, 4, 2, 2}, {2, 4, 2, 2}});
//        obj.equalRowAndColPairs(new int[][]{{11, 1}, {1, 11}});
//        obj.equalRowAndColPairs2(new int[][]{{3, 2, 1}, {1, 7, 6}, {2, 7, 7}});
//        obj.equalRowAndColPairs2(new int[][]{{3, 1, 2, 2}, {1, 4, 4, 5}, {2, 4, 2, 2}, {2, 4, 2, 2}});
//        obj.equalRowAndColPairs2(new int[][]{{11, 1}, {1, 11}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fruit Into Baskets");
//        //https://leetcode.com/problems/fruit-into-baskets/
//        obj.fruitsIntoBasket(new int[]{1, 2, 1});
//        obj.fruitsIntoBasket(new int[]{0, 1, 2, 2});
//        obj.fruitsIntoBasket(new int[]{1, 2, 3, 2, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Length of the Longest Alphabetical Continuous Substring");
//        //https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/
//        obj.longestLengthSubstringOfContigousLetters("abacaba");
//        obj.longestLengthSubstringOfContigousLetters("abcde");
//        obj.longestLengthSubstringOfContigousLetters("aaaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Alert Using Same Key-Card Three or More Times in a One Hour");
//        //https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/
//        obj.workersGettingAlertsMoreThanTriceInAnHour(
//                new String[]{"daniel", "daniel", "daniel", "luis", "luis", "luis", "luis"},
//                new String[]{"10:00", "10:40", "11:00", "09:00", "11:00", "13:00", "15:00"});
//        obj.workersGettingAlertsMoreThanTriceInAnHour(
//                new String[]{"leslie", "leslie", "leslie", "clare", "clare", "clare", "clare"},
//                new String[]{"13:00", "13:20", "14:00", "18:00", "18:51", "19:30", "19:49"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Step-By-Step Directions From a Binary Tree Node to Another");
//        //https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(1));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Step by step direction between two nodes in binary tree: "
//                + obj.stepByStepDirectionsBetweenTwoNodesInBinaryTree(root, 3, 6));
//        root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(1));
//        System.out.println("Step by step direction between two nodes in binary tree: "
//                + obj.stepByStepDirectionsBetweenTwoNodesInBinaryTree(root, 2, 1));
//        System.out.println("Find Distance In A Binary Tree");
//        //https://leetcode.com/problems/find-distance-in-a-binary-tree/description/
//        //https://leetcode.ca/all/1740.html#:~:text=1740.-,Find%20Distance%20in%20a%20Binary%20Tree,from%20one%20to%20the%20other.
//        root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(1));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Find distance in the binary tree : " + obj.findDistanceInBinaryTree(root, 3, 6));
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(2));
//        root.getLeft().getRight().setLeft(new TreeNode<>(7));
//        root.getLeft().getRight().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(1));
//        root.getRight().setLeft(new TreeNode<>(0));
//        root.getRight().setRight(new TreeNode<>(8));
//        System.out.println("Find distance in the binary tree : " + obj.findDistanceInBinaryTree(root, 5, 0));
//        System.out.println("Find distance in the binary tree : " + obj.findDistanceInBinaryTree(root, 5, 7));
//        System.out.println("Find distance in the binary tree : " + obj.findDistanceInBinaryTree(root, 5, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Path in Binary Matrix");
//        //https://leetcode.com/problems/shortest-path-in-binary-matrix/
//        //https://practice.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{0, 1}, {1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{0, 0, 0}, {1, 1, 0}, {1, 1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{1, 0, 0}, {1, 1, 0}, {1, 1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{
//            {0, 1, 1, 0, 0, 0},
//            {0, 1, 0, 1, 1, 0},
//            {0, 1, 1, 0, 1, 0},
//            {0, 0, 0, 1, 1, 0},
//            {1, 1, 1, 1, 1, 0},
//            {1, 1, 1, 1, 1, 0}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Satisfiability of Equality Equations");
//        //https://leetcode.com/problems/satisfiability-of-equality-equations/
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"a==b", "b!=a"}));
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"b==a", "a==b"}));
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"a==b", "b!=c", "c==a"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Subsequence in Non-Increasing Order");
//        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
//        obj.minSubseqOfNonIncreasingOrder_Greedy_HeapBased(new int[]{4, 3, 10, 9, 8});
//        obj.minSubseqOfNonIncreasingOrder_Greedy(new int[]{4, 3, 10, 9, 8});
//        obj.minSubseqOfNonIncreasingOrder_Greedy_HeapBased(new int[]{4, 4, 7, 6, 7});
//        obj.minSubseqOfNonIncreasingOrder_Greedy(new int[]{4, 4, 7, 6, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Push Dominoes");
//        //https://leetcode.com/problems/push-dominoes/
//        obj.pushDominoes("RR.L");
//        obj.pushDominoes(".L.R...LR..L..");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Uncommon Subsequence II");
//        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/
//        obj.longestUncommonSubseqTwo(new String[]{"aba", "cdc", "eae"});
//        obj.longestUncommonSubseqTwo(new String[]{"aaa", "aaa", "aa"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Widest Vertical Area Between Two Points Containing No Points");
//        //https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/
//        obj.maxWidthBetweenGivenPoints(new int[][]{{8, 7}, {9, 9}, {7, 4}, {9, 7}});
//        obj.maxWidthBetweenGivenPoints(new int[][]{{3, 1}, {9, 0}, {1, 0}, {1, 4}, {5, 3}, {8, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find K-th Smallest Pair Distance");
//        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/
//        obj.kThSmallestPairDistance(new int[]{1, 3, 1}, 1);
//        obj.kThSmallestPairDistance(new int[]{1, 1, 1}, 2);
//        obj.kThSmallestPairDistance(new int[]{1, 6, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find K Pairs with Smallest Sums");
//        //https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
//        obj.kThSmallestPairSum(new int[]{1, 7, 11}, new int[]{2, 4, 6}, 3);
//        obj.kThSmallestPairSum(new int[]{1, 1, 2}, new int[]{1, 2, 3}, 2);
//        obj.kThSmallestPairSum(new int[]{1, 2}, new int[]{3}, 3);
//        obj.kThSmallestPairSum2(new int[]{1, 7, 11}, new int[]{2, 4, 6}, 3);
//        obj.kThSmallestPairSum2(new int[]{1, 1, 2}, new int[]{1, 2, 3}, 2);
//        obj.kThSmallestPairSum2(new int[]{1, 2}, new int[]{3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Atoms");
//        //https://leetcode.com/problems/number-of-atoms/
//        obj.numberOfAtoms("H2O");
//        obj.numberOfAtoms("Mg(OH)2");
//        obj.numberOfAtoms("K4(ON(SO3)2)2");
//        obj.numberOfAtoms("K(K(K(K)))");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Rounds to Complete All Tasks");
//        //https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/
//        System.out.println("Min rounds to complete tasks: "
//                + obj.minRoundsToCompleteAllTasks_Greedy(new int[]{2, 2, 3, 3, 2, 4, 4, 4, 4, 4}));
//        System.out.println("Min rounds to complete tasks: "
//                + obj.minRoundsToCompleteAllTasks_Greedy(new int[]{2, 3, 3}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sentence Similarity");
//        //https://leetcode.com/problems/sentence-similarity/description/
//        System.out.println("Sentence similarity : "
//                + obj.sentenceSimilarity(new String[]{"great", "acting", "skills"},
//                new String[]{"fine", "drama", "talent"},
//                new String[][]{{"great", "fine"}, {"drama", "acting"}, {"skills", "talent"}}));
//        System.out.println("Sentence similarity : "
//                + obj.sentenceSimilarity(new String[]{"great"},
//                new String[]{"great"},
//                new String[][]{}));
//        System.out.println("Sentence similarity : "
//                + obj.sentenceSimilarity(new String[]{"great"},
//                new String[]{"doubleplus", "good"},
//                new String[][]{{"great", "doubleplus"}}));
//        System.out.println("Sentence Similarity II");
//        //https://leetcode.com/problems/sentence-similarity-ii/description/
//        System.out.println("Sentence similarity two : "
//                + obj.sentenceSimilarityTwo_Graph(new String[]{"great", "acting", "skills"},
//                new String[]{"fine", "drama", "talent"},
//                new String[][]{{"great","good"},{"fine","good"},{"drama","acting"},{"skills","talent"}}));
//        System.out.println("Sentence similarity two : "
//                + obj.sentenceSimilarityTwo_Graph(new String[]{"I","love","leetcode"},
//                new String[]{"I","love","onepiece"},
//                new String[][]{{"manga","onepiece"},{"platform","anime"},{"leetcode","platform"},{"anime","manga"}}));
//        System.out.println("Sentence similarity two : "
//                + obj.sentenceSimilarityTwo_Graph(new String[]{"I","love","leetcode"},
//                new String[]{"I","love","onepiece"},
//                new String[][]{{"manga","hunterXhunter"},{"platform","anime"},{"leetcode","platform"},{"anime","manga"}}));
//        System.out.println("Sentence Similarity III");
//        //https://leetcode.com/problems/sentence-similarity-iii/
//        obj.sentenceSimilarityThree("My name is Haley", "My Haley");
//        obj.sentenceSimilarityThree("of", "A lot of words");
//        obj.sentenceSimilarityThree("Eating right now", "Eating");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Primes");
//        //https://leetcode.com/problems/count-primes/
//        obj.countPrimes(10);
//        obj.countPrimes(50);
//        obj.countPrimes(100);
//        //obj.countPrimes(5000000); //working but output too long
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Game Of Life");
//        //https://leetcode.com/problems/game-of-life/
//        obj.gameOfLife(new int[][]{{0, 1, 0}, {0, 0, 1}, {1, 1, 1}, {0, 0, 0}});
//        obj.gameOfLife(new int[][]{{1, 1}, {1, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Dice Rolls With Target Sum");
//        //https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(1, 6, 3);
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(2, 6, 7);
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(30, 30, 500);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reachable Nodes With Restrictions");
//        //https://leetcode.com/problems/reachable-nodes-with-restrictions/
//        obj.countReachableNodesWithRestrictions_Graph(
//                new int[][]{{0, 1}, {1, 2}, {3, 1}, {4, 0}, {0, 5}, {5, 6}},
//                new int[]{4, 5});
//        obj.countReachableNodesWithRestrictions_Graph(
//                new int[][]{{0, 1}, {0, 2}, {0, 5}, {0, 4}, {3, 2}, {6, 5}},
//                new int[]{4, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Prefix Scores of Strings");
//        //https://leetcode.com/problems/sum-of-prefix-scores-of-strings/
//        //https://practice.geeksforgeeks.org/problems/geek-and-strings3030/1
//        obj.sumOfPrefixScoresOfString(new String[]{"abc", "ab", "bc", "b"});
//        obj.sumOfPrefixScoresOfString(new String[]{"abcd"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Design Add and Search Words Data Structure");
//        //https://leetcode.com/problems/design-add-and-search-words-data-structure/
//        obj.trieAddAndSearchWords();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If a Word Occurs As a Prefix of Any Word in a Sentence");
//        //https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
//        //https://leetcode.com/problems/counting-words-with-a-given-prefix/
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("i love eating burger", "burg");
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("this problem is an easy problem", "pro");
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("i am tired", "you");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Add One Row to Tree");
//        //https://leetcode.com/problems/add-one-row-to-tree/
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 1);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 2);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 3);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 4);
//        //BFS Iterative approach
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 1);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 2);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 3);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("My Calendar I");
//        //https://leetcode.com/problems/my-calendar-i/
//        obj.myCalendarOne();
//        //https://leetcode.com/problems/my-calendar-iii/
//        obj.myCalendarThree();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Break a Palindrome");
//        //https://leetcode.com/problems/break-a-palindrome/
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("abccba"));
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("a"));
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("aba"));
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("aaa"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Homogenous Substrings/ Number of Subtrings With Ony 1s");
//        //https://leetcode.com/problems/count-number-of-homogenous-substrings/
//        //https://leetcode.com/problems/consecutive-characters/
//        //https://leetcode.com/problems/number-of-substrings-with-only-1s/
//        obj.countNumberOfHomogenousSubstring("abbcccaa");
//        obj.countNumberOfHomogenousSubstring("xy");
//        obj.countNumberOfHomogenousSubstring("zzzzz");
//        obj.numberOfSubstringWithOnlyOnes("0110111");
//        obj.numberOfSubstringWithOnlyOnes("101");
//        obj.numberOfSubstringWithOnlyOnes("111111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Increasing Decreasing String");
//        //https://leetcode.com/problems/increasing-decreasing-string/
//        obj.increasingDecreasingString("aaaabbbbcccc");
//        obj.increasingDecreasingString("rat");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Deletions to Make Array Divisible");
//        //https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/
//        System.out.println("Min deletes to find the smallest value in num array"
//                + "that divides all the numbers fronm numsToDivide array: "
//                + obj.minDeletionsToMakeArrayDivisble(new int[]{2, 3, 2, 4, 3},
//                new int[]{9, 6, 9, 3, 15}));
//        System.out.println("Min deletes to find the smallest value in num array"
//                + "that divides all the numbers fronm numsToDivide array: "
//                + obj.minDeletionsToMakeArrayDivisble(new int[]{4, 3, 6},
//                new int[]{8, 2, 6, 10}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If Array Pairs Are Divisible by k");
//        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 10, 6, 7, 8, 9}, 5));
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 6}, 7));
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 6}, 10));
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{5, 5, 5, 1, 1, 1}, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Subarray to be Removed to Make Array Sorted");
//        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3, 10, 4, 2, 3, 5}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{5, 4, 3, 2, 1}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3, 2, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Points with Cost");
//        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
//        obj.maxNumberOfPointsWithCost_Recursive(new int[][]{{1, 2, 3}, {1, 5, 1}, {3, 1, 1}});
//        obj.maxNumberOfPointsWithCost_Recursive(new int[][]{{1, 5}, {2, 3}, {4, 2}});
//        obj.maxNumberOfPointsWithCost_DP_Memoization(new int[][]{{1, 2, 3}, {1, 5, 1}, {3, 1, 1}});
//        obj.maxNumberOfPointsWithCost_DP_Memoization(new int[][]{{1, 5}, {2, 3}, {4, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize the Difference Between Target and Chosen Elements");
//        //https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
//        obj.minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(
//                new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 13);
//        obj.minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(
//                new int[][]{{1}, {2}, {3}}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Difficulty of a Job Schedule");
//        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{6, 5, 4, 3, 2, 1}, 2);
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{9, 9, 9}, 4);
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{1, 1, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Optimal Partition of String");
//        //https://leetcode.com/problems/optimal-partition-of-string/
//        obj.optimalStringPartitions("abacaba");
//        obj.optimalStringPartitions("ssssss");
//        obj.optimalStringPartitions("abcdef");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array into Disjoint Intervals");
//        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/
//        obj.partitionsArrayIntoDisjointIntervals(new int[]{5, 0, 3, 8, 6});
//        obj.partitionsArrayIntoDisjointIntervals(new int[]{1, 1, 1, 0, 6, 12});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("As Far from Land as Possible");
//        //https://leetcode.com/problems/as-far-from-land-as-possible/
//        obj.asFarFromLandAsPossible_Graph(new int[][]{
//            {1, 0, 1}, {0, 0, 0}, {1, 0, 1}});
//        obj.asFarFromLandAsPossible_Graph(new int[][]{
//            {1, 0, 0}, {0, 0, 0}, {0, 0, 0}});
//        obj.asFarFromLandAsPossible_Graph(new int[][]{
//            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}});
//        obj.asFarFromLandAsPossible_Graph(new int[][]{
//            {1, 1, 1}, {1, 1, 1}, {1, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Arithmetic Subsequence of Given Difference");
//        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/
//        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 2, 3, 4}, 1);
//        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 3, 5, 7}, 1);
//        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 5, 7, 8, 5, 3, 4, 2, 1}, -2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Merge Of Two Strings");
//        //https://leetcode.com/problems/largest-merge-of-two-strings/
//        obj.largestMergeOfTwoStrings("cabaa", "bcaaa");
//        obj.largestMergeOfTwoStrings("abcabc", "abdcaba");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Matching of Players With Trainers");
//        //https://leetcode.com/problems/maximum-matching-of-players-with-trainers/
//        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{4, 7, 9}, new int[]{8, 5, 2, 8});
//        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{1, 1, 1}, new int[]{10});
//        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{10, 11, 12}, new int[]{2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Contains Duplicate III");
//        //https://leetcode.com/problems/contains-duplicate-iii/
//        System.out.println("Contains duplicate three: "
//                + obj.containsDuplicateThree(new int[]{1, 2, 3, 1}, 3, 0));
//        System.out.println("Contains duplicate three: "
//                + obj.containsDuplicateThree(new int[]{1, 5, 9, 1, 5, 9}, 2, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Genetic Mutation / Word Ladder");
//        //https://leetcode.com/problems/minimum-genetic-mutation/
//        System.out.println("Min genetic mutation from start to end: "
//                + obj.minGeneticMutation_Graph("AACCGGTT", "AACCGGTA", Arrays.asList("AACCGGTA")));
//        System.out.println("Min genetic mutation from start to end: "
//                + obj.minGeneticMutation_Graph("AACCGGTT", "AAACGGTA", Arrays.asList("AACCGGTA", "AACCGCTA", "AAACGGTA")));
//        System.out.println("Min genetic mutation from start to end: "
//                + obj.minGeneticMutation_Graph("AAAAACCC", "AACCCCCC", Arrays.asList("AAAACCCC", "AAACCCCC", "AACCCCCC")));
//        //https://leetcode.com/problems/word-ladder/
//        System.out.println("Word ladder from startWord to endWord: "
//                + obj.wordLadder_Graph("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log", "cog")));
//        System.out.println("Word ladder from startWord to endWord: "
//                + obj.wordLadder_Graph("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log")));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Operations to Make Array Continuous");
//        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/
//        obj.minOperationsToMakeArrayContinous(new int[]{4, 2, 5, 3});
//        obj.minOperationsToMakeArrayContinous(new int[]{1, 2, 3, 5, 6});
//        obj.minOperationsToMakeArrayContinous(new int[]{1, 10, 100, 1000});
//        obj.minOperationsToMakeArrayContinous(new int[]{8, 5, 9, 9, 8, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Image Overlap");
//        //https://leetcode.com/problems/image-overlap/
//        obj.largestImageOverlap(
//                new int[][]{{1, 1, 0}, {0, 1, 0}, {0, 1, 0}}, new int[][]{{0, 0, 0}, {0, 1, 1}, {0, 0, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Eliminate Maximum Number of Monsters");
//        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
//        obj.eliminateMaxNumberOfMonster_Greedy(new int[]{1, 3, 4}, new int[]{1, 1, 1});
//        obj.eliminateMaxNumberOfMonster_Greedy(new int[]{1, 1, 2, 3}, new int[]{1, 1, 1, 1});
//        obj.eliminateMaxNumberOfMonster_Greedy(new int[]{3, 2, 4}, new int[]{5, 3, 2});
//        obj.eliminateMaxNumberOfMonster_Greedy(new int[]{4, 2, 3}, new int[]{2, 1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Group the People Given the Group Size They Belong To");
//        //https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
//        obj.groupPeopleInTheirGroupSizes(new int[]{3, 3, 3, 3, 3, 1, 3});
//        obj.groupPeopleInTheirGroupSizes(new int[]{2, 1, 3, 3, 3, 2});
//        obj.groupPeopleInTheirGroupSizes2(new int[]{3, 3, 3, 3, 3, 1, 3});
//        obj.groupPeopleInTheirGroupSizes2(new int[]{2, 1, 3, 3, 3, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Number of K-Sum Pairs");
//        //https://leetcode.com/problems/max-number-of-k-sum-pairs/
//        obj.maxNumberOfKSumPairs(new int[]{1, 2, 3, 4}, 5);
//        obj.maxNumberOfKSumPairs(new int[]{3, 1, 3, 4, 3}, 6);
//        obj.maxNumberOfKSumPairs(new int[]{2, 5, 4, 4, 1, 3, 4, 4, 1, 4, 4, 1, 2, 1, 2, 2, 3, 2, 4, 2}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Repeated DNA Sequences");
//        //https://leetcode.com/problems/repeated-dna-sequences/
//        obj.repeatedDNASequences("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT");
//        obj.repeatedDNASequences("AAAAAAAAAAAAA");
//        obj.repeatedDNASequences("AAAAAAAA");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Laser Beams in a Bank");
//        //https://leetcode.com/problems/number-of-laser-beams-in-a-bank/
//        obj.numberOfLaserBeamsInBank(new String[]{"011001", "000000", "010100", "001000"});
//        obj.numberOfLaserBeamsInBank(new String[]{"000", "111", "000"});
//        obj.numberOfLaserBeamsInBank(new String[]{"111"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Where Will the Ball Fall");
//        //https://leetcode.com/problems/where-will-the-ball-fall/
//        obj.whereWillTheBallsFall_Graph(new int[][]{
//            {1, 1, 1, -1, -1},
//            {1, 1, 1, -1, -1},
//            {-1, -1, -1, 1, 1},
//            {1, 1, 1, 1, -1},
//            {-1, -1, -1, -1, -1}});
//        obj.whereWillTheBallsFall_Graph(new int[][]{
//            {-1}});
//        obj.whereWillTheBallsFall_Graph(new int[][]{
//            {1, 1, 1, 1, 1, 1},
//            {-1, -1, -1, -1, -1, -1},
//            {1, 1, 1, 1, 1, 1},
//            {-1, -1, -1, -1, -1, -1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Array With Elements Not Equal to Average of Neighbors");
//        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
//        obj.arrayWithElementsNotEqualToAverageOfNeighbours(new int[]{1, 2, 3, 4, 5});
//        obj.arrayWithElementsNotEqualToAverageOfNeighbours(new int[]{6, 2, 0, 9, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Consecutive Cards to Pick Up");
//        //https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
//        obj.minConsecutiveCardsToPickUpBetweenSameCards(new int[]{3, 4, 2, 3, 4, 7});
//        obj.minConsecutiveCardsToPickUpBetweenSameCards(new int[]{1, 0, 5, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Area In Matrix Between K Blocked Row & Cols");
//        //https://practice.geeksforgeeks.org/problems/enemy/1
//        System.out.println("Largest area between blocked rows and cols: "
//                + obj.largestAreaInMatrixBetweenKBlockedRowCols(2, 2, new int[][]{{2, 2}}));
//        System.out.println("Largest area between blocked rows and cols: "
//                + obj.largestAreaInMatrixBetweenKBlockedRowCols(3, 3, new int[][]{{3, 3}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distinct Subsequences");
//        //https://leetcode.com/problems/distinct-subsequences/
//        obj.distinctSubsequences_Recursive_Memoization("rabbbit", "rabbit");
//        obj.distinctSubsequences_Recursive_Memoization("babgbag", "bag");
//        obj.distinctSubsequences_DP_Memoization("rabbbit", "rabbit");
//        obj.distinctSubsequences_DP_Memoization("babgbag", "bag");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Array Removals");
//        //https://practice.geeksforgeeks.org/problems/array-removals/1
//        obj.arrayRemovals_Recursive_Memoization(new int[]{1, 3, 4, 9, 10, 11, 12, 17, 20}, 4);
//        obj.arrayRemovals_Recursive_Memoization(new int[]{1, 5, 6, 2, 8}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Frequency Stack");
//        //https://leetcode.com/problems/maximum-frequency-stack/
//        obj.implementMaxFreqStack();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Construct K Palindrome Strings");
//        //https://leetcode.com/problems/construct-k-palindrome-strings/
//        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
//                + obj.isPossibleToConstructKPallindromeString("annabelle", 2));
//        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
//                + obj.isPossibleToConstructKPallindromeString("leetcode", 3));
//        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
//                + obj.isPossibleToConstructKPallindromeString("true", 4));
//        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
//                + obj.isPossibleToConstructKPallindromeString("aafaaeaagaahaak", 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Destroy Sequential Targets");
//        //https://leetcode.com/problems/destroy-sequential-targets/
//        obj.destroySequentialTarget(new int[]{3, 7, 8, 1, 1, 5}, 2);
//        obj.destroySequentialTarget(new int[]{1, 3, 5, 2, 4, 6}, 2);
//        obj.destroySequentialTarget(new int[]{6, 2, 5}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete and Earn");
//        //https://leetcode.com/problems/delete-and-earn/
//        obj.deleteAndEarn_Recursive_Memoization(new int[]{3, 4, 2});
//        obj.deleteAndEarn_Recursive_Memoization(new int[]{2, 2, 3, 3, 3, 4});
//        obj.deleteAndEarn_DP_Memoization(new int[]{3, 4, 2});
//        obj.deleteAndEarn_DP_Memoization(new int[]{2, 2, 3, 3, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Word Search");
//        //https://leetcode.com/problems/word-search/
//        char[][] charArr = new char[][]{
//            {'D', 'D', 'D', 'G', 'D', 'D'},
//            {'B', 'B', 'D', 'E', 'B', 'S'},
//            {'B', 'S', 'K', 'E', 'B', 'K'},
//            {'D', 'D', 'D', 'D', 'D', 'E'},
//            {'D', 'D', 'D', 'D', 'D', 'E'},
//            {'D', 'D', 'D', 'D', 'D', 'G'}
//        };
//        String str = "GEEKS";
//        System.out.println("Word search : " + obj.wordSearch_Graph(charArr, str));
//        charArr = new char[][]{
//            {'B', 'B', 'M', 'B', 'B', 'B'},
//            {'C', 'B', 'A', 'B', 'B', 'B'},
//            {'I', 'B', 'G', 'B', 'B', 'B'},
//            {'G', 'B', 'I', 'B', 'B', 'B'},
//            {'A', 'B', 'C', 'B', 'B', 'B'},
//            {'M', 'C', 'I', 'G', 'A', 'M'}
//        };
//        str = "MAGIC";
//        System.out.println("Word search : " + obj.wordSearch_Graph(charArr, str));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Word Search II");
//        //https://leetcode.com/problems/word-search-ii/
//        obj.wordSearchTwo_Graph(
//                new char[][]{
//                    {'o', 'a', 'a', 'n'},
//                    {'e', 't', 'a', 'e'},
//                    {'i', 'h', 'k', 'r'},
//                    {'i', 'f', 'l', 'v'}},
//                new String[]{"oath", "pea", "eat", "rain"});
//        obj.wordSearchTwo_Graph(
//                new char[][]{
//                    {'a', 'b'},
//                    {'c', 'd'}},
//                new String[]{"abcd"});
//        obj.wordSearchTwo_Graph_TrieBased(
//                new char[][]{
//                    {'o', 'a', 'a', 'n'},
//                    {'e', 't', 'a', 'e'},
//                    {'i', 'h', 'k', 'r'},
//                    {'i', 'f', 'l', 'v'}},
//                new String[]{"oath", "pea", "eat", "rain"});
//        obj.wordSearchTwo_Graph_TrieBased(
//                new char[][]{
//                    {'a', 'b'},
//                    {'c', 'd'}},
//                new String[]{"abcd"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Orderly Queue");
//        //https://leetcode.com/problems/orderly-queue/
//        obj.orderlyQueue("cba", 1);
//        obj.orderlyQueue("acba", 1);
//        obj.orderlyQueue("baaca", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Bags With Full Capacity of Rocks");
//        //https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/
//        obj.maxBagsCompletelyFilledWithRocks_Greedy(new int[]{2, 3, 4, 5}, new int[]{1, 2, 4, 4}, 2);
//        obj.maxBagsCompletelyFilledWithRocks_Greedy(new int[]{10, 2, 2}, new int[]{2, 2, 0}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Moves to Reach Target Score");
//        //https://leetcode.com/problems/minimum-moves-to-reach-target-score/
//        //https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
//        //https://leetcode.com/problems/count-operations-to-obtain-zero/
//        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(4, 0));
//        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(19, 2));
//        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(10, 4));
//        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(1000000000, 100));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Make The String Great");
//        //https://leetcode.com/problems/make-the-string-great/
//        obj.makeTheStringGreat("leEeetcode");
//        obj.makeTheStringGreat("abBAcC");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Elements in a Contaminated Binary Tree");
//        //https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(-1);
//        root.setRight(new TreeNode<>(6));
//        obj.findElementsInContaminatedBinaryTree(root, Arrays.asList(1, 2));
//        root = new TreeNode<>(-1);
//        root.setLeft(new TreeNode<>(-1));
//        root.getLeft().setLeft(new TreeNode<>(-1));
//        root.getLeft().setRight(new TreeNode<>(-1));
//        root.setRight(new TreeNode<>(-1));
//        obj.findElementsInContaminatedBinaryTree(root, Arrays.asList(1, 3, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Single Element in a Sorted Array");
//        //https://leetcode.com/problems/single-element-in-a-sorted-array/
//        obj.singleElementInSortedArray(new int[]{1, 1, 2, 3, 3, 4, 4, 8, 8});
//        obj.singleElementInSortedArray(new int[]{3, 3, 7, 7, 10, 11, 11});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Increasing Subsequences");
//        //https://leetcode.com/problems/increasing-subsequences/
//        obj.increasingSubsequences_Backtracking(new int[]{4, 6, 7, 7});
//        obj.increasingSubsequences_Backtracking(new int[]{4, 4, 3, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize the Topmost Element After K Moves");
//        //https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/
//        System.out.println("Maximize topmost elements after k moves: "
//                + obj.maximizeTopmostElementAfterKMoves_Greedy(new int[]{5, 2, 2, 4, 0, 6}, 4));
//        System.out.println("Maximize topmost elements after k moves: "
//                + obj.maximizeTopmostElementAfterKMoves_Greedy(new int[]{2}, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Unguarded Cells in the Grid");
//        //https://leetcode.com/problems/count-unguarded-cells-in-the-grid/
//        obj.countUnguardedCellsInGrid(4, 6,
//                new int[][]{{0, 0}, {1, 1}, {2, 3}}, new int[][]{{0, 1}, {2, 2}, {1, 4}});
//        obj.countUnguardedCellsInGrid(3, 3,
//                new int[][]{{1, 1}}, new int[][]{{0, 1}, {1, 0}, {2, 1}, {1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Sum of Distinct Subarrays With Length K");
//        //https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/
//        obj.maxSumOfDistinctSubarrayOfLengthK(new int[]{1, 5, 4, 2, 9, 9, 9}, 3);
//        obj.maxSumOfDistinctSubarrayOfLengthK(new int[]{4, 4, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"
//                + "/ Longest Perfect Piece");
//        //https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{8, 2, 4, 7}, 4);
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{10, 1, 2, 4, 7, 2}, 5);
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{4, 2, 2, 2, 4, 4, 2, 2}, 0);
//        //https://practice.geeksforgeeks.org/problems/close-to-perfection1525/1
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{8, 8, 8, 8}, 1);
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{5, 4, 5, 5, 6, 7, 8, 8, 8, 7, 6}, 1);
//        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{1, 2, 3, 4, 5}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Subarrays With Fixed Bounds");
//        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/
//        obj.countSubarraysWithFixedBounds(new int[]{1, 3, 5, 2, 7, 5}, 1, 5);
//        obj.countSubarraysWithFixedBounds(new int[]{1, 1, 1, 1}, 1, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Beauty of All Substrings");
//        //https://leetcode.com/problems/sum-of-beauty-of-all-substrings/
//        obj.sumOfBeautyOfAllSubstring("aaab");
//        obj.sumOfBeautyOfAllSubstring("aabcb");
//        obj.sumOfBeautyOfAllSubstring("aabcbaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Difference Between Largest and Smallest Value in Three Moves");
//        //https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/
//        System.out.println("Min Diff between min and max value: "
//                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{5, 3, 2, 4}));
//        System.out.println("Min Diff between min and max value: "
//                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{1, 5, 0, 10, 14}));
//        System.out.println("Min Diff between min and max value: "
//                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{3, 100, 20}));
//        System.out.println("Min Diff between min and max value: "
//                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{-1, -2, -3, -4, -5}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Unique partitions");
//        //https://practice.geeksforgeeks.org/problems/unique-partitions1041/1
//        obj.uniquePartitions_Recursive(3);
//        obj.uniquePartitions_Recursive(4);
//        obj.uniquePartitions_Recursive(10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Nearest Exit from Entrance in Maze");
//        //https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/
//        System.out.println("Nearest exit from maze dist: "
//                + obj.nearestExitFromMaze_Graph(new char[][]{
//            {'+', '+', '.', '+'},
//            {'.', '.', '.', '.'},
//            {'.', '+', '+', '.'}}, new int[]{1, 2}));
//        System.out.println("Nearest exit from maze dist: "
//                + obj.nearestExitFromMaze_Graph(new char[][]{
//            {'+', '+', '+'},
//            {'.', '.', '.'},
//            {'+', '+', '+'}}, new int[]{1, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Circular Array Loop");
//        //https://leetcode.com/problems/circular-array-loop/
//        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{2, -1, 1, 2, 2}));
//        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{-1, -2, -3, -4, -5, 6}));
//        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{1, -1, 5, 1, 4}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Players With Zero or One Losses");
//        //https://leetcode.com/problems/find-players-with-zero-or-one-losses/
//        obj.findPlayerWithZeroOrOneLosses(new int[][]{{1, 3}, {2, 3}, {3, 6},
//        {5, 6}, {5, 7}, {4, 5}, {4, 8}, {4, 9}, {10, 4}, {10, 9}});
//        obj.findPlayerWithZeroOrOneLosses(new int[][]{{2, 3}, {1, 3}, {5, 4}, {6, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Short Encoding of Words");
//        //https://leetcode.com/problems/short-encoding-of-words/
//        obj.shortEncodingOfWords(new String[]{"t"});
//        obj.shortEncodingOfWords(new String[]{"time", "me", "bell"});
//        obj.shortEncodingOfWords(new String[]{"time", "me", "bell", "chime"});
//        obj.shortEncodingOfWords(new String[]{"time", "me", "bell", "chimeno"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove Covered Intervals");
//        //https://leetcode.com/problems/remove-covered-intervals/
//        obj.removeCoveredIntervals(new int[][]{{1, 4}, {3, 6}, {2, 8}});
//        obj.removeCoveredIntervals(new int[][]{{1, 4}, {2, 3}});
//        obj.removeCoveredIntervals(new int[][]{{2, 4}, {1, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest 1-Bordered Square");
//        //https://leetcode.com/problems/largest-1-bordered-square/
//        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}});
//        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{1, 1, 0, 0}});
//        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Making File Names Unique");
//        //https://leetcode.com/problems/making-file-names-unique/
//        obj.makingFileNamesUnique(new String[]{"pes", "fifa", "gta", "pes(2019)"});
//        obj.makingFileNamesUnique(new String[]{"gta", "gta(1)", "gta", "avalon"});
//        obj.makingFileNamesUnique(new String[]{"onepiece", "onepiece(1)", "onepiece(2)", "onepiece(3)", "onepiece"});
//        obj.makingFileNamesUnique(new String[]{"onepiece", "onepiece(1)", "onepiece(2)",
//            "onepiece(3)", "onepiece", "onepiece(4)"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Occurrences of a Substring");
//        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/
//        obj.maxOccurenceSubstringFollowingCondition("aababcaab", 2, 3, 4);
//        obj.maxOccurenceSubstringFollowingCondition("aaaa", 1, 3, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Task Scheduler II");
//        //https://leetcode.com/problems/task-scheduler-ii/
//        obj.taskSchedulerTwo(new int[]{1, 2, 1, 2, 3, 1}, 3);
//        obj.taskSchedulerTwo(new int[]{5, 8, 8, 5}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Prefix and Suffix Search");
//        //https://leetcode.com/problems/prefix-and-suffix-search/
//        obj.prefixAndSuffixSearch(new String[]{"apple"}, new String[][]{{"a", "e"}, {"a", "a"}});
//        obj.prefixAndSuffixSearch(new String[]{"time", "me", "chime", "moonchime"},
//                new String[][]{{"t", "me"}, {"m", "e"}, {"mo", "chime"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Implement Magic Dictionary");
//        //https://leetcode.com/problems/implement-magic-dictionary/
//        obj.magicDictionary(new String[]{"hello", "leetcode"},
//                new String[]{"hello", "hhllo", "hell", "leetcoded"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Lexicographical Numbers");
//        //https://leetcode.com/problems/lexicographical-numbers/
//        obj.lexicographicalNumbers_Recursion(13);
//        obj.lexicographicalNumbers_Recursion(2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Node With Highest Edge Score");
//        //https://leetcode.com/problems/node-with-highest-edge-score/
//        obj.nodesWithHighestEdgeScore_Graph(new int[]{1, 0, 0, 0, 0, 7, 7, 5});
//        obj.nodesWithHighestEdgeScore_Graph(new int[]{2, 0, 0, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Average Difference");
//        //https://leetcode.com/problems/minimum-average-difference/
//        obj.minAverageDiff(new int[]{2, 5, 3, 9, 5, 3});
//        obj.minAverageDiff(new int[]{0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Falling Path Sum/ Minimum Falling Path Sum II/ Paint House / Paint House II");
//        //https://leetcode.com/problems/minimum-falling-path-sum/description/
//        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{2, 1, 3}, {6, 5, 4}, {7, 8, 9}});
//        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{-19, 57}, {-40, -5}});
//        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{17, 82}, {1, -44}});
//        //https://leetcode.com/problems/minimum-falling-path-sum-ii/
//        //https://leetcode.com/problems/paint-house/description/
//        //https://leetcode.com/problems/paint-house-ii/description/
//        obj.minFallingPathSumTwo_Recursive_Memoization(new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
//        obj.minFallingPathSumTwo_Recursive_Memoization(new int[][]{{7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Path Cost in a Grid");
//        //https://leetcode.com/problems/minimum-path-cost-in-a-grid/description/
//        obj.minPathCostInGrid_Recursive_Memoization(
//                new int[][]{{5, 3}, {4, 0}, {2, 1}},
//                new int[][]{{9, 8}, {1, 5}, {10, 12}, {18, 6}, {2, 4}, {14, 3}});
//        obj.minPathCostInGrid_Recursive_Memoization(
//                new int[][]{{5, 1, 2}, {4, 0, 3}},
//                new int[][]{{12, 10, 15}, {20, 23, 8}, {21, 7, 1}, {8, 1, 13}, {9, 10, 25}, {5, 3, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cherry Pickup II");
//        //https://leetcode.com/problems/cherry-pickup-ii/
//        obj.cherryPickupTwo_Recursive_Memoization(new int[][]{{3, 1, 1}, {2, 5, 1}, {1, 5, 5}, {2, 1, 1}});
//        obj.cherryPickupTwo_Recursive_Memoization(new int[][]{{1, 0, 0, 0, 0, 0, 1},
//        {2, 0, 0, 0, 0, 3, 0}, {2, 0, 9, 0, 0, 0, 0}, {0, 3, 0, 5, 4, 0, 0}, {1, 0, 2, 3, 0, 0, 6}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Odd Levels of Binary Tree");
//        //https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(8));
//        root.getLeft().setRight(new TreeNode<>(13));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setLeft(new TreeNode<>(21));
//        root.getRight().setRight(new TreeNode<>(34));
//        obj.reverseOddLevelsOfPerfectBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Closest Nodes Queries in a Binary Search Tree");
//        //https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/
//        TreeNode<Integer> root = new TreeNode<>(6);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(13));
//        root.getRight().setLeft(new TreeNode<>(9));
//        root.getRight().setRight(new TreeNode<>(15));
//        root.getRight().getRight().setLeft(new TreeNode<>(14));
//        obj.closestNodesQueriesInBinarySearchTree(root, Arrays.asList(2, 5, 16));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete Leaves With a Given Value");
//        //https://leetcode.com/problems/delete-leaves-with-a-given-value/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.deleteLeavesWithGiveValue(root, 2);
//        root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(2));
//        obj.deleteLeavesWithGiveValue(root, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Difference Between Node and Ancestor");
//        //https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/
//        TreeNode<Integer> root = new TreeNode<>(8);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(6));
//        root.getLeft().getRight().setLeft(new TreeNode<>(4));
//        root.getLeft().getRight().setRight(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(14));
//        root.getRight().getRight().setLeft(new TreeNode<>(13));
//        obj.maxDiffBetweenNodesAndAncestor(root);
//        root = new TreeNode<>(1);
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(0));
//        root.getRight().getRight().setLeft(new TreeNode<>(3));
//        obj.maxDiffBetweenNodesAndAncestor(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Amount of Time for Binary Tree to Be Infected");
//        //https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().getLeft().setRight(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(6));
//        obj.timeRequiredToInfectBinaryTree(root, 3);
//        root = new TreeNode<>(1);
//        obj.timeRequiredToInfectBinaryTree(root, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Binary Tree");
//        //https://leetcode.com/problems/maximum-binary-tree/
//        obj.maxBinaryTree(new int[]{3, 2, 1, 6, 0, 5});
//        obj.maxBinaryTree(new int[]{3, 2, 1});
//        System.out.println("Maximum Binary Tree II");
//        //https://leetcode.com/problems/maximum-binary-tree-ii/description/
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(2));
//        obj.maxBinaryTreeTwo(root, 5);
//        root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(4));
//        obj.maxBinaryTreeTwo(root, 3);
//        root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(3));
//        obj.maxBinaryTreeTwo(root, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("People Whose List of Favorite Companies Is Not a Subset of Another List");
//        //https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
//        List<List<String>> favouriteCompanies = new ArrayList<>();
//        favouriteCompanies.add(Arrays.asList("leetcode", "google", "facebook"));
//        favouriteCompanies.add(Arrays.asList("google", "microsoft"));
//        favouriteCompanies.add(Arrays.asList("google", "facebook"));
//        favouriteCompanies.add(Arrays.asList("google"));
//        favouriteCompanies.add(Arrays.asList("amazon"));
//        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
//        favouriteCompanies = new ArrayList<>();
//        favouriteCompanies.add(Arrays.asList("leetcode", "google", "facebook"));
//        favouriteCompanies.add(Arrays.asList("leetcode", "amazon"));
//        favouriteCompanies.add(Arrays.asList("google", "facebook"));
//        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
//        favouriteCompanies = new ArrayList<>();
//        favouriteCompanies.add(Arrays.asList("leetcode"));
//        favouriteCompanies.add(Arrays.asList("amazon"));
//        favouriteCompanies.add(Arrays.asList("google"));
//        favouriteCompanies.add(Arrays.asList("facebook"));
//        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print Words Vertically");
//        //https://leetcode.com/problems/print-words-vertically/description/
//        obj.printWordsVertically("HOW ARE YOU");
//        obj.printWordsVertically("TO BE OR NOT TO BE");
//        obj.printWordsVertically("CONTEST IS COMING");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Bulls and Cows");
//        //https://leetcode.com/problems/bulls-and-cows/description/
//        obj.bullsAndCows("1807", "7810");
//        obj.bullsAndCows("1122", "2211");
//        obj.bullsAndCows("1122", "1222");
//        obj.bullsAndCows("1123", "0111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Sum of a Pair With Equal Sum of Digits");
//        //https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/
//        obj.maxPairSumWithEqualDigitSum(new int[]{18, 43, 36, 13, 7});
//        obj.maxPairSumWithEqualDigitSum(new int[]{10, 12, 19, 14});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Unreachable Pairs of Nodes in an Undirected Graph");
//        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/
//        obj.countUnreachablePairOfNodes_Graph(3, new int[][]{{0, 1}, {0, 2}, {1, 2}});
//        obj.countUnreachablePairOfNodes_Graph(7, new int[][]{{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Bridge");
//        //https://leetcode.com/problems/shortest-bridge/description/
//        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
//            {0, 1}, {1, 0}}));
//        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
//            {0, 1, 0},
//            {0, 0, 0},
//            {0, 0, 1}}));
//        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
//            {1, 1, 1, 1, 1},
//            {1, 0, 0, 0, 1},
//            {1, 0, 1, 0, 1},
//            {1, 0, 0, 0, 1},
//            {1, 1, 1, 1, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Detonate the Maximum Bombs");
//        //https://leetcode.com/problems/detonate-the-maximum-bombs/description/
//        obj.detonateMaxBombs_Graph(new int[][]{{2, 1, 3}, {6, 1, 4}});
//        obj.detonateMaxBombs_Graph(new int[][]{{1, 1, 5}, {10, 10, 5}});
//        obj.detonateMaxBombs_Graph(new int[][]{{1, 2, 3}, {2, 3, 1}, {3, 4, 2}, {4, 5, 3}, {5, 6, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Dungeon Game");
//        //https://leetcode.com/problems/dungeon-game/description/
//        obj.dungeonGame_Recursive_Memoization(new int[][]{{-2, -3, 3}, {-5, -10, 1}, {10, 30, -5}});
//        obj.dungeonGame_Recursive_Memoization(new int[][]{{0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Previous Permutation With One Swap");
//        //https://leetcode.com/problems/previous-permutation-with-one-swap/description/
//        obj.previousPermutationWithOneSwap_Greedy(new int[]{3, 2, 1});
//        obj.previousPermutationWithOneSwap_Greedy(new int[]{1, 1, 5});
//        obj.previousPermutationWithOneSwap_Greedy(new int[]{1, 9, 4, 6, 7});
//        obj.previousPermutationWithOneSwap_Greedy(new int[]{3, 1, 1, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Expressive Words");
//        //https://leetcode.com/problems/expressive-words/description/
//        obj.expressiveWords("heeellooo", new String[]{"hello", "hi", "helo"});
//        obj.expressiveWords("zzzzzyyyyy", new String[]{"zzyy", "zy", "zyy"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find All Groups of Farmland");
//        //https://leetcode.com/problems/find-all-groups-of-farmland/description/
//        obj.findAllGroupOfFarmland_Graph(new int[][]{
//            {1, 0, 0},
//            {0, 1, 1},
//            {0, 1, 1}});
//        obj.findAllGroupOfFarmland_Graph(new int[][]{
//            {1, 1},
//            {1, 1}});
//        obj.findAllGroupOfFarmland_Graph(new int[][]{{0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sum of Distances in Tree");
        //https://leetcode.com/problems/sum-of-distances-in-tree/description/
        obj.sumOfDistancesInTree_Graph(2, new int[][]{{0, 1}});
        obj.sumOfDistancesInTree_Graph(6, new int[][]{{0, 1}, {0, 2}, {2, 3}, {2, 4}, {2, 5}});
        obj.sumOfDistancesInTree_Graph(1, new int[][]{});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Domino and Tromino Tiling");
        //https://leetcode.com/problems/domino-and-tromino-tiling/description/
        obj.dominoTrominoTiling_DP_Memoization(1);
        obj.dominoTrominoTiling_DP_Memoization(2);
        obj.dominoTrominoTiling_DP_Memoization(3);
        obj.dominoTrominoTiling_DP_Memoization(4);
        obj.dominoTrominoTiling_DP_Memoization(5);
        obj.dominoTrominoTiling_DP_Memoization(1000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Custom Sort String");
//        //https://leetcode.com/problems/custom-sort-string/description/
//        obj.customSortString("cba", "abcd");
//        obj.customSortString("cbafg", "abcd");
//        obj.customSortString("cba", "zxagabcdiz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Single valued subtree");
//        //https://leetcode.com/problems/univalued-binary-tree/description/
//        //https://practice.geeksforgeeks.org/problems/single-valued-subtree/1
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(5));
//        obj.univaluedBinaryTree(root);
//        obj.countSingleValuedSubtreeInATree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Nodes with Even-Valued Grandparent");
//        //https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description/
//        TreeNode<Integer> root = new TreeNode<>(6);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().setRight(new TreeNode<>(7));
//        root.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root.getLeft().getRight().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(1));
//        root.getRight().setRight(new TreeNode<>(3));
//        root.getRight().getRight().setRight(new TreeNode<>(5));
//        obj.sumOfNodesWithEvenValuedGrandparent(root);
//        root = new TreeNode<>(1);
//        obj.sumOfNodesWithEvenValuedGrandparent(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print Ancestor of given Target Node in a Binary Tree");
//        //https://youtu.be/2VZHLtHM_6w
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().getLeft().setRight(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(6));
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 1);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 5);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 6);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 9);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All Ancestors of a Node in a Directed Acyclic Graph");
//        //https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/
//        obj.allAncestorsOfAllNodesInDAG_Graph(8, new int[][]{{0, 3}, {0, 4}, {1, 3},
//        {2, 4}, {2, 7}, {3, 5}, {3, 6}, {3, 7}, {4, 6}});
//        obj.allAncestorsOfAllNodesInDAG_Graph(5, new int[][]{{0, 1}, {0, 2}, {0, 3},
//        {0, 4}, {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Kth Ancestor of a Tree Node");
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/
        obj.kThAncestorOfTreeNode_Graph(7, new int[]{-1, 0, 0, 1, 1, 2, 2}, new int[][]{{3, 1}, {5, 2}, {6, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Buddy Strings");
        //https://leetcode.com/problems/buddy-strings/description/
        System.out.println("Buddy strings: " + obj.buddyStrings("ab", "ab"));
        System.out.println("Buddy strings: " + obj.buddyStrings("aa", "aa"));
        System.out.println("Buddy strings: " + obj.buddyStrings("ab", "ba"));
        System.out.println("Buddy strings: " + obj.buddyStrings("abcaa", "abcbb"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Balloons");
//        //https://leetcode.com/problems/maximum-number-of-balloons/description/
//        obj.maxNumberOfBalloonsFromText("balloon");
//        obj.maxNumberOfBalloonsFromText("nlaebolko");
//        obj.maxNumberOfBalloonsFromText("loonbalxballpoon");
//        obj.maxNumberOfBalloonsFromText("leetcode");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Palindrome Partitioning");
//        //https://leetcode.com/problems/palindrome-partitioning/description/
//        obj.pallindromePartitioning_Backtracking("aab");
//        obj.pallindromePartitioning_Backtracking("a");
//        obj.pallindromePartitioning_Backtracking("aabbaa");
//        System.out.println("Palindrome Partitioning II");
//        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
//        obj.pallindromePartitioningTwo_Recursive_Memoization("a");
//        obj.pallindromePartitioningTwo_Recursive_Memoization("aa");
//        obj.pallindromePartitioningTwo_Recursive_Memoization("ab");
//        obj.pallindromePartitioningTwo_Recursive_Memoization("aba");
//        obj.pallindromePartitioningTwo_Recursive_Memoization("aab");
//        obj.pallindromePartitioningTwo_DP_Memoization("a");
//        obj.pallindromePartitioningTwo_DP_Memoization("aa");
//        obj.pallindromePartitioningTwo_DP_Memoization("ab");
//        obj.pallindromePartitioningTwo_DP_Memoization("aba");
//        obj.pallindromePartitioningTwo_DP_Memoization("aab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove Nodes From Linked List");
//        //https://leetcode.com/problems/remove-nodes-from-linked-list/description/
//        Node<Integer> head = new Node<>(5);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(13));
//        head.getNext().getNext().setNext(new Node<>(3));
//        head.getNext().getNext().getNext().setNext(new Node<>(8));
//        obj.removeEveryNodeWhichHasStrictlyGreaterNodeToRight(head);
//        head = new Node<>(1);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(1));
//        head.getNext().getNext().setNext(new Node<>(1));
//        obj.removeEveryNodeWhichHasStrictlyGreaterNodeToRight(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Wildcard Matching");
        //https://leetcode.com/problems/wildcard-matching/description/
        obj.wildCardMatching_Recursive_Memoization("aa", "a");
        obj.wildCardMatching_Recursive_Memoization("aa", "*");
        obj.wildCardMatching_Recursive_Memoization("cb", "?a");
        obj.wildCardMatching_Recursive_Memoization("abxyzef", "ab*ef");
        obj.wildCardMatching_Recursive_Memoization("abef", "ab*ef");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Chunks To Make Sorted I/ II");
//        //https://leetcode.com/problems/max-chunks-to-make-sorted/description/
//        obj.maxChunkToMakeSorted(new int[]{4, 3, 2, 1, 0});
//        obj.maxChunkToMakeSorted(new int[]{1, 0, 2, 3, 4});
//        obj.maxChunkToMakeSorted(new int[]{0, 1, 2, 3, 4});
//        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/
//        obj.maxChunkToMakeSortedTwo(new int[]{5, 4, 3, 2, 1});
//        obj.maxChunkToMakeSortedTwo(new int[]{2, 1, 3, 4, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Increment to Make Array Unique");
//        //https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/
//        obj.minIncreamentToMakeArrayUnique(new int[]{1, 2, 2});
//        obj.minIncreamentToMakeArrayUnique(new int[]{3, 2, 1, 2, 1, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Validate Stack Sequences");
//        //https://leetcode.com/problems/validate-stack-sequences/description/
//        obj.validateStackSequences(new int[]{1, 2, 3, 4, 5}, new int[]{4, 5, 3, 2, 1});
//        obj.validateStackSequences(new int[]{1, 2, 3, 4, 5}, new int[]{4, 3, 5, 1, 2});
//        obj.validateStackSequences2(new int[]{1, 2, 3, 4, 5}, new int[]{4, 5, 3, 2, 1});
//        obj.validateStackSequences2(new int[]{1, 2, 3, 4, 5}, new int[]{4, 3, 5, 1, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the longest string from the string array");
//        //https://practice.geeksforgeeks.org/problems/8d157f11af5416087251513cfc38ffc4d23be308/1
//        obj.findLongestString(new String[]{"ab", "a", "abc", "abd"});
//        obj.findLongestString(new String[]{"ab", "a", "aa", "abd", "abc", "abda", "abdd", "abde", "abdab"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Moves to Equal Array Elements");
//        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
//        obj.minMovesToEqualArrayElements(new int[]{1, 2, 3});
//        obj.minMovesToEqualArrayElements(new int[]{1, 1, 1});
//        System.out.println("Minimum Moves to Equal Array Elements II");
//        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/description/
//        obj.minMovesToMakeArrayEqualTwo(new int[]{1, 2, 3});
//        obj.minMovesToMakeArrayEqualTwo(new int[]{1, 10, 2, 9});
//        System.out.println("Minimum Operations to Make a Uni-Value Grid");
//        //https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/description/
//        System.out.println("Min operations to make a uni-valued grid : "
//                + obj.minOperationsToMakeUniValuedGrid(new int[][]{{2, 4}, {6, 8}}, 2));
//        System.out.println("Min operations to make a uni-valued grid : "
//                + obj.minOperationsToMakeUniValuedGrid(new int[][]{{1, 5}, {2, 3}}, 1));
//        System.out.println("Min operations to make a uni-valued grid : "
//                + obj.minOperationsToMakeUniValuedGrid(new int[][]{{1, 2}, {3, 4}}, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Ice Cream Bars");
//        //https://leetcode.com/problems/maximum-ice-cream-bars/description/
//        obj.maxIcecreamBars_Greedy(new int[]{1, 3, 2, 4, 1}, 7);
//        obj.maxIcecreamBars_Greedy(new int[]{10, 6, 8, 7, 7, 8}, 5);
//        obj.maxIcecreamBars_Greedy(new int[]{1, 6, 3, 1, 2, 5}, 20);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Coloring A Border");
//        //https://leetcode.com/problems/coloring-a-border/description/
//        obj.coloringBorders_Graph(new int[][]{{1, 1}, {1, 2}}, 0, 0, 3);
//        obj.coloringBorders_Graph(new int[][]{{1, 2, 2}, {2, 3, 2}}, 0, 1, 3);
//        obj.coloringBorders_Graph(new int[][]{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, 1, 1, 3);
//        obj.coloringBorders_Graph(new int[][]{{1, 1, 1, 1, 1}, {1, 2, 2, 2, 1},
//        {1, 2, 2, 2, 1}, {1, 2, 2, 2, 1}, {1, 1, 1, 1, 1}}, 2, 2, 3);
//        obj.coloringBorders_Graph(new int[][]{{1, 2, 1, 2, 1, 2}, {2, 2, 2, 2, 1, 2},
//        {1, 2, 2, 2, 1, 2}}, 1, 3, 1);
//        obj.coloringBorders_Graph(
//                new int[][]{{2,2,2,1,1,1,2},{2,2,2,1,1,1,2},{2,1,1,1,1,1,2},{2,2,2,2,2,2,2}}, 2, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Interval List Intersections");
//        //https://leetcode.com/problems/interval-list-intersections/description/
//        obj.intervalsListIntersection(new int[][]{{0, 2}, {5, 10}, {13, 23}, {24, 25}},
//                new int[][]{{1, 5}, {8, 12}, {15, 24}, {25, 26}});
//        obj.intervalsListIntersection(new int[][]{{1, 3}, {5, 9}},
//                new int[][]{});
//        obj.intervalsListIntersection(new int[][]{{0, 5}, {12, 15}, {21, 25}},
//                new int[][]{{6, 11}, {16, 20}, {26, 30}});
//        obj.intervalsListIntersection(new int[][]{{0, 2}, {5, 10}},
//                new int[][]{{1, 5}, {8, 12}, {15, 24}, {25, 26}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Absolute difference divisible by K");
//        //https://practice.geeksforgeeks.org/problems/e0059183c88ab680b2f73f7d809fb8056fe9dc43/1
//        obj.countPairsWithAbsoluteDiffDivisibleByK(new int[]{3, 7, 11}, 4);
//        obj.countPairsWithAbsoluteDiffDivisibleByK(new int[]{1, 2, 3, 4}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Value of K Coins From Piles");
//        //https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/
//        obj.maxValueFromKCoinsFromPiles_Recursive_Memoization(new int[][]{{1, 100, 3}, {7, 8, 9}}, 2);
//        obj.maxValueFromKCoinsFromPiles_Recursive_Memoization(
//                new int[][]{{100}, {100}, {100}, {100}, {100}, {100}, {1, 1, 1, 1, 1, 1, 700}}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Time to Collect All Apples in a Tree");
//        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/
//        obj.minTimeToCollectAllApplesInATree_Graph(7,
//                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}},
//                new boolean[]{false, false, true, false, true, true, false});
//        obj.minTimeToCollectAllApplesInATree_Graph(7,
//                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}},
//                new boolean[]{false, false, true, false, false, true, false});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Nodes in the Sub-Tree With the Same Label");
//        //https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description/
//        obj.numberOfNodesInSubtreeWithSameLabel_Graph(7,
//                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}}, "abaedcd");
//        obj.numberOfNodesInSubtreeWithSameLabel_Graph(4,
//                new int[][]{{0, 1}, {1, 2}, {0, 3}}, "bbbb");
//        obj.numberOfNodesInSubtreeWithSameLabel_Graph(5,
//                new int[][]{{0, 1}, {0, 2}, {1, 3}, {0, 4}}, "aabab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Path With Different Adjacent Characters");
        //https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 0, 1, 1, 2}, "abacbe");
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 0, 0}, "aabc");
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 1}, "aab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Lexicographically Smallest Equivalent String");
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/
        obj.lexicographicallySmallestEquivalentString_Graph("parker", "morris", "parser");
        obj.lexicographicallySmallestEquivalentString_Graph("hello", "world", "hold");
        obj.lexicographicallySmallestEquivalentString_Graph("leetcode", "programs", "sourcecode");
        obj.lexicographicallySmallestEquivalentString_Graph(
                "opecenadojbodihfgmpijpfocomhcncicefpohkibjckijghii",
                "ndlbhpaeppgekfhnjnmmplmdoifdhbglmedpjgleofgnahglbe",
                "ttusuhhrabgsswpaapxoxdanchyccmpjitwwmfioedtbiggfru");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Accounts Merge");
//        //https://leetcode.com/problems/accounts-merge/description/
//        obj.accountsMerge_Graph(new String[][]{
//            {"John", "johnsmith@mail.com", "john_newyork@mail.com"},
//            {"John", "johnsmith@mail.com", "john00@mail.com"},
//            {"Mary", "mary@mail.com"},
//            {"John", "johnnybravo@mail.com"}});
//        obj.accountsMerge_Graph(new String[][]{
//            {"Gabe", "Gabe0@m.co", "Gabe3@m.co", "Gabe1@m.co"},
//            {"Kevin", "Kevin3@m.co", "Kevin5@m.co", "Kevin0@m.co"},
//            {"Ethan", "Ethan5@m.co", "Ethan4@m.co", "Ethan0@m.co"},
//            {"Hanzo", "Hanzo3@m.co", "Hanzo1@m.co", "Hanzo0@m.co"},
//            {"Fern", "Fern5@m.co", "Fern1@m.co", "Fern0@m.co"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Apply Discount to Prices");
//        //https://leetcode.com/problems/apply-discount-to-prices/description/
//        obj.applyDiscountToPrices("there are $1 $2 and 5$ candies in the shop", 50);
//        obj.applyDiscountToPrices("1 2 $3 4 $5 $6 7 8$ $9 $10$", 100);
//        //round off required case
//        obj.applyDiscountToPrices("duew$11mengf $8 $1", 7);
//        //amount of long type required
//        obj.applyDiscountToPrices("706hzu76jjh7yufr5x9ot60v149k5 $7651913186 pw2o $6", 28);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove All Occurrences of a Substring");
//        //https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
//        obj.removeAllOccurencesOfSubstring("daabcbaabcbc", "abc");
//        obj.removeAllOccurencesOfSubstring("axxxxyyyyb", "xy");
//        obj.removeAllOccurencesOfSubstring("abcabcabcabcabc", "abc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove One Element to Make the Array Strictly Increasing");
//        //https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/description/
//        System.out.println("Is array strictly increasing: "
//                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{1, 2, 10, 5, 7}));
//        System.out.println("Is array strictly increasing: "
//                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{2, 3, 1, 2}));
//        System.out.println("Is array strictly increasing: "
//                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{1, 1, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Chunked Palindrome Decomposition");
//        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/
//        obj.longestChunkedPallindromeDecomposition_Greedy("ghiabcdefhelloadamhelloabcdefghi");
//        obj.longestChunkedPallindromeDecomposition_Greedy("merchant");
//        obj.longestChunkedPallindromeDecomposition_Greedy("antaprezatepzapreanta");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Decoded String at Index");
        //https://leetcode.com/problems/decoded-string-at-index/description/
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("leet2code3", 10));
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("ha22", 5));
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("a2345678999999999999999", 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Restore IP Addresses");
//        //https://leetcode.com/problems/restore-ip-addresses/description/
//        obj.restoreIPAddresses_Backtracking("25525511135");
//        obj.restoreIPAddresses_Backtracking("0000");
//        obj.restoreIPAddresses_Backtracking("101023");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Snakes and Ladders");
        //https://leetcode.com/problems/snakes-and-ladders/description/
        obj.snakesAndLadder_Graph(new int[][]{
                {-1, -1, -1, -1, -1, -1},
                {-1, -1, -1, -1, -1, -1},
                {-1, -1, -1, -1, -1, -1},
                {-1, 35, -1, -1, 13, -1},
                {-1, -1, -1, -1, -1, -1},
                {-1, 15, -1, -1, -1, -1}});
        obj.snakesAndLadder_Graph(new int[][]{
                {-1, -1}, {-1, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Closest Node to Given Two Nodes");
        //https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/
        obj.findClosestNodeToGivenTwoNodes_Graph(new int[]{2, 2, 3, -1}, 0, 1);
        obj.findClosestNodeToGivenTwoNodes_Graph(new int[]{1, 2, -1}, 0, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Data Stream as Disjoint Intervals");
//        //https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/
//        obj.dataStreamAsDisjointIntervals(
//                Arrays.asList("addNum", "getIntervals", "addNum", "getIntervals",
//                        "addNum", "getIntervals", "addNum", "getIntervals",
//                        "addNum", "getIntervals"),
//                Arrays.asList(1, -1, 3, -1, 7, -1, 2, -1, 6, -1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Best Team With No Conflicts");
        //https://leetcode.com/problems/best-team-with-no-conflicts/description/
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{1, 3, 5, 10, 15}, new int[]{1, 2, 3, 4, 5});
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{4, 5, 6, 5}, new int[]{2, 1, 2, 1});
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{1, 2, 3, 5}, new int[]{8, 9, 10, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Naming a Company");
//        //https://leetcode.com/problems/naming-a-company/description/
//        obj.namingACompany(new String[]{"coffee", "donuts", "time", "toffee"});
//        obj.namingACompany(new String[]{"lack", "back"});
//        obj.namingACompany(new String[]{"phhrrjjcm", "zjfkpps", "pm", "fnpduelfe", "mxtvjnq"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Greatest Common Divisor of Strings");
//        //https://leetcode.com/problems/greatest-common-divisor-of-strings/description/
//        System.out.println("Greatest common divisor of strings : "
//                + obj.greatestCommonDivisorOfStrings("ABCABC", "ABC"));
//        System.out.println("Greatest common divisor of strings : "
//                + obj.greatestCommonDivisorOfStrings("ABABAB", "ABAB"));
//        System.out.println("Greatest common divisor of strings : "
//                + obj.greatestCommonDivisorOfStrings("LEET", "CODE"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path with Alternating Colors");
        //https://leetcode.com/problems/shortest-path-with-alternating-colors/description/
        obj.shortestPathWithAlternatingColors_Graph(3, new int[][]{{0, 1}, {1, 2}}, new int[][]{});
        obj.shortestPathWithAlternatingColors_Graph(3, new int[][]{{0, 1}}, new int[][]{{2, 1}});
        obj.shortestPathWithAlternatingColors_Graph(5,
                new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}}, new int[][]{{1, 2}, {2, 3}, {3, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Divide Players Into Teams of Equal Skill");
//        //https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/description/
//        System.out.println("Player chemistry : "
//                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 2, 5, 1, 3, 4}));
//        System.out.println("Player chemistry : "
//                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 4}));
//        System.out.println("Player chemistry : "
//                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{1, 1, 2, 3}));
//        System.out.println("Player chemistry : "
//                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 2, 5, 1, 3, 6}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Fuel Cost to Report to the Capital");
//        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/
//        obj.minFuelToReachCapitalCity_Graph(new int[][]{{0, 1}, {0, 2}, {0, 3}}, 5);
//        obj.minFuelToReachCapitalCity_Graph(new int[][]{{3, 1}, {3, 2}, {1, 0}, {0, 4}, {0, 5}, {4, 6}}, 2);
//        obj.minFuelToReachCapitalCity_Graph(new int[][]{}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Odd Numbers in an Interval Range");
//        //https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/
//        obj.countOddNumbersInIntervalRange(3, 7);
//        obj.countOddNumbersInIntervalRange(8, 10);
//        obj.countOddNumbersInIntervalRange(278382788, 569302584);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Good Ways to Split a String");
//        //https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/
//        obj.numberOfGoodWaysToSplitString("aacaba");
//        obj.numberOfGoodWaysToSplitString("abcd");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Cheapest Flights Within K Stops");
        //https://leetcode.com/problems/cheapest-flights-within-k-stops/description/
        obj.cheapestFlightsWithinKStops_Graph(4,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}}, 0, 3, 1);
        obj.cheapestFlightsWithinKStops_Graph(3,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {0, 2, 500}}, 0, 2, 1);
        obj.cheapestFlightsWithinKStops_Graph(3,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {0, 2, 500}}, 0, 2, 0);
        obj.cheapestFlightsWithinKStops_Graph(4,
                new int[][]{{0, 1, 1}, {0, 2, 5}, {1, 2, 1}, {2, 3, 1}}, 0, 3, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Letter Case Permutation");
//        //https://leetcode.com/problems/letter-case-permutation/description/
//        obj.letterCasePermutation_Backtracking("a1b2");
//        obj.letterCasePermutation_Backtracking("3z4");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Repeated String Match");
//        //https://leetcode.com/problems/repeated-string-match/description/
//        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("abcd", "cdabcdab"));
//        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("a", "aa"));
//        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("aaaaaaaaaaaaaaab", "ba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Append K Integers With Minimal Sum");
//        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/
//        obj.appendKIntegerWithMinSum_Greedy(new int[]{1, 4, 25, 10, 25}, 2);
//        obj.appendKIntegerWithMinSum_Greedy(new int[]{5, 6}, 6);
//        obj.appendKIntegerWithMinSum_Greedy(new int[]{1}, 100000000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Integers to Choose From a Range I");
//        //https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/description/
//        obj.maxNumberOfIntegersToChooseFromRange_Greedy(new int[]{1, 6, 5}, 5, 6);
//        obj.maxNumberOfIntegersToChooseFromRange_Greedy(new int[]{1, 2, 3, 4, 5, 6, 7}, 8, 1);
//        obj.maxNumberOfIntegersToChooseFromRange_Greedy(new int[]{11}, 7, 50);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Create Binary Tree From Descriptions");
//        //https://leetcode.com/problems/create-binary-tree-from-descriptions/description/
//        obj.createBinaryTreeFromDescription_Graph(new int[][]{{20, 15, 1}, {20, 17, 0},
//        {50, 20, 1}, {50, 80, 0}, {80, 19, 1}});
//        obj.createBinaryTreeFromDescription_Graph(new int[][]{{1, 2, 1}, {2, 3, 0}, {3, 4, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Largest Sum in a Binary Tree");
//        //https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(8));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setRight(new TreeNode<>(6));
//        root.setRight(new TreeNode<>(9));
//        root.getRight().setLeft(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.kthLargestLevelSumInBinaryTree(root, 2);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        obj.kthLargestLevelSumInBinaryTree(root, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Good Leaf Nodes Pairs");
//        //https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(3));
//        System.out.println("Pairs of good leaf nodes in binary tree: "
//                + obj.numberOfGoodLeafNodesPairsOFBinaryTree(root, 3));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Pairs of good leaf nodes in binary tree: "
//                + obj.numberOfGoodLeafNodesPairsOFBinaryTree(root, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Operations to Convert Number");
//        //https://leetcode.com/problems/minimum-operations-to-convert-number/description/
//        System.out.println("Minimum operations to convert number: "
//                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{2, 4, 12}, 2, 12));
//        System.out.println("Minimum operations to convert number: "
//                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{3, 5, 7}, 0, -4));
//        System.out.println("Minimum operations to convert number: "
//                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{2, 8, 16}, 0, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reward Top K Students");
//        //https://leetcode.com/problems/reward-top-k-students/description/
//        obj.rewardTopKStudents(
//                new String[]{"smart", "brilliant", "studious"},
//                new String[]{"not"},
//                new String[]{"this student is studious", "the student is smart"},
//                new int[]{1, 2},
//                2);
//        obj.rewardTopKStudents(
//                new String[]{"smart", "brilliant", "studious"},
//                new String[]{"not"},
//                new String[]{"this student is not studious", "the student is smart"},
//                new int[]{1, 2},
//                2);
//        obj.rewardTopKStudents(
//                new String[]{"fkeofjpc", "qq", "iio"},
//                new String[]{"jdh", "khj", "eget", "rjstbhe", "yzyoatfyx", "wlinrrgcm"},
//                new String[]{"rjstbhe eget kctxcoub urrmkhlmi yniqafy fkeofjpc iio yzyoatfyx khj iio",
//                    "gpnhgabl qq qq fkeofjpc dflidshdb qq iio khj qq yzyoatfyx",
//                    "tizpzhlbyb eget z rjstbhe iio jdh jdh iptxh qq rjstbhe",
//                    "jtlghe wlinrrgcm jnkdbd k iio et rjstbhe iio qq jdh",
//                    "yp fkeofjpc lkhypcebox rjstbhe ewwykishv egzhne jdh y qq qq",
//                    "fu ql iio fkeofjpc jdh luspuy yzyoatfyx li qq v",
//                    "wlinrrgcm iio qq omnc sgkt tzgev iio iio qq qq",
//                    "d vhg qlj khj wlinrrgcm qq f jp zsmhkjokmb rjstbhe"},
//                new int[]{96537918, 589204657, 765963609, 613766496, 43871615, 189209587, 239084671, 908938263},
//                3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Can Place Flowers");
//        //https://leetcode.com/problems/can-place-flowers/description/
//        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 1}, 1));
//        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 1}, 2));
//        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 0, 1}, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Score For String rp Or pr");
//        //https://leetcode.com/problems/maximum-score-from-removing-substrings/description/
//        //https://practice.geeksforgeeks.org/problems/d25f415de2ff3e02134de03e17ad019d723ab2e9/1
//        obj.maxScoreForString_Greedy("cdbcbbaaabab", 4, 5);
//        obj.maxScoreForString_Greedy("aabbaaxybbaabb", 5, 4);
//        obj.maxScoreForString_Greedy("lbbfbbabgabaaaaamubb", 10, 20);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Greatest Sum Divisible by Three");
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/description/
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{3, 6, 5, 1, 8});
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{4});
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{1, 2, 3, 4, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Score of a Path Between Two Cities");
//        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
//        obj.minScoreOfPathBetweenTwoCities_Graph(4, new int[][]{{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}});
//        obj.minScoreOfPathBetweenTwoCities_Graph(4, new int[][]{{1, 2, 2}, {1, 3, 4}, {3, 4, 7}});
//        obj.minScoreOfPathBetweenTwoCities_Graph_UnionFind(4, new int[][]{{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}});
//        obj.minScoreOfPathBetweenTwoCities_Graph_UnionFind(4, new int[][]{{1, 2, 2}, {1, 3, 4}, {3, 4, 7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Operations to Make Network Connected");
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(4,
                new int[][]{{0, 1}, {0, 2}, {1, 2}}));
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(6,
                new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}}));
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(6,
                new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(4,
                new int[][]{{0, 1}, {0, 2}, {1, 2}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(6,
                new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(6,
                new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if There is a Valid Path in a Grid");
//        //https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description/
//        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{2, 4, 3}, {6, 5, 2}});
//        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{1, 2, 1}, {1, 2, 1}});
//        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{1, 1, 2}});
//        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{2, 6, 3}, {6, 5, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Cycle in a Graph");
//        //https://leetcode.com/problems/longest-cycle-in-a-graph/description/
//        obj.longestCycleInGraph_Graph(new int[]{3, 3, 4, 2, 3});
//        obj.longestCycleInGraph_Graph(new int[]{2, -1, 3, 1});
//        obj.longestCycleInGraph_Graph(new int[]{3, 3, 0, 0, 7, 0, 7, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Alphabet Board Path");
//        //https://leetcode.com/problems/alphabet-board-path/description/
//        obj.alphabetBoardPath("leet");
//        obj.alphabetBoardPath("code");
//        obj.alphabetBoardPath("zdz");
//        obj.alphabetBoardPath("lezet");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Cost For Tickets");
//        //https://leetcode.com/problems/minimum-cost-for-tickets/description/
//        obj.minCostForTickets_Recursive_Memoization(new int[]{1, 4, 6, 7, 8, 20},
//                new int[]{2, 7, 15});
//        obj.minCostForTickets_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31},
//                new int[]{2, 7, 15});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reducing Dishes");
//        //https://leetcode.com/problems/reducing-dishes/description/
//        obj.reducingDishes_Recursive_Memoization(new int[]{-1, -8, 0, 5, -9});
//        obj.reducingDishes_Recursive_Memoization(new int[]{4, 3, 2});
//        obj.reducingDishes_Recursive_Memoization(new int[]{-1, -4, -5});
//        //greedy solution
//        obj.reducingDishes_Greedy(new int[]{-1, -8, 0, 5, -9});
//        obj.reducingDishes_Greedy(new int[]{4, 3, 2});
//        obj.reducingDishes_Greedy(new int[]{-1, -4, -5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Subarray Sum with One Deletion");
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{1, -2, 0, 3});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{1, -2, -2, 3});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{-1, -1, -1, -1});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{100, 30, 1, 987, 400, 200, 9});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Scramble String");
        //https://leetcode.com/problems/scramble-string/description/
        obj.scrambledStrings_Recursive_Memoization("great", "rgeat");
        obj.scrambledStrings_Recursive_Memoization("abcde", "caebd");
        obj.scrambledStrings_Recursive_Memoization("a", "a");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways of Cutting a Pizza");
        //https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description/
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "AAA", "..."}, 3);
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "AA.", "..."}, 3);
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "A..", "..."}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Take K of Each Character From Left and Right");
        //https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/
        System.out.println("Min k char pick up from left & right: "
                + obj.takeKOfEachCharFromLeftRight("aabaaaacaabc", 2));
        System.out.println("Min k char pick up from left & right: "
                + obj.takeKOfEachCharFromLeftRight("a", 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Swap Adjacent in LR String");
        //https://leetcode.com/problems/swap-adjacent-in-lr-string/description/
        System.out.println("Swap adjacent LR string possible: " + obj.swapAdjacentLRString("RXXLRXRXL", "XRLXXRRLX"));
        System.out.println("Swap adjacent LR string possible: " + obj.swapAdjacentLRString("X", "L"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Successful Pairs of Spells and Potions");
        //https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/
        obj.successfulPairsOfSpellsAndPotions(new int[]{5, 1, 3}, new int[]{1, 2, 3, 4, 5}, 7);
        obj.successfulPairsOfSpellsAndPotions(new int[]{3, 1, 2}, new int[]{8, 5, 8}, 16);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Steps Required To Make String Empty");
        //https://practice.geeksforgeeks.org/problems/6a1b365b520f10c8a29b533eb72951b4b4237b57/1
        obj.minStepsReqToMakeStringEmpty_Greedy("bbaaabb");
        obj.minStepsReqToMakeStringEmpty_Greedy("aababaa");
        obj.minStepsReqToMakeStringEmpty_Greedy("bababa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimize Maximum of Array");
        //https://leetcode.com/problems/minimize-maximum-of-array/description/
        obj.minimizeMaxArray_Greedy(new int[]{3, 7, 1, 6});
        obj.minimizeMaxArray_Greedy(new int[]{10, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Without AAA or BBB");
        //https://leetcode.com/problems/string-without-aaa-or-bbb/description/
        obj.stringWithoutAAAOrBBB_Greedy(1, 2);
        obj.stringWithoutAAAOrBBB_Greedy(4, 1);
        obj.stringWithoutAAAOrBBB_Greedy(4, 8);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Outermost Parentheses");
        //https://leetcode.com/problems/remove-outermost-parentheses/description/
        obj.removeOutermostParenthesis("(()())(())");
        obj.removeOutermostParenthesis("(()())(())(()(()))");
        obj.removeOutermostParenthesis("()()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest Color Value in a Directed Graph");
        //https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/
        System.out.println("Largest color value in directed graph : "
                + obj.largestColorValueInDirectedGraph_Graph("abaca", new int[][]{{0, 1}, {0, 2}, {2, 3}, {3, 4}}));
        System.out.println("Largest color value in directed graph : "
                + obj.largestColorValueInDirectedGraph_Graph("a", new int[][]{{0, 0}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Target Sum");
        //https://leetcode.com/problems/target-sum/description/
        obj.targetSum_Recursive_Memoization(new int[]{1, 1, 1, 1, 1}, 3);
        obj.targetSum_Recursive_Memoization(new int[]{1}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Form a Target String Given a Dictionary");
        //https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/
        obj.waysToFormStringFromDict_Recursive_Memoization(new String[]{"acca", "bbbb", "caca"}, "aba");
        obj.waysToFormStringFromDict_Recursive_Memoization(new String[]{"abba", "baab"}, "bab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Maximum Number of Marked Indices");
        //https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/description/
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{3, 5, 2, 4});
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{9, 2, 5, 4});
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{7, 6, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Additions to Make Valid String");
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/description/
        obj.minAdditionToMakeValidString("b");
        obj.minAdditionToMakeValidString("aaa");
        obj.minAdditionToMakeValidString("abc");
        obj.minAdditionToMakeValidString("aaaabbbc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Sum BST in Binary Tree/ Largest BST Subtree in Binary Tree");
//        //https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/
//        //https://leetcode.com/problems/largest-bst-subtree/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(5));
//        root.getRight().getRight().setLeft(new TreeNode<>(4));
//        root.getRight().getRight().setRight(new TreeNode<>(6));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(2));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(-4);
//        root.setLeft(new TreeNode<>(-2));
//        root.setRight(new TreeNode<>(-5));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(-2);
//        root.setLeft(new TreeNode<>(-6));
//        root.getLeft().setLeft(new TreeNode<>(-7));
//        root.getLeft().setRight(new TreeNode<>(-4));
//        root.setRight(new TreeNode<>(-1));
//        obj.maxSumBSTInBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Differ By One Char");
        //https://leetcode.com/problems/strings-differ-by-one-character/
        //https://leetcode.ca/2020-03-02-1554-Strings-Differ-by-One-Character/
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar1(new String[]{"abcd", "acbd", "aacd"}));
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar1(new String[]{"ab", "cd", "yz"}));
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar1(new String[]{"abcd", "cccc", "abyd", "abab"}));
        System.out.println("Strings differ by one char (approach based onRABIN KARP/ ROLLING HASH): "
                + obj.stringsDifferByOneChar2(new String[]{"abcd", "acbd", "aacd"}));
        System.out.println("Strings differ by one char (approach based onRABIN KARP/ ROLLING HASH): "
                + obj.stringsDifferByOneChar2(new String[]{"ab", "cd", "yz"}));
        System.out.println("Strings differ by one char (approach based onRABIN KARP/ ROLLING HASH): "
                + obj.stringsDifferByOneChar2(new String[]{"abcd", "cccc", "abyd", "abab"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Profitable Schemes");
        //https://leetcode.com/problems/profitable-schemes/description/
        obj.profitableScheme_Recursive_Memoization(5, 3, new int[]{2, 2}, new int[]{2, 3});
        obj.profitableScheme_Recursive_Memoization(10, 5, new int[]{2, 3, 5}, new int[]{6, 7, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Similar String Groups");
        //https://leetcode.com/problems/similar-string-groups/description/
        obj.similarStringGroups_Graph(new String[]{"tars", "rats", "arts", "star"});
        obj.similarStringGroups_Graph(new String[]{"omv", "ovm"});
        obj.similarStringGroups_Graph_UnionFind(new String[]{"tars", "rats", "arts", "star"});
        obj.similarStringGroups_Graph_UnionFind(new String[]{"omv", "ovm"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sum Of Integer Smaller Than Each Value of Array");
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        obj.smallerSumThanEachValueInArray(new int[]{1, 2, 3});
        obj.smallerSumThanEachValueInArray(new int[]{4, 4});
        obj.smallerSumThanEachValueInArray(
                new int[]{0, 7, 7, 9, 0, 0, 5, 1, 0, 6, 6, 5, 8, 9, 9, 9, 1, 2, 4, 3});
        obj.smallerSumThanEachValueInArray_HashMapBased(new int[]{1, 2, 3});
        obj.smallerSumThanEachValueInArray_HashMapBased(new int[]{4, 4});
        obj.smallerSumThanEachValueInArray_HashMapBased(
                new int[]{0, 7, 7, 9, 0, 0, 5, 1, 0, 6, 6, 5, 8, 9, 9, 9, 1, 2, 4, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Restore The Array");
        //https://leetcode.com/problems/restore-the-array/description/
        obj.restoreArray_Recursive_Memoization("1000", 10000);
        obj.restoreArray_Recursive_Memoization("1000", 10);
        obj.restoreArray_Recursive_Memoization("1317", 2000);
        obj.restoreArray_Recursive_Memoization("48486250454844645287030712560644579294181", 989);
        obj.restoreArray_DP_Memoization("1000", 10000);
        obj.restoreArray_DP_Memoization("1000", 10);
        obj.restoreArray_DP_Memoization("1317", 2000);
        obj.restoreArray_DP_Memoization("48486250454844645287030712560644579294181", 989);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Ways To Make K Partiton String Of Length M");
        //https://leetcode.com/discuss/interview-question/2257966/Google-OA
        obj.waysToMakeKPartitionStringOfMLength_Recursive_Memoization("232387421", 3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Graph As Tree Diameter");
        //https://leetcode.com/problems/tree-diameter/
        //https://leetcode.ca/all/1245.html
        obj.graphAsTreeDiameter_Graph(new int[][]{{0, 1}, {0, 2}});
        obj.graphAsTreeDiameter_Graph(new int[][]{{0, 1}, {1, 2}, {2, 3}, {1, 4}, {4, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Nearest smaller tower");
        //https://practice.geeksforgeeks.org/problems/a520c08a8ea9b617be25c38b0fc2fe057e889253/1
        obj.nearestSmallerTower(new int[]{1, 3, 2});
        obj.nearestSmallerTower(new int[]{4, 8, 3, 5, 3});
        obj.nearestSmallerTower(new int[]{1, 2, 3, 2, 1, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Next Greater Element IV");
        //https://leetcode.com/problems/next-greater-element-iv/description/
        obj.nearestGreaterElementFour(new int[]{2, 4, 0, 9, 6});
        obj.nearestGreaterElementFour(new int[]{3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Operations to Reduce X to Zero");
        //https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description/
        obj.minOperationToReduceXToZero(new int[]{1, 1, 4, 2, 3}, 5);
        obj.minOperationToReduceXToZero(new int[]{5, 6, 7, 8, 9}, 4);
        obj.minOperationToReduceXToZero(new int[]{3, 2, 20, 1, 1, 3}, 10);
        obj.minOperationToReduceXToZero(new int[]{1, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path in Weighted undirected graph");
        //https://leetcode.com/problems/design-graph-with-shortest-path-calculator/description/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
        obj.shorestPathInWeightedUndirectedGraph_Graph(5,
                new int[][]{{1, 2, 2}, {2, 5, 5}, {2, 3, 4}, {1, 4, 1}, {4, 3, 3}, {3, 5, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Checking Existence of Edge Length Limited Paths");
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //TLE for normal DFS based approach for larger inputs
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph(3,
                new int[][]{{0, 1, 2}, {1, 2, 4}, {2, 0, 8}, {1, 0, 16}},
                new int[][]{{0, 1, 2}, {0, 2, 5}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph(5,
                new int[][]{{0, 1, 10}, {1, 2, 5}, {2, 3, 9}, {3, 4, 13}},
                new int[][]{{0, 4, 14}, {1, 4, 13}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(3,
                new int[][]{{0, 1, 2}, {1, 2, 4}, {2, 0, 8}, {1, 0, 16}},
                new int[][]{{0, 1, 2}, {0, 2, 5}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(5,
                new int[][]{{0, 1, 10}, {1, 2, 5}, {2, 3, 9}, {3, 4, 13}},
                new int[][]{{0, 4, 14}, {1, 4, 13}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Redundant Connection");
        //https://leetcode.com/problems/redundant-connection/description/
        obj.redundantConnections_Graph(new int[][]{{1, 2}, {1, 3}, {2, 3}});
        obj.redundantConnections_Graph(new int[][]{{1, 2}, {2, 3}, {3, 4}, {1, 4}, {1, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Max Number of Edges to Keep Graph Fully Traversable");
        //https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 1, 2}, {3, 2, 3}, {1, 1, 3}, {1, 2, 4}, {1, 1, 2}, {2, 3, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 1, 2}, {3, 2, 3}, {1, 1, 4}, {2, 1, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 2, 3}, {1, 1, 2}, {2, 3, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(2,
                new int[][]{{1, 1, 2}, {2, 1, 2}, {3, 1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Combination Sum IV (4)");
        //https://leetcode.com/problems/combination-sum-iv/description/
        obj.combinationSumFour_Recursive_Memoization(new int[]{1, 2, 3}, 4);
        obj.combinationSumFour_Recursive_Memoization(new int[]{9}, 3);
        obj.combinationSumFour_Recursive_Memoization(new int[]{1, 2, 3}, 32);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Prefix Common Array of Two Arrays");
        //https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/
        obj.prefixCommonArrayOfTwoArrays(new int[]{1, 3, 2, 4}, new int[]{3, 1, 2, 4});
        obj.prefixCommonArrayOfTwoArrays(new int[]{2, 3, 1}, new int[]{3, 1, 2});
        obj.prefixCommonArrayOfTwoArrays(new int[]{1, 2, 3, 4}, new int[]{1, 2, 3, 4});
        obj.prefixCommonArrayOfTwoArrays(new int[]{4, 3, 2, 1}, new int[]{1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Dota2 Senate");
        //https://leetcode.com/problems/dota2-senate/description/
        obj.dota2Senate_Greedy("RD");
        obj.dota2Senate_Greedy("RDD");
        obj.dota2Senate_Greedy("RRDRD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Detect Cycles in 2D Grid");
        //https://leetcode.com/problems/detect-cycles-in-2d-grid/description/
        obj.detectCycleIn2DGrid_Graph(new char[][]{
                {'a', 'a', 'a', 'a'},
                {'a', 'b', 'b', 'a'},
                {'a', 'b', 'b', 'a'},
                {'a', 'a', 'a', 'a'}});
        obj.detectCycleIn2DGrid_Graph(new char[][]{
                {'c', 'c', 'c', 'a'},
                {'c', 'd', 'c', 'c'},
                {'c', 'c', 'e', 'c'},
                {'f', 'c', 'c', 'c'}});
        obj.detectCycleIn2DGrid_Graph(new char[][]{
                {'a', 'b', 'b'},
                {'b', 'z', 'b'},
                {'b', 'b', 'a'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Subsequences That Satisfy the Given Sum Condition");
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        obj.subseqSatisfyGivenSumCond_1(new int[]{3, 5, 6, 7}, 9);
        obj.subseqSatisfyGivenSumCond_1(new int[]{3, 3, 6, 8}, 10);
        obj.subseqSatisfyGivenSumCond_1(new int[]{2, 3, 3, 4, 6, 7}, 12);
        obj.subseqSatisfyGivenSumCond_2(new int[]{3, 5, 6, 7}, 9);
        obj.subseqSatisfyGivenSumCond_2(new int[]{3, 3, 6, 8}, 10);
        obj.subseqSatisfyGivenSumCond_2(new int[]{2, 3, 3, 4, 6, 7}, 12);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Check if Array Is Sorted and Rotated");
        //https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{3, 4, 5, 1, 2}));
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{2, 1, 3, 4}));
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{1, 2, 3}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Longest Valid Obstacle Course at Each Position");
        //https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description/
        obj.longestValidObstacleCourseAtEachPosition(new int[]{1, 2, 3, 2});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{2, 2, 1});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{3, 1, 5, 6, 4, 2});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{5, 1, 5, 5, 1, 3, 4, 5, 1, 4});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{5, 2, 5, 4, 1, 1, 1, 5, 3, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Reach a Position After Exactly k Steps");
        //https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(1, 2, 3);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(2, 5, 10);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(989, 1000, 99);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(1, 1000, 1000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Stay in the Same Place After Some Steps");
        //https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/
        obj.waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization(3, 2);
        obj.waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization(2, 4);
        obj.waysToStayInSamePlaceAfterSomeSteps_Recursive_Memoization(4, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Mirror");
        //https://practice.geeksforgeeks.org/problems/d385b9d635b7b10eef6bf365b84922aaeec9eb98/1
        obj.stringMirror("bvdfndkn");
        obj.stringMirror("casd");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Making A Large Island");
        //https://leetcode.com/problems/making-a-large-island/description/
        System.out.println("Making a large island : " + obj.makingALargeIsland_Graph(new int[][]{{1}}));
        System.out.println("Making a large island : " + obj.makingALargeIsland_Graph(new int[][]{{0}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
                {1, 0},
                {0, 1}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
                {1, 1},
                {1, 0}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
                {1, 1},
                {1, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Amount of Time to Fill Cups");
        //https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/description/
        obj.minTimeToFillCups_Greedy(new int[]{1, 4, 2});
        obj.minTimeToFillCups_Greedy(new int[]{5, 4, 4});
        obj.minTimeToFillCups_Greedy(new int[]{5, 0, 0});
        obj.minTimeToFillCups_Greedy(new int[]{0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Validate Binary Tree Nodes");
        //https://leetcode.com/problems/validate-binary-tree-nodes/description/
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(4, new int[]{1, -1, 3, -1}, new int[]{2, -1, -1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(4, new int[]{1, -1, 3, -1}, new int[]{2, 3, -1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(2, new int[]{1, 0}, new int[]{-1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(3, new int[]{1, -1, -1}, new int[]{-1, -1, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Elements to Add to Form a Given Sum");
        //https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/description/
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{1, -1, 1}, 3, -4);
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{1, -10, 9, 1}, 100, 0);
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{-10, 10}, 20, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Parsing A Boolean Expression");
        //https://leetcode.com/problems/parsing-a-boolean-expression/description/
        obj.parsingBooleanExpression("&(|(f))");
        obj.parsingBooleanExpression("|(f,f,f,t)");
        obj.parsingBooleanExpression("!(&(f,t))");
        obj.parsingBooleanExpression("!(t)");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Solving Questions With Brainpower");
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        obj.solvingQuestionsWithBrainPower_Recursive_Memoization(
                new int[][]{{3, 2}, {4, 3}, {4, 4}, {2, 5}});
        obj.solvingQuestionsWithBrainPower_Recursive_Memoization(
                new int[][]{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}});
        obj.solvingQuestionsWithBrainPower_DP_Memoization(
                new int[][]{{3, 2}, {4, 3}, {4, 4}, {2, 5}});
        obj.solvingQuestionsWithBrainPower_DP_Memoization(
                new int[][]{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Binary Subarrays With Sum");
        //https://leetcode.com/problems/binary-subarrays-with-sum/description/
        obj.binarySubarraySumEqualToGoal(new int[]{1, 0, 1, 0, 1}, 2);
        obj.binarySubarraySumEqualToGoal(new int[]{0, 0, 0, 0, 0}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Ways To Build Good Strings");
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        obj.countWaysToBuildGoodStrings_Recursive_Memoization(3, 3, 1, 1);
        obj.countWaysToBuildGoodStrings_Recursive_Memoization(2, 3, 1, 2);
        obj.countWaysToBuildGoodStrings_DP_Memoization(3, 3, 1, 1);
        obj.countWaysToBuildGoodStrings_DP_Memoization(2, 3, 1, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sort Integers by The Power Value");
        //https://leetcode.com/problems/sort-integers-by-the-power-value/description/
        obj.sortIntegersByPowerValue_Recursive_Memoization(12, 15, 2);
        obj.sortIntegersByPowerValue_Recursive_Memoization(7, 11, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Score of an Array After Marking All Elements");
        //https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/
        obj.scoreForArrayAfterMarkingAllElements_Greedy(new int[]{2, 1, 3, 4, 5, 2});
        obj.scoreForArrayAfterMarkingAllElements_Greedy(new int[]{2, 3, 5, 1, 3, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize Score After N Operations");
//        //https://leetcode.com/problems/maximize-score-after-n-operations/description/
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{1, 2});
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{3, 4, 6, 8});
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Add Minimum Number of Rungs");
        //https://leetcode.com/problems/add-minimum-number-of-rungs/description/
        obj.addMinNumberOfRungs_Greedy(new int[]{1, 3, 5, 10}, 2);
        obj.addMinNumberOfRungs_Greedy(new int[]{3, 6, 8, 10}, 3);
        obj.addMinNumberOfRungs_Greedy(new int[]{3, 4, 6, 7}, 2);
        obj.addMinNumberOfRungs_Greedy(new int[]{2, 1000000000}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Nesting Depth of the Parentheses");
        //https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/
        obj.maxNestedDepthOfParenthesis("(1+(2*3)+((8)/4))+1");
        obj.maxNestedDepthOfParenthesis("(1)+((2))+(((3)))");
        obj.maxNestedDepthOfParenthesis("(((())))");
        obj.maxNestedDepthOfParenthesis("()()()()");
        System.out.println("Maximum Nesting Depth of Two Valid Parentheses Strings");
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/
        obj.maxNestedDepthOfTwoValidParenthesisString("(()())");
        obj.maxNestedDepthOfTwoValidParenthesisString("()(())()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Execution of All Suffix Instructions Staying in a Grid");
        //https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/description/
        obj.executionOfAllInstructionsStayingInGrid(3, new int[]{0, 1}, "RRDDLU");
        obj.executionOfAllInstructionsStayingInGrid(2, new int[]{1, 1}, "LURD");
        obj.executionOfAllInstructionsStayingInGrid(1, new int[]{0, 0}, "LRUD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximal Network Rank");
        //https://leetcode.com/problems/maximal-network-rank/description/
        obj.maximalNetworkRank_Graph(4, new int[][]{{0, 1}, {0, 3}, {1, 2}, {1, 3}});
        obj.maximalNetworkRank_Graph(5, new int[][]{{0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 3}, {2, 4}});
        obj.maximalNetworkRank_Graph(8, new int[][]{{0, 1}, {1, 2}, {2, 3}, {2, 4}, {5, 6}, {5, 7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Evaluate Division");
        //https://leetcode.com/problems/evaluate-division/description/
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}, {"b", "c"}},
                new double[]{2.0, 3.0},
                new String[][]{{"a", "c"}, {"b", "a"}, {"a", "e"}, {"a", "a"}, {"x", "x"}});
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}, {"b", "c"}, {"bc", "cd"}},
                new double[]{1.5, 2.5, 5.0},
                new String[][]{{"a", "c"}, {"c", "b"}, {"bc", "cd"}, {"cd", "bc"}});
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}},
                new double[]{0.5},
                new String[][]{{"a", "b"}, {"b", "a"}, {"a", "c"}, {"x", "y"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Paths in Matrix Whose Sum Is Divisible by K");
        //https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{5, 2, 4}, {3, 0, 5}, {0, 7, 2}}, 3);
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{0, 0}}, 5);
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{7, 3, 4, 9}, {2, 3, 6, 2}, {2, 3, 7, 0}}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Earn Points");
        //https://leetcode.com/problems/number-of-ways-to-earn-points/description/
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{6, 1}, {3, 2}, {2, 3}}, 6);
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{50, 1}, {50, 2}, {50, 5}}, 5);
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{6, 1}, {3, 2}, {2, 3}}, 18);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the City With the Smallest Number of Neighbors at a Threshold Distance");
        //https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/
        obj.cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(
                4, new int[][]{{0, 1, 3}, {1, 2, 1}, {1, 3, 4}, {2, 3, 1}}, 4);
        obj.cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(
                5, new int[][]{{0, 1, 2}, {0, 4, 8}, {1, 2, 3}, {1, 4, 2}, {2, 3, 1}, {3, 4, 1}}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Performance of a Team");
        //https://leetcode.com/problems/maximum-performance-of-a-team/
        obj.maxPerformanceOfTeam_Greedy(6, 2, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
        obj.maxPerformanceOfTeam_Greedy(6, 3, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
        obj.maxPerformanceOfTeam_Greedy2(6, 2, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
        obj.maxPerformanceOfTeam_Greedy2(6, 3, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Subsequence Score");
        //https://leetcode.com/problems/maximum-subsequence-score/description/
        obj.maxSubsequenceScore_Greedy(new int[]{1, 3, 3, 2}, new int[]{2, 1, 3, 4}, 3);
        obj.maxSubsequenceScore_Greedy(new int[]{4, 2, 3, 1, 1}, new int[]{7, 5, 10, 9, 6}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Turbulent Subarray");
        //https://leetcode.com/problems/longest-turbulent-subarray/description/
        obj.longestTurbulentSubarray(new int[]{9, 4, 2, 10, 7, 8, 8, 1, 9});
        obj.longestTurbulentSubarray(new int[]{4, 8, 12, 16});
        obj.longestTurbulentSubarray(new int[]{100});
        obj.longestTurbulentSubarray(new int[]{9, 9});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Most Profit Assigning Work");
        //https://leetcode.com/problems/most-profit-assigning-work/description/
        obj.mostProfitAssigningWork(
                new int[]{2, 4, 6, 8, 10}, new int[]{10, 20, 30, 40, 50}, new int[]{4, 5, 6, 7});
        obj.mostProfitAssigningWork(
                new int[]{85, 47, 57}, new int[]{24, 66, 99}, new int[]{40, 25, 25});
        obj.mostProfitAssigningWork(
                new int[]{68, 35, 52, 47, 86}, new int[]{67, 17, 1, 81, 3}, new int[]{92, 10, 85, 84, 82});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Stone Game II");
        //https://leetcode.com/problems/stone-game-ii/description/
        obj.stoneGameTwo_Recursive_Memoization(new int[]{2, 7, 9, 4, 4});
        obj.stoneGameTwo_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 100});
        System.out.println("Stone Game III");
        //https://leetcode.com/problems/stone-game-iii/description/
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, 7});
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, -9});
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, 6});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, 7});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, -9});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Predict the Winner");
        //https://leetcode.com/problems/predict-the-winner/description/
        obj.predictTheWinner_Recursive_Memoization(new int[]{1, 5, 2});
        obj.predictTheWinner_Recursive_Memoization(new int[]{1, 5, 233, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Subarrays With Equal Sum");
        //https://leetcode.com/problems/find-subarrays-with-equal-sum/description/
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{4, 2, 4}));
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{1, 2, 3, 4, 5}));
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{0, 0, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Cost to Cut a Stick");
        //https://leetcode.com/problems/minimum-cost-to-cut-a-stick/description/
        obj.minCostToCutStick_Recursive_Memoization(7, new int[]{1, 3, 4, 5});
        obj.minCostToCutStick_Recursive_Memoization(9, new int[]{5, 6, 1, 4, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Replace Words");
        //https://leetcode.com/problems/replace-words/description/
        obj.replaceWords(Arrays.asList("cat", "bat", "rat"), "the cattle was rattled by the battery");
        obj.replaceWords(Arrays.asList("a", "b", "c"), "aadsfasf absbs bbab cadsfafs");
        obj.replaceWords(Arrays.asList("catt", "cat", "bat", "rat"), "the cattle was rattled by the battery");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sentence Screen Fitting");
        //https://leetcode.com/problems/sentence-screen-fitting/
        obj.sentenceScreenFitting(new String[]{"hello", "world"}, 2, 8);
        obj.sentenceScreenFitting(new String[]{"a", "bcd", "e"}, 3, 6);
        obj.sentenceScreenFitting(new String[]{"i", "had", "apple", "pie"}, 4, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Good Meals");
        //https://leetcode.com/problems/count-good-meals/description/
        obj.countGoodMeals(new int[]{1, 3, 5, 7, 9});
        obj.countGoodMeals(new int[]{1, 1, 1, 3, 3, 3, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Split of Positive Even Integers");
        //https://leetcode.com/problems/maximum-split-of-positive-even-integers/description/
        obj.maxSplitOfPositiveEvenIntegers_Greedy(12);
        obj.maxSplitOfPositiveEvenIntegers_Greedy(7);
        obj.maxSplitOfPositiveEvenIntegers_Greedy(28);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Odd Even Jump");
        //https://leetcode.com/problems/odd-even-jump/description/
        obj.oddEvenJumps(new int[]{10, 13, 12, 14, 15});
        obj.oddEvenJumps(new int[]{2, 3, 1, 1, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Area Rectangle");
        //https://leetcode.com/problems/minimum-area-rectangle/description/
        obj.minAreaRectangle(new int[][]{{1, 1}, {1, 3}, {3, 1}, {3, 3}, {2, 2}});
        obj.minAreaRectangle(new int[][]{{1, 1}, {1, 3}, {3, 1}, {3, 3}, {4, 1}, {4, 3}});
        obj.minAreaRectangle(new int[][]{{1, 1}, {3, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Value of Equation");
        //https://leetcode.com/problems/max-value-of-equation/description/
        obj.maxValueOfEquation(new int[][]{{1, 3}, {2, 0}, {5, 10}, {6, -10}}, 1);
        obj.maxValueOfEquation(new int[][]{{0, 0}, {3, 0}, {9, 2}}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Adding Spaces to a String");
        //https://leetcode.com/problems/adding-spaces-to-a-string/description/
        obj.addingSpacesToString("LeetcodeHelpsMeLearn", new int[]{8, 13, 15});
        obj.addingSpacesToString("icodeinpython", new int[]{1, 5, 7, 9});
        obj.addingSpacesToString("spacing", new int[]{0, 1, 2, 3, 4, 5, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Distribute Repeating Integers");
        //https://leetcode.com/problems/distribute-repeating-integers/description/
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 2, 3, 4}, new int[]{2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 2, 3, 3}, new int[]{2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 1, 2, 2}, new int[]{2, 2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 1, 1, 1, 1}, new int[]{2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Operations to Make a Subsequence");
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/description/
        obj.minOperationsToMakeASubseq(new int[]{5, 1, 3}, new int[]{9, 4, 2, 3, 4});
        obj.minOperationsToMakeASubseq(new int[]{6, 4, 8, 1, 3, 2}, new int[]{4, 7, 6, 2, 3, 8, 6, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("One Edit Distance");
        //https://leetcode.com/problems/one-edit-distance/description/
        System.out.println("One edit distance : " + obj.isOneEditDistance("ab", "acb"));
        System.out.println("One edit distance : " + obj.isOneEditDistance("", ""));
        System.out.println("One edit distance : " + obj.isOneEditDistance("abcd", "abc"));
        System.out.println("One edit distance : " + obj.isOneEditDistance("aca", "caca"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Words Within Two Edits of Dictionary");
        //https://leetcode.com/problems/words-within-two-edits-of-dictionary/description/
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"word", "note", "ants", "wood"},
                new String[]{"wood", "joke", "moat"});
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"yes"},
                new String[]{"not"});
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"tsl", "sri", "yyy", "rbc", "dda", "qus", "hyb", "ilu", "ahd"},
                new String[]{"uyj", "bug", "dba", "xbe", "blu", "wuo", "tsf", "tga"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("First Completely Painted Row or Column");
        //https://leetcode.com/problems/first-completely-painted-row-or-column/description/
        System.out.println("First index where row or col completely painted : "
                + obj.firstCompletelyPaintedRowOrCol(
                new int[]{1, 3, 4, 2}, new int[][]{{1, 4}, {2, 3}}));
        System.out.println("First index where row or col completely painted : "
                + obj.firstCompletelyPaintedRowOrCol(
                new int[]{2, 8, 7, 4, 1, 3, 5, 6, 9}, new int[][]{{3, 2, 5}, {1, 4, 6}, {8, 7, 9}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Divisibility Array of a String");
        //https://leetcode.com/problems/find-the-divisibility-array-of-a-string/description/
        obj.findDivisibiltyArrayOfString("998244353", 3);
        obj.findDivisibiltyArrayOfString("1010", 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Negative Numbers in a Sorted Matrix");
        //https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/
        //https://leetcode.com/problems/find-smallest-letter-greater-than-target/description/
        obj.countNegativesInSortedMatrix(
                new int[][]{{4, 3, 2, -1}, {3, 2, 1, -1}, {1, 1, -1, -2}, {-1, -1, -2, -3}});
        obj.countNegativesInSortedMatrix(
                new int[][]{{3, 2}, {1, 0}});
        obj.countNegativesInSortedMatrix(
                new int[][]{{3, -1, -3, -3, -3}, {2, -2, -3, -3, -3}, {1, -2, -3, -3, -3}, {0, -3, -3, -3, -3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Build an Array With Stack Operations");
        //https://leetcode.com/problems/build-an-array-with-stack-operations/description/
        obj.buildArrayWithStackOperations(new int[]{1, 3}, 3);
        obj.buildArrayWithStackOperations(new int[]{1, 2, 3}, 3);
        obj.buildArrayWithStackOperations(new int[]{1, 2}, 4);
        obj.buildArrayWithStackOperations(new int[]{1, 3, 7, 9}, 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Rearrange Array to Maximize Prefix Score");
        //https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/description/
        obj.rearrangeArrayToMaxPrefixScore_Greedy(new int[]{2, -1, 0, 1, -3, 3, -3});
        obj.rearrangeArrayToMaxPrefixScore_Greedy(new int[]{-2, -3, 0});
        obj.rearrangeArrayToMaxPrefixScore_Greedy(new int[]{2, 1, 0, 1, 3, 3, 3});
        obj.rearrangeArrayToMaxPrefixScore_Greedy(new int[]{-2, -1, -1, -3, -3, -3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest Number After Mutating Substring");
        //https://leetcode.com/problems/largest-number-after-mutating-substring/description/
        System.out.println("Largest number after mutating string : "
                + obj.largestNumberAfterMutatingSubstring_Greedy(
                "132", new int[]{9, 8, 5, 0, 3, 6, 4, 2, 6, 8}));
        System.out.println("Largest number after mutating string : "
                + obj.largestNumberAfterMutatingSubstring_Greedy(
                "021", new int[]{9, 4, 3, 5, 7, 2, 1, 9, 0, 6}));
        System.out.println("Largest number after mutating string : "
                + obj.largestNumberAfterMutatingSubstring_Greedy(
                "5", new int[]{1, 4, 7, 5, 3, 2, 5, 6, 9, 4}));
        System.out.println("Largest number after mutating string : "
                + obj.largestNumberAfterMutatingSubstring_Greedy(
                "334111", new int[]{0, 9, 2, 3, 3, 2, 5, 5, 5, 5}));
        System.out.println("Largest number after mutating string : "
                + obj.largestNumberAfterMutatingSubstring_Greedy(
                "214010", new int[]{6, 7, 9, 7, 4, 0, 3, 4, 4, 7}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Value at a Given Index in a Bounded Array");
        //https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/
        obj.maxValueAtGivenIndexInBoundedArray(4, 2, 6);
        obj.maxValueAtGivenIndexInBoundedArray(6, 1, 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Length of a Concatenated String with Unique Characters");
        //https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/description/
        obj.maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(
                new String[]{"un", "iq", "ue"});
        obj.maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(
                new String[]{"cha", "r", "act", "ers"});
        obj.maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(
                new String[]{"abcdefghijklmnopqrstuvwxyz"});
        obj.maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(
                new String[]{"aa", "bb"});
        obj.maxLenOfConcatenatedStringWithUniqueChars_Recursive_Memoization(
                new String[]{"pxa", "ghxqdobesypaz", "rismkaxhlc", "eyxq"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Score Words Formed by Letters");
        //https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/
        obj.maxScoreOfWordFormedByLetters_Recursive_Memoization(
                new String[]{"dog", "cat", "dad", "good"},
                new char[]{'a', 'a', 'c', 'd', 'd', 'd', 'g', 'o', 'o'},
                new int[]{1, 0, 9, 5, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0});
        obj.maxScoreOfWordFormedByLetters_Recursive_Memoization(
                new String[]{"xxxz", "ax", "bx", "cx"},
                new char[]{'z', 'a', 'b', 'c', 'x', 'x', 'x'},
                new int[]{4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 10});
        obj.maxScoreOfWordFormedByLetters_Recursive_Memoization(
                new String[]{"leetcode"},
                new char[]{'l', 'e', 't', 'c', 'o', 'd'},
                new int[]{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Summary Ranges");
        //https://leetcode.com/problems/summary-ranges/description/
        obj.summaryRanges(new int[]{});
        obj.summaryRanges(new int[]{0, 1, 2, 4, 5, 7});
        obj.summaryRanges(new int[]{0, 2, 3, 4, 6, 8, 9});
        obj.summaryRanges(new int[]{0, 1, 2, 3, 4, 5, 6, 7});
        obj.summaryRanges(new int[]{0, 2, 4, 7, 10, 13, 17, 21});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Numbers with Unique Digits");
        //https://leetcode.com/problems/count-numbers-with-unique-digits/description/
        System.out.println("Count number of unique numbers : " + obj.countNumberOfUniqueNumbers(2));
        System.out.println("Count number of unique numbers : " + obj.countNumberOfUniqueNumbers(0));
        System.out.println("Count number of unique numbers : " + obj.countNumberOfUniqueNumbers(8));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Water and Jug Problem");
        //https://leetcode.com/problems/water-and-jug-problem/description/
        System.out.println("Water and jug problem : " + obj.waterAndJug_Graph(3, 5, 4));
        System.out.println("Water and jug problem : " + obj.waterAndJug_Graph(2, 6, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Build a Matrix With Conditions");
        //https://leetcode.com/problems/build-a-matrix-with-conditions/description/
        obj.buildMatrixWithConditions_Graph(3, new int[][]{{1, 2}, {3, 2}}, new int[][]{{2, 1}, {3, 2}});
        //cycle in rowCondition[] as 1->2->3->1
        obj.buildMatrixWithConditions_Graph(3, new int[][]{{1, 2}, {2, 3}, {3, 1}, {2, 3}}, new int[][]{{2, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Reorder Array to Get Same BST");
        //https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/
        obj.numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization(new int[]{2, 1, 3});
        obj.numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization(new int[]{3, 4, 5, 1, 2});
        obj.numberOfWaysToReorderArrayToGetSameBST_Recursive_Memoization(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Strictly Greater Value Than Pivot");
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 0);
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 1);
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 2);
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 3);
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 4);
        obj.findAStrictlyGreaterValueThanPivot(new int[]{1, 3, 2, 4}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Make Array Strictly Increasing");
        //https://leetcode.com/problems/make-array-strictly-increasing/description/
        obj.makeArrayStrictlyIncreasing_Recursive_Memoization(new int[]{1, 5, 3, 6, 7}, new int[]{1, 3, 2, 4});
        obj.makeArrayStrictlyIncreasing_Recursive_Memoization(new int[]{1, 5, 3, 6, 7}, new int[]{4, 3, 1});
        obj.makeArrayStrictlyIncreasing_Recursive_Memoization(new int[]{1, 5, 3, 6, 7}, new int[]{1, 6, 3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Ticket Counter");
        //https://practice.geeksforgeeks.org/problems/ticket-counter-2731/1
        System.out.println("Ticket counter - last person to dequed from queue : "
                + obj.ticketCounter_Greedy(9, 3));
        System.out.println("Ticket counter - last person to dequed from queue : "
                + obj.ticketCounter_Greedy(5, 1));
        System.out.println("Ticket counter - last person to dequed from queue : "
                + obj.ticketCounter_Greedy(5, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Painting the Walls");
        //https://leetcode.com/problems/painting-the-walls/
        obj.paintingTheWalls_Recursive_Memoization(new int[]{1, 2, 3, 2}, new int[]{1, 2, 3, 2});
        obj.paintingTheWalls_Recursive_Memoization(new int[]{2, 3, 4, 2}, new int[]{1, 1, 1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Product of Word Lengths");
//        //https://leetcode.com/problems/maximum-product-of-word-lengths/description/
//        obj.maxProdOfWordlength(new String[]{"abcw", "baz", "foo", "bar", "xtfn", "abcdef"});
//        obj.maxProdOfWordlength(new String[]{"a", "ab", "abc", "d", "cd", "bcd", "abcd"});
//        obj.maxProdOfWordlength(new String[]{"a", "aa", "aaa", "aaaa"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find K-Length Substrings With No Repeated Characters");
        //https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/description/
        //https://leetcode.ca/all/1100.html
        obj.kLengthedSubstringsWithUniqueChars("havefunonleetcode", 5);
        obj.kLengthedSubstringsWithUniqueChars("home", 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Cost to Make Array Equal");
        //https://leetcode.com/problems/minimum-cost-to-make-array-equal/description/
        obj.minCostToMakeArrayEqual_Greedy(new int[]{1, 3, 5, 2}, new int[]{2, 3, 1, 14});
        obj.minCostToMakeArrayEqual_Greedy(new int[]{2, 2, 2, 2, 2}, new int[]{4, 2, 8, 1, 3});
        obj.minCostToMakeArrayEqual_Greedy(
                new int[]{735103, 366367, 132236, 133334, 808160, 113001, 49051, 735598,
                        686615, 665317, 999793, 426087, 587000, 649989, 509946, 743518},
                new int[]{724182, 447415, 723725, 902336, 600863, 287644, 13836, 665183,
                        448859, 917248, 397790, 898215, 790754, 320604, 468575, 825614});
        obj.minCostToMakeArrayEqual(new int[]{1, 3, 5, 2}, new int[]{2, 3, 1, 14});
        obj.minCostToMakeArrayEqual(new int[]{2, 2, 2, 2, 2}, new int[]{4, 2, 8, 1, 3});
        obj.minCostToMakeArrayEqual(
                new int[]{735103, 366367, 132236, 133334, 808160, 113001, 49051, 735598,
                        686615, 665317, 999793, 426087, 587000, 649989, 509946, 743518},
                new int[]{724182, 447415, 723725, 902336, 600863, 287644, 13836, 665183,
                        448859, 917248, 397790, 898215, 790754, 320604, 468575, 825614});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Arithmetic Subsequence");
        //https://leetcode.com/problems/longest-arithmetic-subsequence/description/
        obj.longestArithemticSubsequence(new int[]{3, 6, 9, 12});
        obj.longestArithemticSubsequence(new int[]{9, 4, 7, 2, 10});
        obj.longestArithemticSubsequence(new int[]{20, 1, 15, 3, 10, 5, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Fruits Harvested After at Most K Steps");
        //https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/description/
        obj.maxFruitsHarvestedAfterAtMostKSteps(new int[][]{{2, 8}, {6, 3}, {8, 6}}, 5, 4);
        obj.maxFruitsHarvestedAfterAtMostKSteps(new int[][]{{0, 9}, {4, 1}, {5, 7}, {6, 2}, {7, 4}, {10, 9}}, 5, 4);
        obj.maxFruitsHarvestedAfterAtMostKSteps(new int[][]{{0, 3}, {6, 4}, {8, 5}}, 3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Tallest Billboard");
//        //https://leetcode.com/problems/tallest-billboard/description/
//        //for larger inputs, this version of recurions will give TLE and it can't memoized
//        //obj.tallestBillboard_Recursive(new int[]{1,2,3,6});
//        //obj.tallestBillboard_Recursive(new int[]{1,2,3,4,5,6});
//        //obj.tallestBillboard_Recursive(new int[]{1,2});
//        //this version of recurive memoization is optimised but still memo[][] takes 10000 size
//        //obj.tallestBillboard_Recursive_Memoization(new int[]{1,2,3,6});
//        //obj.tallestBillboard_Recursive_Memoization(new int[]{1,2,3,4,5,6});
//        //obj.tallestBillboard_Recursive_Memoization(new int[]{1,2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Cost to Reach Destination in Time");
        //https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/description/
        System.out.println("Min cost to reach dest in time : "
                + obj.minCostToReachDestinationInTime_Graph(
                new int[][]{{0, 1, 10}, {1, 2, 10}, {2, 5, 10}, {0, 3, 1}, {3, 4, 10}, {4, 5, 15}},
                30,
                new int[]{5, 1, 2, 20, 20, 3}));
        System.out.println("Min cost to reach dest in time : "
                + obj.minCostToReachDestinationInTime_Graph(
                new int[][]{{0, 1, 10}, {1, 2, 10}, {2, 5, 10}, {0, 3, 1}, {3, 4, 10}, {4, 5, 15}},
                29,
                new int[]{5, 1, 2, 20, 20, 3}));
        System.out.println("Min cost to reach dest in time : "
                + obj.minCostToReachDestinationInTime_Graph(
                new int[][]{{0, 1, 10}, {1, 2, 10}, {2, 5, 10}, {0, 3, 1}, {3, 4, 10}, {4, 5, 15}},
                25,
                new int[]{5, 1, 2, 20, 20, 3}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count All Possible Routes");
        //https://leetcode.com/problems/count-all-possible-routes/description/
        obj.countAllPossibleRoutes_Recursive_Memoization(new int[]{2, 3, 6, 8, 4}, 1, 3, 5);
        obj.countAllPossibleRoutes_Recursive_Memoization(new int[]{4, 3, 1}, 1, 0, 6);
        obj.countAllPossibleRoutes_Recursive_Memoization(new int[]{5, 2, 1}, 0, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Total Cost to Hire K Workers");
        //https://leetcode.com/problems/total-cost-to-hire-k-workers/description/
        obj.totalCostToHireKWorkers(new int[]{17, 12, 10, 2, 7, 2, 11, 20, 8}, 3, 4);
        obj.totalCostToHireKWorkers(new int[]{1, 2, 4, 1}, 3, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Hills and Valleys in an Array");
        //https://leetcode.com/problems/count-hills-and-valleys-in-an-array/description/
        obj.countHillsAndValleysInArray(new int[]{2, 4, 1, 1, 6, 5});
        obj.countHillsAndValleysInArray(new int[]{6, 6, 5, 5, 4, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Path with Maximum Probability");
        //https://leetcode.com/problems/path-with-maximum-probability/description/
        System.out.println("Path with max probability : "
                + obj.pathWithMaxProbability_Graph(3,
                new int[][]{{0, 1}, {1, 2}, {0, 2}}, new double[]{0.5, 0.5, 0.2},
                0, 2));
        System.out.println("Path with max probability : "
                + obj.pathWithMaxProbability_Graph(3,
                new int[][]{{0, 1}, {1, 2}, {0, 2}}, new double[]{0.5, 0.5, 0.3},
                0, 2));
        System.out.println("Path with max probability : "
                + obj.pathWithMaxProbability_Graph(3,
                new int[][]{{0, 1}}, new double[]{0.5},
                0, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find All the Lonely Nodes");
//        //https://leetcode.com/problems/find-all-the-lonely-nodes/
//        //https://leetcode.ca/all/1469.html
//        TreeNode<Integer> root = new TreeNode<>(5);
//        obj.findAllLonelyNodesInBinaryTree(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(3));
//        obj.findAllLonelyNodesInBinaryTree(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(6));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(5));
//        root.getRight().getRight().setRight(new TreeNode<>(7));
//        obj.findAllLonelyNodesInBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path to Get All Keys");
        //https://leetcode.com/problems/shortest-path-to-get-all-keys/description/
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@.a..", "###.#", "b.A.B"});
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@..aA", "..B#.", "....b"});
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@Aa"});
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@fedcbBCDEFaA"});
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@...a", ".###A", "b.BCc"});
        obj.shortestPathToGetAllKeys_Graph(new String[]{"@...a", "###.#", "b.A.B"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Last Day Where You Can Still Cross");
        //https://leetcode.com/problems/last-day-where-you-can-still-cross/description/
        obj.lastDayWhereYouCanStillCross_Graph(2, 2, new int[][]{{1, 1}, {2, 1}, {1, 2}, {2, 2}});
        obj.lastDayWhereYouCanStillCross_Graph(2, 2, new int[][]{{1, 1}, {1, 2}, {2, 1}, {2, 2}});
        obj.lastDayWhereYouCanStillCross_Graph(3, 4,
                new int[][]{{1, 2}, {2, 1}, {3, 3}, {2, 2}, {1, 1}, {1, 3}, {2, 3}, {3, 2}, {3, 1}});
        System.out.println("Last day where you can still cross : "
                + obj.lastDayWhereYouCanStillCross_Graph_UnionFind(2, 2, new int[][]{{1, 1}, {2, 1}, {1, 2}, {2, 2}}));
        System.out.println("Last day where you can still cross : "
                + obj.lastDayWhereYouCanStillCross_Graph_UnionFind(2, 2, new int[][]{{1, 1}, {1, 2}, {2, 1}, {2, 2}}));
        System.out.println("Last day where you can still cross : "
                + obj.lastDayWhereYouCanStillCross_Graph_UnionFind(3, 4,
                new int[][]{{1, 2}, {2, 1}, {3, 3}, {2, 2}, {1, 1}, {1, 3}, {2, 3}, {3, 2}, {3, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Number of Achievable Transfer Requests");
        //https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/description/
        obj.maxNumberOfAchievableTransferRequest_Backtracking(5,
                new int[][]{{0, 1}, {1, 0}, {0, 1}, {1, 2}, {2, 0}, {3, 4}});
        obj.maxNumberOfAchievableTransferRequest_Backtracking(3,
                new int[][]{{0, 0}, {1, 2}, {2, 1}});
        obj.maxNumberOfAchievableTransferRequest_Backtracking(4,
                new int[][]{{0, 3}, {3, 1}, {1, 2}, {2, 0}});
        obj.maxNumberOfAchievableTransferRequest_Backtracking(4,
                new int[][]{{1, 2}, {1, 2}, {2, 2}, {0, 2}, {2, 1}, {1, 1}, {1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Even Odd Subarray With Threshold");
        //https://leetcode.com/contest/weekly-contest-352/problems/longest-even-odd-subarray-with-threshold/
        obj.longestEvenOddSubarrayWithThreshold(new int[]{1}, 1);
        obj.longestEvenOddSubarrayWithThreshold(new int[]{4}, 1);
        obj.longestEvenOddSubarrayWithThreshold(new int[]{3, 5, 7, 2}, 4);
        obj.longestEvenOddSubarrayWithThreshold(new int[]{2, 3, 4, 5, 6, 7, 8}, 8);
        obj.longestEvenOddSubarrayWithThreshold(new int[]{3, 2, 5, 4}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Make Number of Distinct Characters Equal");
        //https://leetcode.com/problems/make-number-of-distinct-characters-equal/description/
        System.out.println("Make number of distinct chars equal : "
                + obj.makeNumberOfDistinctCharsEqual("ac", "b"));
        System.out.println("Make number of distinct chars equal : "
                + obj.makeNumberOfDistinctCharsEqual("abcc", "aab"));
        System.out.println("Make number of distinct chars equal : "
                + obj.makeNumberOfDistinctCharsEqual("abcde", "fghij"));
        System.out.println("Make number of distinct chars equal : "
                + obj.makeNumberOfDistinctCharsEqual("aa", "ab"));
        System.out.println("Make number of distinct chars equal : "
                + obj.makeNumberOfDistinctCharsEqual("a", "bb"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Substring With Maximum Cost");
        //https://leetcode.com/problems/find-the-substring-with-maximum-cost/description/
        //TLE on larger input values
        //obj.findSubstringWithMaxCost_Recursive_Memoization("adaa", "d", new int[]{-1000});
        //obj.findSubstringWithMaxCost_Recursive_Memoization("abc", "abc", new int[]{-1, -1, -1});
        //obj.findSubstringWithMaxCost_Recursive_Memoization("yzy", "rzay", new int[]{0, -4, 3, -3});
        obj.findSubstringWithMaxCost_DP_Memoization("adaa", "d", new int[]{-1000});
        obj.findSubstringWithMaxCost_DP_Memoization("abc", "abc", new int[]{-1, -1, -1});
        obj.findSubstringWithMaxCost_DP_Memoization("yzy", "rzay", new int[]{0, -4, 3, -3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Path with Maximum Gold");
        //https://leetcode.com/problems/path-with-maximum-gold/description/
        obj.pathWithMaxGold_Backtracking(new int[][]{{0, 6, 0}, {5, 8, 7}, {0, 9, 0}});
        obj.pathWithMaxGold_Backtracking(new int[][]{{1, 0, 7}, {2, 0, 6}, {3, 4, 5}, {0, 3, 0}, {9, 0, 20}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Put Marbles in Bags");
        //https://leetcode.com/problems/put-marbles-in-bags/description/
        obj.putMarblesInBag_Greedy(new int[]{1, 3, 5, 1}, 2);
        obj.putMarblesInBag_Greedy(new int[]{1, 3}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Substring With Largest Variance");
        //https://leetcode.com/problems/substring-with-largest-variance/description/
        //will give TLE on larger inputs while calculating its variance
        //obj.substringWithLargestVariance_Recursive_Memoization("aababbb");
        //obj.substringWithLargestVariance_Recursive_Memoization("abcde");
        //obj.substringWithLargestVariance_Recursive_Memoization("aaaaa");
        obj.substringWithLargestVariance_DP_Memoization("aababbb");
        obj.substringWithLargestVariance_DP_Memoization("abcde");
        obj.substringWithLargestVariance_DP_Memoization("aaaaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Loud and Rich");
        //https://leetcode.com/problems/loud-and-rich/description/
        obj.loudAndRich_Graph(
                new int[][]{{1, 0}, {2, 1}, {3, 1}, {3, 7}, {4, 3}, {5, 3}, {6, 3}},
                new int[]{3, 2, 5, 4, 6, 1, 7, 0});
        obj.loudAndRich_Graph(new int[][]{}, new int[]{0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Concatenated Words");
        //https://leetcode.com/problems/concatenated-words/description/
        obj.concatenatedWords(new String[]{"cat", "cats", "catsdogcats", "dog",
                "dogcatsdog", "hippopotamuses", "rat", "ratcatdogcat"});
        obj.concatenatedWords(new String[]{"cat", "dog", "catdog"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count the Number of Complete Components");
        //https://leetcode.com/problems/count-the-number-of-complete-components/description/
        obj.countNumberOfCompleteComponents_Graph(6, new int[][]{{0, 1}, {0, 2}, {1, 2}, {3, 4}});
        obj.countNumberOfCompleteComponents_Graph(6, new int[][]{{0, 1}, {0, 2}, {1, 2}, {3, 4}, {3, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Profit in Job Scheduling");
        //https://leetcode.com/problems/maximum-profit-in-job-scheduling/description/
        //https://practice.geeksforgeeks.org/problems/649205908e04ac00f303626fa845261318adfa8f/1
        obj.maxProfitInJobScheduling_Recursive_Memoization(
                new int[]{1, 2, 3, 3}, new int[]{3, 4, 5, 6}, new int[]{50, 10, 40, 70});
        obj.maxProfitInJobScheduling_Recursive_Memoization(
                new int[]{1, 2, 3, 4, 6}, new int[]{3, 5, 10, 6, 9}, new int[]{20, 20, 100, 70, 60});
        obj.maxProfitInJobScheduling_Recursive_Memoization(
                new int[]{1, 1, 1}, new int[]{2, 3, 4}, new int[]{5, 6, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Number of Events That Can Be Attended");
        //https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/
        obj.maxNumberOfEventsThatCanBeAttended_Greedy(new int[][]{{1, 2}, {2, 3}, {3, 4}});
        obj.maxNumberOfEventsThatCanBeAttended_Greedy(new int[][]{{1, 2}, {2, 3}, {3, 4}, {1, 2}});
        obj.maxNumberOfEventsThatCanBeAttended_Greedy(new int[][]{{1, 4}, {4, 4}, {2, 2}, {3, 4}, {1, 1}});
        System.out.println("Maximum Number of Events That Can Be Attended II");
        //https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/description/
        //https://leetcode.com/problems/two-best-non-overlapping-events/description/
        obj.maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization(
                new int[][]{{1, 2, 4}, {3, 4, 3}, {2, 3, 1}}, 2);
        obj.maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization(
                new int[][]{{1, 2, 4}, {3, 4, 3}, {2, 3, 10}}, 2);
        obj.maxNumberOfEventsThatCanBeAttendedTwo_Recursive_Memoization(
                new int[][]{{1, 1, 1}, {2, 2, 2}, {3, 3, 3}, {4, 4, 4}}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Alternating Subsequence Sum");
        //https://leetcode.com/problems/maximum-alternating-subsequence-sum/description/
        obj.maxAlternatingSubseqSum_Recursive_Memoization(new int[]{4, 2, 5, 3});
        obj.maxAlternatingSubseqSum_Recursive_Memoization(new int[]{5, 6, 7, 8});
        obj.maxAlternatingSubseqSum_Recursive_Memoization(new int[]{6, 2, 1, 2, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Wiggle Sort II");
        //https://leetcode.com/problems/wiggle-sort/submissions/
        //https://leetcode.com/problems/wiggle-sort-ii/description/
        obj.wiggleSortTwo_Greedy(new int[]{1, 5, 1, 1, 6, 4});
        obj.wiggleSortTwo_Greedy(new int[]{1, 3, 2, 2, 3, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Convert an Array Into a 2D Array With Conditions");
        //https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/description/
        obj.convertArrayToMatrixWithConditions(new int[]{1, 3, 4, 1, 2, 3, 1});
        obj.convertArrayToMatrixWithConditions(new int[]{1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Repeating Substring");
        //https://leetcode.com/problems/longest-repeating-substring/description/
        //https://leetcode.ca/all/1062.html
        obj.longestRepeatingSubstring("abcd");
        obj.longestRepeatingSubstring("abbaba");
        obj.longestRepeatingSubstring("aabcaabdaab");
        obj.longestRepeatingSubstring("aaaaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Distinct Numbers in Each Subarray");
        //https://leetcode.com/problems/distinct-numbers-in-each-subarray/description/
        //https://leetcode.ca/all/1852.html
        obj.distinctNumbersInEachSubarray(new int[]{1, 2, 3, 2, 2, 1, 3}, 3);
        obj.distinctNumbersInEachSubarray(new int[]{1, 1, 1, 1, 2, 3, 4}, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Russian Doll Envelopes");
        //https://leetcode.com/problems/russian-doll-envelopes/description/
        obj.russianDollsEnvelopes_DP_Memoization(new int[][]{{5, 4}, {6, 4}, {6, 7}, {2, 3}});
        obj.russianDollsEnvelopes_DP_Memoization(new int[][]{{1, 1}, {1, 1}, {1, 1}});
        obj.russianDollsEnvelopes_DP_Memoization(new int[][]{{4, 5}, {4, 6}, {6, 7}, {2, 3}, {1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Knight Probability in Chessboard");
        //https://leetcode.com/problems/knight-probability-in-chessboard/description/
        obj.knightProbabiltyInChessBoard_Recursive_Memoization(3, 2, 0, 0);
        obj.knightProbabiltyInChessBoard_Recursive_Memoization(1, 0, 0, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Substrings That Begin and End With the Same Letter");
        //https://leetcode.com/problems/substrings-that-begin-and-end-with-the-same-letter/description/
        //https://leetcode.ca/2021-12-06-2083-Substrings-That-Begin-and-End-With-the-Same-Letter/
        obj.substringsBeginsAndEndsWithSameChar("a");
        obj.substringsBeginsAndEndsWithSameChar("abcba");
        obj.substringsBeginsAndEndsWithSameChar("abacad");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("All Possible Full Binary Trees");
        //https://leetcode.com/problems/all-possible-full-binary-trees/description/
        obj.allPossibleFullBinaryTrees_Recursive_Memoization(1);
        obj.allPossibleFullBinaryTrees_Recursive_Memoization(2);
        obj.allPossibleFullBinaryTrees_Recursive_Memoization(3);
        obj.allPossibleFullBinaryTrees_Recursive_Memoization(7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Unique Binary Search Trees II");
        //https://leetcode.com/problems/unique-binary-search-trees-ii/description/
        obj.uniqueBinarySearchTreesTwo_Recursive_Memoization(3);
        obj.uniqueBinarySearchTreesTwo_Recursive_Memoization(1);
        obj.uniqueBinarySearchTreesTwo_Recursive_Memoization(5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Different Ways to Add Parentheses");
        //https://leetcode.com/problems/different-ways-to-add-parentheses/description/
        obj.waysToAddParenthesis_Recursive_Memoization("22-1");
        obj.waysToAddParenthesis_Recursive_Memoization("2-1-1");
        obj.waysToAddParenthesis_Recursive_Memoization("2*3-4*5");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Deletions to Make String Balanced");
        //https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/description/
        obj.minDeletionsToMakeStringBalanced1("aababbab");
        obj.minDeletionsToMakeStringBalanced1("bbaaaaabb");
        obj.minDeletionsToMakeStringBalanced1("aaaa");
        obj.minDeletionsToMakeStringBalanced1("bbbb");
        obj.minDeletionsToMakeStringBalanced2("aababbab");
        obj.minDeletionsToMakeStringBalanced2("bbaaaaabb");
        obj.minDeletionsToMakeStringBalanced2("aaaa");
        obj.minDeletionsToMakeStringBalanced2("bbbb");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sort the Students by Their Kth Score");
        //https://leetcode.com/problems/sort-the-students-by-their-kth-score/description/
        obj.sortTheStudentByTheirKThScore(new int[][]{{10, 6, 9, 1}, {7, 5, 11, 2}, {4, 8, 3, 15}}, 2);
        obj.sortTheStudentByTheirKThScore(new int[][]{{3, 4}, {5, 6}}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Soup Servings");
        //https://leetcode.com/problems/soup-servings/
        obj.soupServings_Recursive_Memoization(50);
        obj.soupServings_Recursive_Memoization(100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Lexicographically Smallest Pallindrome");
        //https://leetcode.com/problems/lexicographically-smallest-palindrome/
        obj.lexicographicallySmallestPallindrome("egcfe");
        obj.lexicographicallySmallestPallindrome("abcd");
        obj.lexicographicallySmallestPallindrome("seven");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum ASCII Delete Sum for Two Strings");
        //https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/
        System.out.println("Min ASCII delete sum for two strings (approach Edit Distance): "
                + obj.minAsciiDeleteSumForTwoStrings_Recusrive_Memoization("a", "a"));
        System.out.println("Min ASCII delete sum for two strings (approach Edit Distance): "
                + obj.minAsciiDeleteSumForTwoStrings_Recusrive_Memoization("sea", "eat"));
        System.out.println("Min ASCII delete sum for two strings (approach Edit Distance): "
                + obj.minAsciiDeleteSumForTwoStrings_Recusrive_Memoization("delete", "leet"));
        //solved myself :), more intuitive approach and faster than above recursive_memoization
        System.out.println("Min ASCII delete sum for two strings (approach LCS): "
                + obj.minAsciiDeleteSumForTwoStrings_DP_Memoization("a", "a"));
        System.out.println("Min ASCII delete sum for two strings (approach LCS): "
                + obj.minAsciiDeleteSumForTwoStrings_DP_Memoization("sea", "eat"));
        System.out.println("Min ASCII delete sum for two strings (approach LCS): "
                + obj.minAsciiDeleteSumForTwoStrings_DP_Memoization("delete", "leet"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary Tree Upside Down");
//        //https://leetcode.com/problems/binary-tree-upside-down/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        obj.binaryTreeUpSideDown(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        obj.binaryTreeUpSideDown(root);
//        obj.binaryTreeUpSideDown(null);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Leaves of Binary Tree");
//        //https://leetcode.com/problems/find-leaves-of-binary-tree/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        obj.findLeavesOfBinaryTree(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        obj.findLeavesOfBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Operations to Sort a Binary Tree by Level");
//        //https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().setRight(new TreeNode<>(6));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(8));
//        root.getRight().getLeft().setLeft(new TreeNode<>(9));
//        root.getRight().setRight(new TreeNode<>(5));
//        root.getRight().getRight().setLeft(new TreeNode<>(10));
//        obj.minOprnsToSortBinaryTreeByLevels(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().setRight(new TreeNode<>(6));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.minOprnsToSortBinaryTreeByLevels(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Nearest Right Node in Binary Tree");
        //https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/description/
        TreeNode<Integer> root = new TreeNode<>(1);
        root.setLeft(new TreeNode<>(2));
        root.getLeft().setRight(new TreeNode<>(4));
        root.setRight(new TreeNode<>(3));
        root.getRight().setLeft(new TreeNode<>(5));
        root.getRight().setRight(new TreeNode<>(6));
        System.out.println("Find nearest right node to target : " + obj.findNearestRightNodeInBinaryTree(root, 4));
        root = new TreeNode<>(3);
        root.setRight(new TreeNode<>(4));
        root.getRight().setLeft(new TreeNode<>(2));
        System.out.println("Find nearest right node to target : " + obj.findNearestRightNodeInBinaryTree(root, 4));
        root = new TreeNode<>(1);
        System.out.println("Find nearest right node to target : " + obj.findNearestRightNodeInBinaryTree(root, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Buildings With an Ocean View");
        //https://leetcode.com/problems/buildings-with-an-ocean-view/description/
        obj.buildingWithAnOceanView(new int[]{4, 2, 3, 1});
        obj.buildingWithAnOceanView(new int[]{4, 3, 2, 1});
        obj.buildingWithAnOceanView(new int[]{1, 3, 2, 4});
        obj.buildingWithAnOceanView(new int[]{4, 4, 4, 4});
        obj.buildingWithAnOceanView2(new int[]{4, 2, 3, 1});
        obj.buildingWithAnOceanView2(new int[]{4, 3, 2, 1});
        obj.buildingWithAnOceanView2(new int[]{1, 3, 2, 4});
        obj.buildingWithAnOceanView2(new int[]{4, 4, 4, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Car Fleet");
        //https://leetcode.com/problems/car-fleet/description/
        obj.carFleet(new int[]{10, 8, 0, 5, 3}, new int[]{2, 4, 1, 1, 3}, 12);
        obj.carFleet(new int[]{3}, new int[]{3}, 10);
        obj.carFleet(new int[]{0, 2, 4}, new int[]{4, 2, 1}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Group Shifted Strings");
        //https://leetcode.com/problems/group-shifted-strings/description/
        obj.groupShiftedStrings(new String[]{"abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"});
        obj.groupShiftedStrings(new String[]{"a"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("The Earliest Moment When Everyone Become Friends");
        //https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/description/
        System.out.println("Earliest time when everyone become friend : "
                + obj.earliestMomentEveryoneBecomeFriends_Graph(
                new int[][]{{20190101, 0, 1}, {20190104, 3, 4}, {20190107, 2, 3},
                        {20190211, 1, 5}, {20190224, 2, 4}, {20190301, 0, 3},
                        {20190312, 1, 2}, {20190322, 4, 5}}, 6));
        System.out.println("Earliest time when everyone become friend : "
                + obj.earliestMomentEveryoneBecomeFriends_Graph(
                new int[][]{{0, 2, 0}, {1, 0, 1}, {3, 0, 3},
                        {4, 1, 2}, {7, 3, 1}}, 4));
        System.out.println("Earliest time when everyone become friend : "
                + obj.earliestMomentEveryoneBecomeFriends_Graph(
                new int[][]{{9, 3, 0}, {0, 2, 1}, {8, 0, 1},
                        {1, 3, 2}, {2, 2, 0}, {3, 3, 1}}, 4));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Distance to Target Color");
        //https://leetcode.com/problems/shortest-distance-to-target-color/description/
        obj.shortestDistanceToTargetColor(new int[]{1, 1, 2, 1, 3, 2, 2, 3, 3},
                new int[][]{{1, 3}, {2, 2}, {6, 1}});
        obj.shortestDistanceToTargetColor(new int[]{1, 2}, new int[][]{{0, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Design Hit Counter");
        //https://leetcode.com/problems/design-hit-counter/description/
        obj.designHitCounter(
                Arrays.asList("hit", "hit", "hit", "getHits", "hit", "getHits", "getHits"),
                Arrays.asList(1, 2, 3, 4, 300, 300, 301));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Range Frequency Queries");
        //https://leetcode.com/problems/range-frequency-queries/description/
        obj.designRangeFrequencyQuery(Arrays.asList(
                Arrays.asList(12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56),
                Arrays.asList(1, 2, 4),
                Arrays.asList(0, 11, 33)));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Design File System");
        //https://leetcode.com/problems/design-file-system/description/
        obj.designFileSystem(Arrays.asList("createPath", "get"),
                Arrays.asList(
                        Arrays.asList("/a", "1"),
                        Arrays.asList("/a")));
        obj.designFileSystem(Arrays.asList("createPath", "createPath", "createPath"),
                Arrays.asList(
                        Arrays.asList("/j", "1"),
                        Arrays.asList("/j/i", "2"),
                        Arrays.asList("/ji/w", "3")));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Design Phone Directory");
        //https://leetcode.com/problems/design-phone-directory/description/
        obj.designPhoneDirectory(
                Arrays.asList("PhoneDirectory", "get", "get", "check", "get", "check", "release", "check"),
                Arrays.asList(Arrays.asList(3),
                        Arrays.asList(), Arrays.asList(), Arrays.asList(2),
                        Arrays.asList(), Arrays.asList(2), Arrays.asList(2), Arrays.asList(2)));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Music Playlists");
        //https://leetcode.com/problems/number-of-music-playlists/description/
        obj.numberOfMusicPlaylists_Recursive_Memoization(3, 3, 1);
        obj.numberOfMusicPlaylists_Recursive_Memoization(2, 3, 0);
        obj.numberOfMusicPlaylists_Recursive_Memoization(2, 3, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Ones and Zeroes");
        //https://leetcode.com/problems/ones-and-zeroes/description/
        obj.onesAndZeroes_Recursive_Memoization(new String[]{"10", "0001", "111001", "1", "0"}, 5, 3);
        obj.onesAndZeroes_Recursive_Memoization(new String[]{"10", "0", "1"}, 1, 1);
        obj.onesAndZeroes_Recursive_Memoization(new String[]{"00", "000"}, 1, 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Vowels Permutation");
        //https://leetcode.com/problems/count-vowels-permutation/description/
        obj.countVowelPermutation_Recursive_Memoization(1);
        obj.countVowelPermutation_Recursive_Memoization(2);
        obj.countVowelPermutation_Recursive_Memoization(5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sliding Subarray Beauty");
        //https://leetcode.com/problems/sliding-subarray-beauty/description/
        obj.slidingSubarrayBeauty(new int[]{1, -1, -3, -2, 3}, 3, 2);
        obj.slidingSubarrayBeauty(new int[]{-1, -2, -3, -4, -5}, 2, 2);
        obj.slidingSubarrayBeauty(new int[]{-3, 1, 2, -3, 0, -3}, 2, 1);
        obj.slidingSubarrayBeauty(new int[]{-1, -1, -3, -2, -3}, 3, 2);
        obj.slidingSubarrayBeauty(new int[]{-1, -1, -3, -2, -3}, 3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Transforms Into Another String");
        //https://leetcode.com/problems/string-transforms-into-another-string/description/
        System.out.println("Can string str1 transforms into str2 : "
                + obj.stringTransformsIntoAnotherString("aabcc", "ccdee"));
        System.out.println("Can string str1 transforms into str2 : "
                + obj.stringTransformsIntoAnotherString("leetcode", "codeleet"));
        System.out.println("Can string str1 transforms into str2 : "
                + obj.stringTransformsIntoAnotherString("abcdefghijklmnopqrstuvwxyz", "bcdefghijklmnopqrstuvwxyza"));
        System.out.println("Can string str1 transforms into str2 : "
                + obj.stringTransformsIntoAnotherString("abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Brace Expansion");
        //https://leetcode.com/problems/brace-expansion/description/
        obj.braceExpansion_Backtracking("{a,b}c{d,e}f");
        obj.braceExpansion_Backtracking("abcd");
        obj.braceExpansion_Backtracking("{a,b}{z,x,y}");
        obj.braceExpansion_Backtracking("{a,b}cxxy{d,e}f");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Ideal Subsequence");
        //https://leetcode.com/problems/longest-ideal-subsequence/description/
        obj.longestIdealSubsequence_DP_Memoization("acfgbd", 2);
        obj.longestIdealSubsequence_DP_Memoization("abcd", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Word Distance III");
        //https://leetcode.com/problems/shortest-word-distance-iii/description/
        //https://leetcode.com/problems/shortest-word-distance/description/
        obj.shortestWordDistThree(new String[]{"practice", "makes", "perfect", "coding", "makes"},
                "makes", "coding");
        obj.shortestWordDistThree(new String[]{"practice", "makes", "perfect", "coding", "makes"},
                "makes", "makes");
        obj.shortestWordDistThree(new String[]{"a", "a", "c", "b"},
                "a", "b");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Check if There is a Valid Partition For The Array");
        //https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/description/
        obj.checkIfValidPartitionOfArray_Recursive_Memoization(new int[]{4, 4, 4, 5, 6});
        obj.checkIfValidPartitionOfArray_Recursive_Memoization(new int[]{1, 1, 1, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Score of All Prefixes of an Array");
        //https://leetcode.com/problems/find-the-score-of-all-prefixes-of-an-array/description/
        obj.scoresOfAllPrefixesOfArray(new int[]{2, 3, 7, 5, 10});
        obj.scoresOfAllPrefixesOfArray(new int[]{1, 1, 2, 4, 8, 16});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Smallest String With Swaps");
        //https://leetcode.com/problems/smallest-string-with-swaps/description/
        obj.smallestStringWithSwaps_Graph("dcab", new int[][]{{0, 3}, {1, 2}});
        obj.smallestStringWithSwaps_Graph("dcab", new int[][]{{0, 3}, {1, 2}, {0, 2}});
        obj.smallestStringWithSwaps_Graph("cba", new int[][]{{0, 1}, {1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Process Restricted Friend Requests");
        //https://leetcode.com/problems/process-restricted-friend-requests/description/
        obj.processRestrictedFriendRequests_Graph(3,
                new int[][]{{0, 1}}, new int[][]{{0, 2}, {2, 1}});
        obj.processRestrictedFriendRequests_Graph(3,
                new int[][]{{0, 1}}, new int[][]{{1, 2}, {0, 2}});
        obj.processRestrictedFriendRequests_Graph(5,
                new int[][]{{0, 1}, {1, 2}, {2, 3}}, new int[][]{{0, 4}, {1, 2}, {3, 1}, {3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Islands II");
        //https://leetcode.com/problems/number-of-islands-ii/description/
        obj.numberOfIslandsTwo_Graph(3, 3, new int[][]{{0, 0}, {0, 1}, {1, 2}, {2, 1}});
        obj.numberOfIslandsTwo_Graph(1, 1, new int[][]{{0, 0}});
        obj.numberOfIslandsTwo_Graph(8, 2, new int[][]{{7, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("K-Similar Strings");
        //https://leetcode.com/problems/k-similar-strings/description/
        System.out.println("K - similar strings : " + obj.kSimilarString_Graph("ab", "ba"));
        System.out.println("K - similar strings : " + obj.kSimilarString_Graph("abc", "bca"));
        System.out.println("K - similar strings : " + obj.kSimilarString_Graph("abcdel", "abldec"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Distance from All Buildings");
        //https://leetcode.com/problems/shortest-distance-from-all-buildings/description/
        obj.shortestDistanceFromAllBuildings_Graph(new int[][]{{1, 0, 2, 0, 1}, {0, 0, 0, 0, 0}, {0, 0, 1, 0, 0}});
        obj.shortestDistanceFromAllBuildings_Graph(new int[][]{{1, 0}});
        obj.shortestDistanceFromAllBuildings_Graph(new int[][]{{1}});
        //edge case building with cell(0, 2) is blocked by cell(0, 1) & cell(1, 2)
        //hence none of the empty cell will have COUNT_BUILDINGS == totalBuildings
        obj.shortestDistanceFromAllBuildings_Graph(new int[][]{{0, 2, 1}, {1, 0, 2}, {0, 1, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path to Get Food");
        //https://leetcode.com/problems/shortest-path-to-get-food/description/
        System.out.println("Shortest path to get food : " + obj.shortestPathToGetFood_Graph(new char[][]{
                {'X', 'X', 'X', 'X', 'X', 'X'},
                {'X', '*', 'O', 'O', 'O', 'X'},
                {'X', 'O', 'O', '#', 'O', 'X'},
                {'X', 'X', 'X', 'X', 'X', 'X'}}));
        System.out.println("Shortest path to get food : " + obj.shortestPathToGetFood_Graph(new char[][]{
                {'X', 'X', 'X', 'X', 'X'},
                {'X', '*', 'X', 'O', 'X'},
                {'X', 'O', 'X', '#', 'X'},
                {'X', 'X', 'X', 'X', 'X'}}));
        System.out.println("Shortest path to get food : " + obj.shortestPathToGetFood_Graph(new char[][]{
                {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'},
                {'X', '*', 'O', 'X', 'O', '#', 'O', 'X'},
                {'X', 'O', 'O', 'X', 'O', 'O', 'X', 'X'},
                {'X', 'O', 'O', 'O', 'O', '#', 'O', 'X'},
                {'X', 'X', 'X', 'X', 'X', 'X', 'X', 'X'}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("01 Matrix");
        //https://leetcode.com/problems/01-matrix/description/
        obj.matrix01_Graph(new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}});
        obj.matrix01_Graph(new int[][]{{0, 0, 0}, {0, 1, 0}, {1, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Line of Consecutive One in Matrix");
        //https://leetcode.com/problems/longest-line-of-consecutive-one-in-matrix/description/
        obj.longestLineOfConsecutiveOneInGrid(new int[][]{{0, 1, 1, 0}, {0, 1, 1, 0}, {0, 0, 0, 1}});
        obj.longestLineOfConsecutiveOneInGrid(new int[][]{{1, 1, 1, 1}, {0, 1, 1, 0}, {0, 0, 0, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Subarray with Sum at Least K");
        //https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/
        obj.shortestSubarrayWithSumAtleastK(new int[]{1}, 1);
        obj.shortestSubarrayWithSumAtleastK(new int[]{1, 2}, 4);
        obj.shortestSubarrayWithSumAtleastK(new int[]{2, -1, 2}, 3);
        obj.shortestSubarrayWithSumAtleastK(new int[]{-1, -3, -4, 5, -1, 1, 0, 5, -4, 2}, 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Check if There is a Path With Equal Number of 0's And 1's");
        //https://leetcode.com/problems/check-if-there-is-a-path-with-equal-number-of-0s-and-1s/description/
        obj.checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization(new int[][]{
                {0, 1, 0, 0}, {0, 1, 0, 0}, {1, 0, 1, 0}});
        obj.checkIfPathExistsWithEqualZerosAndOnes_Recursive_Memoization(new int[][]{
                {1, 1, 0}, {0, 0, 1}, {1, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree");
        //https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/
        obj.findCriticalAndPseudoCriticalEdgesInMST_Graph(5,
                new int[][]{{0, 1, 1}, {1, 2, 1}, {2, 3, 2}, {0, 3, 2}, {0, 4, 3}, {3, 4, 3}, {1, 4, 6}});
        obj.findCriticalAndPseudoCriticalEdgesInMST_Graph(4,
                new int[][]{{0, 1, 1}, {1, 2, 1}, {2, 3, 1}, {0, 3, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Smallest Common Region");
        //https://leetcode.com/problems/smallest-common-region/description/
        obj.smallestCommonRegion_Graph(new String[][]{
                        {"Earth", "North America", "South America"},
                        {"North America", "United States", "Canada"},
                        {"United States", "New York", "Boston"},
                        {"Canada", "Ontario", "Quebec"},
                        {"South America", "Brazil"}},
                "Quebec", "New York");
        obj.smallestCommonRegion_Graph(new String[][]{
                        {"Earth", "North America", "South America"},
                        {"North America", "United States", "Canada"},
                        {"United States", "New York", "Boston"},
                        {"Canada", "Ontario", "Quebec"},
                        {"South America", "Brazil"}},
                "Canada", "South America");
        obj.smallestCommonRegion_Graph(new String[][]{
                        {"Earth", "North America", "South America"},
                        {"North America", "United States", "Canada"},
                        {"United States", "New York", "Boston"},
                        {"Canada", "Ontario", "Quebec"},
                        {"South America", "Brazil"}},
                "Canada", "Quebec");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Reverse Words in a String II");
        //https://leetcode.com/problems/reverse-words-in-a-string-ii/description/
        obj.reverseWordsInStringTwo(new char[]{'t', 'h', 'e', ' ', 's', 'k', 'y', ' ', 'i', 's', ' ', 'b', 'l', 'u', 'e'});
        obj.reverseWordsInStringTwo(new char[]{'a'});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Palindrome Permutation I/ II");
        //https://leetcode.com/problems/palindrome-permutation/description/
        //https://leetcode.com/problems/palindrome-permutation-ii/description/
        obj.pallindromePermutationsTwo_Backtracking("aabb");
        obj.pallindromePermutationsTwo_Backtracking("abc");
        obj.pallindromePermutationsTwo_Backtracking("aaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Duplicate Letters");
        //https://leetcode.com/problems/remove-duplicate-letters/description/
        //https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/
        obj.removeDuplicateLettersToMakeLexicographicallySmallestString("bcabc");
        obj.removeDuplicateLettersToMakeLexicographicallySmallestString("cbacdcbc");
        obj.removeDuplicateLettersToMakeLexicographicallySmallestString("cbacdcbcd");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Score After Splitting a String");
        //https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/
        obj.maxScoreAfterSplittingBinaryString("011101");
        obj.maxScoreAfterSplittingBinaryString("00111");
        obj.maxScoreAfterSplittingBinaryString("000000000");
        obj.maxScoreAfterSplittingBinaryString("1111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Subarrays With Score Less Than K");
        //https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/
        obj.countSubarraysWithScoreLessThanK(new int[]{2, 1, 4, 3, 5}, 10);
        obj.countSubarraysWithScoreLessThanK(new int[]{1, 1, 1}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Ways to Split Array Into Good Subarrays");
        //https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/description/
        //TLE on larger inputs
//        System.out.println("Ways to split array into good subarrays : "
//                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization(new int[]{1}));
//        System.out.println("Ways to split array into good subarrays : "
//                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization(new int[]{0, 1, 0, 0, 1}));
//        System.out.println("Ways to split array into good subarrays : "
//                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization(new int[]{0, 1, 0}));
//        System.out.println("Ways to split array into good subarrays : "
//                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_Recursive_Memoization(new int[]{0, 0, 0}));
        System.out.println("Ways to split array into good subarrays : "
                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_DP_Memoization(new int[]{1}));
        System.out.println("Ways to split array into good subarrays : "
                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_DP_Memoization(new int[]{0, 1, 0, 0, 1}));
        System.out.println("Ways to split array into good subarrays : "
                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_DP_Memoization(new int[]{0, 1, 0}));
        System.out.println("Ways to split array into good subarrays : "
                + obj.waysToSplitBinaryArrayIntoGoodSubarrays_DP_Memoization(new int[]{0, 0, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Partition String Into Substrings With Values at Most K");
        //https://leetcode.com/problems/partition-string-into-substrings-with-values-at-most-k/description/
        System.out.println("Partition string into substring with values atmost k : "
                + obj.partitionIntoSubstringWithValueAtmostK_Greedy("165462", 60));
        System.out.println("Partition string into substring with values atmost k : "
                + obj.partitionIntoSubstringWithValueAtmostK_Greedy("238182", 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Missing Ranges");
        //https://leetcode.com/problems/missing-ranges/description/
        obj.missingRanges(new int[]{0, 1, 3, 50, 75}, 0, 99);
        obj.missingRanges(new int[]{-1}, -1, -1);
        obj.missingRanges(new int[]{0, 1, 2}, -3, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Non-decreasing Subarray From Two Arrays");
        //https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/description/
        obj.longestNonDecrSubarrayFromTwoArrays_DP_Memoization(new int[]{2, 3, 1}, new int[]{1, 2, 1});
        obj.longestNonDecrSubarrayFromTwoArrays_DP_Memoization(new int[]{1, 3, 2, 1}, new int[]{2, 2, 3, 4});
        obj.longestNonDecrSubarrayFromTwoArrays_DP_Memoization(new int[]{1, 1}, new int[]{2, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Special Array With X Elements Greater Than or Equal X");
        //https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/description/
        System.out.println("Special array : " + obj.specialArrayWithXElementsGreaterOrEqualToX(new int[]{0}));
        System.out.println("Special array : " + obj.specialArrayWithXElementsGreaterOrEqualToX(new int[]{3, 5}));
        System.out.println("Special array : " + obj.specialArrayWithXElementsGreaterOrEqualToX(new int[]{0, 0}));
        System.out.println("Special array : " + obj.specialArrayWithXElementsGreaterOrEqualToX(new int[]{0, 4, 3, 0, 4}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("The Latest Time to Catch a Bus");
        //https://leetcode.com/problems/the-latest-time-to-catch-a-bus/description/
        System.out.println("Latest time to catch bus : "
                + obj.latestTimeToCatchBus_Greedy(new int[]{10, 20}, new int[]{2, 17, 18, 19}, 2));
        System.out.println("Latest time to catch bus : "
                + obj.latestTimeToCatchBus_Greedy(new int[]{20, 30, 10}, new int[]{19, 13, 26, 4, 25, 11, 21}, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Absolute File Path");
        //https://leetcode.com/problems/longest-absolute-file-path/description/
        obj.longestAbsoluteFilePath("dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext");
        obj.longestAbsoluteFilePath(
                "dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Insert Greatest Common Divisors in Linked List");
//        //https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description/
//        Node<Integer> head = new Node<>(18);
//        head.setNext(new Node<>(6));
//        head.getNext().setNext(new Node<>(10));
//        head.getNext().getNext().setNext(new Node<>(3));
//        obj.insertGCDInLinkedList(head);
//        head = new Node<>(7);
//        obj.insertGCDInLinkedList(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Smallest Common Element in All Rows");
        //https://leetcode.com/problems/find-smallest-common-element-in-all-rows/description/
        System.out.println("Smallest common element : "
                + obj.smallestCommonElement(
                new int[][]{{1, 2, 3, 4, 5}, {2, 4, 5, 8, 10}, {3, 5, 7, 9, 11}, {1, 3, 5, 7, 9}}));
        System.out.println("Smallest common element : "
                + obj.smallestCommonElement(
                new int[][]{{1, 2, 3}, {2, 3, 4}, {2, 3, 5}}));
        System.out.println("Smallest common element : "
                + obj.smallestCommonElement(
                new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sort Vowels in a String");
        //https://leetcode.com/problems/sort-vowels-in-a-string/description/
        obj.sortVowelsInString("lEetcOde");
        obj.sortVowelsInString("lYmpH");
        obj.sortVowelsInString("aeiouAEIOU");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Penalty for a Shop");
        //https://leetcode.com/problems/minimum-penalty-for-a-shop/description/
        obj.minPenaltyForShop("YYNY");
        obj.minPenaltyForShop("NNNNN");
        obj.minPenaltyForShop("YYYY");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Number of Coins You Can Get");
        //https://leetcode.com/problems/maximum-number-of-coins-you-can-get/description/
        obj.maxNumberOfCoinsYouCanGet_Greedy(new int[]{2, 4, 1, 2, 7, 8});
        obj.maxNumberOfCoinsYouCanGet_Greedy(new int[]{2, 4, 5});
        obj.maxNumberOfCoinsYouCanGet_Greedy(new int[]{9, 8, 7, 6, 5, 1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Removing Minimum Number of Magic Beans");
        //https://leetcode.com/problems/removing-minimum-number-of-magic-beans/description/
        obj.removingMinNumberOfMagicBeans_Greedy(new int[]{4, 1, 6, 5});
        obj.removingMinNumberOfMagicBeans_Greedy(new int[]{2, 10, 3, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Replacements to Sort the Array");
        //https://leetcode.com/problems/minimum-replacements-to-sort-the-array/description/
        obj.minReplacementsToSortTheArray_Greedy(new int[]{3, 9, 3});
        obj.minReplacementsToSortTheArray_Greedy(new int[]{1, 2, 3, 4, 5});
        obj.minReplacementsToSortTheArray_Greedy(new int[]{9, 7, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Number of Taps to Open to Water a Garden");
        //https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/
        System.out.println("Min number of taps : "
                + obj.minNumberOfTapsToOpenToWaterGarden_Greedy(5, new int[]{3, 4, 1, 1, 0, 0}));
        System.out.println("Min number of taps : "
                + obj.minNumberOfTapsToOpenToWaterGarden_Greedy(3, new int[]{0, 0, 0, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Extra Characters in a String");
        //https://leetcode.com/problems/extra-characters-in-a-string/description/
        obj.extraCharsInString_Recursive_Memoization("leetscode", new String[]{"leet", "code", "leetcode"});
        obj.extraCharsInString_Recursive_Memoization("sayhelloworld", new String[]{"hello", "world"});
        obj.extraCharsInString_DP_Memoization("leetscode", new String[]{"leet", "code", "leetcode"});
        obj.extraCharsInString_DP_Memoization("sayhelloworld", new String[]{"hello", "world"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count All Valid Pickup and Delivery Options");
        //https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/?envType=daily-question&envId=2023-09-10
        obj.countAllValidPickupAndDelivery_DP_Memoization(1);
        obj.countAllValidPickupAndDelivery_DP_Memoization(2);
        obj.countAllValidPickupAndDelivery_DP_Memoization(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Deletions to Make Character Frequencies Unique");
        //https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/description/
        obj.minDeletionsToMakeCharFreqUnique_Greedy("aaabbbccc");
        obj.minDeletionsToMakeCharFreqUnique_Greedy("aab");
        obj.minDeletionsToMakeCharFreqUnique_Greedy("aaabbbcc");
        obj.minDeletionsToMakeCharFreqUnique_Greedy("ceabaacb");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Letter To Equalize Frequency");
        //https://leetcode.com/problems/remove-letter-to-equalize-frequency/description/
        System.out.println("Can chars be equalized after one delete : "
                + obj.removeLetterToEqualizeFreq("aabbccabc"));
        System.out.println("Can chars be equalized after one delete : "
                + obj.removeLetterToEqualizeFreq("abcc"));
        System.out.println("Can chars be equalized after one delete : "
                + obj.removeLetterToEqualizeFreq("aazz"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Reconstruct Itinerary");
        //https://leetcode.com/problems/reconstruct-itinerary/description/
        obj.reconstructItinerary_Graph(
                new String[][]{{"MUC", "LHR"}, {"JFK", "MUC"}, {"SFO", "SJC"}, {"LHR", "SFO"}});
        obj.reconstructItinerary_Graph(
                new String[][]{{"JFK", "SFO"}, {"JFK", "ATL"}, {"SFO", "ATL"}, {"ATL", "JFK"}, {"ATL", "SFO"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Valid Clock Times");
        //https://leetcode.com/problems/number-of-valid-clock-times/description/
        obj.numberOfValidClockTimes("12:30");
        obj.numberOfValidClockTimes("??:??");
        obj.numberOfValidClockTimes("?5:00");
        obj.numberOfValidClockTimes("0?:0?");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path Visiting All Nodes");
        //https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/
        System.out.println("Shortest path visited all nodes : "
                + obj.shortestPathVisitingAllNodes_Graph(new int[][]{{1, 2, 3}, {0}, {0}, {0}}));
        System.out.println("Shortest path visited all nodes : "
                + obj.shortestPathVisitingAllNodes_Graph(new int[][]{{1}, {0, 2, 4}, {1, 3, 4}, {2}, {1, 2}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Repeating Substring");
        //https://leetcode.com/problems/maximum-repeating-substring/description/
        System.out.println("Maximum K repeating value of word : "
                + obj.maxRepeatingSubstring("ababc", "ab"));
        System.out.println("Maximum K repeating value of word : "
                + obj.maxRepeatingSubstring("ababc", "ba"));
        System.out.println("Maximum K repeating value of word : "
                + obj.maxRepeatingSubstring("ababc", "ac"));
        System.out.println("Maximum K repeating value of word : "
                + obj.maxRepeatingSubstring("aaabaaaabaaabaaaabaaaabaaaabaaaaba", "aaaba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Champagne Tower");
        //https://leetcode.com/problems/champagne-tower/description/
        obj.champagneTower_DP_Memoization(1, 1, 1);
        obj.champagneTower_DP_Memoization(2, 1, 1);
        obj.champagneTower_DP_Memoization(100000009, 33, 17);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Colored Pieces if Both Neighbors are the Same Color");
        //https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/description/
        obj.removeColoredPiecesIfNeighboursAreSame_Greedy("AAABABB");
        obj.removeColoredPiecesIfNeighboursAreSame_Greedy("AA");
        obj.removeColoredPiecesIfNeighboursAreSame_Greedy("ABBBBBBBAAA");
        obj.removeColoredPiecesIfNeighboursAreSame_Greedy("BBBAAA");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Subarrays with K Different Integers");
        //https://leetcode.com/problems/subarrays-with-k-different-integers/description/
        obj.subarrayWithKDifferentIntegers(new int[]{1, 2, 1}, 2);
        obj.subarrayWithKDifferentIntegers(new int[]{1, 2, 1, 2, 3}, 2);
        obj.subarrayWithKDifferentIntegers(new int[]{1, 2, 1, 3, 4}, 3);
        //https://leetcode.com/discuss/interview-question/370157
        //https://practice.geeksforgeeks.org/problems/count-number-of-substrings4528/1
        obj.substringsWithKDistinctCharacters("aba", 2);
        obj.substringsWithKDistinctCharacters("abaaca", 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Integer Break");
        //https://leetcode.com/problems/integer-break/description/
        obj.integerBreak_Recursive_Memoization(2);
        obj.integerBreak_Recursive_Memoization(10);
        //MATH based approach
        System.out.println("Integer break (approach Maths) : " + obj.integerBreak(2));
        System.out.println("Integer break (approach Maths) : " + obj.integerBreak(10));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Build Array Where You Can Find The Maximum Exactly K Comparisons");
        //https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/description/
        obj.buildArraysWithExactlyKMaximumValue_Recursive_Memoization(2, 3, 1);
        obj.buildArraysWithExactlyKMaximumValue_Recursive_Memoization(5, 2, 3);
        obj.buildArraysWithExactlyKMaximumValue_Recursive_Memoization(9, 1, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Dot Product of Two Subsequences");
        //https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/
        obj.maxDotProductsWithTwoSubseq_Recursive_Memoization(new int[]{2, 1, -2, 5}, new int[]{3, 0, -6});
        obj.maxDotProductsWithTwoSubseq_Recursive_Memoization(new int[]{3, -2}, new int[]{2, -6, 7});
        obj.maxDotProductsWithTwoSubseq_Recursive_Memoization(new int[]{-1, -1}, new int[]{1, 1});
    }

}
