/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package fun;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Random;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 *
 * @author sangeetdas
 */
public class DSA450Questions {

    class GraphEdge {

        int vertex;
        int weight;

        public GraphEdge(int vertex, int weight) {
            this.vertex = vertex;
            this.weight = weight;
        }

    }

    public void reverseArray(int[] a) {

        int len = a.length;

        //.....................O(N)
        for (int i = 0; i < len / 2; i++) {
            int temp = a[i];
            a[i] = a[len - i - 1];
            a[len - i - 1] = temp;
        }

        //output
        for (int x : a) {
            System.out.print(x + " ");
        }
        System.out.println();

    }

    public void arrayElementMoreThan_NDivK(int[] a, int K) {

        int N = a.length;
        int count = N / K;
        Map<Integer, Integer> map = new HashMap<>();
        for (int x : a) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }

        map.entrySet().stream()
                .filter(e -> e.getValue() > count)
                .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue()))
                .entrySet()
                .stream()
                .forEach(e -> System.out.println(e.getKey()));

    }

    public void minMaxInArray_1(int[] a) {

        //...................T: O(N)
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        for (int i = 0; i < a.length; i++) {
            max = Math.max(max, a[i]);
            min = Math.min(min, a[i]);
        }

        //outpur
        System.out.println("Min and max value in array: " + min + " " + max);
    }

    public void minMaxInArray_2(int[] a) {

        //https://www.geeksforgeeks.org/maximum-and-minimum-in-an-array/
        //...................T: O(N)
        //Min no of comparision
        int min = Integer.MIN_VALUE;
        int max = Integer.MAX_VALUE;

        int n = a.length;
        int itr = 0;
        //check if array is even/odd
        if (n % 2 == 0) {
            max = Math.max(a[0], a[1]);
            min = Math.min(a[0], a[1]);
            //in case of even choose min & max from first two element
            //and set itr to start from 2nd index i.e(3rd element) in pair wise
            itr = 2;
        } else {
            max = a[0];
            min = a[0];
            //in case of odd choose first element as min & max both
            //set itr to 1 i.e, 2nd element
            itr = 1;
        }

        //since we checking itr and itr+1 value in loop 
        //so run loop to n-1 so that itr+1th element corresponds to n-1th element
        while (itr < n - 1) {

            //check current itr and itr+1 element
            if (a[itr] > a[itr + 1]) {
                max = Math.max(max, a[itr]);
                min = Math.min(min, a[itr + 1]);
            } else {
                max = Math.max(max, a[itr + 1]);
                min = Math.min(min, a[itr]);
            }
            itr++;
        }

        //outpur
        System.out.println("Min and max value in array: " + min + " " + max);

    }

    public void kThSmallestElementInArray(int[] arr, int K) {

        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
                (o1, o2) -> o2.compareTo(o1)
        );

        for (int val : arr) {
            maxHeap.add(val);
            if (maxHeap.size() > K) {
                maxHeap.poll();
            }
        }
        //output
        System.out.println(K + " th smallest element: " + maxHeap.peek());
    }

    public void kThLargestElementInArray(int[] arr, int K) {
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();

        for (int val : arr) {
            minHeap.add(val);
            if (minHeap.size() > K) {
                minHeap.poll();
            }
        }
        //output
        System.out.println(K + " th largest element: " + minHeap.peek());
    }

    public void kThSmallestTrimmedNumber(String[] nums, int[][] queries) {
        //https://leetcode.com/problems/query-kth-smallest-trimmed-number/
        //based on kThSmallestElementInArray()
        int n = queries.length;
        int numLength = nums[0].length();
        int[] result = new int[n];
        //Pair<String, Integer> = <nums[index], index>
        PriorityQueue<Pair<String, Integer>> maxHeap = new PriorityQueue<>(
                (a, b) -> a.getKey().equals(b.getKey())
                ? b.getValue() - a.getValue()
                : b.getKey().compareTo(a.getKey()));

        for (int i = 0; i < n; i++) {
            maxHeap.clear();

            int k = queries[i][0];
            int trim = queries[i][1];

            for (int index = 0; index < nums.length; index++) {
                String num = nums[index];
                //trim-index = numLength - trim ==> num.substring(numLength - trim)
                //substring req is from trim-index till end of num string
                maxHeap.add(new Pair<>(num.substring(numLength - trim), index));
                if (maxHeap.size() > k) {
                    maxHeap.poll();
                }
            }
            //value == index
            result[i] = maxHeap.peek().getValue();
        }
        //output
        System.out.println("KTh smallest trimmed number for given queries: " + Arrays.toString(result));
    }

    public void sortArrayOf012_1(int[] arr) {

        //.............T: O(N)
        //.............S: O(3)
        Map<Integer, Integer> map = new HashMap<>();
        for (int val : arr) {
            map.put(val, map.getOrDefault(val, 0) + 1);
        }

        //creating array
        int k = 0;
        for (int val = 0; val <= 2; val++) {
            int freq = map.get(val);
            while (freq != 0) {
                arr[k++] = val;
                freq--;
            }
        }

        //output
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private void swapIntArray(int[] a, int x, int y) {
        int temp;
        temp = a[x];
        a[x] = a[y];
        a[y] = temp;
    }

    public void sortArrayOf012_2(int[] arr) {

        //.............T: O(N)
        //.............S: O(1)
        //https://leetcode.com/problems/sort-colors/
        //https://www.geeksforgeeks.org/sort-an-array-of-0s-1s-and-2s/
        //based on Dutch National Flag Algorithm
        int start = 0;
        int mid = 0;
        int end = arr.length - 1;
        while (mid <= end) {
            switch (arr[mid]) {
                case 0: {
                    swapIntArray(arr, start, mid);
                    start++;
                    mid++;
                    break;
                }
                case 1:
                    mid++;
                    break;
                case 2: {
                    swapIntArray(arr, mid, end);
                    end--;
                    break;
                }
            }
        }
        //output
        for (int val : arr) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private void nextPermutation_Print(int[] nums) {
        for (int x : nums) {
            System.out.print(x);
        }
        System.out.println();
    }

    public void nextPermutation(int[] nums) {

        int N = nums.length;

        //length == 1
        if (N == 1) {
            //output:
            nextPermutation_Print(nums);
            return;
        }

        //check if desc sorted
        boolean descSorted = true;
        for (int i = 1; i < N; i++) {
            if (nums[i - 1] < nums[i]) {
                descSorted = false;
                break;
            }
        }

        if (descSorted) {
            for (int i = 0; i < N / 2; i++) {
                swapIntArray(nums, i, N - i - 1);
            }
            nextPermutation_Print(nums);
            return;
        }

        //any other cases
        int firstDecNumIndex = N - 1;
        for (int i = N - 2; i >= 0; i--) {
            if (nums[i] < nums[firstDecNumIndex]) {
                firstDecNumIndex = i;
                break;
            }
            firstDecNumIndex = i;
        }

        int justGreaterNumIndex = firstDecNumIndex + 1;
        int diff = nums[justGreaterNumIndex] - nums[firstDecNumIndex];
        for (int i = justGreaterNumIndex + 1; i < N; i++) {
            int currDiff = nums[i] - nums[firstDecNumIndex];
            if (currDiff > 0 && currDiff < diff) {
                diff = currDiff;
                justGreaterNumIndex = i;
            }
        }

        swapIntArray(nums, firstDecNumIndex, justGreaterNumIndex);
        Arrays.sort(nums, firstDecNumIndex + 1, N);

        //output:
        nextPermutation_Print(nums);
    }

    private int factorialLargeNumber_Multiply(int x, int[] res, int resSize) {

        int carry = 0;
        for (int i = 0; i < resSize; i++) {
            int prod = res[i] * x + carry;
            res[i] = prod % 10;
            carry = prod / 10;
        }

        while (carry != 0) {

            res[resSize] = carry % 10;
            carry = carry / 10;
            resSize++;
        }

        return resSize;
    }

    public void factorialLargeNumber(int N) {
        int[] res = new int[Integer.MAX_VALUE / 200];
        res[0] = 1;

        int resSize = 1;
        for (int x = 2; x <= N; x++) {
            resSize = factorialLargeNumber_Multiply(x, res, resSize);
        }

        //output
        for (int i = resSize - 1; i >= 0; i--) {
            System.out.print(res[i]);
        }
        System.out.println();
    }

    public void rainWaterTrappingUsingStack(int[] height) {

        //https://leetcode.com/problems/trapping-rain-water/solution/
        //..................T: O(N)
        //..................S: O(N)
        int ans = 0;
        int current = 0;
        int N = height.length;
        Stack<Integer> s = new Stack<>();
        while (current < N) {

            while (!s.isEmpty() && height[current] > height[s.peek()]) {

                int top = s.pop();
                if (s.isEmpty()) {
                    break;
                }

                int distance = current - s.peek() - 1;
                int boundedHeight = Math.min(height[current], height[s.peek()]) - height[top];
                ans += distance * boundedHeight;
            }
            s.push(current++);
        }

        //output
        System.out.println("Rain water trapping using stack: " + ans);
    }

    public void rainWaterTrappingUsingTwoPointers(int[] height) {
        //https://leetcode.com/problems/trapping-rain-water
        //OPTIMISED than stack
        //..................T: O(N)
        //..................S: O(1)
        int left = 0;
        int right = height.length - 1;
        int ans = 0;
        int leftMax = 0;
        int rightMax = 0;
        while (right > left) {
            if (height[left] < height[right]) {

                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    ans += (leftMax - height[left]);
                }

                left++;
            } else {

                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    ans += (rightMax - height[right]);
                }

                right--;
            }
        }

        //output
        System.out.println("Rain water trapping using tow pointers: " + ans);
    }

    public void findMaximumProductSubarray(int[] nums) {
        //https://leetcode.com/problems/maximum-product-subarray/
        //Explanation: https://www.youtube.com/watch?v=lXVy6YWFcRM
        //based on KADANES ALGO
        int result = Integer.MIN_VALUE;
        int currMaxProd = 1;
        int currMinProd = 1;
        for (int val : nums) {
            int tempCurrMax = currMaxProd;
            currMaxProd = Math.max(Math.max(val * currMaxProd, val * currMinProd), val);
            currMinProd = Math.min(Math.min(val * tempCurrMax, val * currMinProd), val);
            result = Math.max(currMaxProd, result);
        }

        //output:
        System.out.println("Maximum product subarray: " + result);
    }

    public int kadaneAlgorithm(int[] arr) {

        //for finding maximum sum subarray
        int maxSum = arr[0];
        int currMaxSum = arr[0];
        for (int i = 1; i < arr.length; i++) {
            currMaxSum = Math.max(arr[i], currMaxSum + arr[i]);
            maxSum = Math.max(maxSum, currMaxSum);
        }
        //output
        return maxSum;
    }

    public void kadaneAlgorithm_PointingIndexes(int[] arr) {

        int maxSum = 0;
        int currMaxSum = 0;
        int maxElement = Integer.MIN_VALUE;
        int maxElementIndex = 0;

        int start = 0;
        int end = 0;
        int index = 0;
        while (index < arr.length) {

            currMaxSum += arr[index];
            //case to handle all negative element
            if (arr[index] > maxElement) {
                maxElement = arr[index];
                maxElementIndex = index;
            }
            if (currMaxSum < 0) {
                currMaxSum = 0;
                start = index + 1;
            }
            if (maxSum < currMaxSum) {
                maxSum = currMaxSum;
                end = index;
            }
            index++;
        }

        //output:
        System.out.println("Max sum subarray with start & end: "
                + (maxSum == 0
                        ? maxElement + " Start: " + maxElementIndex + " end: " + maxElementIndex
                        : maxSum + " Start: " + start + " end: " + end)
        );
    }

    public void moveNegativeElementsToOneSideOfArray(int[] arr) {

        //Two pointer approach
        //...........................T: O(N)
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();

        int n = arr.length;
        int negativeIndex = 0;
        int positiveIndex = n - 1;

        while (positiveIndex > negativeIndex) {

            //if any element in left side id already a -ve then that element should be taken into consideration
            //move to next element
            while (negativeIndex < positiveIndex && arr[negativeIndex] < 0) {
                negativeIndex++;
            }

            //same way any +ve no on the right side should not be counted and move to next element
            while (negativeIndex < positiveIndex && arr[positiveIndex] > 0) {
                positiveIndex--;
            }

            //as we are planning to shift all the -ve elements to left side of array
            //after above while loops we will be having
            // +ve element (arr[f] > 0) in left side AND any -ve element(arr[h] <0) on right side should be swapped 
            swapIntArray(arr, negativeIndex, positiveIndex);
            negativeIndex++;
            positiveIndex--;
        }

        //output:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void findUnionAndIntersectionOfTwoArrays(int[] a, int[] b) {

        int m = a.length;
        int n = b.length;
        int maxLen = Math.max(m, n);
        Set<Integer> unionSet = new HashSet<>();
        for (int i = 0; i < maxLen; i++) {

            if (i < m) {
                unionSet.add(a[i]);
            }

            if (i < n) {
                unionSet.add(b[i]);
            }
        }

        //output
        System.out.println("No of union element: " + unionSet.size() + " elements: " + unionSet);

        //finding intersection of two array
        Set<Integer> aSet = new HashSet<>();
        Set<Integer> bSet = new HashSet<>();
        for (int x : a) {
            aSet.add(x);
        }
        for (int x : b) {
            bSet.add(x);
        }

        Set<Integer> intersectionSet = new HashSet<>();
        for (int i = 0; i < maxLen; i++) {

            if (i < m) {
                if (aSet.contains(a[i]) && bSet.contains(a[i])) {
                    intersectionSet.add(a[i]);
                }
            }

            if (i < n) {
                if (aSet.contains(b[i]) && bSet.contains(b[i])) {
                    intersectionSet.add(b[i]);
                }
            }
        }

        //output
        System.out.println("No of intersection element: " + intersectionSet.size() + " elements: " + intersectionSet);
    }

    public void rotateArrayByK_BruteForce(int[] arr, int k) {
        //.......................T: O(N^2)
        //https://leetcode.com/problems/rotate-array/
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
        int actualK = k; //just for output purpose
        int n = arr.length;

        while (k-- != 0) {
            int last = arr[n - 1];
            for (int i = n - 1; i >= 1; i--) {
                arr[i] = arr[i - 1];
            }

            arr[0] = last;
        }

        //output:
        System.out.println("Rotate array by " + actualK + " steps output brute force: ");
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    private void rotateArrayByK_ReverseArray(int[] arr, int start, int end) {

        while (end > start) {
            int temp = arr[start];
            arr[start] = arr[end];
            arr[end] = temp;
            start++;
            end--;
        }
    }

    public void rotateArrayByK(int[] arr, int k) {
        //......................T: O(N)
        //https://leetcode.com/problems/rotate-array/
        //explanation: https://youtu.be/BHr381Guz3Y
        //actual:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();

        int len = arr.length;
        //if k > len, mod it with len so that k always fall under range of len
        k = k % len;
        int start = 0;
        //reverse the array
        rotateArrayByK_ReverseArray(arr, start, len - 1);

        //reverse first [0 to k] elements
        rotateArrayByK_ReverseArray(arr, start, k - 1);

        //reverse remaining [k to len] elements
        rotateArrayByK_ReverseArray(arr, k, len - 1);

        //output:
        System.out.println("Rotate array by " + k + " steps output approach2: ");
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void minimizeDifferenceBetweenHeights(int[] arr, int k) {

        //problem statement: https://practice.geeksforgeeks.org/problems/minimize-the-heights3351/1
        //sol: https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/
        int n = arr.length;

        Arrays.sort(arr);

        int ans = arr[n - 1] - arr[0];

        int big = arr[0] + k;
        int small = arr[n - 1] - k;

        int temp = big;
        big = Math.max(big, small);
        small = Math.min(temp, small);

        //all in between a[0] to a[n-1] i.e, a[1] -> a[n-2]
        for (int i = 1; i < n - 1; i++) {

            int subtract = arr[i] - k;
            int add = arr[i] + k;

            // If both subtraction and addition 
            // do not change diff 
            if (subtract >= small || add <= big) {
                continue;
            }

            // Either subtraction causes a smaller 
            // number or addition causes a greater 
            // number. Update small or big using 
            // greedy approach (If big - subtract 
            // causes smaller diff, update small 
            // Else update big) 
            if (big - subtract <= add - small) {
                small = subtract;
            } else {
                big = add;
            }
        }
        //output:
        System.out.println("Min height: " + Math.min(ans, big - small));
    }

    public void bestProfitToBuySellStock(int[] prices) {

        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
        int buy = Integer.MAX_VALUE;
        int maxProfit = 0;
        for (int i = 0; i < prices.length; i++) {
            //buy any stock at min price, so find a price < minPrice
            if (prices[i] < buy) {
                buy = prices[i];
            }

            //if any price > minPrice, we can sell that stock to earn profit
            //maxProfit = max(maxProfit, price - minPrice)
            maxProfit = Math.max(maxProfit, prices[i] - buy);
        }

        //output:
        System.out.println("Maximum profit from buying and selling the stocks: " + maxProfit);
    }

    public void countAllPairsInArrayThatSumIsK(int[] arr, int K) {
        /*
         //brute force apprach
         //........................T: O(N^2)
         int pairCount = 0;
         for(int i=0; i<arr.length; i++){
         for(int j=i+1; j<arr.length; j++){
         if(arr[i] + arr[j] == K){
         pairCount++;
         }
         }
         }
        
         System.out.println("Count of pairs whose sum is equal to K: "+pairCount);
         */

        //Time optimised approach
        //https://www.geeksforgeeks.org/count-pairs-with-given-sum/
        //.......................T: O(N)
        //.......................S: O(N)
        Map<Integer, Integer> map = new HashMap<>();
        for (int val : arr) {
            map.put(val, map.getOrDefault(val, 0) + 1);
        }

        int pairCount = 0;
        for (int val : arr) {
            pairCount += map.getOrDefault(K - val, 0);

            if (K - val == val) {
                pairCount--;
            }
        }

        System.out.println("Count of pairs whose sum is equal to K: " + pairCount / 2);
    }

    public boolean checkIfSubarrayWithSum0(int[] arr) {

        int n = arr.length;
        int sum = 0;
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i++) {
            sum += arr[i];

            if (arr[i] == 0 || sum == 0 || set.contains(sum)) {
                return true;
            }
            set.add(sum);
        }
        return false;
    }

    public void bestProfitToBuySellStockCanHoldAtmostOneStock(int[] prices) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/2058747/JAVA-or-Single-loop-solution
        int n = prices.length;
        int min = prices[0];
        int max = prices[0];
        int profit = 0;
        for (int price : prices) {
            if (price > max) {
                max = price;
            } else {
                profit += max - min;
                min = price;
                max = price;
            }
        }
        //output:
        System.out.println("Max profit frm buying selling stock atmost twice: " + (profit + max - min));
    }

    public void bestProfitToBuySellStockAtMostTwice(int[] prices) {

        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
        int n = prices.length;
        int[] maxProfits = new int[n];

        int maxSellingPrice = prices[n - 1];
        //looping all prices and checking if currBuyPrice will
        //give max profit from if sold at maxSellingPrice
        for (int i = n - 2; i >= 0; i--) {
            int currBuyPrice = prices[i];
            if (currBuyPrice > maxSellingPrice) {
                maxSellingPrice = currBuyPrice;
            }
            //choosing the max profits, that we already have seen(maxProfit[i + 1])
            //or if we buy at currBuyPrice and sell at maxSellingPrice
            maxProfits[i] = Math.max(maxProfits[i + 1], maxSellingPrice - currBuyPrice);
        }

        int minBuyPrice = prices[0];
        //looping all prices and checking if currSellPrice will
        //give max profit from if previously bought at minBuyPrice
        for (int i = 1; i < n; i++) {
            int currSellPrice = prices[i];
            if (minBuyPrice > currSellPrice) {
                minBuyPrice = currSellPrice;
            }
            //choosing the max profits, that we already have seen(maxProfit[i - 1])
            //or if we sell at currSellPrice that was bought at minBuyPrice
            //in addition with the previous max profit((bought and sold from above loop)maxProfit[i])
            maxProfits[i] = Math.max(maxProfits[i - 1], maxProfits[i] + (currSellPrice - minBuyPrice));
        }

        //output:
        System.out.println("Max profit frm buying selling stock atmost twice: " + maxProfits[n - 1]);
    }

    public void mergeIntervals_1(int[][] intervals) {

        //.................................T: O(N.LogN)
        //https://leetcode.com/problems/merge-intervals/
        //https://leetcode.com/problems/non-overlapping-intervals/
        System.out.println("approach 1");
        List<int[]> result = new ArrayList<>();

        if (intervals == null || intervals.length == 0) {
            //return result.toArray(new int[0][]);
            return;
        }

        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        int prevStart = intervals[0][0];
        int prevEnd = intervals[0][1];

        for (int i = 1; i < intervals.length; i++) {

            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (currStart <= prevEnd) {
                //overlapping situation, choose the max end time out of two that can cover most intervals
                prevEnd = Math.max(prevEnd, currEnd);
            } else if (currStart > prevEnd) {
                //no overlapp situation
                result.add(new int[]{prevStart, prevEnd});
                prevStart = currStart;
                prevEnd = currEnd;
            }
        }

        //final pair
        result.add(new int[]{prevStart, prevEnd});
        //output:
        int[][] output = result.toArray(new int[result.size()][]);
        for (int[] r : output) {
            System.out.print("[");
            for (int c : r) {
                System.out.print(c + " ");
            }
            System.out.println("]");
            System.out.println();
        }
    }

    public void mergeIntervals_2(int[][] intervals) {

        //.................................T: O(N.LogN)
        //https://leetcode.com/problems/merge-intervals/
        System.out.println("approach 2");
        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));
        LinkedList<int[]> merged = new LinkedList<>();
        for (int[] interval : intervals) {

            if (merged.isEmpty() || merged.getLast()[1] < interval[0]) {
                merged.add(interval);
            } else {
                merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]);
            }
        }

        //output:
        int[][] output = merged.toArray(new int[merged.size()][]);
        for (int[] r : output) {
            System.out.print("[");
            for (int c : r) {
                System.out.print(c + " ");
            }
            System.out.println("]");
            System.out.println();
        }
    }

    public void minOperationsToMakeArrayPallindrome(int[] arr) {

        //TWO POINTERS
        int n = arr.length;
        int start = 0;
        int end = n - 1;
        int minOpr = 0;
        while (end >= start) {

            if (arr[start] == arr[end]) {
                start++;
                end--;
            } else if (arr[start] > arr[end]) {
                end--;
                arr[end] += arr[end + 1];
                minOpr++;
            } else {
                start++;
                arr[start] += arr[start - 1];
                minOpr++;
            }
        }

        //output:
        System.out.println("Minimum operation to make array pallindrome: " + minOpr);
    }

    public void productOfArrayExcludingElementItself_BruteForce(int[] arr) {

        //.....................T: O(N)
        int n = arr.length;
        int[] result = new int[n];
        int prod = 1;

        for (int i = 0; i < n; i++) {
            prod *= arr[i];
        }

        for (int i = 0; i < n; i++) {
            result[i] = prod / arr[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void productOfArrayExcludingElementItself_Optimised1(int[] arr) {

        //.....................T: O(N)
        //.....................S: O(N)
        int n = arr.length;
        int[] result = new int[n];
        int[] leftProd = new int[n];
        int[] rightProd = new int[n];

        leftProd[0] = 1;
        rightProd[n - 1] = 1;

        for (int i = 1; i < n; i++) {
            leftProd[i] = leftProd[i - 1] * arr[i - 1];
        }

        for (int i = n - 2; i >= 0; i--) {
            rightProd[i] = rightProd[i + 1] * arr[i + 1];
        }

        for (int i = 0; i < n; i++) {
            result[i] = leftProd[i] * rightProd[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void productOfArrayExcludingElementItself_Optimised2(int[] arr) {

        //.....................T: O(N)
        //.....................S: O(1) //result[] is needed to save output 
        int n = arr.length;
        int[] result = new int[n];

        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * arr[i - 1];
        }

        int right = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] = result[i] * right;
            right *= arr[i];
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void maximumOfAllSubArrayOfSizeK(int[] arr, int K) {
        //https://leetcode.com/problems/sliding-window-maximum/
        //https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/
        List<Integer> result = new ArrayList<>();
        int n = arr.length;
        int index;
        Deque<Integer> queue = new LinkedList<>();
        for (index = 0; index < K; index++) {
            //check curr element >= last added element
            while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[index]) {
                queue.removeLast();
            }
            queue.addLast(index);
        }

        for (; index < n; index++) {

            result.add(arr[queue.peekFirst()]);

            //index => endIndex, q.peekFirst() = startIndex
            //endIndex - startIndex >= window(K) then maintain window size
            while (!queue.isEmpty() && index - queue.peekFirst() >= K) {
                queue.removeFirst();
            }

            while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[index]) {
                queue.removeLast();
            }
            queue.addLast(index);
        }
        result.add(arr[queue.peekFirst()]);

        //output:
        System.out.println("Max of all subarrays of size K: " + result);
    }

    public void averageWaitingTime(int[][] customers) {
        //https://leetcode.com/problems/average-waiting-time
        double n = customers.length;
        double timeAtPrevOrderEnd = 0;
        double totalTime = 0;
        for (int[] order : customers) {
            int arrivalTime = order[0];
            int prepTime = order[1];
            timeAtPrevOrderEnd = (timeAtPrevOrderEnd > arrivalTime ? timeAtPrevOrderEnd : arrivalTime)
                    + prepTime;
            totalTime += (timeAtPrevOrderEnd - arrivalTime);
        }
        //output:
        System.out.println("Average waitig time: " + (totalTime / n));
    }

    public int minimumTimeDifference(List<String> timePoints) {

        //problem statement: https://leetcode.com/problems/minimum-time-difference/
        //explanation: https://youtu.be/c5ecNf7JM1Q
        //1 hour = 60 min
        //24 hour = 24 * 60 min == 1440 min
        boolean[] everyMinute = new boolean[24 * 60]; //[1440]

        //convert the string "HH:MM" time format to minute only 
        for (String time : timePoints) {
            String[] timeSplit = time.split(":");
            int hour = Integer.parseInt(timeSplit[0]);
            int minute = Integer.parseInt(timeSplit[1]);

            //total minute in an hour = hour * 60 + minute
            //that total minute is minute based index in everyMinute
            int minuteIndex = (hour * 60) + minute;
            //if a minute is already seen and that same timePoint comes again
            //the diff b/w these two timePoints is minimum
            //ex: "10:02", "10:02"
            if (everyMinute[minuteIndex]) {
                return 0;
            }
            everyMinute[minuteIndex] = true;
        }

        int firstTime = -1;
        int prevTime = -1;
        int minDiff = Integer.MAX_VALUE;

        for (int i = 0; i < 1440; i++) {

            if (everyMinute[i]) {

                if (firstTime == -1) {

                    firstTime = i;
                    prevTime = i;
                } else {

                    minDiff = Math.min(minDiff, Math.min(
                            i - prevTime, //clockwise dir
                            1440 - i + prevTime //anti clockwise dir
                    ));

                    prevTime = i;
                }
            }
        }

        minDiff = Math.min(minDiff, Math.min(
                prevTime - firstTime, //clockwise dir
                1440 - prevTime + firstTime //anti clockwise dir
        ));

        return minDiff;
    }

    public void contigousArrayWithEqualZeroAndOne(int[] arr) {

        //https://leetcode.com/problems/contiguous-array/
        Map<Integer, Integer> prefixSumIndexes = new HashMap<>();
        prefixSumIndexes.put(0, -1);
        int prefixSum = 0;
        int maxLen = 0;

        for (int i = 0; i < arr.length; i++) {

            prefixSum += arr[i] == 1 ? 1 : -1;

            if (prefixSumIndexes.containsKey(prefixSum)) {
                maxLen = Math.max(maxLen, i - prefixSumIndexes.get(prefixSum));
            } else {
                prefixSumIndexes.put(prefixSum, i);
            }
        }
        //output:
        System.out.println("Max length: " + maxLen);
    }

    public void maxSumPathInTwoSortedArrays(int[] arr1, int[] arr2) {

        //https://www.geeksforgeeks.org/maximum-sum-path-across-two-arrays/
        int m = arr1.length;
        int n = arr2.length;

        int result = 0;
        int arrSum1 = 0;
        int arrSum2 = 0;

        int i = 0; // for arr1
        int j = 0; // for arr2

        while (i < m && j < n) {

            if (arr1[i] < arr2[j]) {
                arrSum1 += arr1[i++];
            } else if (arr1[i] > arr2[j]) {
                arrSum2 += arr2[j++];
            } else {
                //common point
                result += Math.max(arrSum1, arrSum2);

                arrSum1 = 0;
                arrSum2 = 0;

                int temp = i;
                while (i < m && arr1[i] == arr2[j]) {
                    arrSum1 += arr1[i++];
                }

                while (j < n && arr1[temp] == arr2[j]) {
                    arrSum2 += arr2[j++];
                }

                result += Math.max(arrSum1, arrSum2);

                arrSum1 = 0;
                arrSum2 = 0;
            }
        }

        while (i < m) {
            arrSum1 += arr1[i++];
        }

        while (j < n) {
            arrSum2 += arr2[j++];
        }

        result += Math.max(arrSum1, arrSum2);

        //output:
        System.out.println("Max path sum: " + result);
    }

    public void asteroidCollision(int[] asteroids) {

        //https://leetcode.com/problems/asteroid-collision/
        //explanation: https://youtu.be/6GGTBM7mwfs

        /*
         cond when two collide
         peek = -ve, incoming = -ve = left, left dir no collision //1 if cond in while()
         peek = -ve, incoming = +ve = left, right dir no collision //1 if cond in for()
         peek = +ve, incoming = +ve = right, right dir no collision //1 if cond in for()
         peek = +ve, incoming = -ve = right, left dir will collision
         if(abs(incoming) > peek) all peek will be destroyed and incoming will remain in sack //last else cond   
         if(abs(incoming) < peek) incoming will be destroyed and stack remain same //3 else if cond
         if(abs(incoming) == peek) both will be destroyed and stack need to pop out peek value //2 else if cond
        
         */
        Stack<Integer> stack = new Stack<>();

        for (int stone : asteroids) {
            if (stack.isEmpty() || stone > 0) {
                stack.push(stone);
            } else {
                while (true) {
                    int prevStone = stack.peek();
                    if (prevStone < 0) {
                        //prevStone = -ve, stone = -ve => left, left
                        //prevStone = -ve, stone = +ve => left, right
                        //both cases not collision will happen and we
                        //can add stone to our stack
                        stack.push(stone);
                        break;
                    } else if (prevStone == -stone) {
                        //prevStone = +ve, stone = -ve => 
                        //prevStone == abs(stone) => right, left & size same
                        stack.pop();
                        break;
                    } else if (prevStone > -stone) {
                        //prevStone = +ve, stone = -ve =>
                        //prevStone > abs(stone) => right, left, stone get destroyed
                        break;
                    } else {
                        //prevStone = +ve, stone = -ve => right, left
                        //but abs(stone) > prevStone then all prevStone under this situation will get destroyed
                        stack.pop();
                        if (stack.isEmpty()) {
                            //once all such prevStone get destroyed, add stone
                            stack.push(stone);
                            break;
                        }
                    }
                }
            }
        }

        //output:
        //int[] output = stack.stream().mapToInt(stone -> stone).toArray();
        int[] output = new int[stack.size()];
        int index = stack.size() - 1;
        while (!stack.isEmpty()) {
            output[index--] = stack.pop();
        }

        for (int x : output) {
            System.out.print(x + " ");
        }

        System.out.println();
    }

    public void jumpGame(int[] nums) {

        //https://leetcode.com/problems/jump-game/
        //Explanation: https://youtu.be/muDPTDrpS28
        int reachablePoint = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > reachablePoint) {
                System.out.println("Can we reach the end of nums array from 0th index: NO");
                return;
            }
            reachablePoint = Math.max(reachablePoint, i + nums[i]);
        }

        System.out.println("can we reach the end of nums array from 0th index: YES");
    }

    public void jumpGameTwo(int[] nums) {
        //https://leetcode.com/problems/jump-game-ii/description/
        //https://leetcode.com/problems/jump-game-ii/solutions/3076867/jump-game-ii/
        int n = nums.length;
        int steps = 0;
        int farthestPoint = 0;
        int endPoint = 0;

        for (int i = 0; i < n - 1; i++) {
            farthestPoint = Math.max(farthestPoint, i + nums[i]);
            if (i == endPoint) {
                steps++;
                endPoint = farthestPoint;
            }
        }
        //output
        System.out.println("Steps to reach the end point : " + steps);
    }

    public void jumpGameThree(int[] nums, int startIndex) {
        //https://leetcode.com/problems/jump-game-iii/
        int n = nums.length;
        boolean[] visited = new boolean[n];
        Queue<Integer> queue = new LinkedList<>();
        queue.add(startIndex);

        while (!queue.isEmpty()) {
            int currIndex = queue.poll();

            if (visited[currIndex] == true) {
                continue;
            }
            visited[currIndex] = true;
            if (nums[currIndex] == 0) {
                System.out.println("Can we reach where nums value is 0 from startIndex index: YES");
                return;
            }

            int leftIndex = currIndex - nums[currIndex];
            int rightIndex = currIndex + nums[currIndex];

            if (leftIndex >= 0) {
                queue.add(leftIndex);
            }
            if (rightIndex < n) {
                queue.add(rightIndex);
            }
        }
        System.out.println("Can we reach where nums value is 0 from startIndex index: NO");
    }

    public int jumpGameFour(int[] nums) {
        //https://leetcode.com/problems/jump-game-iv/
        //exlanation: https://youtu.be/XgP3w7Txvlc
        //BFS approach
        int n = nums.length;

        Map<Integer, List<Integer>> valIndexMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            valIndexMap.putIfAbsent(nums[i], new ArrayList<>());
            valIndexMap.get(nums[i]).add(i);
        }

        int src = 0;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        queue.add(src);

        int steps = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                int currIndex = queue.poll();

                visited.add(currIndex);

                if (currIndex == n - 1) {
                    return steps;
                }

                //i + 1 where: i + 1 < arr.length.
                //i - 1 where: i - 1 >= 0.
                int forward = currIndex + 1;
                int backward = currIndex - 1;

                //j where: arr[i] == arr[j] and i != j.
                List<Integer> sameValIndexJumps = valIndexMap.get(nums[currIndex]);

                //adding in sameValIndexJumps because they will eventually be checked in
                //below for loop if we need to add it in queue
                sameValIndexJumps.add(forward);
                sameValIndexJumps.add(backward);

                for (int jIndex : sameValIndexJumps) {
                    //jIndex || forward || backward indexes is not in arr range
                    // OR these indexes are already visited then skip
                    if (!(jIndex >= 0 && jIndex < n) || visited.contains(jIndex)) {
                        continue;
                    }
                    queue.add(jIndex);
                }
                //clearing because we have already added all the jIndex in queue
                //if at any other point we see arr[i] == arr[j] and i != j.
                //we dont need to redundently add them again and again.
                sameValIndexJumps.clear();
            }
            steps++;
        }
        return -1;
    }

    public boolean jumpGameSeven(String str, int minJump, int maxJump) {
        //https://leetcode.com/problems/jump-game-vii/
        //explanation: https://youtu.be/v1HpZUnQ4Yo
        //BFS approach
        int n = str.length();
        char[] arr = str.toCharArray();

        int src = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(src);

        int farthtestReached = 0;

        while (!queue.isEmpty()) {

            int currIndex = queue.poll();
            int start = Math.max(currIndex + minJump, farthtestReached + 1);
            //range: from currIndex we can move to maxJump + 1 (+1 is to include maxJump also)
            //it can be possible that currIndex + maxJump + 1 is beyond arr[] length
            //so choosing the min of two ranges
            int range = Math.min(currIndex + maxJump + 1, n);
            for (int next = start; next < range; next++) {
                if (arr[next] == '0') {
                    if (next == n - 1) {
                        return true;
                    }
                    queue.add(next);
                }
            }
            farthtestReached = currIndex + maxJump;
        }
        return false;
    }

    public boolean frogJump(int[] stones) {
        //https://leetcode.com/problems/frog-jump/
        class Jump {

            int currStone;
            int jump;

            public Jump(int currStone, int jump) {
                this.currStone = currStone;
                this.jump = jump;
            }

        }

        int n = stones.length;
        int lastStone = stones[n - 1];
        Queue<Jump> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        Set<Integer> stonesSet = new HashSet<>();
        for (int stone : stones) {
            stonesSet.add(stone);
        }

        int currStone = 0;
        int jump = 0;
        queue.add(new Jump(currStone, jump));

        while (!queue.isEmpty()) {
            Jump curr = queue.poll();
            currStone = curr.currStone;
            jump = curr.jump;

            //if we have reached the last stone
            if (currStone == lastStone) {
                return true;
            }

            //if any currStone doesn't exist in the stone list,
            //we can't move there, so continue
            if (!stonesSet.contains(currStone)) {
                continue;
            }
            //from curr jump we can furtehr move to k, k - 1, k + 1 move
            for (int moveK = -1; moveK <= 1; moveK++) {
                //if any currStone and jump previously visited, continue
                if (visited.contains(currStone + "," + (jump + moveK))) {
                    continue;
                }
                queue.add(new Jump(currStone + jump + moveK, jump + moveK));
                visited.add(currStone + "," + (jump + moveK));
            }
        }
        return false;
    }

    public void nextGreaterElement2_CyclicArray(int[] arr) {

        //explanation: https://leetcode.com/problems/next-greater-element-ii/solution/
        //array to be considered as cyclic
        int n = arr.length;
        int[] output = new int[n];
        Stack<Integer> stack = new Stack<>();
        for (int i = 2 * n - 1; i >= 0; i--) {

            while (!stack.isEmpty() && arr[stack.peek()] <= arr[i % n]) {
                stack.pop();
            }

            output[i % n] = stack.isEmpty() ? -1 : arr[stack.peek()];

            stack.push(i % n);
        }

        //output:
        System.out.println("Next greater element 2 in cyclic array : " + Arrays.toString(output));
    }

    public void findMedianInDataStream(int[] stream) {

        //explanantion: https://leetcode.com/problems/find-median-from-data-stream/solution/
        //[HEAP BASED]
        PriorityQueue<Integer> minHeap = new PriorityQueue<>((a, b) -> a.compareTo(b));
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b.compareTo(a));

        for (int num : stream) {

            maxHeap.add(num);
            minHeap.add(maxHeap.poll());

            if (maxHeap.size() < minHeap.size()) {
                maxHeap.add(minHeap.poll());
            }

            double median = maxHeap.size() > minHeap.size()
                    ? maxHeap.peek()
                    : (double) (maxHeap.peek() + minHeap.peek()) * 0.5;

            System.out.println("Median: " + median);
        }
    }

    public void medianOfTwoSortedArrays(int[] arr1, int[] arr2) {
        //.......................T: O(n + m), n & m length of arr1 & arr2
        //.......................S: O(1)
        //https://leetcode.com/problems/median-of-two-sorted-arrays/
        //OPTIMISED
        /*
        brute force 
        approach1 is to put both arrays in a list, sort the list,
        then on the basis of total size of list we can find median
        odd length = list[size / 2]
        even length = (list[size / 2] + list[(size / 2) - 1]) / 2.0
        this will take
        T: O((n + m).Log(n + m)), n & m length of arr1 & arr2, for adding
        both arrays in list and then sorting list again
        S: O(n + m), for list we make
        
        approach2 is to use the fact that our given arrays arr1 & arr2 are
        already sorted, we can use below while() to create our list that will
        reduce our T: O(n + m) but S: O(n + m)
        
        but below approach is OPTIMIZED because we know that to find the median
        we need to find the median point of both arrays combined, rather than
        creating a list, we can calculate the medianPoint uptil its <= len / 2 
         */
        int n = arr1.length;
        int m = arr2.length;

        int len = n + m;
        boolean isLengthEven = len % 2 == 0;
        int medianPoint = 0;

        double midVal = 0;
        double midValPrev = midVal;

        int i = 0;
        int j = 0;

        while (i < n && j < m && medianPoint <= len / 2) {
            if (arr1[i] <= arr2[j]) {
                midValPrev = midVal;
                midVal = arr1[i];
                i++;
            } else {
                midValPrev = midVal;
                midVal = arr2[j];
                j++;
            }
            medianPoint++;
        }

        while (i < n && medianPoint <= len / 2) {
            midValPrev = midVal;
            midVal = arr1[i];
            i++;
            medianPoint++;
        }

        while (j < m && medianPoint <= len / 2) {
            midValPrev = midVal;
            midVal = arr2[j];
            j++;
            medianPoint++;
        }

        double medianOfTwoSortedArrays = isLengthEven
                ? (midVal + midValPrev) / 2.0
                : midVal;
        //output
        System.out.println("Median of two sorted arrays: " + medianOfTwoSortedArrays);
    }

    public void numPairsDivisibleBy60(int[] times) {

        //https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
        int[] seen = new int[60];
        int result = 0;

        for (int time : times) {
            int hashedTime = time % 60;
            int complement = 60 - hashedTime == 60 || 60 - hashedTime < 0
                    ? 0 : 60 - hashedTime;
            result += seen[complement];
            seen[hashedTime]++;
        }

        //output:
        System.out.println("Total pair: " + result);
    }

    private int mergeSort(int[] arr, int start, int mid, int end) {

        int[] left = Arrays.copyOfRange(arr, start, mid + 1); //start to mid
        int[] right = Arrays.copyOfRange(arr, mid + 1, end + 1); //mid + 1 to end
//        IntStream.of(left).boxed().forEach(row -> System.out.println(row));
//        System.out.println();
//        IntStream.of(right).boxed().forEach(row -> System.out.println(row));
        int i = 0;
        int j = 0;
        int k = start;
        int swaps = 0;
        while (i < left.length && j < right.length) {

            if (left[i] <= right[j]) {
                arr[k++] = left[i++];
            } else {
                arr[k++] = right[j++];
                swaps += (mid + 1) - (start + i);
            }
        }

        while (i < left.length) {
            arr[k++] = left[i++];
        }

        while (j < right.length) {
            arr[k++] = right[j++];
        }

        return swaps;
    }

    private int divideAndMerge(int[] arr, int start, int end) {
        int count = 0;
        if (end > start) {

            int mid = start + (end - start) / 2;
            count += divideAndMerge(arr, start, mid);
            count += divideAndMerge(arr, mid + 1, end);
            count += mergeSort(arr, start, mid, end);
        }
        return count;
    }

    public void countInversion(int[] arr) {

        //..........................T: O(n log n)
        //..........................S: O(N) temp(left, right arrays)
        //https://www.geeksforgeeks.org/counting-inversions/
        int n = arr.length;
        int countInversion = divideAndMerge(arr, 0, n - 1);
        System.out.println("Count inversion: " + countInversion);
        //array is also got sorted
//        for(int row: arr){
//            System.out.print(row+" ");
//        }
    }

    public void minimumWindowSubarrayForTargetSumK(int[] arr, int K) {

        //SLIDING WINDOW BASIC
        //explanation: https://youtu.be/jKF9AcyBZ6E
        int start = 0;
        int end = 0;
        int sum = 0;
        int win = Integer.MAX_VALUE;
        int index = 0;
        while (end < arr.length) {

            sum += arr[end];

            while (sum >= K) {
                win = Math.min(win, end - start + 1);
                index = start;
                sum -= arr[start];
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Minimum length of subarrays whose sum (>= K): " + (win >= Integer.MAX_VALUE ? 0 : win));
        System.out.println("array element:");
        if (win != Integer.MAX_VALUE) {
            for (int i = 0; i < win; i++) {
                System.out.print(arr[index + i] + " ");
            }
        }
        System.out.println();
    }

    public void flipMZerosFindMaxLengthOfConsecutiveOnes(int[] arr, int M) {
        //https://leetcode.com/problems/max-consecutive-ones-iii/
        int start = 0;
        int end = 0;
        int zeroCount = 0;
        int bestWin = 0;
        int bestStart = 0;

        while (end < arr.length) {

            if (zeroCount <= M) {
                if (arr[end] == 0) {
                    zeroCount++;
                }
                end++;
            }

            if (zeroCount > M) {
                if (arr[start] == 0) {
                    zeroCount--;
                }
                start++;
            }

            if (end - start > bestWin && zeroCount <= M) {
                bestWin = end - start;
                bestStart = start;
            }
        }

        //output
        System.out.println("Length of consecutive ones after flipping M zeros: " + bestWin);
        System.out.println("Indexs of zeros to flip");
        for (int i = 0; i < bestWin; i++) {
            if (arr[bestStart + i] == 0) {
                System.out.print((bestStart + i) + " ");
            }
        }
        System.out.println();
    }

    public void firstNegativeNumberInWindowKFromArray(int[] arr, int K) {
        //SLIDING WINDOW and modification of maximumOfAllSubArrayOfSizeK()
        Deque<Integer> dQueue = new LinkedList<>();
        List<Integer> result = new ArrayList<>();
        int index = 0;

        for (; index < K; index++) {
            if (arr[index] < 0) {
                dQueue.addLast(index);
            }
        }

        while (index < arr.length) {

            result.add(dQueue.isEmpty() ? 0 : arr[dQueue.peekFirst()]);

            while (!dQueue.isEmpty() && index - dQueue.peekFirst() >= K) {
                dQueue.removeFirst();
            }

            if (arr[index] < 0) {
                dQueue.addLast(index);
            }
            index++;
        }

        result.add(dQueue.isEmpty() ? 0 : arr[dQueue.peekFirst()]);

        //output
        //int[] output = result.stream().mapToInt(val -> val).toArray();
        System.out.println("First negative number in window of K: " + result);
    }

    public boolean handOfStraight(int[] arr, int W) {

        //https://leetcode.com/problems/hand-of-straights/
        //explanation: https://leetcode.com/problems/hand-of-straights/solution/
        int n = arr.length;
        //if we can not make a group of size (W) out of n length arr return false
        if (n % W != 0) {
            return false;
        }

        TreeMap<Integer, Integer> map = new TreeMap<>(); //TreeMap is important
        for (int c : arr) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        while (!map.isEmpty()) {
            //treemap.firstKey() returns first lowest key from the treemap
            int firstLowestKey = map.firstKey();
            for (int c = firstLowestKey; c < firstLowestKey + W; c++) {
                if (!map.containsKey(c)) {
                    return false;
                }

                map.put(c, map.get(c) - 1);
                if (map.get(c) <= 0) {
                    map.remove(c);
                }
            }
        }

        return true;
    }

    public void sortedSquaresOfSortedArray_1(int[] arr) {

        //..........................T: O(N)
        //..........................S: O(N)
        //https://leetcode.com/problems/squares-of-a-sorted-array/
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int x : arr) {
            minHeap.add(x * x);
        }

        int[] result = new int[arr.length];
        int index = 0;
        while (!minHeap.isEmpty()) {
            result[index++] = minHeap.poll();
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void sortedSquaresOfSortedArray_2(int[] arr) {

        //OPTIMISED
        //..........................T: O(N)
        //..........................S: O(1)
        //https://leetcode.com/problems/squares-of-a-sorted-array/
        int n = arr.length;

        int firstPositiveIndex = 0;
        while (firstPositiveIndex < n && arr[firstPositiveIndex] < 0) {
            firstPositiveIndex++;
        }

        int lastNegativeIndex = firstPositiveIndex - 1;

        int[] result = new int[n];
        int index = 0;
        while (lastNegativeIndex >= 0 && firstPositiveIndex < n) {

            int negativeSqr = arr[lastNegativeIndex] * arr[lastNegativeIndex];
            int positiveSqr = arr[firstPositiveIndex] * arr[firstPositiveIndex];

            if (negativeSqr < positiveSqr) {
                result[index++] = negativeSqr;
                lastNegativeIndex--;
            } else {
                result[index++] = positiveSqr;
                firstPositiveIndex++;
            }
        }

        while (lastNegativeIndex >= 0) {

            int negativeSqr = arr[lastNegativeIndex] * arr[lastNegativeIndex];
            result[index++] = negativeSqr;
            lastNegativeIndex--;
        }

        while (firstPositiveIndex < n) {

            int positiveSqr = arr[firstPositiveIndex] * arr[firstPositiveIndex];
            result[index++] = positiveSqr;
            firstPositiveIndex++;
        }

        //output:
        for (int x : result) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void moveZeroesToEnd(int[] arr) {

        //https://leetcode.com/problems/move-zeroes/
        int index = 0;
        //move all non-zero elements to index location and update index ptr
        for (int x : arr) {
            if (x != 0) {
                arr[index++] = x;
            }
        }

        //from curr index location fill array with 0
        for (; index < arr.length; index++) {
            arr[index] = 0;
        }

        //output:
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void containerWithMostWater(int[] height) {

        //.......................T: O(N)
        //https://leetcode.com/problems/container-with-most-water/
        //explanation: https://youtu.be/6PrIRPpTI9Q
        //maxArea b/w two maxima
        //ex: [1,8,6,2,5,4,8,3,7]
        //min of two maxima(height[]) * dist b/w two maxima(index dist)
        //first 2 maxima = 8(ind 1) & 8(ind 6) area = min(8, 8) * (6 - 1) = 8 * 5 = 40
        //other 2 maxima = 8(ind 1) & 7(ind 8) area = min(8, 7) * (8 - 1) = 7 * 7 = 49 (MAX_AREA)
        int n = height.length;
        int start = 0;
        int end = n - 1;
        int maxArea = 0;
        int area = 0;

        while (end > start) {
            //water can be contained within two heights where one of height is
            //lesser than the other one and max height upto water can be filled without
            //overflowing is min(height[start], height[end])
            if (height[start] < height[end]) {
                //calculations: area = length * breadth
                area = height[start] * (end - start);
                maxArea = Math.max(maxArea, area);
                start++;
            } else {
                area = height[end] * (end - start);
                maxArea = Math.max(maxArea, area);
                end--;
            }
        }

        //output:
        System.out.println("Most water can be contained with area of: " + maxArea);
    }

    public int smallestMissingPositiveNumber(int[] arr) {

        //........................T: O(N)
        //explanation: https://www.youtube.com/watch?v=-lfHWWMmXXM
        if (arr == null || arr.length == 0) {
            return 0;
        }

        int n = arr.length;
        int i = 0;

        for (; i < n; i++) {
            int index = arr[i] - 1;
            while (arr[i] > 0 && arr[i] < n
                    && arr[i] != arr[index]) {

                //swap
                int temp = arr[i];
                arr[i] = arr[index];
                arr[index] = temp;
                index = arr[i] - 1; //update
            }
        }

        for (i = 0; i < n; i++) {
            if (arr[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }

    public void subarraySumEqualsK(int[] arr, int K) {
        //https://leetcode.com/problems/subarray-sum-equals-k/
        //explanation: https://youtu.be/BrWp4gf10fs
        int result = 0;
        int prefixSum = 0;
        Map<Integer, Integer> prefixSumCounter = new HashMap<>();
        prefixSumCounter.put(0, 1); //default sum -> occurence

        for (int element : arr) {
            prefixSum += element;
            result += prefixSumCounter.getOrDefault(prefixSum - K, 0);
            prefixSumCounter.put(prefixSum, prefixSumCounter.getOrDefault(prefixSum, 0) + 1);
        }

        //output:
        System.out.println("Subarrays whose sum equals to K: " + result);
    }

    public void longestSubarrayWithSumEqualsK(int[] arr, int K) {
        //https://www.geeksforgeeks.org/longest-sub-array-sum-k/
        //https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1
        //based on subarraySumEqualsK()
        int n = arr.length;
        int prefixSum = 0;
        int maxLen = 0;
        Map<Integer, Integer> prefixSumIndexes = new HashMap<>();
        //a default prefix sum of 0 exists at index -1
        prefixSumIndexes.put(0, -1);

        for (int i = 0; i < n; i++) {

            prefixSum += arr[i];

            if (!prefixSumIndexes.containsKey(prefixSum)) {
                prefixSumIndexes.put(prefixSum, i);
            }

            if (prefixSumIndexes.containsKey(prefixSum - K)) {
                maxLen = Math.max(maxLen, i - prefixSumIndexes.get(prefixSum - K));
            }
        }

        //output:
        System.out.println("Longest subarrays whose sum equals to K: " + maxLen);
    }

    public boolean continousSubarraySum(int[] nums, int k) {
        //https://leetcode.com/problems/continuous-subarray-sum/
        //explanation: https://youtu.be/M9IaD8oSSoQ
        //based on subarraySumEqualsK()
        /*
        To understand this question, you have to understand how remainders work.
        If k = 5, then 6 % 5 = 1, which also means (6 + 5) % 5 = 1. So you use a
        hash map to check if you have seen that remainder before. If yes, then
        you know between both indexes, it is 5 (i.e. (6 + 5) - 6 = 5).
        This question tests nothing other than knowing how remainders work.
         */
        int n = nums.length;
        Map<Integer, Integer> remainderIndexMap = new HashMap<>();
        remainderIndexMap.put(0, -1); // default remainder 0 with index as -1
        int prefixSum = 0;
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int rem = prefixSum % k;
            if (remainderIndexMap.containsKey(rem)) {
                if (i - remainderIndexMap.get(rem) >= 2) {
                    return true;
                }
            } else {
                remainderIndexMap.put(rem, i);
            }
        }
        return false;
    }

    private int countNicePairsInArray_NumReverse(int num) {
        StringBuilder sb = new StringBuilder(String.valueOf(num)).reverse();
        //remove any preceeding zeroes if any, after the reverse
        //ex: num = 1200, reverse = 0021 remove zeroes = 21
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }
        return Integer.parseInt(sb.toString());
    }

    public void countNicePairsInArray(int[] nums) {
        //https://leetcode.com/problems/count-nice-pairs-in-an-array/
        //https://leetcode.com/problems/count-nice-pairs-in-an-array/discuss/1140804/JAVA-oror-HashMap
        //based on subarraySumEqualsK()
        /*
        A pair of indices (i, j) is nice if it satisfies all of the following
        conditions:
        1. 0 <= i < j < nums.length
        2. nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
         */
        int n = nums.length;
        int mod = 1000000007;
        int pairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int numRev = countNicePairsInArray_NumReverse(nums[i]);
            int diff = nums[i] - numRev;
            pairs = (pairs + freq.getOrDefault(diff, 0)) % mod;
            freq.put(diff, freq.getOrDefault(diff, 0) + 1);
        }
        //output
        System.out.println("Nice pairs count: " + pairs);
    }

    public void countNumberOfBadPairs(int[] nums) {
        //https://leetcode.com/problems/count-number-of-bad-pairs/
        //based on subarraySumEqualsK() & countNicePairsInArray()
        /*
        Count number of bad pairs = TotalPairs - Count number of good pairs
        A pair of indices (i, j) is a bad pair if i < j and j - i != nums[j] - nums[i].
        
        the above cond can be written as 
        bad pairs ==> nums[i] - i != nums[j] - j
        then good pairs ==> nums[i] - i == nums[j] - j
         */
        int n = nums.length;
        //this typecasting of 1L and 2L is req otherwise it was giving error
        long totalPairs = n * (n - 1L) / 2L;
        long goodPairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int diff = nums[i] - i;
            goodPairs += freq.getOrDefault(diff, 0);
            freq.put(diff, freq.getOrDefault(diff, 0) + 1);
        }
        //output
        System.out.println("Count number of bad pairs: " + (totalPairs - goodPairs));
    }

    public void numberOfPairsOfInterchangeableRectangles(int[][] rectangles) {
        //https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/
        //based on subarraySumEqualsK()
        int n = rectangles.length;
        long pairs = 0;
        Map<Double, Long> freq = new HashMap<>();
        for (int i = 0; i < n; i++) {
            double width = rectangles[i][0];
            double height = rectangles[i][1];
            double ratio = width / height;
            pairs += freq.getOrDefault(ratio, 0L);
            freq.put(ratio, freq.getOrDefault(ratio, 0L) + 1L);
        }
        //output
        System.out.println("Number of pairs of interchangeable rectangles: " + pairs);
    }

    public void numberOfSubarraysWithKOddNums(int[] nums, int k) {
        //https://leetcode.com/problems/count-number-of-nice-subarrays/
        //based on subarraySumEqualsK()
        int n = nums.length;
        int countSubarr = 0;

        Map<Integer, Integer> prefixSumCounter = new HashMap<>();
        prefixSumCounter.put(0, 1);

        int oddCount = 0;

        for (int i = 0; i < n; i++) {
            oddCount += nums[i] % 2 == 0 ? 0 : 1;
            countSubarr += prefixSumCounter.getOrDefault(oddCount - k, 0);
            prefixSumCounter.put(oddCount, prefixSumCounter.getOrDefault(oddCount, 0) + 1);
        }
        //output
        System.out.println("Number of subarrays that contains k odd numbers: " + countSubarr);
    }

    public void subarraySumDivisibleByK(int[] arr, int K) {

        //https://leetcode.com/problems/subarray-sums-divisible-by-k/
        //https://leetcode.com/problems/subarray-sums-divisible-by-k/discuss/1227888/Java-Map-soln.
        //explanation: https://youtu.be/QM0klnvTQzk
        //APPROACH similar to subarraySumEqualsK()
        /*
         ex: arr = [4,5,0,-2,-3,1], k = 5
         There are 7 subarrays with a sum divisible by k = 5:
         [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
         */
        Map<Integer, Integer> prefixSumRemainderCounter = new HashMap<>();
        prefixSumRemainderCounter.put(0, 1); // Default: remainder = 0, freq = 1
        int prefixSum = 0;
        int count = 0;

        for (int val : arr) {
            prefixSum += val;
            int remainder = prefixSum % K;
            //handle -ve remainder
            remainder = remainder < 0 ? remainder + K : remainder;
            count += prefixSumRemainderCounter.getOrDefault(remainder, 0);
            prefixSumRemainderCounter.put(remainder,
                    prefixSumRemainderCounter.getOrDefault(remainder, 0) + 1);
        }
        //output
        System.out.println("Total subarrays divisible by K: " + count);
    }

    public void longestSubarraySumDivisibleByK(int[] nums, int k) {
        //https://practice.geeksforgeeks.org/problems/longest-subarray-with-sum-divisible-by-k1259/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article
        //based on subarraySumEqualsK() & subarraySumDivisibleByK()
        int n = nums.length;
        int prefixSum = 0;
        int longestSubarr = 0;
        Map<Integer, Integer> remainderIndex = new HashMap<>();
        //a default remainder of 0 exists at index -1
        remainderIndex.put(0, -1);

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int remainder = prefixSum % k;
            remainder = remainder < 0 ? remainder + k : remainder;
            if (remainderIndex.containsKey(remainder)) {
                longestSubarr = Math.max(longestSubarr, i - remainderIndex.get(remainder));
            } else {
                //why this put() in else part?, because,
                //as we need longest subarray, so if we are seeing a particular
                //remainder in map, then that remainder must maintain its first-occurence
                //of index i.e, i. if we always update an existing remainder with new index
                //i then the longest subarray calculation will be incorrect
                remainderIndex.put(remainder, i);
            }
        }
        //output
        System.out.println("Longest subarray with ssum divisble by k : " + longestSubarr);
    }

    public void subarrayProductLessThanK(int[] nums, int K) {
        //https://leetcode.com/problems/subarray-product-less-than-k/
        //explanation: https://youtu.be/SxtxCSfSGlo
        //based on SLIDING WINDOW
        /*
        
         ex: [10, 5, 2, 6]
         The 8 subarrays that have product less than 100 are: 
         [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].
         Note that [10, 5, 2] is not included as the product of 100 
         is not strictly less than k.
        
         */
        int n = nums.length;
        int subarr = 0;
        int currProd = 1;
        int start = 0;
        int end = 0;

        while (end < n) {

            currProd *= nums[end];

            while (end > start && currProd >= K) {
                currProd /= nums[start];
                start++;
            }

            if (currProd < K) {
                subarr += (end - start + 1);
            }
            end++;
        }

        //output:
        System.out.println("Total subarrays with product less than K: " + subarr);
    }

    public void makeSumDivisibleByK(int[] nums, int k) {
        //https://leetcode.com/problems/make-sum-divisible-by-p/description/
        //https://leetcode.com/problems/make-sum-divisible-by-p/solutions/854197/java-c-python-prefix-sum/
        //based on subarraySumDivisibleByK()
        int n = nums.length;
        int subarrLength = n;
        int arrSumRemainder = 0;
        int prefixSumRemainder = 0;
        Map<Integer, Integer> lastRemainderIndex = new HashMap<>();
        //default case: remainder 0 exist at index -1
        lastRemainderIndex.put(0, -1);

        //calculating the remainder for the whole arr[], if its already 0 then
        //we dont need to remove any subarray(possible empty) to make arr[] sum
        //divisible by k so then the empty subarray length becomes 0
        //but if the remainder is not 0, then there exist a subarray whose sum's
        //remainder is causing this remainder and we need to find that shortest
        //subarray
        for (int val : nums) {
            arrSumRemainder = (arrSumRemainder + val) % k;
        }

        for (int i = 0; i < n; i++) {
            prefixSumRemainder = (prefixSumRemainder + nums[i]) % k;
            lastRemainderIndex.put(prefixSumRemainder, i);
            int prevRemainder = (prefixSumRemainder - arrSumRemainder + k) % k;
            //default subarrLength is n, so if at any time prevRem is not there
            //in map, we get -n as default from this map then i - -n ==> i + n
            //==> a number always greater than n itself(== N) so here min(n, N)
            //will bound to choose n only but if there exist a prevRem whose value
            //is there in map then i - prevRemIndex < n hence min(n, i - prevRemIndex)
            //==> i - prevRemIndex
            subarrLength = Math.min(subarrLength, i - lastRemainderIndex.getOrDefault(prevRemainder, -n));
        }
        //output
        System.out.println("Shortest subarray removal to make remaining sum divisible by k: "
                + (subarrLength < n ? subarrLength : -1));
    }

    public boolean globalAndLocalInversionCountAreEqual(int[] arr) {

        //THIS QUESTION IS NOT SIMILAR TO COUNT INVERSION, follow link for question desc
        //https://leetcode.com/problems/global-and-local-inversions
        //explanantion: https://youtu.be/vFH3zrUbvD4
        /*
        
         The number of (global) inversions is the number of i < j with 0 <= i < j < N and A[i] > A[j].

         The number of local inversions is the number of i with 0 <= i < N and A[i] > A[i+1].
        
         ex: arr = 1, 0, 2
         global = 1, 0 as index 0 < 1 and arr[0] > arr[1]
         local = 1, 0 as index 0 < N and arr[0] > arr[0 + 1]
         so total global inversion  == total local inversion
        
         */
        int n = arr.length;
        int max = -1;
        for (int i = 0; i < n - 2; i++) {
            max = Math.max(max, arr[i]);
            if (max > arr[i + 2]) {
                return false;
            }
        }
        return true;
    }

    public int longestConsecutiveSequence(int[] arr) {
        //https://leetcode.com/problems/longest-consecutive-sequence/
        int N = arr.length;

        if (N == 1) {
            return 1;
        }

        Set<Integer> set = new HashSet<>();
        for (int val : arr) {
            set.add(val);
        }

        int maxLen = 0;
        int currLen;
        for (int val : arr) {
            if (set.contains(val - 1)) {
                continue;
            }
            currLen = 0;
            int nextNum = val;
            while (set.contains(nextNum)) {
                set.remove(nextNum);
                nextNum++;
                currLen++;
            }
            maxLen = Math.max(maxLen, currLen);
        }
        return maxLen;
    }

    public void maxDifferenceOfIndexes(int[] arr) {

        //........................T: O(N)
        //........................S: O(N)
        //OPTIMISED
        //https://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/
        /*
         The task is to find the maximum of j - i subjected to the constraint of A[i] <= A[j].
         */
        int n = arr.length;
        int i;
        int j;
        int maxDiff = -1;
        int[] leftMin = new int[n];
        int[] rightMax = new int[n];

        leftMin[0] = arr[0];
        for (i = 1; i < n; i++) {
            leftMin[i] = Math.min(arr[i], leftMin[i - 1]);
        }

        rightMax[n - 1] = arr[n - 1];
        for (i = n - 2; i >= 0; i--) {
            rightMax[i] = Math.max(arr[i], rightMax[i + 1]);
        }

        i = 0;
        j = 0;

        while (i < n && j < n) {
            if (leftMin[i] <= rightMax[j]) {
                maxDiff = Math.max(maxDiff, j - i);
                j++;
            } else {
                i++;
            }
        }

        //output
        System.out.println("Mmax diff: " + maxDiff);
    }

    public void rearrangeArrayElements(int[] arr) {

        //OPTIMISED
        //.................................T: O(N)
        //.................................S: O(1)
        //https://www.geeksforgeeks.org/rearrange-given-array-place/
        /*
         Given an array arr[] of size N where every element is in the range 
         from 0 to n-1. 
         Rearrange the given array so that arr[i] becomes arr[arr[i]].
         */
        int n = arr.length;

        for (int i = 0; i < n; i++) {
            arr[i] += (arr[arr[i]] % n) * n;
        }

        for (int i = 0; i < n; i++) {
            arr[i] /= n;
        }

        //output
        for (int x : arr) {
            System.out.print(x + " ");
        }
        System.out.println();
    }

    public void minimumRangeContainingAtleastOneElementFromKSortedList(int[][] kSortedList) {

        ////............................T: O(N*K*LogK)
        //............................S: O(K)
        //https://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/
        //APPROACH SIMILAR TO k sorted list/array
        class Data {

            final int row;
            final int len;
            int col;

            public Data(int row, int col, int len) {
                this.row = row;
                this.len = len;
                this.col = col;
            }
        }

        int K = kSortedList.length;

        int max = Integer.MIN_VALUE;
        int minRange = Integer.MAX_VALUE;
        int minElementRange = -1;
        int maxElementRange = -1;

        PriorityQueue<Data> minHeap = new PriorityQueue<>((a, b) -> {
            return kSortedList[a.row][a.col] - kSortedList[b.row][b.col];
        });

        for (int r = 0; r < K; r++) {
            minHeap.add(new Data(r, 0, kSortedList[r].length));
            max = Math.max(max, kSortedList[r][0]); //max element from all the first element of K sorted list([r][0])
        }

        while (!minHeap.isEmpty()) {

            Data curr = minHeap.poll(); //its minHeap, root is always min

            int min = kSortedList[curr.row][curr.col];

            //find range
            if ((max - min) < minRange) {
                minRange = max - min;
                minElementRange = min;
                maxElementRange = max;
            }

            if (curr.col + 1 < curr.len) {
                curr.col++;
                max = Math.max(max, kSortedList[curr.row][curr.col]); //max(currMax, updated element from the kSortedList)
                minHeap.add(curr);
            } else {
                //if some kTh row reached its max len, break (col == KSortedList[row].length)
                //because we have find range from [0, K]
                break;
            }
        }

        //output
        System.out.println("Min range of elements that is present in all K sorted list: "
                + "[" + minElementRange + ", " + maxElementRange + "]");

    }

    public void tupleWithSameProduct(int[] arr) {

        //https://practice.geeksforgeeks.org/problems/sum-equals-to-sum4006/1 (SAME APPROACH)
        //https://leetcode.com/problems/tuple-with-same-product/
        Map<Integer, Integer> map = new HashMap<>();
        int count = 0;

        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                int mul = arr[i] * arr[j];
                if (map.containsKey(mul)) {
                    count += map.get(mul);
                }
                map.put(mul, map.getOrDefault(mul, 0) + 1);
            }
        }

        //output
        //explanation of multiply with 8 = https://www.tutorialspoint.com/tuple-with-the-same-product-in-cplusplus
        System.out.println("Possible tuple counts: " + (count * 8));
    }

    public void kDiffPairsInArray(int[] arr, int k) {
        //https://leetcode.com/problems/k-diff-pairs-in-an-array/
        //https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/
        int pair = 0;
        Map<Integer, Long> map = IntStream.of(arr).boxed()
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        for (int key : map.keySet()) {

            long freq = map.get(key);
            //k > 0 && map.contains(a[row] + k) ex: k = 2 then 1 + k == 3, 3 + k == 5
            //should exists as 2 pairs: (1,3) & (3,5) 
            //k == 0 means a[row] - a[col] = k ==> a[row] = a[col] inorder to make a pair, a[row] or a[col] have freq > 1
            //as pair needs 2 element
            if ((k > 0 && map.containsKey(key + k)) || (k == 0 && freq > 1)) {
                pair++;
            }
        }

        //output
        System.out.println("Count of pair of array element with diff equal to k: " + pair);
    }

    public void leastNumberOfUniqueIntegersLeftAfterKRemoval(int[] arr, int K) {

        //https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
        //can't remove K elements if K is more than array's length
        if (K > arr.length) {
            return;
        }
        //get the frequency count of all the array element
        Map<Integer, Long> map = IntStream.of(arr).boxed()
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        //arrange all the array element at top having less frequency
        PriorityQueue<Integer> minFreq = new PriorityQueue<>(
                (a, b) -> (int) (map.get(a) - map.get(b))
        );

        //put all the unique integers in the minFreq queue
        //minFreq.addAll(IntStream.of(arr).boxed().collect(Collectors.toSet()));
        minFreq.addAll(map.keySet());

        while (K > 0 && !minFreq.isEmpty()) {

            int curr = minFreq.poll();
            //reduce the freq of curr array element 
            //which is least freq untill K becomes 0
            map.put(curr, map.get(curr) - 1);
            //if freq of curr array element is 0 remove it from map and dont add it in minFreq
            if (map.get(curr) <= 0) {
                map.remove(curr);
            } else {
                //if freq of array element is greater than 0, put it back in minFreq
                minFreq.add(curr);
            }
            K--;
        }

        //output
        System.out.println("Total unique integer after K removals: " + minFreq.size() + " K integers left: " + minFreq);
    }

    private void printAllPermutationOfDistinctIntegerArray_Helper(int[] arr,
            int index,
            List<List<Integer>> res) {

        if (index == arr.length) {
            res.add(Arrays.stream(arr).boxed().collect(Collectors.toList()));
        }

        for (int i = index; i < arr.length; i++) {

            //swap
            int temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;

            printAllPermutationOfDistinctIntegerArray_Helper(arr, index + 1, res);

            //swapping back the integers at their orignal places
            temp = arr[index];
            arr[index] = arr[i];
            arr[i] = temp;
        }
    }

    public void printAllPermutationOfDistinctIntegerArray(int[] arr) {

        //https://leetcode.com/problems/permutations/
        //https://leetcode.com/problems/permutations-ii/
        List<List<Integer>> res = new ArrayList<>();
        printAllPermutationOfDistinctIntegerArray_Helper(arr, 0, res);

        //output
        System.out.println("All permutations of distinct integer: " + res);
    }

    private void combinationSum_1_Helper(
            int[] nums, int target, int index, List<Integer> currCombination, List<List<Integer>> result) {

        //we reach to and end index where we can't pick any value further so here
        //we will check if our target has reached 0, if it has reached 0 add the
        //curr combination into result combinations
        if (index >= nums.length) {
            if (target == 0) {
                result.add(currCombination);
            }
            return;
        }

        //we have 2 choices to make, 
        //1.) don't pick the curr val @index and move to next index(==> index + 1) then
        //the target will not be reduced with nums[index] value
        combinationSum_1_Helper(nums, target, index + 1, new ArrayList<>(currCombination), result);

        //2.) pick the curr value @index and reduce target with nums[index] value
        //also make sure that this reduction of target doesn't go negative
        //since we are allowed to pick the same value multiple times hence the index
        //remain as it is
        if (target - nums[index] >= 0) {
            currCombination.add(nums[index]);
            combinationSum_1_Helper(
                    nums, target - nums[index], index, new ArrayList<>(currCombination), result);
        }
    }

    public void combinationSum_1(int[] nums, int target) {
        //..............................T: O(2^N)
        //APPROACH SIMILAR TO SUBSET SUM EQUAL TO TARGET
        //https://leetcode.com/problems/combination-sum
        //https://leetcode.com/problems/combinations/
        List<List<Integer>> result = new ArrayList<>();
        combinationSum_1_Helper(nums, target, 0, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum is equal to target: " + result);
    }

    private void combinationSum_3_Helper(
            int[] nums, int targetSum, int kNums, int index,
            List<Integer> currCombination, List<List<Integer>> result) {

        if (index >= nums.length) {
            if (targetSum == 0 && currCombination.size() == kNums) {
                result.add(currCombination);
            }
            return;
        }

        //2 choices
        //1.) don't pick curr val @index and move to next index(==> index + 1)
        //then targetSum will not be reduced with curr nums[index] value
        combinationSum_3_Helper(
                nums, targetSum, kNums, index + 1, new ArrayList<>(currCombination), result);

        //2.) pick the curr value @index and reduce target with nums[index] value
        //also make sure that this reduction of target doesn't go negative and move
        //to next index (==> index + 1)
        if (targetSum - nums[index] >= 0) {
            currCombination.add(nums[index]);
            combinationSum_3_Helper(
                    nums, targetSum - nums[index], kNums, index + 1,
                    new ArrayList<>(currCombination), result);
        }
    }

    public void combinationSum_3(int kNums, int targetSum) {
        //..............................T: O(2^N)
        //APPROACH SIMILAR TO SUBSET SUM EQUAL TO TARGET
        //https://leetcode.com/problems/combination-sum-iii/
        List<List<Integer>> result = new ArrayList<>();
        //nums can only have [1 to 9] and combinantions will not contain duplication
        //prepare dummy muns[]
        int[] nums = new int[9];
        for (int i = 0; i < 9; i++) {
            nums[i] = i + 1;
        }
        combinationSum_3_Helper(nums, targetSum, kNums, 0, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum is targetSum and have Knums: " + result);
    }

    private void combinationSum_2_Helper(int[] nums, int index, int target,
            List<Integer> curr, List<List<Integer>> res) {

        if (target == 0) {
            res.add(new ArrayList<>(curr));
            return;
        }

        for (int i = index; i < nums.length; i++) {
            //skip, if the curr i-th element is same as prev(i - 1)-th element
            //index is starting point for nums[] and i > index checks that we have
            //atleast 2 values to compare i.e, prev and curr
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }

            //break, if reducing target with the curr i-th value from nums[] is
            //making target negative
            //as the nums[] is sorted now so if by picking curr i-th value makes
            //target negative then further next indexes will also do same
            if (target - nums[i] < 0) {
                break;
            }
            //take only those nums[] elements that are smaller or equal to target
            curr.add(nums[i]);
            combinationSum_2_Helper(nums, i + 1, target - nums[i], curr, res);
            curr.remove(curr.size() - 1);
        }
    }

    public void combinationSum_2(int[] nums, int target) {
        //https://leetcode.com/problems/combination-sum-ii
        List<List<Integer>> result = new ArrayList<>();
        //resulting combination is req in sorted order
        //and by sorting we prevent duplicated combinations
        Arrays.sort(nums);
        combinationSum_2_Helper(nums, 0, target, new ArrayList<>(), result);
        //output
        System.out.println("All combinations whose sum equal to target: "
                + result);
    }

    public int shortestUnsortedContigousSubarray(int[] arr) {

        //https://leetcode.com/problems/shortest-unsorted-continuous-subarray
        /*
         arr[] = [2,6,4,8,10,9,15], unsorted contigous subarray = [6,4,8,10,9]
         if [6,4,8,10,9] this subarray is sorted = [4,6,8,9,10] 
         then whole arr is sorted = [2,4,6,8,9,10,15] 
         find the shortest such kind of this subarray...
        
         explanation: clone the arr and sort the cloned arr(sortedClone)
         arr[] = [2,6,4,8,10,9,15]
         sortedClone[] = [2,4,6,8,9,10,15]
         start iterating on both at same time, 
         if arr[i] != sortedClone[i] 
         (index i of (arr = 6 & sortedClone = 4) where subarray should start)
         (index i of (arr = 9 & sortedClone = 10) where subarray should end)
         start is min(i) and end is max(i)
         */
        int n = arr.length;
        int start = Integer.MAX_VALUE;
        int end = Integer.MIN_VALUE;

        int[] sortedClone = arr.clone();
        Arrays.sort(sortedClone);

        for (int i = 0; i < n; i++) {

            if (arr[i] != sortedClone[i]) {
                //min starting index from where sorting should begin
                start = Math.min(start, i);
                //max ending index till there sorting should end
                end = Math.max(end, i);
            }
        }

        if (start == Integer.MAX_VALUE && end == Integer.MIN_VALUE) {
            return 0;
        }
        return end - start + 1;
    }

    public void minimumOperationsToMakeArrayStrictlyIncr(int[] arr) {

        //https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
        /*
         arr[] = [1,1,1]
         start from index i = 1 nextMax possible (prevElement + 1, currElement)
         = (arr[i - 1] + 1, arr[i])
         opr += diff to make currElement increasing = nextMax - currElement
         currElement = nextMax
         i = 1
         nextMax = max(1 + 1, 1)
         opr += 0 + (2 - 1) = 1
         arr[1] = nextMax = 2 => [1,2,1]
         i = 2
         nextMax = max(2 + 1, 1) = 3
         opr += 1 + (3 - 1) = 1 + 2 => 3
         arr[2] = nextMax = 3
         [1,2,3]
         */
        int n = arr.length;
        int opr = 0;
        for (int i = 1; i < n; i++) {
            int nextMax = Math.max(arr[i - 1] + 1, arr[i]);
            opr += nextMax - arr[i];
            arr[i] = nextMax;
        }

        //output
        System.out.println("Minimum operations to make array strictly increasing: " + opr);
    }

    public void longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(int[] arr) {

        //https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
        //APPROACH is similar to longest consecutive one after M zero flips
        //flipMZerosFindMaxLengthOfConsecutiveOnes()
        /*logic is try to flip only 1 zero and get the max len consecutive ones, 
         now we have to delete one element so just do maxLen - 1 this will be like
         delete that one element to get rest of consecutive ones.
         edge case: when all the elements are 1 and there are no 0s to flip, 
         then maxLen will remain 0 only, if we do maxLen - 1 it will be -ve that 
         means all elements were 1 in arr[] so just do n - 1
         */
        int n = arr.length;
        int m = 1;
        int zeroCount = 0;
        int maxLen = 0;
        int start = 0;
        int end = 0;

        while (end < n) {

            if (zeroCount <= m) {
                if (arr[end] == 0) {
                    zeroCount++;
                }
                end++;
            }

            if (zeroCount > m) {
                if (arr[start] == 0) {
                    zeroCount--;
                }
                start++;
            }

            if (end - start > maxLen && zeroCount == m) {
                maxLen = end - start;
            }
        }

        //output
        System.out.println("Longest consecutive ones after deleting one element: "
                + (maxLen - 1 < 0 ? n - 1 : maxLen - 1));
    }

    public void countSubarrayWithOddSum(int[] arr) {

        //https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum
        //explanation: https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/discuss/1199776/81-Faster-C%2B%2B-Solution
        /*
         ex: [1,3,5] = [[1],[3],[5],[1,3,5]] == 4 subarray with sum is odd
         */
        int n = arr.length;
        int evenSumPrefix = 1; //default 0 which is even
        int oddSumPrefix = 0;
        int sum = 0;
        int res = 0;
        int mod = 1000000007;

        for (int val : arr) {
            sum += val;
            if (sum % 2 == 0) {
                res = (res + oddSumPrefix) % mod;
                evenSumPrefix++;
            } else {
                res = (res + evenSumPrefix) % mod;
                oddSumPrefix++;
            }
        }
        //output
        System.out.println("Count subarray with odd sum: " + res);
    }

    public void mergeNewInterval(int[][] intervals, int[] newInterval) {

        if (intervals.length == 0) {
//            return new int[][]{newInterval};
            return;
        }

        /*
         1.
         ..........a-----b
         .....................p-----q
         2.
         ................a-----b
         ......p-----q
        
         3.
         ..........a------b
         ......p------q
         min(p,a) & max(q, b)
        
         .........a------b
         ............p-------q
         min(p,a) & max(q, b)
        
         .....a----b
         p--------------q
         min(p,a) & max(q, b)
        
         a--------------b
         ....p-----q
         min(p,a) & max(q, b)
         */
        List<int[]> left = new ArrayList<>();
        List<int[]> right = new ArrayList<>();

        for (int[] interval : intervals) {

            if (interval[1] < newInterval[0]) {
                left.add(interval);
            } else if (interval[0] > newInterval[1]) {
                right.add(interval);
            } else {
                newInterval[0] = Math.min(interval[0], newInterval[0]);
                newInterval[1] = Math.max(interval[1], newInterval[1]);
            }
        }

        int[][] res = new int[left.size() + 1 + right.size()][2];
        int index = 0;
        for (int[] l : left) {
            res[index++] = l;
        }

        res[index++] = newInterval;

        for (int[] r : right) {
            res[index++] = r;
        }

        //output
        for (int[] e : res) {
            System.out.print(e[0] + "-" + e[1] + "\n");
        }
        System.out.println();
    }

    public void duplicateZeroInArray(int[] arr) {

        //..............T: O(N) if all e in arr[] != 0 AND O(N^2) if some e in arr[] == 0 (AMORTIZED)
        //https://leetcode.com/problems/duplicate-zeros/
        //actual
        System.out.println("Actual");
        for (int e : arr) {
            System.out.print(e + " ");
        }
        System.out.println();

        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == 0) {
                for (int j = arr.length - 2; j >= i; j--) {
                    arr[j + 1] = arr[j];
                }
                i++;
            }
        }

        //output
        for (int e : arr) {
            System.out.print(e + " ");
        }
        System.out.println();
    }

    public void arrayNesting(int[] arr) {

        //https://leetcode.com/problems/array-nesting/
        /*
         You are given an integer array nums of length n where nums is a 
         permutation of the numbers in the range [0, n - 1].

         You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } 
         subjected to the following rule:

         The first element in s[k] starts with the selection of the element nums[k] of index = k.
         The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
         We stop adding right before a duplicate element occurs in s[k].
         Return the longest length of a set s[k].
         */
        int res = 0;
        for (int i = 0; i < arr.length; i++) {

            if (arr[i] != Integer.MAX_VALUE) {
                int start = arr[i];
                int len = 0;
                while (arr[start] != Integer.MAX_VALUE) {
                    int temp = start;
                    start = arr[start];
                    len++;
                    arr[temp] = Integer.MAX_VALUE;
                }
                res = Math.max(res, len);
            }
        }
        //output
        System.out.println("Longest length: " + res);
    }

    public boolean escapingGhost(int[][] ghosts, int[] target) {

        //https://leetcode.com/problems/escape-the-ghosts/
        //user init coord row, col = 0, 0
        //dist b/w user from target = abs(row - tX) + abs(col - tY)
        int userDist = Math.abs(0 - target[0]) + Math.abs(0 - target[1]);
        for (int[] ghost : ghosts) {
            //dist of ghost from target
            int ghostDistFromTarget = Math.abs(ghost[0] - target[0]) + Math.abs(ghost[1] - target[1]);
            if (ghostDistFromTarget <= userDist) {
                //if the ghost reaches the target before user or at the same time as user reached,
                //ghost will catch you so false
                return false;
            }
        }
        return true;
    }

    public void removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(int[] arr) {

        //https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
        //actual
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();

        int n = arr.length;
        int start = 0;
        int end = 0;
        int currVal = arr[end];
        int atMostCounter = 0;
        while (end < n) {
            //count the occurences of the consecutive same value as that of currVal
            if (arr[end] == currVal) {
                atMostCounter++;
            } else {
                //if the arr[end] didn't match the currVal
                //we will update the currVal and start counting occurences of this value
                currVal = arr[end];
                //reseting counter back to 1 as atleast this curr arr[end] occuring 1 time
                atMostCounter = 1;
            }

            //we only need atmost 2 occurences of the value (arr[end])
            if (atMostCounter <= 2) {
                //put value at start index if it is less that or equal to 2
                //all greater occurences will not be taken into account
                arr[start] = arr[end];
                start++;
            }
            end++;
        }

        //output
        for (int i = 0; i < start; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    private double nPowerOfX_Helper(double x, int n) {
        if (n == 0) { //pow(row, 0) = 1
            return 1;
        }

        if (n == 1) { // pow(row, 1) = row
            return x;
        }

        if (n % 2 == 0) {
            return nPowerOfX_Helper(x * x, n / 2);
        }
        return x * nPowerOfX_Helper(x * x, n / 2);
    }

    public void nPowerOfX(double x, int n) {

        //..................T: O(N * LogN)
        //https://leetcode.com/problems/powx-n/
        /* n can be +ve or -ve value*/
        double output = n >= 0
                ? nPowerOfX_Helper(x, n)
                : 1.0 / nPowerOfX_Helper(x, Math.abs(n));
        System.out.println("pow(x, n): "
                + output);
    }

    public void gasStationCompleteCircuit(int[] gas, int[] cost) {
        //............................T: O(N) + O(N) + O(N)
        //https://leetcode.com/problems/gas-station/
        //explanation: https://youtu.be/lJwbPZGo05A
        //O(N) + O(N), for summing gas[] & cost[]
        if (IntStream.of(gas).sum() < IntStream.of(cost).sum()) {
            System.out.println("Starting index of gas station to complete the circuit(approach 1): -1");
            return;
        }

        int n = gas.length;
        int moveDiff = 0;
        int resultIndex = 0;
        //O(N)
        for (int i = 0; i < n; i++) {

            moveDiff += (gas[i] - cost[i]);
            if (moveDiff < 0) {
                moveDiff = 0;
                resultIndex = i + 1;
            }
        }

        //output;
        System.out.println("Starting index of gas station to complete the circuit(approach 1): "
                + resultIndex);
    }

    public void gasStationCompleteCircuit2(int[] gas, int[] cost) {
        //..............................T: O(N), little optimized
        //https://leetcode.com/problems/gas-station/
        int n = gas.length;
        int maxVal = Integer.MIN_VALUE;
        int resultIndex = n - 1;
        int moveDiff = 0;

        for (int i = n - 1; i >= 0; i--) {

            moveDiff += (gas[i] - cost[i]);
            if (moveDiff > maxVal) {
                maxVal = moveDiff;
                resultIndex = i;
            }
        }

        //output;
        System.out.println("Starting index of gas station to complete the circuit(approach 2): "
                + (moveDiff < 0 ? -1 : resultIndex));
    }

    private void rangeUpdateAndPointQueries_Update(int[] arr, int left, int right, int val) {
        arr[left] += val;
        if (right + 1 < arr.length) {
            arr[right + 1] -= val;
        }
    }

    private int rangeUpdateAndPointQueries_GetQueries(int[] arr, int i) {
        int prefixSum = 0;
        for (int j = 0; j <= i; j++) {
            prefixSum += arr[j];
        }
        return prefixSum;
    }

    public void rangeUpdateAndPointQueries(int[] arr) {

        //https://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/
        int left = 2;
        int right = 4;
        int val = 2;
        rangeUpdateAndPointQueries_Update(arr, left, right, val);

        //Find the element at Index 4 
        int index = 4;
        System.out.println("Element at index " + index + " is " + rangeUpdateAndPointQueries_GetQueries(arr, index));

        left = 0;
        right = 3;
        val = 4;
        rangeUpdateAndPointQueries_Update(arr, left, right, val);

        //Find the element at Index 3 
        index = 3;
        System.out.println("Element at index " + index + " is " + rangeUpdateAndPointQueries_GetQueries(arr, index));
    }

    private boolean isOutOfBound(int x, int xLen, int y, int yLen, int z, int zLen) {
        return x >= xLen || y >= yLen || z >= zLen;
    }

    public void allCommonElementIn3SortedArray(int[] a, int[] b, int[] c) {
        //...........................T: O(N), where N = MIN(xLen, yLen, zLen)
        /*
         If arrays was given unsorted, then one way to solve this problem is to sort the arrays first
         using optimised sort(ex merge sort) then time complexity will be
         T: O(xLen.Log(xLen)) + O(yLen.Log(yLen)) + O(zLen.Log(zLen)) + O(N), N = MIN(xLen, yLen, zLen)
         total sorting time will be time taken to sort the longest array = MAX(xLen, yLen, zLen)
         so overall order = T: O(N.LogN) = MAX(xLen, yLen, zLen)
         */
        //https://practice.geeksforgeeks.org/problems/common-elements1132/1
        int x = 0;
        int y = 0;
        int z = 0;
        int xLen = a.length;
        int yLen = b.length;
        int zLen = c.length;
        int prev = Integer.MIN_VALUE;
        List<Integer> result = new ArrayList<>();

        while (!isOutOfBound(x, xLen, y, yLen, z, zLen)) {
            if (a[x] == b[y] && b[y] == c[z]) {
                //If duplicate values are not required
                if (prev != a[x]) {
                    prev = a[x];
                    result.add(a[x]);
                }
                //if duplicate values are req
                //result.add(a[row]);
                x++;
                y++;
                z++;
            } else if (a[x] < b[y]) {
                x++;
            } else if (b[y] < c[z]) {
                y++;
            } else {
                z++;
            }
        }
        //output
        System.out.println("All common elements in 3 sorted arrays: " + result);
    }

    public void allCommonElementInKUnsortedArray(int[][] kArray) {
        //https://leetcode.com/problems/intersection-of-multiple-arrays/
        //https://www.codingninjas.com/codestudio/problems/common-elements-present-in-all-rows-of-a-matrix_1118111
        int k = kArray.length;
        int COL = kArray[0].length;

        List<Integer> commonElements = new ArrayList<>();
        Map<Integer, Integer> freq = new HashMap<>();

        if (k == 1) {
            for (int col = 0; col < COL; col++) {
                commonElements.add(kArray[0][col]);
            }
        }

        for (int col = 0; col < COL; col++) {
            freq.put(kArray[0][col], 1);
        }

        for (int row = 1; row < k; row++) {
            int freqReqAtKThRow = row;
            for (int col = 0; col < COL; col++) {
                int currCellVal = kArray[row][col];
                if (freq.containsKey(currCellVal) && freq.get(currCellVal) == freqReqAtKThRow) {

                    freq.put(currCellVal, freq.getOrDefault(currCellVal, 0) + 1);

                    //at last row
                    if (row == k - 1) {
                        commonElements.add(currCellVal);
                    }
                }
            }
        }
        //output
        System.out.println("All common elements in K unsorted array: " + commonElements);
    }

    public void randomlyRearrangeElementsOfArray(int[] arr) {
        //https://leetcode.com/problems/shuffle-an-array/
        //.............................T: O(N)
        //.............................S: O(1), in-place
        // random{} generates random num between 0 & 1
        // (i + 1) * Math.random(), (i + 1) is length of arr at ith iteration 
        // so if N = 5, ex: 1)iteration: i = N - 1 => 4 => i => 4 => 4
        // (i) * random ranges => 4 * 0 & 4 * 1 => 0 & 4
        // floor will keep the ranges to lower bounds that also matches with array indexes
        int N = arr.length;
        for (int i = N - 1; i > 0; i--) {
            int randomIndex = (int) Math.floor(i * Math.random());
            //swap
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //output
        System.out.println("Array shuffle: " + Arrays.toString(arr));
    }

    public void randomlyRearrangeElementsOfArray2(int[] arr) {
        //https://leetcode.com/problems/shuffle-an-array/
        //.............................T: O(N)
        //.............................S: O(1), in-place
        Random rand = new Random();
        int N = arr.length;
        for (int i = 0; i < N; i++) {
            int randomIndex = rand.nextInt(N - i) + i;
            //swap
            int temp = arr[i];
            arr[i] = arr[randomIndex];
            arr[randomIndex] = temp;
        }
        //output
        System.out.println("Array shuffle: " + Arrays.toString(arr));
    }

    public int teemoAttackingAshee(int[] timeSeries, int duration) {
        //..............................T: O(N)
        //..............................S: O(1)
        //https://leetcode.com/problems/teemo-attacking
        //https://leetcode.com/problems/teemo-attacking/solution/
        int n = timeSeries.length;
        if (n == 0) {
            return 0;
        }
        int totalTime = 0;
        for (int i = 0; i < n - 1; i++) {
            totalTime += Math.min(timeSeries[i + 1] - timeSeries[i], duration);
        }
        return totalTime + duration;
    }

    public void minOperationToMakeArrayOfSizeNEqual(int n) {
        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/
        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/discuss/2075557/Java-1-Liner-solution
        int operations = n % 2 == 0 ? (n / 2) * (n / 2) : (n / 2) * (n / 2 + 1);
        System.out.println("Min operation to make array equal: " + operations);
    }

    public int findPivotIndex(int[] nums) {
        //https://leetcode.com/problems/find-pivot-index/
        int arrSum = 0;
        int leftPrefixSum = 0;
        for (int val : nums) {
            arrSum += val;
        }
        //ex: [1,7,3,6,5,6] at index  = 3
        //arrSum = 1 + 7 + 3 + 6 + 5 + 6 = 28
        //leftPrefixSum till this is 1 + 7 + 3 = 11
        //leftPrefixSum == arrSum - leftPrefixSum - arr[i]
        //11 == 28 - 11 - 6 ==> 11 == 11 pivot found
        for (int i = 0; i < nums.length; i++) {
            if (leftPrefixSum == arrSum - leftPrefixSum - nums[i]) {
                return i;
            }
            //prefixSum
            leftPrefixSum += nums[i];
        }
        return -1;
    }

    public void findDistinctDiffArray(int[] nums) {
        //https://leetcode.com/problems/find-the-distinct-difference-array/description/
        int n = nums.length;
        int[] distinctDiff = new int[n];
        Map<Integer, Integer> rightSideUniqueVal = new HashMap<>();
        Set<Integer> leftSideUniqueVal = new HashSet<>();

        //count the freqs of value from nums[], this freq will be considered as
        //whole right side of array and rightSideUniqueVal.size is distinct elements
        //in right side of array that is here, initially is whole nums[]
        for (int val : nums) {
            rightSideUniqueVal.put(val, rightSideUniqueVal.getOrDefault(val, 0) + 1);
        }

        for (int i = 0; i < n; i++) {

            int val = nums[i];

            //decrease the count of val @index i in nums[] from rightSideUniqueVal
            rightSideUniqueVal.put(val, rightSideUniqueVal.getOrDefault(val, 0) - 1);
            //if after decreasing the count this val it becomes '0' or negative
            //remove it from rightSideUniqueVal that would mean that for right
            //side array from [i + 1 to n - 1] this val @index i doesn't exist in
            //right part of array
            if (rightSideUniqueVal.get(val) <= 0) {
                rightSideUniqueVal.remove(val);
            }

            //now that we have removed this val @index i from right side of array
            //that also means this reduced/removed value needs to be added in
            //left side of array
            leftSideUniqueVal.add(val);

            //the sizes of leftSideUniqueVal & rightSideUniqueVal will give the 
            //count of unique values in left[0 to i] & right[i + 1 to n - 1] side
            //of array respectively
            distinctDiff[i] = leftSideUniqueVal.size() - rightSideUniqueVal.size();
        }
        //output
        System.out.println("Distinct diff array : " + Arrays.toString(distinctDiff));
    }

    public void maximumSubarraySumWithUniqueElements(int[] arr) {

        //https://leetcode.com/problems/maximum-erasure-value/
        //same as longest substring without repeating character, longestSubstringWithoutRepeatingChar()
        //SLIDING WIINDOW approach
        int n = arr.length;
        Map<Integer, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int maxSum = 0;
        int currSum = 0;
        int maxLenSubarray = 0;
        while (end < n) {
            int val = arr[end];
            freq.putIfAbsent(val, 0);
            //in order to have unique elements, its atmost freq can only be 1
            //if a val is coming more than 1 then we will have to slide the window
            if (freq.get(val) < 1) {
                freq.put(val, freq.get(val) + 1);
                currSum += val;
                maxSum = Math.max(maxSum, currSum);
                maxLenSubarray = Math.max(maxLenSubarray, (end - start + 1));
                end++;
            } else {
                int startVal = arr[start++];
                freq.put(startVal, freq.get(startVal) - 1);
                currSum -= startVal;
            }
        }
        //output
        System.out.println("Maximum subarray sum with unique elements: " + maxSum + " subarray length: " + maxLenSubarray);
    }

    public boolean partitionArrayIntoThreePartsWithEqualSum(int[] arr) {
        //https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/
        //ex arr[a,b,c,l,m,n,p,q,r,s]
        //let say partition be sum1 = [a,b,c], sum2 = [l,m,n], sum3 = [p,q,r,s]
        //we have to prove sum1 == sum2 == sum3
        //total arrSum = sum
        //sum1 + sum2 + sum3 = arrSum
        //if sum1 == sum2 == sum3 then 3 * sum1 = arrSum ==> sum1 = arrSum / 3
        //out total arrSum should be div by 3
        int sumArr = 0;
        for (int val : arr) {
            sumArr += val;
        }

        if (sumArr % 3 != 0) {
            return false;
        }

        int sumPerPartition = sumArr / 3;
        int times = 0;
        int sum = 0;
        for (int val : arr) {
            sum += val;
            if (sum == sumPerPartition * (times + 1)) {
                System.out.println(sum);
                times++;
                if (times == 3) {
                    return true;
                }
            }
        }
        return false;
    }

    public void topKFrequentElements(int[] arr, int k) {
        //https://leetcode.com/problems/top-k-frequent-elements/
        Map<Integer, Long> freq = Arrays.stream(arr).boxed()
                .collect(Collectors.groupingBy(val -> val, Collectors.counting()));
//                or 
//                .collect(Collectors.groupingBy(
//                        Function.identity(),
//                        Collectors.counting())
//                );

        PriorityQueue<Integer> minHeap = new PriorityQueue<>(
                (val1, val2) -> (int) (freq.get(val1) - freq.get(val2))
        );

        for (int key : freq.keySet()) {
            minHeap.add(key);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        //output:
        System.out.println("Frequent elements: ");
        //to convert result in minHeap to int[]
        int[] result = minHeap.stream().mapToInt(val -> val).toArray();
        for (int val : result) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    public void maximumSumCircularSubarray(int[] arr) {
        //https://leetcode.com/problems/maximum-sum-circular-subarray
        //explanation: https://youtu.be/uHsPcy3xUT0
        //ex: [-1,5,5,-2] = maxSumSubArr = [5,5] = 10 by kadens algo
        //ex: [5,-1,-2,5] = maxSumSubArr(circular) = 5]..[5 = 10
        //intutions: 
        //if sum are to be max in circular array i.e around the ends of array in that
        //case there should exists some min sum in between the max sum end and then
        //totalArrSum - -minSumSubArr = maxSumSubArr(circular)
        //ex: [5,-1,-2,5] = maxSumSubArr(circular) = 5]..[5 = 10
        //totalArrSum = 5 + -1 + -2 + 5 = 7
        //minSumSubArr = ]...minSumSubArr...[ => reverseAllSigns(arr[]) =>
        // [-5,1,2,-5] = 1 + 2 = 3 OR - (1 + 2) = -3
        //maxSumSubArr(circular) = 5]..[5 = 10 => totalArrSum - -minSumSubArr = 7 - -3 = 10
        int totalArrSum = Arrays.stream(arr).sum();
        int maxSumSubArr = kadaneAlgorithm(arr);
        //reverseAllSign(arr)
        int minSumSubArr = kadaneAlgorithm(Arrays.stream(arr).map(val -> -val).toArray());
        int maxSumSubArrCircular = maxSumSubArr > 0
                ? Math.max(maxSumSubArr, (totalArrSum - -minSumSubArr))
                //case where arr[] is all negative then smallest element in arr is maxSumSubArr
                : maxSumSubArr;
        //output
        System.out.println("Max sum circular subarray: " + maxSumSubArrCircular);
    }

    public void maxAbsoluteSumOfAnySubarray(int[] arr) {
        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
        //based on Kaden algo & maximumSumCircularSubarray();
        int maxSumSubArr = kadaneAlgorithm(arr);
        //reverseAllSign(arr)
        //minSum of given arr is maxSum of arr with reverse sign,
        //since on reversing sign it would give a maxSum so to
        //call it a minSum we must reverse the sign on result
        int minSumSubArr = -1 * kadaneAlgorithm(Arrays.stream(arr).map(val -> -val).toArray());
        int maxAbsouluteSumAnySubarray = Math.max(Math.abs(maxSumSubArr), Math.abs(minSumSubArr));
        //output
        System.out.println("Max absolute sum any subarray: " + maxAbsouluteSumAnySubarray);
    }

    public void maxAbsoluteSumOfAnySubarray2(int[] nums) {
        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
        //based on Kaden algo
        /*
        as the logic used in above maxAbsoluteSumOfAnySubarray() method
        we will just calculate curr max sum (typical kaden's algo)
        and also curr min sum in the same kaden's algo logic at the same time
        
        since we need the max absolute sum subarray
        we can choose max sum from max(maxSum, currMaxSum, abs(currMinSum))
        
         */
        int currMaxSum = 0;
        int currMinSum = 0;
        int maxAbsouluteSumAnySubarray = nums[0];

        for (int val : nums) {
            currMaxSum = Math.max(currMaxSum + val, val);
            currMinSum = Math.min(currMinSum + val, val);
            maxAbsouluteSumAnySubarray = Math.max(
                    maxAbsouluteSumAnySubarray, Math.max(currMaxSum, Math.abs(currMinSum)));
        }
        //output
        System.out.println("Max absolute sum any subarray: " + maxAbsouluteSumAnySubarray);
    }

    public boolean nonDecreasingArrayWithAtmostOneChange(int[] nums) {
        //https://leetcode.com/problems/non-decreasing-array/
        //explanation: https://youtu.be/RegQckCegDk
        int n = nums.length;
        boolean atMostOneChangeHasDone = false;

        for (int i = 0; i < n - 1; i++) {

            //already increasing ex: 1 2 Or 1 1
            if (nums[i] <= nums[i + 1]) {
                continue;
            }

            //we can modify the array with atmost one element
            //if we have previouly done it, we can't do it second time
            //hence false
            if (atMostOneChangeHasDone) {
                return false;
            }

            //if curr ith value and its next value >= its prev value
            //then convert that ith value to next value nums[i + 1]
            //ex: i == 0 cases like [4, 2], other cond cases like [3,2,5]
            if (i == 0 || nums[i - 1] <= nums[i + 1]) {
                //update nums[i] = 2 with nums[i + 1] = 5
                nums[i] = nums[i + 1];
            } else {
                nums[i + 1] = nums[i];
            }
            atMostOneChangeHasDone = true;
        }
        return true;
    }

    public void twoSum_UnsortedArray(int[] nums, int target) {
        //.........................T: O(N)
        //.........................S: O(N)
        //https://leetcode.com/problems/two-sum/
        Map<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        int[] result = null;
        for (int i = 0; i < n; i++) {

            int diff = target - nums[i];
            if (map.containsKey(diff)) {
                result = new int[]{map.get(diff), i};
                break;
            }
            map.put(nums[i], i);
        }
        //output
        if (result == null) {
            System.out.println("No Two element found that sums equal to target");
        } else {
            System.out.println("Indexes(0-based index) of two element that sums equal to target: "
                    + result[0] + " " + result[1]);
        }
    }

    public void twoSum2_SortedArray(int[] nums, int target) {
        //.........................T: O(N)
        //.........................S: O(1)
        //https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
        //explanation: https://youtu.be/cQ1Oz4ckceM
        //this problem can also be solved with above twoSum_UnsortedArray()
        int n = nums.length;
        int[] result = null;

        int start = 0;
        int end = n - 1;

        while (end > start) {

            int sum = nums[start] + nums[end];
            if (sum == target) {
                result = new int[]{start + 1, end + 1};
                break;
            } else if (sum > target) {
                //curr sum > target because nums[end] > nums[start] as
                //array is sorted so try to reduce larger num from end
                end--;
            } else {
                //curr sum < target because nums[end] > nums[start] as
                //array is sorted so try to increase larger num from start
                start++;
            }
        }

        //output
        if (result == null) {
            System.out.println("No Two element found that sums equal to target");
        } else {
            System.out.println("Indexes(1-based index) of two element that sums equal to target: "
                    + result[0] + " " + result[1]);
        }
    }

    public void threeSum(int[] nums) {
        //https://leetcode.com/problems/3sum/
        //https://www.geeksforgeeks.org/java-program-to-find-all-triplets-with-zero-sum/
        //explanation: https://youtu.be/qJSPYnS35SE
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            //either its the first array element(i == 0)
            //OR current arr element(arr[i]) is not same as prev(arr[i - 1]) 
            if (i == 0 || nums[i - 1] != nums[i]) {

                int start = i + 1;
                int end = n - 1;
                int target = 0 - nums[i];

                while (end > start) {

                    int sum = nums[start] + nums[end];

                    if (target == sum) {
                        result.add(Arrays.asList(nums[i], nums[start], nums[end]));

                        start++;
                        end--;

                        //move start ptr until we find a next distict num[start]
                        while (end > start && nums[start - 1] == nums[start]) {
                            start++;
                        }

                        //move end ptr until we find a next distict num[end]
                        while (end > start && nums[end + 1] == nums[end]) {
                            end--;
                        }

                    } else if (sum < target) {
                        start++;
                    } else {
                        end--;
                    }
                }
            }
        }

        //output:
        System.out.println("All the triplets that sum to 0: " + result);
    }

    public int threeSumClosest(int[] nums, int target) {
        //https://leetcode.com/problems/3sum-closest/
        //based on threeSum()
        int n = nums.length;
        Arrays.sort(nums);
        int closestDiff = Integer.MAX_VALUE;
        int resultSum = 0;

        for (int i = 0; i < n - 2; i++) {
            int start = i + 1;
            int end = n - 1;

            while (end > start) {
                int sumABC = nums[i] + nums[start] + nums[end];
                int currDiff = Math.abs(target - sumABC);
                if (currDiff == 0) {
                    return sumABC;
                }

                if (currDiff < closestDiff) {
                    closestDiff = currDiff;
                    resultSum = sumABC;
                }

                if (sumABC > target) {
                    end--;
                } else {
                    start++;
                }
            }
        }
        return resultSum;
    }

    private void fourSum_twoSumSortedApproach(
            int[] nums, long target, int index, List<Integer> currList, List<List<Integer>> result) {

        int n = nums.length;
        int start = index;
        int end = n - 1;
        while (end > start) {
            long currSum = nums[start] + nums[end];
            if (currSum == target) {
                List<Integer> kSumList = new ArrayList<>(currList);
                kSumList.add(nums[start]);
                kSumList.add(nums[end]);
                result.add(kSumList);
                start++;
                while (start < end && nums[start] == nums[start - 1]) {
                    start++;
                }
            } else if (currSum > target) {
                end--;
            } else {
                start++;
            }
        }
    }

    private void fourSum_CombinationSum2Approach(
            int[] nums, int target, int index, int kSum, List<Integer> currList, List<List<Integer>> result) {
        if (kSum == 2) {
            fourSum_twoSumSortedApproach(nums, target, index, currList, result);
            return;
        }

        for (int i = index; i < nums.length; i++) {
            if (i > index && nums[i] == nums[i - 1]) {
                continue;
            }
            currList.add(nums[i]);
            fourSum_CombinationSum2Approach(
                    nums, target - nums[i], i + 1, kSum - 1, new ArrayList<>(currList), result);
            currList.remove(currList.size() - 1);
        }
    }

    public void fourSum(int[] nums, int target) {
        //https://leetcode.com/problems/4sum/
        //explanation: https://youtu.be/EYeR-_1NRlQ
        //This approach is generic approach for K-sum (4Sum, 5sum...)
        //based on combination_2 & twoSum-Sorted
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int kSum = 4;
        fourSum_CombinationSum2Approach(nums, target, 0, kSum, new ArrayList<>(), result);
        //output
        System.out.println("Four sum/ Generic KSum: " + result);
    }

    public void fourSum_WithThreeSumApproach(int[] nums, int target) {
        //.....................T: O(N^3)
        //https://leetcode.com/problems/4sum/
        //explanation: https://youtu.be/eD95WRfh81c
        //This approach is similar to 3 sum
        List<List<Integer>> result = new ArrayList<>();
        Arrays.sort(nums);
        int n = nums.length;
        for (int i = 0; i < n; i++) {

            //skip, if the curr val at i-th is same as val at (i - 1)-th index
            //to avoid generating same quad nums for target
            if (i > 0 && nums[i - 1] == nums[i]) {
                continue;
            }

            //nums[j] will be considered after the i-th index nums
            for (int j = i + 1; j < n; j++) {

                //skip, if the curr val at j-th is same as val at (j - 1)-th index
                //to avoid generating same quad nums for target
                if (j > i + 1 && nums[j - 1] == nums[j]) {
                    continue;
                }

                long newTarget = (long) target - (long) (nums[i] + nums[j]);

                int start = j + 1;
                int end = n - 1;
                while (end > start) {

                    long sum = nums[start] + nums[end];

                    if (sum == newTarget) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[start], nums[end]));
                        start++;
                        end--;

                        //move start ptr until we find a next distict num[start]
                        while (end > start && nums[start - 1] == nums[start]) {
                            start++;
                        }

                        //move end ptr until we find a next distict num[end]
                        while (end > start && nums[end + 1] == nums[end]) {
                            end--;
                        }
                    } else if (sum < newTarget) {
                        start++;
                    } else {
                        end--;
                    }
                }
            }
        }
        //output
        System.out.println("Four sum (with 3sum approach): " + result);
    }

    public void fourSumTwo(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        //..................T: O(N^2), N is length of given arrays
        //..................S: O(N^2), N is length of given arrays, since we are
        //making sumsMap which we are filling with curr sum of n * n elements from
        //nums3 and nums4, in worst case each of the n * n curr sums will be unique
        //https://leetcode.com/problems/4sum-ii/description/
        /*
        given: nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
        alter this equation as,
        nums1[i] + nums2[j] == -(nums3[k] + nums4[l])

        using k & l nested loop, put the sums of nums3 and nums4 into sums map
        in its negative form as per the alter equation

        using i & j nested loop, check if currSum = nums1[i] + nums2[j] is present
        in sums map and count the freq of these sums as tuples
        
         */
        //all the given arrays are of same length 'n'
        int n = nums1.length;
        Map<Integer, Integer> sumsMap = new HashMap<>();

        for (int k = 0; k < n; k++) {
            for (int l = 0; l < n; l++) {
                int currSum = -(nums3[k] + nums4[l]);
                sumsMap.put(currSum, sumsMap.getOrDefault(currSum, 0) + 1);
            }
        }

        int tuples = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                int currSum = (nums1[i] + nums2[j]);
                tuples += sumsMap.getOrDefault(currSum, 0);
            }
        }

        //output
        System.out.println("Four sum two : " + tuples);
    }

    public void maximumLengthOfSubarrayWithPositiveProduct(int[] nums) {
        //https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/
        int n = nums.length;
        int positiveCount = 0;
        int negativeCount = 0;
        int temp;
        int length = 0;

        for (int val : nums) {

            int anyCase = val == 0 ? 0 : val < 0 ? -1 : 1;
            switch (anyCase) {
                case 0:
                    //reset
                    positiveCount = 0;
                    negativeCount = 0;
                    break;
                case 1:
                    positiveCount++;
                    if (negativeCount != 0) {
                        negativeCount++;
                    }
                    break;
                case -1:
                    temp = positiveCount;
                    positiveCount = negativeCount > 0 ? negativeCount + 1 : 0;
                    negativeCount = temp + 1;
                    break;
            }
            length = Math.max(length, positiveCount);
        }
        //output
        System.out.println("max length of subarray with positive product: " + length);
    }

    public void minimumIntervalToIncludeEachQuery(int[][] intervals, int[] queries) {
        //https://leetcode.com/problems/minimum-interval-to-include-each-query/
        //explanation: https://youtu.be/5hQ5WWW5awQ
        class Node {

            int dist;
            int rightEnd;

            public Node(int dist, int rightEnd) {
                this.dist = dist;
                this.rightEnd = rightEnd;
            }
        }

        //indexes
        int LEFT = 0;
        int RIGHT = 1;

        int intervalLen = intervals.length;
        int queriesLen = queries.length;

        int[] result = new int[queriesLen];

        //<queries[i], List(i)>
        Map<Integer, List<Integer>> queryIndexMap = new HashMap<>();

        for (int i = 0; i < queriesLen; i++) {
            queryIndexMap.putIfAbsent(queries[i], new ArrayList<>());
            queryIndexMap.get(queries[i]).add(i);
        }

        Arrays.sort(queries);
        Arrays.sort(intervals, (a, b) -> a[LEFT] - b[LEFT]);

        PriorityQueue<Node> minHeapDist = new PriorityQueue<>((n1, n2) -> n1.dist - n2.dist);
        int intervalIndex = 0;

        for (int query : queries) {

            //put in all those intervals whose left value is less than equal to query
            //i.e, left <= queries[j]
            while (intervalIndex < intervalLen && intervals[intervalIndex][LEFT] <= query) {
                int left = intervals[intervalIndex][LEFT];
                int right = intervals[intervalIndex][RIGHT];

                int dist = right - left + 1;
                minHeapDist.add(new Node(dist, right));
                intervalIndex++;
            }

            //here in the below loop we will remove all those intervals from heap where
            //query is greater than right part, because we want query to fall under
            //left <= query <= right
            //i.e, queries[j] <= right
            while (!minHeapDist.isEmpty() && minHeapDist.peek().rightEnd < query) {
                minHeapDist.poll();
            }

            //get the first occurring index(i.e, 0) of curr query
            int queryIndex = queryIndexMap.get(query).remove(0);
            if (queryIndexMap.get(query).isEmpty()) {
                queryIndexMap.remove(query);
            }
            result[queryIndex] = minHeapDist.isEmpty() ? -1 : minHeapDist.peek().dist;
        }
        //output
        for (int i = 0; i < queriesLen; i++) {
            System.out.println("For query : " + queries[i] + " dist : " + result[i]);
        }
    }

    public void candyDistributionToNStudent(int[] ratings) {
        //.........................T: O(N)
        //.........................S: O(N + N), left & right neighbour
        //https://leetcode.com/problems/candy/
        //explanation: https://youtu.be/h6_lIwZYHQw
        /*
         rule:
         You are giving candies to these children subjected to the following requirements:
         1. Each child must have at least one candy.
         2. Children with a higher rating get more candies than their neighbors.
         */
        int n = ratings.length;
        int[] leftNeighbour = new int[n];
        int[] rightNeighbour = new int[n];
        int candiesNeeded = 0;
        //atleast 1 candy is given to each student
        leftNeighbour[0] = 1;
        for (int i = 1; i < n; i++) {
            //if rating of curr ith student is greater than its prev left student
            //that curr student should have 1 candy extra than its prev left student
            //otherwise atleast 1 candy should be given
            leftNeighbour[i] = ratings[i] > ratings[i - 1]
                    ? leftNeighbour[i - 1] + 1
                    : 1;
        }
        //atleast 1 candy is given to each student
        rightNeighbour[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            //if rating of curr ith student is greater than its next right student
            //that curr student should have 1 candy extra than its next right student
            //otherwise atleast 1 candy should be given
            rightNeighbour[i] = ratings[i] > ratings[i + 1]
                    ? rightNeighbour[i + 1] + 1
                    : 1;
        }

        for (int i = 0; i < n; i++) {
            //add all the max candies req by each ith student
            candiesNeeded += Math.max(leftNeighbour[i], rightNeighbour[i]);
        }
        //output
        System.out.println("Candies required to be distributed: " + candiesNeeded);
    }

    public void candyDistributionToNStudent2(int[] ratings) {
        //.........................T: O(N)
        //.........................S: O(N), candies
        //OPTIMISED
        //https://leetcode.com/problems/candy/
        //https://leetcode.com/problems/candy/solution/
        //explanation: https://youtu.be/h6_lIwZYHQw
        /*
         rule:
         You are giving candies to these children subjected to the following requirements:
         1. Each child must have at least one candy.
         2. Children with a higher rating get more candies than their neighbors.
         */
        int n = ratings.length;
        int[] candies = new int[n];
        //atleast candy is given to each student
        Arrays.fill(candies, 1);
        int candiesNeeded = 0;
        for (int i = 1; i < n; i++) {
            //if rating of curr ith student is greater than its prev left student
            //that curr student should have 1 candy extra than its prev left student
            //otherwise atleast 1 candy should be given
            candies[i] = ratings[i] > ratings[i - 1]
                    ? candies[i - 1] + 1
                    : 1;
        }

        candiesNeeded = candies[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            //if rating of curr ith student is greater than its next right student
            //that curr student should have 1 candy extra than its next right student
            //otherwise atleast 1 candy should be given
            if (ratings[i] > ratings[i + 1]) {
                candies[i] = Math.max(candies[i], candies[i + 1] + 1);
            }
            candiesNeeded += candies[i];
        }
        //output
        System.out.println("Candies required to be distributed: " + candiesNeeded);
    }

    public void findTriangularSumOfArray(int[] nums) {
        //https://leetcode.com/problems/find-triangular-sum-of-an-array/
        int n = nums.length;
        int index = 1;
        while (n > 1) {
            while (index < n) {
                int sum = nums[index - 1] + nums[index];
                nums[index - 1] = sum % 10;
                index++;
            }
            index = 1;
            n--;
        }
        //output
        System.out.println("Triangular sum of array: " + nums[0]);
    }

    public boolean has132Pattern(int[] nums) {
        //https://leetcode.com/problems/132-pattern/
        //explanation: https://youtu.be/q5ANAl8Z458
        /*
         a 132 pattern is a subsequence of three integers 
         nums[i], nums[j] and nums[k] 
         such that i < j < k and nums[i] < nums[k] < nums[j].
         */
        class Pair {

            int numJ;
            int numI;

            public Pair(int numJ, int numI) {
                this.numJ = numJ;
                this.numI = numI;
            }

        }

        int n = nums.length;
        //as per the question the 132 pattern should be like
        //nums[i] < nums[k] < nums[j]
        //where the num[i] is always smaller than both nums[k] & nums[j]
        //initially currMin = nums[i] = numI
        int currMin = nums[0];
        Stack<Pair> stack = new Stack();

        for (int k = 1; k < n; k++) {

            int numK = nums[k];
            //the loop break when stack.peek().numJ greater than equal to numK 
            //stack.peek().numJ <= numK which is also req as (nums[k] < nums[j])
            while (!stack.isEmpty() && stack.peek().numJ <= numK) {
                stack.pop();
            }
            //now we have figured out numsK < numsJ from above loop only thing we need
            //to check is numK shoudl be greater than numI
            //if that is true we can return out true;
            if (!stack.isEmpty() && numK > stack.peek().numI) {
                return true;
            }
            //push the curr numK which will be the numJ for further i-th iteration
            //and currMin will be the numI
            stack.push(new Pair(numK, currMin));
            currMin = Math.min(currMin, numK);
        }
        return false;
    }

    public void amountToPaintTheArea(int[][] areaPoints) {
        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
        //https://algo.monster/liteproblems/2158
        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
        //explanation: https://www.youtube.com/watch?v=cHYjuMPTHt4
        //<start, end>
        Map<Integer, Integer> paintMap = new HashMap<>();
        List<Integer> result = new ArrayList<>();
        for (int[] point : areaPoints) {

            int start = point[0];
            int end = point[1];

            int cost = 0;
            //for each start to end value, paint each unit sequentially
            //and calculate the cost per unit
            //ex: [4, 10] = seq unit cost = start = 4, cost = 1
            //seq unit cost = start = 5, cost = 2
            //seq unit cost = start = 6, cost = 3 until seq unit = start = 9
            //at the same time add these seq unit and given end in map
            //because in future any other point[] comes that tries to paint the same area
            //we can easily find that and map.value will give the end value which is previous
            //area painted
            while (start < end) {
                if (paintMap.containsKey(start)) {
                    //if curr start is already pained previously
                    //it value = end will tell us upto which point it was covered that time
                    //ex: [4, 10] in between seq unit 7 was also covered map[7 = 10]
                    //now when another point[7, 13] will come it will first check 7 is already painted or not
                    //here it was painted when point[4, 10] so will get the end value
                    //it painted which was map[7] = 10 that means from this 10 we might need to paint
                    start = paintMap.get(start);
                    continue;
                }
                //cost of painting per unit area (start to seq)
                cost++;
                paintMap.put(start, end);
                start++;
            }
            result.add(cost);
        }
        //output
        System.out.println("Total cost to paint the given area points effectively : " + result);
    }

    public void amountToPaintTheArea2(int[][] areaPoints) {
        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
        //https://algo.monster/liteproblems/2158
        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
        //explanation: https://www.youtube.com/watch?v=cHYjuMPTHt4

        List<Integer> result = new ArrayList<>();

        int FENCE_CONSTRAINT = 50000;

        TreeSet<Integer> unpaintedFences = new TreeSet<>();
        //add all the intial fences that are unpainted
        for (int fence = 0; fence <= FENCE_CONSTRAINT; fence++) {
            unpaintedFences.add(fence);
        }

        //iterate through all the areaPoints[][]
        for (int[] point : areaPoints) {

            int start = point[0];
            int end = point[1];
            int cost = 0;

            //for all the unpainted fence from [start to end - 1] will try to paint
            //it and remove it from unpainted fences store
            while (true) {

                //treeset.ceiling(val) will give the next closest-greater or equal
                //value than the given 'val', if not present then null
                int nextUnpaintedFence = unpaintedFences.ceiling(start);

                //if we have reached the end fence then break
                if (nextUnpaintedFence >= end) {
                    break;
                }

                //add cost to paint the curr unpainted fence
                cost++;

                //we got an unpainted fence and painted it will cost += 1 and
                //we will remove it from unpainted fences
                unpaintedFences.remove(nextUnpaintedFence);
            }
            result.add(cost);
        }
        //output
        System.out.println("Total cost to paint the given area points effectively (TreeSet) : " + result);
    }

    public void mThElementAfterKArrayRotation(int[] arr, int k, int m) {
        //https://www.geeksforgeeks.org/cpp-program-to-find-the-mth-element-of-the-array-after-k-left-rotations/
        int n = arr.length;
        k %= n;
        int mthIndex = (k + m - 1) % n;
        //output
        System.out.println("Mth element after k Array rtation : " + arr[mthIndex]);
    }

    public void maximizeSumAfterRemovingValleys(int[] mountains) {
        //https://www.geeksforgeeks.org/maximize-sum-of-given-array-after-removing-valleys/
        int n = mountains.length;
        int[] smallerInLeft = new int[n];
        int[] smallerInRight = new int[n];

        Stack<Integer> stack = new Stack<>();

        //smller to left
        for (int i = 0; i < n; i++) {
            int val = mountains[i];
            while (!stack.isEmpty()
                    && mountains[stack.peek()] >= val) {
                stack.pop();
            }

            if (stack.isEmpty()) {
                //i + 1 == len upto ith element 
                //like if arr supposed to [1,1,1] len = 3 and val = 1 then len * val = 3
                smallerInLeft[i] = (i + 1) * val;
            } else {
                int smallIndex = stack.peek();
                smallerInLeft[i] = smallerInLeft[smallIndex] + (i - smallIndex) * val;
            }
            stack.push(i);
        }

        stack.clear();

        //smller in right
        for (int i = n - 1; i >= 0; i--) {
            int val = mountains[i];
            while (!stack.isEmpty()
                    && mountains[stack.peek()] >= val) {
                stack.pop();
            }

            if (stack.isEmpty()) {
                //n - i is same as len upto ith element
                smallerInRight[i] = (n - i) * val;
            } else {
                int smallIndex = stack.peek();
                smallerInRight[i] = smallerInRight[smallIndex] + (smallIndex - i) * val;
            }
            stack.push(i);
        }
        int maxSum = 0;
        for (int i = 0; i < n; i++) {
            int currSum = smallerInLeft[i] + smallerInRight[i] - mountains[i];
            maxSum = Math.max(maxSum, currSum);
        }
        //output:
        System.out.println("Max sum after removing valleys: " + maxSum);
    }

    public void numberOfVisiblePeopleInQueue(int[] heights) {
        //https://leetcode.com/problems/number-of-visible-people-in-a-queue/
        //based on nextGreaterElementInRight
        /*
        heights[] = [10,6,8,5,11,9]
        n = 6
        stack = {}
        visible[]
        
        ##1
        i = 5, height[i] = 9
        while(!stack.isEmpty) FAIL
        
        if(!stack.isEmpty) FAIL
        
        if(stack.isEmpty) YES
        ==> stack.push(9) ==> PEEK -> {9}
        
        visible[5] = 0
        
        ##2
        i = 4, height[i] = 11
        while(!stack.isEmpty && stack.peek <= 11) YES
        ==> PEEK = 9 <= 11
        ==> visible[i]++ ==> person(11) can see person(9) hence visible[i]++
        ==> stack.pop ==> {}
        ==> visible[4] = 1
        
        if(!stack.isEmpty) FAIL
        
        if(stack.isEmpty) YES
        ==> stack.push(11) ==> PEEK -> {11}
        
        visible[4] = 1
        
        ##3
        i = 3, height[i] = 5
        while(!stack.isEmpty && stack.peek <= 5) FAIL
        ==> PEEK = 11 <= 5, person(5) can't see beyond person(11)
        
        if(!stack.isEmpty) TRUE
        ==> person(5) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++
        ==> visible[3] = 1
        
        if(stack.isEmpty || stack.peek != 5) YES
        ==> 11 != 5
        ==> stack.push(5) ==> PEEK -> {5, 11}
        
        visible[3] = 1
        
        ##4
        i = 2, height[i] = 8
        while(!stack.isEmpty && stack.peek <= 8) YES
        ==> PEEK = 5 <= 8
        ==> visible[i]++ ==> person(8) can see persom(5) hence visible[i]++
        ==> stack.pop ==> {11}
        ==> visible[2] = 1
        
        ==> PEEK = 11 <= 8
        ==> visible[i]++ ==> person(8) can't see beyond person(11)
        
        if(!stack.isEmpty) TRUE
        ==> person(8) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++ 
        ==> visible[2] = 2
        
        if(stack.isEmpty || stack.peek != 8) YES
        ==> 11 != 8
        ==> stack.push(5) ==> PEEK -> {8, 11}
        
        visible[2] = 2
        
        ##5
        i = 1, height[i] = 6
        while(!stack.isEmpty && stack.peek <= 6) FAIL
        ==> PEEK = 8 <= 6, person(6) can't see beyond person(8)
        
        if(!stack.isEmpty) TRUE
        ==> person(6) can't see beyond person(8) BUT can see person(8)
        ==> visible[i]++ 
        ==> visible[1] = 1
        
        if(stack.isEmpty || stack.peek != 6) YES
        ==> 8 != 6
        ==> stack.push(5) ==> PEEK -> {6, 8, 11}
        
        visible[1] = 1
        
        ##6
        i = 0, height[i] = 10
        while(!stack.isEmpty && stack.peek <= 10) FAIL
        ==> PEEK = 6 <= 10
        ==> visible[i]++ ==> person(10) can see persom(6) hence visible[i]++
        ==> stack.pop ==> {8, 11}
        ==> visible[0] = 1
        
        ==> PEEK = 8 <= 10
        ==> visible[i]++ ==> person(10) can see persom(8) hence visible[i]++
        ==> stack.pop ==> {11}
        ==> visible[0] = 2
        
        ==> PEEK = 11 <= 10, person(10) can't see beyond person(11)
        
        if(!stack.isEmpty) TRUE
        ==> person(10) can't see beyond person(11) BUT can see person(11)
        ==> visible[i]++ 
        ==> visible[0] = 3
        
        if(stack.isEmpty || stack.peek != 10) YES
        ==> 11 != 10
        ==> stack.push(10) ==> PEEK -> {10, 11}
        
        visible[0] = 3
        
         */
        int n = heights.length;
        Stack<Integer> stack = new Stack<>();
        int[] personVisible = new int[n];

        for (int i = n - 1; i >= 0; i--) {
            //this while cond allow heights[i] person to check all those 
            //person who are smaller to itself and count them
            while (!stack.isEmpty() && stack.peek() < heights[i]) {
                personVisible[i]++;
                stack.pop();
            }

            //this cond is for the case where height[i] < height[j] where  i < j
            //greater height[j] person is still visible to height[i] person
            if (!stack.isEmpty()) {
                personVisible[i]++;
            }
            if (stack.isEmpty() || heights[i] != stack.peek()) {
                stack.push(heights[i]);
            }
        }
        //output
        for (int val : personVisible) {
            System.out.print(val + " ");
        }
        System.out.println();
    }

    private boolean splitArrayInLargestSum_CanSplit(int[] nums, int largestSum, int m) {
        int subarrays = 1;
        int currSum = 0;
        for (int val : nums) {
            currSum += val;
            if (currSum > largestSum) {
                currSum = val;
                subarrays++;
            }
        }
        return subarrays <= m;
    }

    public void splitArrayInLargestSum(int[] nums, int m) {
        //https://leetcode.com/problems/split-array-largest-sum/
        //explanation: https://youtu.be/YUF3_eBdzsk | https://youtu.be/bcAwHkL7A3A
        /*
         intution:
         1. if m = 1 that means, a single subarray which means the whole array
         is that subarray where the largest sum possible would be sum of arr
         2. if m = arr.length that means, each element of arr is itself a subarray
         (and no subarray is possible m > arr.length) in this case the largest
         sum of sub array would be the max num of arr
         Now if we need to split the arr in m subarrays with largest sum
         that could be formed within range of m >= 1 && m <= n where largest sum would
         lie in range of [maxNum, arrSum]
         ex: arr [7,2,5,10,8] m = 2, maxNum = 10, arrSum = 32
         1. partition (m = 2 subarrays)= [7] | [2,5,10,8] sum = 7 | 25 largest = 25
         2. partition (m = 2 subarrays)= [7,2] | [5,10,8] sum = 9 | 23 largest = 23
         3. partition (m = 2 subarrays)= [7,2,5] | [10,8] sum = 14 | 18 largest = 18
         3. partition (m = 2 subarrays)= [7,2,5,10] | [8] sum = 24 | 8 largest = 24
         these are the possible largest sums we will get if we divide the arr
         into m (non-empty subarrys). From these we need the min largest sum which is 18
         see all these largest sums are in the range of [maxNum, arrSum]
         */
        int maxNum = nums[0];
        int arrSum = 0;
        for (int val : nums) {
            maxNum = Math.max(maxNum, val);
            arrSum += val;
        }

        //minimizing the largest sum would lie between [maxNum, arrSum]
        //Binary search
        int start = maxNum;
        int end = arrSum;
        int minimizedSum = 0;
        while (end >= start) {
            int midSum = start + (end - start) / 2;
            if (splitArrayInLargestSum_CanSplit(nums, midSum, m)) {
                minimizedSum = midSum;
                //since we are trying to minimize the sum, we will reduce end
                end = midSum - 1;
            } else {
                start = midSum + 1;
            }
        }
        //output
        System.out.println("Minimized the largest sum among m subarrays: " + minimizedSum);
    }

    private boolean shipWeightsWithinGivenDays_CheckDays(int[] weights, int maxWeight, int days) {
        int day = 1;
        int currWeightSum = 0;
        for (int weight : weights) {
            currWeightSum += weight;
            if (currWeightSum > maxWeight) {
                day++;
                currWeightSum = weight;
            }
        }
        return day <= days;
    }

    private int shipWeightsWithinGivenDays_BinarySearch(
            int[] weights, int days, int startWeight, int endWeight) {
        int capacity = -1;
        while (endWeight >= startWeight) {
            int midWeight = startWeight + (endWeight - startWeight) / 2;

            if (shipWeightsWithinGivenDays_CheckDays(weights, midWeight, days)) {
                capacity = midWeight;
                endWeight = midWeight - 1;
            } else {
                startWeight = midWeight + 1;
            }
        }
        return capacity;
    }

    public void shipWeightsWithinGivenDays(int[] weights, int days) {
        //https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
        //explanation: https://youtu.be/YUF3_eBdzsk | https://youtu.be/bcAwHkL7A3A
        //based on splitArrayInLargestSum()
        int totalWeight = 0;
        int maxShipmentWeight = 0;
        for (int weight : weights) {
            totalWeight += weight;
            maxShipmentWeight = Math.max(maxShipmentWeight, weight);
        }

        int capacityOfShipNeeded = shipWeightsWithinGivenDays_BinarySearch(
                weights, days, maxShipmentWeight, totalWeight);
        //output:
        System.out.println("Capacity of ship required to ship all weights in given days: " + capacityOfShipNeeded);
    }

    private boolean minimizePageAllocationsToStudents_CanAllocate(
            int[] pages, int maxPageAllocation, int students) {

        int studentsReq = 1;
        int currPagesSum = 0;
        for (int page : pages) {
            currPagesSum += page;
            if (currPagesSum > maxPageAllocation) {
                currPagesSum = page;
                studentsReq++;
            }
        }
        return studentsReq <= students;
    }

    public void minimizePageAllocationsToStudents(int[] pages, int students) {
        //............................T: O(N + N.Log(RANGE)), N = length of pages array
        //RANGE is [min(pages[i]) to sum(pages[i])]
        //https://www.interviewbit.com/problems/allocate-books/
        //explanation: https://youtu.be/gYmWHvRHu-s
        //based on splitArrayInLargestSum()
        int minPage = pages[0];
        int totalPages = 0;
        for (int page : pages) {
            minPage = Math.min(minPage, page);
            totalPages += page;
        }

        //minimize the page allocations to student will lie in range
        //[minPage to totalPages]
        //overall T: O(N * Log(RANGE))
        //Binary search: T; O(Log(RANGE)) 
        int startPage = minPage;
        int endPage = totalPages;
        int minimizesPageAllocation = totalPages;
        while (endPage > startPage) {
            int midPage = startPage + (endPage - startPage) / 2;
            //T: O(N), at worst the below method will check for N pages in pages[]
            //whether we can allocate all of the pages to given student or not
            if (minimizePageAllocationsToStudents_CanAllocate(pages, midPage, students)) {
                minimizesPageAllocation = midPage;
                endPage = midPage - 1;
            } else {
                startPage = midPage + 1;
            }
        }
        //output
        System.out.println("Minimized pages allocation to students: " + minimizesPageAllocation);
    }

    private boolean kokoEatingBananas_CanEat(int[] piles, int maxPile, int hour) {
        int currHr = 0;
        for (int pile : piles) {
            currHr += pile / maxPile;
            if (pile % maxPile != 0) {
                currHr++;
            }
        }
        return currHr <= hour;
    }

    public void kokoEatingBananas(int[] piles, int hour) {
        //https://leetcode.com/problems/koko-eating-bananas/
        //https://leetcode.com/problems/koko-eating-bananas/discuss/1691271/similar-to-allocate-pages-of-books
        int maxPile = Integer.MIN_VALUE;
        for (int pile : piles) {
            maxPile = Math.max(maxPile, pile);
        }

        int start = 1;
        int end = maxPile;

        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (kokoEatingBananas_CanEat(piles, mid, hour)) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        //output
        System.out.println("Minimized speed in koko can eat all the bananas within given hours: " + start);
    }

    private boolean cakeDistributionMaxSweetnessAmongKFriends_isMaxSweetnessPossible(
            int[] sweetness, int reqSweetness, int reqFriends) {

        int friends = 0;
        int currSweetness = 0;
        for (int sweet : sweetness) {
            currSweetness += sweet;
            if (currSweetness >= reqSweetness) {
                friends++;
                currSweetness = 0;
            }
        }
        return friends >= reqFriends + 1;
    }

    public void cakeDistributionMaxSweetnessAmongKFriends(int[] sweetness, int k) {
        //https://practice.geeksforgeeks.org/problems/0a7c7f1089932257071f9fa076f25d353f91e0fd/1
        //based on BINARY SEARCH & splitArrayInLargestSum()
        int minSweetness = Integer.MAX_VALUE;
        int maxSweetness = 0;
        for (int sweet : sweetness) {
            maxSweetness += sweet;
            minSweetness = Math.min(minSweetness, sweet);
        }

        int start = minSweetness;
        int end = maxSweetness;

        int maxSweetnessProvided = 0;

        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (cakeDistributionMaxSweetnessAmongKFriends_isMaxSweetnessPossible(sweetness, mid, k)) {
                maxSweetnessProvided = mid;
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        //output
        System.out.println("Cake distribution with max swetness amon K friends : " + maxSweetnessProvided);
    }

    public void subseqOfLengthKWithLargestSum(int[] nums, int k) {
        //......................T: O(N.LogK) + O(K.LogK), minHeap + List<Pair> sorting
        //https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/
        class Pair {

            int val;
            int index;

            public Pair(int val, int index) {
                this.val = val;
                this.index = index;
            }
        }

        //first find the K largest elements, so sort by value
        //by finding K largest elements, we will have largest sum
        PriorityQueue<Pair> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);

        //K largest elements
        for (int i = 0; i < nums.length; i++) {
            minHeap.add(new Pair(nums[i], i));
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }

        //after above loop, we will left with K largest elements in the heap
        //now sort the values by min index to maintain subseq order
        List<Pair> values = new ArrayList<>(minHeap);
        Collections.sort(values, (a, b) -> a.index - b.index);

        int[] subseq = new int[k]; // values.size == k
        for (int i = 0; i < values.size(); i++) {
            subseq[i] = values.get(i).val;
        }
        //output
        System.out.println("Subsequence of length k having largest sum : " + Arrays.toString(subseq));
    }

    public void rangeSumQueries_BruteForce(int[] nums, int[][] queries) {
        //.........................T: O(M*N), for processing M queries it will
        //take in worst case O(N) time (if for mth query left = 0 and right = N - 1)
        //https://leetcode.com/problems/range-sum-query-immutable/
        List<Integer> sumsInQueryRange = new ArrayList<>();
        //T: O(M)
        for (int[] query : queries) {

            int left = query[0];
            int right = query[1];
            int sum = 0;
            //T: O(N) in worst case
            for (int i = left; i <= right; i++) {
                sum += nums[i];
            }
            sumsInQueryRange.add(sum);
        }
        //output
        System.out.println("Sums from all the queries (Brute Force): " + sumsInQueryRange);
    }

    public void rangeSumQueries(int[] nums, int[][] queries) {
        //.........................T: O(N + M), for finding prefix sum,
        //for processing M queries it will take O(1)
        //https://leetcode.com/problems/range-sum-query-immutable/
        //explanation: https://youtu.be/k5Im14rNUFA
        //OPTIMISED
        //based on PREFIX SUM
        //convert nums array to its prefix sum array
        int prefix = nums[0];
        int n = nums.length;
        for (int i = 1; i < n; i++) {
            prefix += nums[i];
            nums[i] = prefix;
        }
        List<Integer> sumsInQueryRange = new ArrayList<>();
        for (int[] query : queries) {

            int left = query[0];
            int right = query[1];

            int sum = left - 1 < 0
                    ? nums[right]
                    : nums[right] - nums[left - 1];

            sumsInQueryRange.add(sum);
        }
        //output
        System.out.println("Sums from all the queries: " + sumsInQueryRange);
    }

    public void partitionArrayOnGivenPivot(int[] nums, int pivot) {
        //https://leetcode.com/problems/partition-array-according-to-given-pivot/
        //https://leetcode.com/problems/rearrange-array-elements-by-sign
        int n = nums.length;
        List<Integer> smaller = new ArrayList<>();
        List<Integer> same = new ArrayList<>();
        List<Integer> larger = new ArrayList<>();
        List<Integer> result = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            if (nums[i] < pivot) {
                smaller.add(nums[i]);
            } else if (nums[i] == pivot) {
                same.add(nums[i]);
            } else {
                larger.add(nums[i]);
            }
        }

        result.addAll(smaller);
        result.addAll(same);
        result.addAll(larger);

        //output
        //int[] output = result.stream().mapToInt(val -> val).toArray();
        System.out.println("Partition array on given pivot with relative order maintained: " + result);
    }

    public void distinctBarcodes(int[] barcodes) {
        //https://leetcode.com/problems/distant-barcodes/
        //based on reorganizeString()
        //Acc to quest, rearrange barcodes so that no two adjacent barcodes are equal.
        int n = barcodes.length;
        int[] result = new int[n];
        int index = 0;

        Map<Integer, Integer> freq = new HashMap<>();
        for (int val : barcodes) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        PriorityQueue<Integer> maxHeapFreq = new PriorityQueue<>(
                (a, b) -> freq.get(b) - freq.get(a));

        for (int val : freq.keySet()) {
            maxHeapFreq.add(val);
        }

        //until there are 2 or more elements to pick
        //pick firstMostFreqNum and secondMostFreqNum
        while (maxHeapFreq.size() > 1) {

            int firstMostCommonNum = maxHeapFreq.poll();
            int secondMostCommonNum = maxHeapFreq.poll();

            result[index++] = firstMostCommonNum;
            result[index++] = secondMostCommonNum;

            //since we have taken 1 unit of firstMostCommonNum we must reduce its freq
            freq.put(firstMostCommonNum, freq.getOrDefault(firstMostCommonNum, 0) - 1);
            //if there are still some freq for curr firstMostCommonNum is left
            //we will add it back to maxHeap
            if (freq.get(firstMostCommonNum) > 0) {
                maxHeapFreq.add(firstMostCommonNum);
            }

            //since we have taken 1 unit of secondMostCommonNum we must reduce its freq
            freq.put(secondMostCommonNum, freq.getOrDefault(secondMostCommonNum, 0) - 1);
            //if there are still some freq for curr secondMostCommonNum is left
            //we will add it back to maxHeap
            if (freq.get(secondMostCommonNum) > 0) {
                maxHeapFreq.add(secondMostCommonNum);
            }
        }

        //there are chances, that there will remain 1 element in the maxHeap
        //we simply add it to our result 
        if (!maxHeapFreq.isEmpty()) {
            result[index] = maxHeapFreq.poll();
        }
        //output
        System.out.println(Arrays.toString(result));
    }

    public void kRadiusSubarrayAverages(int[] nums, int k) {
        //https://leetcode.com/problems/k-radius-subarray-averages/
        //https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-effort/
        //based on SLIDING WINDOW
        int n = nums.length;
        int[] result = new int[n];
        //default avg at each index
        Arrays.fill(result, -1);

        int start = 0;
        int end = 0;
        //long to handle large numbers
        long winLen = 2 * k + 1;
        long currSum = 0;

        while (end < n) {
            currSum += nums[end];

            if (end - start + 1 == winLen) {
                long avg = currSum / winLen;
                int avgAtIndex = end - k;
                result[avgAtIndex] = (int) avg;
                //minimizing window
                currSum -= nums[start++];
            }
            end++;
        }
        //output
        System.out.println("K radius subarray averages: " + Arrays.toString(result));
    }

    public void stepsToMakeArrayNonDecreasing(int[] nums) {
        //https://leetcode.com/problems/steps-to-make-array-non-decreasing/
        //based on nextGreaterElementToRightInArray
        /*
        ex: [5,3,4,4,7,3,6,11,8,5,11]
        at currVal = 11, stack was empty[]
        stack[{11,0}]
        at currVal = 5, it can't remove 11 as 5 ! greater than prevVal 11
        stack[{11,0}, {5, 0}]
        at currVal = 8, it can remove only 5 thus the count = 1
        stack[{11,0}, {8, 1}]
        at currVal = 11, it can remove only 8 thus the count = 1
        stack[{11,0}, {11, 1}], , steps = 1
        at currVal = 6, it can't remove 11 as 6 ! greater than prevVal 11
        stack[{11,0}, {11, 1}, {6, 0}]
        at currVal = 3, it can't remove 6 as 3 ! greater than prevVal 6
        stack[{11,0}, {11, 1}, {6, 0}, {3, 0}]
        at currVal = 7, it can remove 3, 6 thus count = 2
        stack[{11,0}, {11, 1}, {7, 2}], steps = 2
        at currVal = 4, it can't remove 7 as 4 ! greater than prevVal 7
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}]
        at currVal = 4, it can't remove 4 as 4 ! greater than prevVal 4
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}, {4, 0}]
        at currVal = 4, it can't remove 3 as 3 ! greater than prevVal 4
        stack[{11,0}, {11, 1}, {7, 2}, {4, 0}, {4, 0}, {3, 0}]
        at currVal = 5, it can remove 3, 4, 4 thus count = 3
        stack[{11,0}, {11, 1}, {7, 2}, {5, 3}], steps = 3
        
        this 3 is the max removal we need to make between element [5 to 7]
        to make it non-decreasing, so that much removal will take min of 3 steps
        as each removal will happen in 1 unit steps
         */
        class ValCount {

            int val;
            int count;

            public ValCount(int val, int count) {
                this.val = val;
                this.count = count;
            }

        }

        int n = nums.length;
        int steps = 0;
        Stack<ValCount> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {

            //the count will be calculated for curr val such that
            //we will check like how many elements before this it can remove
            //if this curr val is greater that is previous elements (stack.peek().val < val)
            int removalCount = 0;

            while (!stack.isEmpty() && stack.peek().val < nums[i]) {
                removalCount = Math.max(removalCount + 1, stack.peek().count);
                stack.pop();
            }

            //checking the max with removalCount because
            //as per question, in one step we can remove nums[i]
            //if nums[i - 1] > nums[i] so we are comparing the removal counts
            //at any particular time this count will tell
            //"to remove this much(== removalCount) count we will
            //require atmost (removalCount) steps as each removal
            //will be treated as 1 unit step"
            steps = Math.max(steps, removalCount);

            stack.push(new ValCount(nums[i], removalCount));
        }

        //output
        System.out.println("Total steps to make array non-decreasing: " + steps);
    }

    public void onlineStockSpan(int[] prices) {
        //https://leetcode.com/problems/online-stock-span/
        //based on nextSmallerElementToLeftInArray()
        int n = prices.length;
        Stack<Integer> stack = new Stack<>();
        int[] spans = new int[n];
        for (int i = 0; i < n; i++) {
            int price = prices[i];
            while (!stack.isEmpty() && prices[stack.peek()] <= price) {
                stack.pop();
            }
            spans[i] = stack.isEmpty() ? i + 1 : i - stack.peek();
            stack.push(i);
        }
        //output
        System.out.println("Online stock span for every i-th price: " + Arrays.toString(spans));
    }

    public void maxPointsObtainFromCards(int[] points, int k) {
        //https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/
        //based on SLIDING WINDOW
        /*
        Question asks to choose the num in one step, from either starting or ending
        of points[] that should be of length k and this k-length array should give the
        max points.
        intution behind this, rather than doing a simple sliding window of window size k
        find the totalsPointSum (i.e, points[] sum) and do a sliding window on (n - k)
        size and we can find the maxPoint with totalPointSum - currPointSum(in curr window)
        
        ex: points: [1,2,3,4,5,6,1], k = 3
        totalPointSum = sum(points[]) = 22
        winSize = n - k => 7 - 3 = 4
        win1: [1,2,3,4],5,6,1 | currWindowSum = [1,2,3,4] = 10 | totalPointSum - currWindowSum = 22 - 10 = 12
        win2: 1,[2,3,4,5],6,1 | currWindowSum = [2,3,4,5] = 14 | totalPointSum - currWindowSum = 22 - 14 = 8
        win3: 1,2,[3,4,5,6],1 | currWindowSum = [3,4,5,6] = 18 | totalPointSum - currWindowSum = 22 - 18 = 4
        win4: 1,2,3,[4,5,6,1] | currWindowSum = [4,5,6,1] = 16 | totalPointSum - currWindowSum = 22 - 16 = 6
        
        maxPoints = 12
         */
        int n = points.length;
        //as per the question we can either choose values from start or end
        //we can choose 'k' value from these positions. so think it the other ways
        //each time we consider a window of size 'window' we will leave k elements
        //on either start or end or both (see above intuition)
        int window = n - k;

        int maxPoints = 0;

        int totalPointSum = 0;
        for (int point : points) {
            totalPointSum += point;
        }

        int currWindowSum = 0;
        int index = 0;
        //calculate the sum of first 'window' length subarray
        //i.e, win1: [1,2,3,4],5,6,1
        for (; index < window; index++) {
            currWindowSum += points[index];
        }

        //initial max points from first 'window' length subarray sum
        maxPoints = totalPointSum - currWindowSum;

        int start = 0;
        //end ptr should start from the window-th index(i.e, after the first 'window')
        int end = index;

        while (end < n) {

            //maintain the subarray sum having length 'window' by adding a new 
            //points[end] value and reducing points[start] value
            //ex: 
            //win1: [1,2,3,4],5,6,1
            //win2: 1,[2,3,4,5],6,1
            //win3: 1,2,[3,4,5,6],1
            currWindowSum += points[end];
            currWindowSum -= points[start];

            start++;
            end++;

            maxPoints = Math.max(maxPoints, totalPointSum - currWindowSum);

        }
        //output
        System.out.println("Max point sum: " + maxPoints);
    }

    public void minStepsToRemoveMaxAndMinValueFromFrontOrBack(int[] nums) {
        //https://leetcode.com/problems/removing-minimum-and-maximum-from-array/
        /*
        ex: nums: [2,10,7,5,4,1,8,6] maxVal = 10 & minVal = 1 | maxIndex = 1, minIndex = 5
        
        1. removing max or min val from front
        <---
        [2,10,7,5,4,1,8,6] (2 steps to remove maxVal == 10, i.e, maxIndex + 1)
        <-----------
        [2,10,7,5,4,1,8,6] (6 steps to remove minVal == 1, i.e, minIndex + 1)
        stepsForRemovingBothFromFront = max(2, 6)
        
        2. removing max or min val from back
            ------------>
        [2,10,7,5,4,1,8,6] (7 steps to remove maxVal == 10, i.e, n - maxIndex)
                    ---->
        [2,10,7,5,4,1,8,6] (3 steps to remove minVal == 1, i.e, n - minIndex)
        stepsForRemovingBothFromBack = max(7, 3)
        
        3. removing each of the value from front and back
        <---
        [2,10,7,5,4,1,8,6] (for removing maxVal == 10, from either front or back will take 2 or 7 steps)
            ------------>
        stepsForRemovingMaxVal = min(2, 7);
        
        <-----------
        [2,10,7,5,4,1,8,6] (for removing minVal == 1, from either front or back will take 6 or 3 steps)
                    ---->
        stepsForRemovingMinVal = min(6, 3);
        
        stepsForRemovingMaxMinSeparately = stepsForRemovingMaxVal + stepsForRemovingMinVal;
        
        now choose which possible scenario will give min no of steps
        minSteps = Math.min(stepsForRemovingMaxMinSeparately,
                Math.min(stepsForRemovingBothFromFront, stepsForRemovingBothFromBack));
         */
        int n = nums.length;
        int maxVal = Integer.MIN_VALUE;
        int minVal = Integer.MAX_VALUE;

        int maxIndex = 0;
        int minIndex = 0;

        //simply finding the maxVal and its index and minVal and its index from array
        for (int i = 0; i < n; i++) {
            int val = nums[i];
            if (val > maxVal) {
                maxVal = val;
                maxIndex = i;
            }
            if (val < minVal) {
                minVal = val;
                minIndex = i;
            }
        }

        int stepsForRemovingBothFromFront = Math.max(maxIndex + 1, minIndex + 1);
        int stepsForRemovingBothFromBack = Math.max(n - maxIndex, n - minIndex);

        //steps for removing each element from either front or back,
        //depending which one is giving lesser steps
        //min steps for removing just the max val either from front or back
        int stepsForRemovingMaxVal = Math.min(maxIndex + 1, n - maxIndex);
        //min steps for removing just the min val either from front or back
        int stepsForRemovingMinVal = Math.min(minIndex + 1, n - minIndex);

        int stepsForRemovingMaxMinSeparately = stepsForRemovingMaxVal + stepsForRemovingMinVal;

        int minSteps = Math.min(stepsForRemovingMaxMinSeparately,
                Math.min(stepsForRemovingBothFromFront, stepsForRemovingBothFromBack));
        //output
        System.out.println("Min steps for removing max & min value from array: " + minSteps);
    }

    public void maxConsecutiveFloorsWithoutIncludingSpecialFloors(int bottom, int top, int[] special) {
        //https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
        /*
        floors: [2    3   sorted([4, 6])  7   8   9]
        4 - 2 = 2 consecutive-non-special floors(2, 3)
        6 - 4 - 1 = 1 consecutive-non-special floors(5)
        9 - 6 = 3 consecutive-non-special floors(7, 8, 9)
        maxConsecutiveFloors = max(2, 1, 3) = 3
         */
        int n = special.length;
        Arrays.sort(special);
        //first consecutive floors will be between
        //first(bottom) floor and the first special floor(after sorting)
        int maxConsecutiveFloors = special[0] - bottom;

        //there can be some consecutive-non-special floors between
        //two special floors in sorted special[] that will be (special[i] - special[i - 1] - 1)
        //choose where we are tracking most num of consecutive floors
        for (int i = 1; i < n; i++) {
            maxConsecutiveFloors = Math.max(maxConsecutiveFloors,
                    special[i] - special[i - 1] - 1);
        }

        //and finally the consecutive floors can be between
        //last special floor(after sorting) and the top floor given
        maxConsecutiveFloors = Math.max(maxConsecutiveFloors,
                top - special[n - 1]);

        System.out.println("Max consecutive floors in given bottom to top floors without some special floors: "
                + maxConsecutiveFloors);
    }

    public void findGoodDayToRobBank(int[] security, int time) {
        //https://leetcode.com/problems/find-good-days-to-rob-the-bank/
        int n = security.length;
        List<Integer> days = new ArrayList<>();
        List<Integer> incrDaysBeforeIThDay = new ArrayList<>();
        List<Integer> nonIncrDaysBeforeIThDay = new ArrayList<>();

        //calculating days that are greater than the curr i-th day
        incrDaysBeforeIThDay.add(0);
        for (int i = 1; i < n; i++) {
            if (security[i - 1] >= security[i]) {
                incrDaysBeforeIThDay.add(
                        incrDaysBeforeIThDay.get(incrDaysBeforeIThDay.size() - 1) + 1
                );
            } else {
                incrDaysBeforeIThDay.add(0);
            }
        }

        //calculating days where curr i-th day is greater than its previous
        nonIncrDaysBeforeIThDay.add(0);
        for (int i = 1; i < n; i++) {
            if (security[i - 1] <= security[i]) {
                nonIncrDaysBeforeIThDay.add(
                        nonIncrDaysBeforeIThDay.get(nonIncrDaysBeforeIThDay.size() - 1) + 1
                );
            } else {
                nonIncrDaysBeforeIThDay.add(0);
            }
        }

        //starting day = time because in order to rob the bank there is a
        //'time' range before and after from our curr day, so any day starting from < time
        //will not give that before-range, same is the reason for running it till n - time
        //so that we can have after-range form our curr day
        for (int day = time; day < n - time; day++) {
            if (incrDaysBeforeIThDay.get(day) < time || nonIncrDaysBeforeIThDay.get(day + time) < time) {
                continue;
            }
            days.add(day);
        }
        //output
        System.out.println("Good days to rob the bank: " + days);
    }

    public void longestMountainInArray(int[] arr) {
        //https://leetcode.com/problems/longest-mountain-in-array/
        int n = arr.length;
        int maxMountainSize = 0;
        int mountainStart = 0;

        while (mountainStart < n) {
            int mountainEnd = mountainStart;

            if (mountainEnd + 1 < n && arr[mountainEnd] < arr[mountainEnd + 1]) {
                //after this loop our mountainEnd will be at the mountain-peek index
                //strictly incr to mountain-peek
                while (mountainEnd + 1 < n && arr[mountainEnd] < arr[mountainEnd + 1]) {
                    mountainEnd++;
                }

                //validate if this is the actually the mountain-peek
                if (mountainEnd + 1 < n && arr[mountainEnd] > arr[mountainEnd + 1]) {
                    //strictly decr from mountain-peek
                    while (mountainEnd + 1 < n && arr[mountainEnd] > arr[mountainEnd + 1]) {
                        mountainEnd++;
                    }

                    maxMountainSize = Math.max(maxMountainSize, mountainEnd - mountainStart + 1);
                }
            }
            mountainStart = Math.max(mountainEnd, mountainStart + 1);
        }
        //output
        System.out.println("Longest mountain size: " + maxMountainSize);
    }

    public boolean increasingTripletSubseq(int[] nums) {
        //https://leetcode.com/problems/increasing-triplet-subsequence/
        int n = nums.length;
        int firstMin = Integer.MAX_VALUE;
        int secondMin = Integer.MAX_VALUE;

        for (int val : nums) {
            if (val <= firstMin) {
                firstMin = val;
            } else if (val <= secondMin) {
                secondMin = val;
            } else {
                return true;
            }
        }
        return false;
    }

    public void deckRevealedIncreasing(int[] deck) {
        //https://leetcode.com/problems/reveal-cards-in-increasing-order/
        //https://leetcode.com/problems/reveal-cards-in-increasing-order/solution/
        //question statement not cleared right now, need explanation & update comment is future
        int n = deck.length;
        int[] result = new int[n];
        //saving the indexes from [0 to n-1]
        Queue<Integer> indexes = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            indexes.add(i);
        }

        //sorting the cards in the deck in increasing order
        Arrays.sort(deck);

        for (int card : deck) {
            //here polling an index from indexes queue will get you first 
            //even-index(0,2,4...). Because all the odd-index
            //will be moved back in the queue by below if-block
            result[indexes.poll()] = card;
            if (!indexes.isEmpty()) {
                //all the odd-index move back in the queue, until
                //even index are set increasingly
                indexes.add(indexes.poll());
            }
        }
        //output
        System.out.println("Deck revealed increasing: " + Arrays.toString(result));
    }

    private int sumOfSubarrayMins_PickElement(int[] arr, int index) {
        return (index == -1 || index == arr.length) ? Integer.MIN_VALUE : arr[index];
    }

    public void sumOfSubarrayMins(int[] arr) {
        //https://leetcode.com/problems/sum-of-subarray-minimums/
        //https://leetcode.com/problems/sum-of-subarray-minimums/discuss/2535363/JavaOne-Pass-Monotonic-Stack-with-Comments
        int n = arr.length;
        long result = 0l;
        int mod = 1000000007;
        Stack<Integer> indexes = new Stack<>();
        for (int i = -1; i <= n; i++) {

            while (!indexes.isEmpty()
                    && sumOfSubarrayMins_PickElement(arr, indexes.peek()) > sumOfSubarrayMins_PickElement(arr, i)) {
                int currIndex = indexes.pop();
                int start = indexes.peek();
                int end = i;
                result = (result + (long) (currIndex - start) * (end - currIndex) * arr[currIndex]) % mod;
            }
            indexes.push(i);
        }
        //output
        System.out.println("Sum of subarray minimums elements: " + result);
    }

    public void maxAreaOfPieceOfCake(int height, int width, int[] horizontalCuts, int[] verticalCuts) {
        //https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
        /*
        height = 5, width = 4, horizontalCuts = [1,2,4], verticalCuts = [1, 3]
        
        initial cut point
        left-edge \ top-edge
                      verCut[0]         verCut[1]
                    0       1       2       3       4
        horCut[0]   1-------|---------------|---------
        horCut[1]   2-------|---------------|---------
                    3       |  piece area   |
        horCut[2]   4-------|---------------|---------
                    5       |               |
        
        maxDiffHorizontal is between horCut[3] and horCut[1] (4 - 2) = 2
        maxDiffVertical is between verCut[1] and horCut[0] (3 - 1) = 2
        
        max cake piece area = maxDiffHorizontal * maxDiffVertical
         */
        int horLen = horizontalCuts.length;
        int vertLen = verticalCuts.length;

        Arrays.sort(horizontalCuts);
        Arrays.sort(verticalCuts);

        //inital diff between the first cut point and starting of cake top edge == 0
        int maxDiffOfHorizontalCuts = horizontalCuts[0] - 0;
        //inital diff between the first cut point and starting of cake left edge == 0
        int maxDiffOfVerticalCuts = verticalCuts[0] - 0;

        //find the max diff between two consecutive cuts after sorting
        for (int row = 1; row < horLen; row++) {
            maxDiffOfHorizontalCuts = Math.max(maxDiffOfHorizontalCuts,
                    horizontalCuts[row] - horizontalCuts[row - 1]);
        }

        //also find the max diff between actual height and last cut point after sorting
        maxDiffOfHorizontalCuts = Math.max(maxDiffOfHorizontalCuts,
                height - horizontalCuts[horLen - 1]);

        //find the max diff between two consecutive cuts after sorting
        for (int col = 1; col < vertLen; col++) {
            maxDiffOfVerticalCuts = Math.max(maxDiffOfVerticalCuts,
                    verticalCuts[col] - verticalCuts[col - 1]);
        }

        //also find the max diff between actual width and last cut point after sorting
        maxDiffOfVerticalCuts = Math.max(maxDiffOfVerticalCuts,
                width - verticalCuts[vertLen - 1]);

        //output
        System.out.println("Max area of piece of cake: " + (maxDiffOfHorizontalCuts * maxDiffOfVerticalCuts));
    }

    public void freqOfMostFrequentElement(int[] nums, int k) {
        //https://leetcode.com/problems/frequency-of-the-most-frequent-element/
        //based on SLIDING WINDOW
        int n = nums.length;
        Arrays.sort(nums);
        int start = 0;
        int end = 0;
        int sum = 0;
        int freq = 0;

        while (end < n) {
            sum += nums[end];
            //since we have sorted the nums[] so each nums[i] will be greater 
            //than its prev value
            //this below while cond means,
            //(end - start + 1) * nums[end] means we need num[end] to be most freq
            //element under [start to end]
            //ex nums = [1,2,4] when start = 0, end = 1
            //winLen = end - start + 1 = 2
            //winLen * nums[end] ==> 2 * 4 = 8 
            //this means if we make our nums like this nums[[4, 4], 4] it should
            //have a total sum of winLen * nums[end]
            //BUT
            //the actual sum till this [start to end] is 'sum'
            //means we need (winLen * nums[end]) but total at this point is 'sum'
            //if the diff of them is atmost K we can use all the K operations to
            //make our sum == winLen * nums[end] and hence under [start to end] all
            //elements will be equal to nums[end] hence winLen == freq of nums[end]
            //BUT
            //if this diff is greater than K we will never be able to do K operations
            //to cover up that diff then we reduce our window
            while ((end - start + 1) * nums[end] - sum > k) {
                sum -= nums[start];
                start++;
            }
            //end - start + 1 == winLen will tell that under above while cond
            //it is possible to make nums[end] to be most freq element from [start to end]
            //if we do k operations, and if we can do that then this winLen will contain
            //most freq element
            freq = Math.max(freq, (end - start + 1));
            end++;
        }
        //output
        System.out.println("After performing atmost K operations in elements, freq of most frequent element: " + freq);
    }

    public void findAllLonelyNumberInArray(int[] nums) {
        //https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
        List<Integer> lonelyElements = new ArrayList<>();
        int n = nums.length;

        Arrays.sort(nums);

        for (int i = 0; i < n; i++) {

            //skip the given valid (non-lonely) nums[i]
            //if prev nums[i - 1] is consecutive prev num of nums[i]
            //or prev nums[i - 1] is same as nums[i]
            if (i - 1 >= 0 && (nums[i - 1] == nums[i] - 1 || nums[i - 1] == nums[i])) {
                continue;
            }

            //skip the given valid (non-lonely) nums[i]
            //if next nums[i + 1] is consecutive next num of nums[i]
            //or next nums[i + 1] is same as nums[i]
            if (i + 1 < n && (nums[i + 1] == nums[i] + 1 || nums[i + 1] == nums[i])) {
                continue;
            }
            //here we have lonely nums[i]
            lonelyElements.add(nums[i]);
        }
        //output
        System.out.println("All the lonley elements in arrasy: " + lonelyElements);
    }

    public void numberOfSubarraysFilledWithZeros(int[] nums) {
        //https://leetcode.com/problems/number-of-zero-filled-subarrays/
        //based on SLIDING WINDOW
        int n = nums.length;
        long currSum = 0;
        long subarrays = 0;
        int start = 0;
        int end = 0;

        while (end < n) {
            currSum += nums[end];
            //nums[] can have +ve or -ve values so at any point in time
            //where our currSum is either greater than 0 or less than 0
            //we must reduce it to currSum == 0 because
            //ex any subarray[] with zeoes [0,0] the currSum always remain 0 only
            while (currSum > 0 || currSum < 0) {
                currSum -= nums[start];
                start++;
            }
            //if we have shrinked our window to a subarray where currSum == 0
            //we have a subarray where it is zero(s) only
            if (currSum == 0) {
                subarrays += (end - start + 1);
            }
            end++;
        }
        //output
        System.out.println("Number of subarrays filled with zeroes: " + subarrays);
    }

    private void productOfTheLastKNumbersHelper(
            List<String> commandStrings, List<Integer> commandValues) {
        class PrefixProduct {

            int num;
            int prefixProd;

            public PrefixProduct(int num, int prefixProd) {
                this.num = num;
                this.prefixProd = prefixProd;
            }

        }

        int inputLength = commandStrings.size();

        int ARBITARY_VALUE_FOR_ADD_COMMAND = Integer.MIN_VALUE;

        List<PrefixProduct> prefixProdList = new ArrayList<>();
        List<Integer> result = new ArrayList<>();

        for (int i = 0; i < inputLength; i++) {

            String command = commandStrings.get(i);
            int value = commandValues.get(i);

            if (command.equals("add")) {
                if (value == 0) {
                    //if we ever see the the value 0, we will clear out our list
                    //beacuse if we don't do this our prefixProd will go 0 from
                    //that point
                    prefixProdList.clear();
                } else if (prefixProdList.isEmpty()) {
                    //if list was empty that means it the first record, save both
                    //as num & prefixprod
                    prefixProdList.add(new PrefixProduct(value, value));
                } else {
                    //just like we find a prefixSum in array, here we are also
                    //doing the same thing, curr value will be multiplied with
                    //the last prefixProd
                    int size = prefixProdList.size();
                    int currPrefixProd = prefixProdList.get(size - 1).prefixProd * value;
                    prefixProdList.add(new PrefixProduct(value, currPrefixProd));
                }
                //for 'add' command a corresponding value(no meaning as such)
                result.add(ARBITARY_VALUE_FOR_ADD_COMMAND);
            } else if (command.equals("getProduct")) {
                int k = value;
                int size = prefixProdList.size();
                //k can be greater than the actual list size only when we have 
                //encountered a 0 previously (otherwise acc to question 1 <= k <= list.size())
                //beacuse in 'add' we have a logic to clear list whenever we see 0
                //otherwise our prefixProd will go 0
                if (k > size) {
                    result.add(0);
                } else {
                    int kthIndexFromLast = size - k;

                    //formula: productFromKthIndexToLast = totalProd / (prod @k-index/ num @k-index)
                    //that is like productFromKthIndexToLast == [k to size]
                    int totalProduct = prefixProdList.get(size - 1).prefixProd;

                    int prefixProductTillKThIndex = prefixProdList.get(kthIndexFromLast).prefixProd;
                    int valueAtKThIndex = prefixProdList.get(kthIndexFromLast).num;

                    //(prod @k-index/ num @k-index)
                    int prefixProdBeforeKthIndexFromLast = prefixProductTillKThIndex / valueAtKThIndex;

                    int productFromKthIndexToLast
                            = totalProduct / prefixProdBeforeKthIndexFromLast;

                    result.add(productFromKthIndexToLast);
                }
            }
        }
        //output
        System.out.println("Last Kth product in the data stream: " + result);
    }

    public void productOfTheLastKNumbers() {
        //......................T: O(1)
        //......................S: O(N), storing N incoming nums from data stream
        //https://leetcode.com/problems/product-of-the-last-k-numbers/
        /*
        ex: nums[1,2,3,4,5]
        prefixProd [1,2,6,24,120]
        size = 5
        num:            1   2   3   4   5
        prefixProd:     1   2   6   24  120
        
        totalProd = lastProd @prefixProd == 120
        
        let say k == 3 then need to find the last k prod i.e, [3 to 5] == [3 * 4 * 5] = 60
        
        kThIndexfromLast = size - k ==> 5 - 3 = 2
        nums[kThIndexfromLast] = num[2] ==> 3
        
        prefixProductTillKThIndex = prefixProd @kThIndexfromLast == 6
        valueAtKThIndex = num @kThIndexfromLast = 3;
        
        prefixProdBeforeKthIndexFromLast == prefixProd just before kThIndexfromLast == 2
        that also means (prefixProductTillKThIndex / valueAtKThIndex)
        ==> 6 / 3 == 2, How?
        simply beacuse we are doing the prefixProd, so we got prefixProd == 6 at
        num[kThIndexfromLast] == num[2] == 3 by multiplying its prefixProd(i.e 2)
        by this value(i.e 3) so dividing back we will get prefixProd before kThIndexfromLast
        
        productFromKthIndexToLast = totalProd / prefixProdBeforeKthIndexFromLast
        ==> 120 / 2 = 60 i.e, [3 to 5] == [3 * 4 * 5]
         */
        //input
        List<String> commandStrings = new ArrayList<>(
                Arrays.asList("add", "add", "add", "add", "add", "getProduct",
                        "getProduct", "getProduct", "add", "getProduct"));
        List<Integer> commandValues = new ArrayList<>(
                Arrays.asList(3, 0, 2, 5, 4, 2, 3, 4, 8, 2));
        //output
        productOfTheLastKNumbersHelper(commandStrings, commandValues);
    }

    public void findOriginalArrayFromDoubledArray(int[] changed) {
        //https://leetcode.com/problems/find-original-array-from-doubled-array/
        //https://leetcode.com/problems/array-of-doubled-pairs/
        /*
        Given that there was some OriginalArray[] where each of its element get doubled
        and added into the array and we are given this changed[] array. Need to find 
        back the originalArrays(if possible)
        originalArray[].length = changed[].length / 2
        
        Intution:
        Sort the arrays first and create a freq map for the changed[]
        
        Now iterate over the changed[] and try to remove the val and ist doubledVal
        reduce freq by freq and if there is no more freq left remove the element from
        freq map
        
        Since the changed[] is double the original array therefore, if we form the 
        originalArray that is of reqLen break the loop because thats how the originalArray
        initially was
        
         */
        int n = changed.length;
        int reqLen = n / 2;

        List<Integer> originalArray = new ArrayList<>();
        Map<Integer, Integer> freq = new HashMap<>();

        for (int val : changed) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        Arrays.sort(changed);

        for (int val : changed) {

            int doubledVal = 2 * val;

            //to handle cases for 0 (ex: [0,0,0,0])
            if (val == 0 && freq.containsKey(val) && freq.get(val) <= 1) {
                continue;
            }

            if (freq.containsKey(val) && freq.containsKey(doubledVal)) {

                originalArray.add(val);

                freq.put(val, freq.getOrDefault(val, 0) - 1);
                if (freq.get(val) <= 0) {
                    freq.remove(val);
                }

                freq.put(doubledVal, freq.getOrDefault(doubledVal, 0) - 1);
                if (freq.get(doubledVal) <= 0) {
                    freq.remove(doubledVal);
                }
            }
            if (originalArray.size() == reqLen) {
                break;
            }
        }
        //output
        System.out.println("Original array from given changed array: " + (originalArray.size() == reqLen
                ? originalArray
                : Arrays.toString(new int[]{})));
    }

    private int kConcatenationMaxSubarraySum_KadenAlgo(int[] arr) {
        //slightly modified version of actual kaden's algo
        int n = arr.length;
        int maxSum = arr[0];
        int currSum = arr[0];
        for (int i = 1; i < n; i++) {
            currSum = Math.max(arr[i], currSum + arr[i]);
            //if currSum goes negative then reset currSum to 0
            currSum = Math.max(currSum, 0);
            maxSum = Math.max(maxSum, currSum);
        }
        return maxSum;
    }

    public int kConcatenationMaxSubarraySum(int[] arr, int k) {
        //https://leetcode.com/problems/k-concatenation-maximum-sum/
        //based on kaden's algo
        int mod = 1000000007;
        int n = arr.length;
        //if arr is concatenated k == 1 times that is same arr as original
        if (k == 1) {
            return kConcatenationMaxSubarraySum_KadenAlgo(arr) % mod;
        }

        int[] twiceTheArr = new int[2 * n];
        for (int i = 0; i < n; i++) {
            //first half same as arr[]
            twiceTheArr[i] = arr[i];
            //other half is also same as arr[]
            twiceTheArr[n + i] = arr[i];
        }

        if (k == 2) {
            return kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
        }

        long totalSum = 0;
        for (int val : arr) {
            totalSum += val;
        }

        if (totalSum >= 0) {
            int twiceTheArrMaxSum = kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
            int remaining = (int) ((totalSum % mod) * (k - 2) % mod);
            return (int) (twiceTheArrMaxSum + remaining) % mod;
        }
        return kConcatenationMaxSubarraySum_KadenAlgo(twiceTheArr) % mod;
    }

    public void sumOfEvenNumbersAfterGivenQueries(int[] nums, int[][] queries) {
        //https://leetcode.com/problems/sum-of-even-numbers-after-queries/
        int n = nums.length;
        int m = queries.length;
        int[] result = new int[m];

        int totalEvenSum = 0;

        for (int val : nums) {
            //if val is even number add it to totalEvenSum
            totalEvenSum += val % 2 == 0 ? val : 0;
        }

        int qIndex = 0;
        for (int[] query : queries) {
            int val = query[0];
            int index = query[1];

            int oldNumVal = nums[index];
            //if the old num value at given index was even that means, it was
            //used to form the totalEvenSum now adjust this num by deleting
            //it from totalEvenSum
            totalEvenSum -= oldNumVal % 2 == 0 ? oldNumVal : 0;

            //update the value at index in nums[] by the given value in query
            nums[index] += val;

            //now if the new updated value in nums[] becomes an even number
            //we must consider this number in our totalEvenSum, then again adjust
            //this totalEvenSum
            totalEvenSum += nums[index] % 2 == 0 ? nums[index] : 0;

            //at this point we have proccessed our single query, we must store 
            //the totalEvenSum till now in our result[]
            result[qIndex++] = totalEvenSum;
        }
        //output
        System.out.println("Sum of even number after queries: " + Arrays.toString(result));
    }

    public void fruitsIntoBasket(int[] fruits) {
        //https://leetcode.com/problems/fruit-into-baskets/
        //based on SLIDING WINDOW
        //this question is like longest contigous subarray with ATMOST k (here == 2)
        //numbers(repetitions allowed)
        int n = fruits.length;
        Map<Integer, Integer> basket = new HashMap<>();
        int start = 0;
        int end = 0;
        int maxTreeRange = 0;
        while (end < n) {
            int fruitsEnd = fruits[end];
            basket.put(fruitsEnd, basket.getOrDefault(fruitsEnd, 0) + 1);

            //basket can contain atmost 2 fruits
            while (basket.size() > 2) {
                int fruitsStart = fruits[start];
                basket.put(fruitsStart, basket.getOrDefault(fruitsStart, 0) - 1);
                if (basket.get(fruitsStart) <= 0) {
                    basket.remove(fruitsStart);
                }
                start++;
            }

            //if currently the basket contains fruits <= 2 that can be our tree range
            if (basket.size() <= 2) {
                maxTreeRange = Math.max(maxTreeRange, end - start + 1);
            }
            end++;
        }
        //output
        System.out.println("Max tree range where basket can contains atmost fruits: " + maxTreeRange);
    }

    public void maxWidthBetweenGivenPoints(int[][] points) {
        //https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/
        //simple plain sorting, why this one was a Medium question on leetcode,
        //don't know :P
        int n = points.length;
        //sort the points in incr order of row-axis,
        //if row-axis are same then sort in incr order of col-axis else incr order of row-axis
        Arrays.sort(points, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        int maxWidth = 0;
        for (int i = 1; i < n; i++) {
            int prevX = points[i - 1][0];
            int currX = points[i][0];
            maxWidth = Math.max(maxWidth, currX - prevX);
        }
        //output
        System.out.println("Max width from given points: " + maxWidth);
    }

    public void kThSmallestPairDistance(int[] nums, int k) {
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/solution/
        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/196304/Verbosely-commented-Python-Approach-3-with-example-walkthrough
        //based on BINARY SEARCH + SLIDING WINDOW
        /*
        A straight forward Pair generation(using nested for loops) + Heap method
        would also work but that was giving TLE for large inputs
         */
        int n = nums.length;

        Arrays.sort(nums);

        int min = nums[0];
        int max = nums[n - 1];

        int low = 0;
        int high = max - min;

        while (high > low) {

            int mid = low + (high - low) / 2;

            int pairs = 0;
            int start = 0;
            int end = 0;

            while (end < n) {
                while (nums[end] - nums[start] > mid) {
                    start++;
                }
                pairs += (end - start);
                end++;
            }
            if (pairs >= k) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        //output
        System.out.println("KTh smallest pair distance: " + low);
    }

    public void kThSmallestPairSum(int[] nums1, int[] nums2, int k) {
        //https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
        class Pair {

            int u;
            int v;
            long sum;

            public Pair(int u, int v, long sum) {
                this.u = u;
                this.v = v;
                this.sum = sum;
            }

        }

        int n = nums1.length;
        int m = nums2.length;
        List<List<Integer>> kSmallestSumPairs = new ArrayList<>();
        PriorityQueue<Pair> maxHeapSum = new PriorityQueue<>(
                (a, b) -> (int) (b.sum - a.sum));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {

                int smallestSum = nums1[i] + nums2[j];

                //if the curr maxHeap size is less than k we can pick this pair
                //as we need min k smallest sum pair
                if (maxHeapSum.size() < k) {
                    maxHeapSum.add(new Pair(nums1[i], nums2[j], smallestSum));
                } else {
                    //here this cond smallestSum < maxHeapSum.peek().sum is checked
                    //because  we need k smallest pair and in this else block
                    //we have atleast k pairs, now we need to decide if the
                    //curr smallestSum is pickable or not
                    //here if size is greater than the k
                    //we will check before polling that the curr smallestSum
                    //is smaller than the curr peek sum or not, if it smaller then
                    //only pick this pair else break from this loop, why break?
                    //because in question it is given that both nums1 & nums2 are
                    //sorted so if the curr smallestSum is greater than curr peek sum
                    //then it will always be higher after this
                    if (smallestSum < maxHeapSum.peek().sum) {
                        //remove the peek higher sum
                        maxHeapSum.poll();
                        //put the curr pair with the smallestSum;
                        maxHeapSum.add(new Pair(nums1[i], nums2[j], smallestSum));
                    } else {
                        //here if the curr smallestSum is actually greater than the
                        //curr peek sum, it will always remain greater so no need to 
                        //waste time after this, so break also prevent TLE
                        break;
                    }
                }
            }
        }

        while (!maxHeapSum.isEmpty()) {
            Pair pair = maxHeapSum.poll();
            kSmallestSumPairs.add(Arrays.asList(pair.u, pair.v));
        }
        //output
        System.out.println("K smallest pair sum: " + kSmallestSumPairs);
    }

    private boolean minDeletionsToMakeArrayDivisble_IsDivisible(
            int val, Set<Integer> numsToDivideSet) {
        for (int num : numsToDivideSet) {
            if (num % val != 0) {
                return false;
            }
        }
        return true;
    }

    public int minDeletionsToMakeArrayDivisble(int[] nums, int[] numsToDivide) {
        //https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/
        Set<Integer> numsToDivideSet = new HashSet<>(IntStream.of(numsToDivide)
                .boxed().collect(Collectors.toSet()));

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.addAll(IntStream.of(nums).boxed().collect(Collectors.toList()));

        int deletes = 0;
        while (!minHeap.isEmpty()) {

            int peek = minHeap.peek();
            //if the curr smallest peek value is able to divide all the num in numsToDivideSet
            //then the result would be how many deletes we made to get to this peek value
            if (minDeletionsToMakeArrayDivisble_IsDivisible(peek, numsToDivideSet)) {
                return deletes;
            } else {
                //the above peek value was not able to divide all the nums in 
                //numsToDivideSet that means this peek value is not the smallest
                //value for our result that should divide all the nums in numsToDivideSet
                //we must poll this num from minHeap and if there are more num
                //equal to this poll them out too
                int polled = minHeap.poll();
                //since one element is polled, we deleted it
                deletes += 1;
                //if more num are same as peek/polled value delete them as well
                while (!minHeap.isEmpty() && minHeap.peek() == polled) {
                    deletes++;
                    minHeap.poll();
                }
            }
        }
        return -1;
    }

    public boolean checkIfArrayPairsAreDivisibleByK(int[] nums, int k) {
        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/
        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/discuss/709691/Java-7ms-Simple-Solution
        int[] freq = new int[k];
        for (int val : nums) {
            val %= k;
            if (val < 0) {
                val += k;
            }
            freq[val]++;
        }
        if (freq[0] % 2 != 0) {
            return false;
        }
        for (int i = 1; i <= k / 2; i++) {
            if (freq[i] != freq[k - i]) {
                return false;
            }
        }
        return true;
    }

    public int shortestSubarrayRemovedToMakeArrayNonDecreasing(int[] arr) {
        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/discuss/830480/C%2B%2B-O(N)-Sliding-window-Explanation-with-Illustrations
        int n = arr.length;
        int left = 0;
        int right = n - 1;

        //move left index to the peek element in arr from start
        //ex: a[row] <= a[col] <= a[left] <-- PEEK
        while (left + 1 < n && arr[left] <= arr[left + 1]) {
            left++;
        }

        //means the given arr is already non-decreasing, so no subarray to be
        //removed to make it no-decreasing then its length is 0
        if (left == n - 1) {
            return 0;
        }

        //move the right index to deepest valley in the arr from end
        //ex: VALLEY --> a[right] <= a[col] <= a[row]
        while (right > left && arr[right - 1] <= arr[right]) {
            right--;
        }

        //currently, two possibility to make arr non-decreasing is
        //1. arr[0 to left] is already non-dec so remove the subarray after the
        //left index which is (n - left - 1)
        //2. arr[right to n - 1] is already non-dec so remove the subarray before
        //the right index which is (right)
        int minLength = Math.min(n - left - 1, right);

        //there is another possibility to remove the subarray to make arr non-decreasing
        //is to find the shortest subarray between left and right indexes
        int start = 0;
        int end = right;

        //here we are checking if the window between start & end gives us the
        //shortest subarray to be removed, by comparing arr[end] >= arr[start]
        //hence the removable subarray length becomes end - start - 1
        while (left >= start && end < n) {
            if (arr[end] >= arr[start]) {
                minLength = Math.min(minLength, end - start - 1);
                start++;
            } else {
                end++;
            }
        }
        return minLength;
    }

    public void partitionsArrayIntoDisjointIntervals(int[] nums) {
        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/
        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/solution/
        /*
        partition it into two (contiguous) subarrays left and right so that:

        1. Every element in left is less than or equal to every element in right.
        2. left and right are non-empty.
        3. left has the smallest possible size.
         */
        int n = nums.length;
        int currMax = nums[0];
        int possibleMax = nums[0];
        int length = 1;
        for (int i = 1; i < n; i++) {
            if (currMax > nums[i]) {
                length = i + 1;
                currMax = possibleMax;
            } else {
                possibleMax = Math.max(possibleMax, nums[i]);
            }
        }
        //output
        System.out.println("Partition length: " + length);
    }

    public boolean containsDuplicateThree(int[] nums, int indexDiff, int valueDiff) {
        //https://leetcode.com/problems/contains-duplicate-iii/
        //https://leetcode.com/problems/contains-duplicate-iii/discuss/2728206/Java-Solution-using-TreeMap-and-sliding-window-oror-O(nLog(indexDiff))
        //based on SLIDING WINDOW
        /*
        Find a pair of indices (i, j) such that:
        1. i != j,
        2. abs(i - j) <= indexDiff.
        3. abs(nums[i] - nums[j]) <= valueDiff, and
         */
        int n = nums.length;
        int start = 0;
        int end = start + 1;
        TreeMap<Integer, Integer> valIndex = new TreeMap<>();
        valIndex.put(nums[start], start);

        while (end < n) {

            if (end <= start + indexDiff) {
                Integer minVal = valIndex.floorKey(nums[end]);
                Integer maxVal = valIndex.ceilingKey(nums[end]);

                if (minVal != null && Math.abs(nums[end] - minVal) <= valueDiff) {
                    return true;
                }

                if (maxVal != null && Math.abs(nums[end] - maxVal) <= valueDiff) {
                    return true;
                }

                valIndex.put(nums[end], end);
                end++;
            } else {
                if (valIndex.get(nums[start]) <= start) {
                    valIndex.remove(nums[start]);
                }
                start++;
            }
        }
        return false;
    }

    public void minOperationsToMakeArrayContinous(int[] nums) {
        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/
        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/discuss/2725833/Java-Sliding-Windows
        //based on SLIDING WINDOW
        /*
        nums[] is considered continuous if both of the following conditions are fulfilled:
        1. All elements in nums are unique.
        2. The difference between the maximum element and the minimum element in
        nums equals nums.length - 1.
         */
        int len = nums.length;
        nums = Arrays.stream(nums).sorted().distinct().toArray();
        int newLen = nums.length;
        int start = 0;
        int end = 0;
        int oprn = len;

        while (end < newLen) {
            while (nums[end] - nums[start] >= len) {
                start++;
            }
            oprn = Math.min(oprn, len - (end - start + 1));
            end++;
        }
        //output
        System.out.println("Min number of operation to make array continous: " + oprn);
    }

    public void groupPeopleInTheirGroupSizes(int[] groupSizes) {
        //https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
        int n = groupSizes.length;
        List<List<Integer>> groupWithPeople = new ArrayList<>();
        Map<Integer, List<Integer>> groups = new HashMap<>();

        for (int people = 0; people < n; people++) {
            int groupSize = groupSizes[people];

            //create a new group in map with size == groupSize, and put all the
            //people into this group until we we reach the max size of curr group
            groups.putIfAbsent(groupSize, new ArrayList<>());
            groups.get(groupSize).add(people);

            //when we reach the maxSize of the curr group == groupSize
            //take that groups and put that in separate list groupWithPeople
            //and since we have reached the maxSize limit for the curr group we 
            //can remove this group from map that would mean we have processes
            //one group and later on we can create a new groups in map with the
            //same groupSize
            if (groups.get(groupSize).size() == groupSize) {
                groupWithPeople.add(groups.get(groupSize));
                groups.remove(groupSize);
            }
        }
        //output
        System.out.println("People in groups with fixed group sizes: " + groupWithPeople);
    }

    public void maxNumberOfKSumPairs(int[] nums, int k) {
        //https://leetcode.com/problems/max-number-of-k-sum-pairs/
        Map<Integer, Integer> freq = new HashMap<>();
        int oprn = 0;
        for (int val : nums) {
            int diff = k - val;
            if (freq.containsKey(diff)) {
                oprn++;
                freq.put(diff, freq.getOrDefault(diff, 0) - 1);
                if (freq.get(diff) <= 0) {
                    freq.remove(diff);
                }
            } else {
                freq.put(val, freq.getOrDefault(val, 0) + 1);
            }
        }
        //output
        System.out.println("Max number of k sum pairs: " + oprn);
    }

    public void arrayWithElementsNotEqualToAverageOfNeighbours(int[] nums) {
        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/discuss/2762685/2-Solutions-oror-O(Nlogn)-and-O(N)-oror-Easy
        int n = nums.length;
        for (int i = 1; i < n - 1; i++) {
            if (nums[i - 1] + nums[i + 1] == 2 * nums[i]) {
                swapIntArray(nums, i, i + 1);
            }
        }

        for (int i = n - 2; i >= 1; i--) {
            if (nums[i - 1] + nums[i + 1] == 2 * nums[i]) {
                swapIntArray(nums, i, i - 1);
            }
        }
        //output
        System.out.println("Arrays with elements not equal to average of neighbours: " + Arrays.toString(nums));
    }

    public void minConsecutiveCardsToPickUpBetweenSameCards(int[] cards) {
        //https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
        /*
        cards[] = [3,4,2,3,4,7]
        same cards = 3 at index 0 & 3 cards to pick between them = 3 - 0 + 1 = 4
        same cards = 4 at index 1 & 4 cards to pick between them = 4 - 1 + 1 = 4
        min cards picked is 4
         */
        int n = cards.length;
        int minPickUps = Integer.MAX_VALUE;
        Map<Integer, Integer> valIndex = new HashMap<>();

        for (int end = 0; end < n; end++) {
            //curr card value
            int cardValue = cards[end];
            //if any card value already exists that matches with curr card value
            //we need to calculate the min cards to pick between this currCard and
            //same card that already existed 
            if (valIndex.containsKey(cardValue)) {
                //end = index of curr card 
                //valIndex.get(cardValue) = index of same card that already existed
                int cardsToPick = end - valIndex.get(cardValue) + 1;
                //pick min
                minPickUps = Math.min(minPickUps, cardsToPick);
            }
            valIndex.put(cardValue, end);
        }
        //output
        System.out.println("Min consecutive cards to pick between cards with same value: "
                + (minPickUps == Integer.MAX_VALUE ? -1 : minPickUps));
    }

    public void destroySequentialTarget(int[] nums, int space) {
        //https://leetcode.com/problems/destroy-sequential-targets/
        //https://leetcode.com/problems/destroy-sequential-targets/discuss/2773080/Counter-or-Python
        int maxFreq = 0;
        Map<Integer, Integer> destroyFreq = new HashMap<>();
        for (int val : nums) {
            int destroy = val % space;
            destroyFreq.put(destroy, destroyFreq.getOrDefault(destroy, 0) + 1);
            maxFreq = Math.max(maxFreq, destroyFreq.get(destroy));
        }

        int result = Integer.MAX_VALUE;
        for (int val : nums) {
            int destroy = val % space;
            if (destroyFreq.get(destroy) == maxFreq) {
                result = Math.min(result, val);
            }
        }
        //output
        System.out.println("Destroy sequential target: " + result);
    }

    public void singleElementInSortedArray(int[] nums) {
        //https://leetcode.com/problems/single-element-in-a-sorted-array/
        //https://leetcode.com/problems/single-element-in-a-sorted-array/discuss/2803159/Single-Element-In-A-Sorted-Array-or-C%2B%2B-or-O(logn)or-Binary-Search
        //based on BINARY SEARCH
        int n = nums.length;
        int start = 0;
        int end = n - 1;
        while (end > start) {
            int mid = start + (end - start) / 2;
            if ((mid % 2 == 0 && nums[mid] == nums[mid + 1])
                    || (mid % 2 == 1 && nums[mid] == nums[mid - 1])) {
                start = mid + 1;
            } else {
                end = mid;
            }
        }
        //output
        System.out.println("Single element in sorted array : " + nums[start]);
    }

    public void maxSumOfDistinctSubarrayOfLengthK(int[] nums, int k) {
        //https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/
        //based on SLIDING WINDOW
        int n = nums.length;
        Map<Integer, Integer> distinctValInWindow = new HashMap<>();
        int start = 0;
        int end = 0;
        long currSum = 0;
        long distinctSubarrayMaxSum = 0;
        while (end < n) {

            currSum += nums[end];

            distinctValInWindow.put(nums[end], distinctValInWindow.getOrDefault(nums[end], 0) + 1);

            if (end - start + 1 == k) {
                //curr subarray of size == window of size K
                //should hold all elemets distinct, if all the elements are
                //distinct then distinctValInWindow.size == K
                if (distinctValInWindow.size() == k) {
                    distinctSubarrayMaxSum = Math.max(distinctSubarrayMaxSum, currSum);
                }

                //shrink the window
                currSum -= nums[start];
                distinctValInWindow.put(nums[start], distinctValInWindow.getOrDefault(nums[start], 0) - 1);
                if (distinctValInWindow.get(nums[start]) <= 0) {
                    distinctValInWindow.remove(nums[start]);
                }
                start++;
            }
            end++;
        }
        //output
        System.out.println("Max sum of distinct subarray of length k: " + distinctSubarrayMaxSum);
    }

    public void longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(int[] nums, int limit) {
        //..........................T: O(N*LogN), N is length of nums[]
        //..........................S: O(N), N is length of nums[]
        //worst case can be where nums[] contains the same value
        //https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
        //https://practice.geeksforgeeks.org/problems/close-to-perfection1525/1
        //based on SLIDING WINDOW
        int n = nums.length;
        int start = 0;
        int end = 0;
        //tree map stores the key in sorted order and fetching the min & max value
        //is easily possible
        TreeMap<Integer, Integer> minMax = new TreeMap<>();
        int maxLen = 0;

        while (end < n) {

            minMax.put(nums[end], minMax.getOrDefault(nums[end], 0) + 1);

            //treemap stores the nums[] value as key and keep it in sorted order
            //min is at root and max will be in last
            int min = minMax.firstKey();
            int max = minMax.lastKey();

            //shink the window size when the dif of min & max value is greater than limit
            while (start < end && max - min > limit) {
                minMax.put(nums[start], minMax.getOrDefault(nums[start], 0) - 1);
                if (minMax.get(nums[start]) <= 0) {
                    minMax.remove(nums[start]);
                }
                start++;
                //update the new min & max
                min = minMax.firstKey();
                max = minMax.lastKey();
            }
            maxLen = Math.max(maxLen, end - start + 1);
            end++;
        }
        //output
        System.out.println("Max length of subarray where the diff of its min & max value is atmost 1: " + maxLen);
    }

    public void countSubarraysWithFixedBounds(int[] nums, int minK, int maxK) {
        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/
        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/discuss/2784063/PYTHON-SOLUTION-100-EXPLAINED-LINE-BY-LINE
        //based on SLIDING WINDOW
        int n = nums.length;
        int start = 0;
        int end = 0;
        long count = 0;
        int minValIndex = -1;
        int maxValIndex = -1;

        while (end < n) {
            //run the loop till the nums[end] is in the bounds of [minK, maxK]
            while (end < n && (nums[end] >= minK && nums[end] <= maxK)) {
                if (nums[end] == minK) {
                    minValIndex = end;
                }

                if (nums[end] == maxK) {
                    maxValIndex = end;
                }

                if (minValIndex != -1 && maxValIndex != -1) {
                    count += (Math.min(minValIndex, maxValIndex) - start + 1);
                }

                end++;
            }

            //since the above loop will break when there is a nums[end] not in
            //the [minK, maxK] bound so we also don't need this curr end index
            //that is not in bounds, so move to next end index == end + 1
            end += 1;
            start = end;
            //reset
            minValIndex = maxValIndex = -1;
        }
        //output
        System.out.println("Subarrays that in the fixed bounds: " + count);
    }

    private int circularArrayLoop_nextIndex(int[] nums, int index, boolean isFrontDir) {
        int n = nums.length;

        int nextIndex = (index + nums[index]) % n;

        if (nextIndex < 0) {
            nextIndex = n + nextIndex;
        }

        if (index == nextIndex) {
            return -1;
        }

        boolean nextDir = nums[nextIndex] >= 0;

        if (nextDir != isFrontDir) {
            return -1;
        }

        return nextIndex;
    }

    public boolean circularArrayLoop(int[] nums) {
        //https://leetcode.com/problems/circular-array-loop/
        //https://leetcode.com/problems/circular-array-loop/discuss/2820902/Circular-Array-problem-solved-(Java)
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            boolean isFrontDir = nums[i] >= 0;
            int slow = i;
            int fast = i;
            while (true) {

                slow = circularArrayLoop_nextIndex(nums, slow, isFrontDir);
                if (slow == -1) {
                    break;
                }

                int tempFast = circularArrayLoop_nextIndex(nums, fast, isFrontDir);
                if (tempFast == -1) {
                    break;
                }

                fast = circularArrayLoop_nextIndex(nums, fast, isFrontDir);
                if (fast == -1) {
                    break;
                }

                if (slow == fast) {
                    return true;
                }
            }
        }
        return false;
    }

    public void findPlayerWithZeroOrOneLosses(int[][] matches) {
        //https://leetcode.com/problems/find-players-with-zero-or-one-losses/
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> wonAllMatches = new ArrayList<>();
        List<Integer> lostOnlyOneMatches = new ArrayList<>();

        Map<Integer, Integer> winners = new HashMap<>();
        Map<Integer, Integer> loosers = new HashMap<>();

        int minPlayer = Integer.MAX_VALUE;
        int maxPlayer = Integer.MIN_VALUE;

        for (int[] match : matches) {

            int winner = match[0];
            int looser = match[1];

            //with minPlayer and maxPlayer we figuring out the range of players
            //who played matches
            minPlayer = Math.min(minPlayer, Math.min(winner, looser));
            maxPlayer = Math.max(maxPlayer, Math.max(winner, looser));

            //winners map will have all the players who won
            winners.put(winner, winners.getOrDefault(winner, 0) + 1);
            //loosers map will have all the players who lost
            loosers.put(looser, loosers.getOrDefault(looser, 0) + 1);
        }

        //from the range of players
        for (int player = minPlayer; player <= maxPlayer; player++) {
            //a player who won AND never lost is the one who won all the matches
            if (winners.containsKey(player) && !loosers.containsKey(player)) {
                wonAllMatches.add(player);
            } else if (loosers.containsKey(player) && loosers.get(player) == 1) {
                //a player who never won BUT lost only 1 times is the one who
                //lost only one match
                lostOnlyOneMatches.add(player);
            }
        }

        result.add(wonAllMatches);
        result.add(lostOnlyOneMatches);

        //output
        System.out.println("Players with 1) zero loss & 2) one loss:  " + result);
    }

    public void removeCoveredIntervals(int[][] intervals) {
        //https://leetcode.com/problems/remove-covered-intervals/
        //https://leetcode.com/problems/remove-covered-intervals/discuss/2749987/intuitive-solution-using-python
        int n = intervals.length;
        //sort on the start time
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        int crossover = 0;
        int prevStart = intervals[0][0];
        int prevEnd = intervals[0][1];

        for (int i = 1; i < n; i++) {
            int currStart = intervals[i][0];
            int currEnd = intervals[i][1];

            if (prevEnd >= currEnd || (currStart == prevStart && currEnd >= prevEnd)) {
                crossover++;
                prevEnd = Math.max(prevEnd, currEnd);
            } else {
                prevStart = currStart;
                prevEnd = currEnd;
            }
        }
        //output
        System.out.println("After removing crossovered intervals, remaining intervals: " + (n - crossover));
    }

    public void taskSchedulerTwo(int[] tasks, int space) {
        //https://leetcode.com/problems/task-scheduler-ii/
        //https://leetcode.com/problems/task-scheduler-ii/discuss/2842466/Java-using-HashMap-time-complexity-O(n)
        Map<Integer, Long> taskDays = new HashMap<>();
        long days = 0;
        for (int task : tasks) {

            if (!taskDays.containsKey(task) || (days - taskDays.get(task) > (long) space)) {
                taskDays.put(task, days);
            } else if (taskDays.containsKey(task)) {
                long waitDays = (long) space - days + taskDays.get(task) + 1L;
                days += waitDays;
                taskDays.put(task, days);
            }
            days++;
        }
        //output
        System.out.println("Min days required: " + days);
    }

    public void minAverageDiff(int[] nums) {
        //https://leetcode.com/problems/minimum-average-difference/
        int n = nums.length;
        long[] prefixSumArr = new long[n];
        long currPrefixSum = 0;
        for (int i = 0; i < n; i++) {
            currPrefixSum += nums[i];
            prefixSumArr[i] = currPrefixSum;
        }

        long totalSum = currPrefixSum;
        int resultIndex = -1;
        long minAbsAvgDiff = Long.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            long firstAvg = prefixSumArr[i] / (long) (i + 1);
            long secondAvg = (i == n - 1)
                    ? 0 : (totalSum - prefixSumArr[i]) / (long) (n - i - 1);
            long currAbsAvg = Math.abs(firstAvg - secondAvg);
            if (currAbsAvg < minAbsAvgDiff) {
                minAbsAvgDiff = currAbsAvg;
                resultIndex = i;
            }
        }
        //output
        System.out.println("Min absolute average difference: " + resultIndex);
    }

    private int maxPairSumWithEqualDigitSum_DigitSum(int val) {
        int digitSum = 0;
        while (val > 0) {
            digitSum += (val % 10);
            val /= 10;
        }
        return digitSum;
    }

    public void maxPairSumWithEqualDigitSum(int[] nums) {
        //https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/
        /*
        nums[] = [18,43,36,13,7]
        digitSum: 
        18 == 1 + 8 = 9
        43 == 4 + 3 = 7
        36 == 3 + 6 = 9
        13 == 1 + 3 = 4
        7 == 7 = 7
        digitSumWithVals: 
        {9 = [18, 36], 7 = [43, 7], 4 = [13]}
        now looping over the map's values(), after sorting we will get max pair in
        the list's end (n - 1 & n - 2)
         */
        //group all the values in nums[] whose val's sum of digit are same
        Map<Integer, List<Integer>> digitSumWithVals = new HashMap<>();
        for (int val : nums) {
            int digitSum = maxPairSumWithEqualDigitSum_DigitSum(val);
            digitSumWithVals.putIfAbsent(digitSum, new ArrayList<>());
            digitSumWithVals.get(digitSum).add(val);
        }

        int maxSum = 0;
        for (List<Integer> vals : digitSumWithVals.values()) {
            //for a max pair sum we need min 2 vals in the list, if the vals.size
            //is less than 2 skip
            if (vals.size() < 2) {
                continue;
            }
            int size = vals.size();
            //since we need max pair sum sort the vals list such that max 2 values
            //are in the end, the pick the last two max vaues (n - 1) & (n - 2)
            //adding these two max values will give the max pair sum
            Collections.sort(vals);
            int currSum = vals.get(size - 1) + vals.get(size - 2);
            maxSum = Math.max(maxSum, currSum);
        }
        //output
        System.out.println("Max pair sum with digit sum: " + (maxSum == 0 ? -1 : maxSum));
    }

    public void maxChunkToMakeSorted(int[] arr) {
        //https://leetcode.com/problems/max-chunks-to-make-sorted/description/
        //https://leetcode.com/problems/max-chunks-to-make-sorted/solutions/113528/simple-java-o-n-solution-with-detailed-explanation/
        /*
        given an integer array arr of length n that represents a permutation of
        the integers in the range [0, n - 1]
        
        this algorithm wants us to do is finding some splitting line so that
        numbers being left of this line are all small than numbers right of this
        line. The idea is very similar to quick sort. What the answer of this
        question is how many lines you can find. So that is why we want the max
        array, or we can only need a number for storing the maximum number up to
        now(because original array is 0 to len-1), as long as the max number
        equals the index, we know that all numbers left to this point are smaller
        than this point and numbers right to this point are larger than this point,
        then we count add one.
         */
        int n = arr.length;
        int chunks = 0;
        int maxVal = 0;
        for (int i = 0; i < n; i++) {
            maxVal = Math.max(maxVal, arr[i]);
            if (maxVal == i) {
                chunks++;
            }
        }
        //output
        System.out.println("Max chunks to make arr sorted: " + chunks);
    }

    public void maxChunkToMakeSortedTwo(int[] arr) {
        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/
        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/solutions/2821654/advance-sorting-technique/
        int n = arr.length;
        int[] minFromRight = new int[n + 1];
        Arrays.fill(minFromRight, Integer.MAX_VALUE);
        for (int i = n - 1; i >= 0; i--) {
            minFromRight[i] = Math.min(minFromRight[i + 1], arr[i]);
        }

        int maxOnLeft = Integer.MIN_VALUE;
        int chunks = 0;

        for (int i = 0; i < n; i++) {
            maxOnLeft = Math.max(maxOnLeft, arr[i]);
            if (maxOnLeft <= minFromRight[i + 1]) {
                chunks++;
            }
        }
        //output
        System.out.println("Max chunks to make arr sorted two: " + chunks);
    }

    public void minIncreamentToMakeArrayUnique(int[] nums) {
        //https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/
        /*
        ex: num = [3,2,1,2,1,7]
        sort(nums) = [1,1,2,2,3,7]
        uniqVal = nums[0] = 1
        #1.
        val = 1, uniqVal = 1
        req increament: incr = max(0, uniqVal - val) ==> max(0, 1 - 1) = 0;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(1 + 1, 1 + 1) = 2
        
        #2.
        val = 1, uniqVal = 2
        //means for arr to be unique we need a value 2 but curr value is still 1
        req increament: incr = max(0, uniqVal - val) ==> max(0, 2 - 1) = 1;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(2 + 1, 1 + 1) = 3
        
        #3.
        val = 2, uniqVal = 3
        //means for arr to be unique we need a value 3 but curr value is 2
        req increament: incr = max(0, uniqVal - val) ==> max(0, 3 - 2) = 1;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(3 + 1, 2 + 1) = 4
        
        #4.
        val = 2, uniqVal = 4
        //means for arr to be unique we need a value 4 but curr value is 2
        req increament: incr = max(0, uniqVal - val) ==> max(0, 4 - 2) = 2;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(4 + 1, 2 + 1) = 5
        
        #5.
        val = 3, uniqVal = 5
        //means for arr to be unique we need a value 5 but curr value is 3
        req increament: incr = max(0, uniqVal - val) ==> max(0, 5 - 3) = 2;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(5 + 1, 3 + 1) = 6
        
        #5.
        val = 7, uniqVal = 6
        req increament: incr = max(0, uniqVal - val) ==> max(0, 6 - 7) = 0;
        next uniqVal: max(uniqVal + 1, val + 1) ==> max(6 + 1, 7 + 1) = 8
        
        incr = 0 + 1 + 1 + 2 + 2 + 0 ==> 6
         */
        Arrays.sort(nums);
        int incr = 0;
        //unique value in the array should starts from first smallest value in
        //curr arr[] after sorting
        int uniqueVal = nums[0];
        for (int val : nums) {
            //incr req from curr val to the req unique value
            incr += Math.max(0, uniqueVal - val);
            //next unique value required to be in the array
            uniqueVal = Math.max(uniqueVal + 1, val + 1);
        }
        //output
        System.out.println("Min increament to make array unique: " + incr);
    }

    public void validateStackSequences(int[] pushed, int[] popped) {
        //........................T: O(N)
        //........................T: O(N), for using a stack
        //https://leetcode.com/problems/validate-stack-sequences/description/
        int n = popped.length;

        int j = 0;

        Stack<Integer> stack = new Stack<>();

        for (int val : pushed) {
            stack.push(val);
            //if stack has some data and also if pop seq at j-th index is same as
            //what we have at stack.peek, then actually pop it from stack move j
            //to next popped seq (== j++)
            while (!stack.isEmpty() && stack.peek() == popped[j]) {
                stack.pop();
                j++;
            }
        }

        //output
        System.out.println("Validate stack seq: " + stack.isEmpty());
    }

    public void validateStackSequences2(int[] pushed, int[] popped) {
        //........................T: O(N)
        //........................T: O(1)
        //OPTIMIZED
        //https://leetcode.com/problems/validate-stack-sequences/description/
        //https://leetcode.com/problems/validate-stack-sequences/solutions/1853250/java-c-space-complexity-going-from-o-n-o-1/
        int n = popped.length;

        int i = 0;
        int j = 0;

        for (int val : pushed) {
            //i++ simulates pushing a i-th value in stack and moving to next seq
            //in pushed seq
            pushed[i++] = val;
            //since i moved to next pushed seq but pushed[i - 1] value is stack's
            //peek value, if that peek value is same as what is needed to be popped
            //from popped seq at j-th index pop that and move to next pop value in
            //popped seq
            while (i > 0 && pushed[i - 1] == popped[j]) {
                i--;
                j++;
            }
        }

        //output
        System.out.println("Validate stack seq: " + (i == 0));
    }

    public void minMovesToEqualArrayElements(int[] nums) {
        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
        int n = nums.length;
        int moves = 0;
        Arrays.sort(nums);

        for (int i = 0; i < n; i++) {
            moves += nums[i] - nums[0];
        }
        //output
        System.out.println("Min moves to equal array elements: " + moves);
    }

    public void intervalsListIntersection(int[][] firstList, int[][] secondList) {
        //.............................T: O(M + N), M & N length of firstList & secondList
        //https://leetcode.com/problems/interval-list-intersections/description/
        //based on TWO POINTER
        /*
        ex: 
        firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]
        firstList:  0----2   5-----10     13-----23  24---25
        secondList:   1------5   8-----12     15-----24   25---26
        
        start = max(firstList[start], secondList[start])
        end = min(firstList[end], secondList[end])
        
        start = max(0, 1) = 1, end = min(2, 5) = 2  ==> intersection = [1,2]
        firstList[end] > secondList[end] ==> 2 > 5 ==> i++ ==> firstList next slot = [5,10]
        
        start = max(5, 1) = 5, end = min(5, 10) = 5  ==> intersection = [5,5]
        firstList[end] > secondList[end] ==> 10 > 5 ==> j++ ==> secondList next slot = [8,12]
        .
        .
        .
        same....
        
        intersections: [1, 2],[5,5],[8,10],[15,23],[24,24],[25,25]
        
         */
        int m = firstList.length;
        int n = secondList.length;

        //start & end time indexes in given list
        int START = 0;
        int END = 1;

        int i = 0;
        int j = 0;

        List<int[]> intervalIntersections = new ArrayList<>();

        while (i < m && j < n) {

            //start & end time of the intersecting time from first & second list
            int start = Math.max(firstList[i][START], secondList[j][START]);
            int end = Math.min(firstList[i][END], secondList[j][END]);

            //take only valid intersections
            if (end >= start) {
                intervalIntersections.add(new int[]{start, end});
            }

            //if firstList end time is greater than secondList end time
            //move next time slot in secondList(== j++) to compare with firstList
            //else move next time slot in firstList(== i++) to compare with secondList
            if (firstList[i][END] > secondList[j][END]) {
                j++;
            } else {
                i++;
            }
        }
        //output
        //return intervalIntersections.toArray(new int[intervalIntersections.size()][2]);
        if (intervalIntersections.isEmpty()) {
            System.out.println("No intersections possible");
            return;
        }

        for (int[] intersection : intervalIntersections) {
            System.out.print(Arrays.toString(intersection) + " ");
        }
        System.out.println();
    }

    public void countPairsWithAbsoluteDiffDivisibleByK(int[] nums, int k) {
        //https://practice.geeksforgeeks.org/problems/e0059183c88ab680b2f73f7d809fb8056fe9dc43/1
        //https://www.geeksforgeeks.org/count-pairs-in-an-array-whose-absolute-difference-is-divisible-by-k/
        /*
        1. Convert each elements (A[i]) of the array to ((A[i]+K)%K)
        2. Use hashing technique to store the number of times (A[i]%K) occurs in the array
        3. Now, if an element A[i] occurs row times in the array then add row*(row-1)/2
        (choosing any 2 elements out of row elements ) in the count pair where 1<=i<=n.
        This is because value of each elements of the array lies between 0 to K-1
        so the absolute difference is divisible only if value of both the elements
        of a pair are equal
         */
        int n = nums.length;
        long pairs = 0;
        int[] hash = new int[k];

        for (int i = 0; i < n; i++) {
            nums[i] = (nums[i] + k) % k;
        }

        for (int rem : nums) {
            hash[rem]++;
        }

        for (int i = 0; i < k; i++) {
            pairs += (hash[i] * (hash[i] - 1)) / 2;
        }

        //output
        System.out.println("Pairs with absolute diff divisible by k: " + pairs);
    }

    private boolean removeOneElementMakeArrayStrictlyIncr_IsStrictlyIncr(int[] nums, int skipIndex) {
        int n = nums.length;
        int prevVal = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            if (i == skipIndex) {
                continue;
            }
            if (prevVal >= nums[i]) {
                return false;
            }
            prevVal = nums[i];
        }
        return true;
    }

    public boolean removeOneElementMakeArrayStrictlyIncr(int[] nums) {
        //https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/description/
        int n = nums.length;
        //starting from -1 will basically consider all nums[] to be checked
        //rest other indexes 0 to n - 1 will be skipped iteratively
        //if removing the skip-index make it strictly incr then true
        for (int skipIndex = -1; skipIndex < n; skipIndex++) {
            //if skipping this skipIndex will make the nums[] strictly incr
            //checking if nums[] is strictly incr if val at skipIndex is assumed
            //to be removed
            if (removeOneElementMakeArrayStrictlyIncr_IsStrictlyIncr(nums, skipIndex)) {
                System.out.println("Remove " + nums[skipIndex]
                        + " to make " + Arrays.toString(nums) + " stictly incr");
                return true;
            }

        }
        return false;
    }

    public void dataStreamAsDisjointIntervals(List<String> commands, List<Integer> values) {
        //https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/
        class Helper {

            Set<Integer> values;

            public Helper() {
                this.values = new TreeSet<>();
            }

            //keep all the incoming interval value in sorted order
            //because we will need to calculate all those intervals which are
            //forming disjoint intervals
            public void addNum(int num) {
                values.add(num);
            }

            public int[][] getIntervals() {

                if (values.isEmpty()) {
                    return new int[0][2];
                }

                //initial start & end of curr interval
                int start = -1;
                int end = -1;
                List<int[]> intervals = new ArrayList<>();

                for (int value : values) {

                    //a default case when we start, for the first interval in
                    //values list, this first interval becomes start & end of
                    //curr interval, for later comming value from values we need
                    //to check if that comming next value is joining with curr end
                    if (start < 0) {
                        start = end = value;
                    } else if (value == end + 1) {
                        //if the curr value is same as prev end + 1 then this value
                        //gets consumed in the curr interval of [start, end] hence
                        //end = value
                        end = value;
                    } else {
                        //if curr value != prev end + 1, means this curr value is
                        //forming a disjoint because it can't be included in the
                        //curr ongoing interval [start, end]
                        //so we this curr interval in list, start the next disjoint
                        //interval with curr value
                        intervals.add(new int[]{start, end});
                        start = end = value;
                    }
                }

                intervals.add(new int[]{start, end});
                return intervals.toArray(new int[0][]);
            }

        }

        Helper helper = new Helper();
        for (int i = 0; i < commands.size(); i++) {

            String command = commands.get(i);
            int value = values.get(i);

            if (command.equals("addNum")) {
                helper.addNum(value);
            } else {
                int[][] intervals = helper.getIntervals();
                for (int[] interval : intervals) {
                    System.out.print(Arrays.toString(interval));
                }
                System.out.println();
            }
        }
    }

    public long dividePlayersIntoTeamsOfEqualSkill(int[] skill) {
        //https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/description/
        //based on TWO POINTER
        int n = skill.length;
        if (n == 2) {
            return skill[0] * skill[1];
        }

        long totalSum = 0;
        for (int val : skill) {
            totalSum += val;
        }

        //as length of skill(== n) is even so teams is number of pairs
        long teams = n / 2;

        //if the whole array sum can't be divided among the number of teams we have
        //means sum of each pair of our teams == totalSum 
        if (totalSum % teams != 0) {
            return -1;
        }

        long eachTeamSum = totalSum / teams;

        Arrays.sort(skill);

        int start = 0;
        int end = n - 1;
        long chemistry = 0;

        while (end > start) {
            if (skill[start] + skill[end] == eachTeamSum) {
                chemistry += (skill[start] * skill[end]);
                start++;
                end--;
            } else {
                return -1;
            }
        }
        return chemistry;
    }

    public void countOddNumbersInIntervalRange(int low, int high) {
        //https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/
        https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/solutions/2957338/count-odd-numbers-in-an-interval-range/
        //based on MATH concept, and test for code optimization using this concept
        /*
        brute force approach seems simple
        run loop from [low to high] and check for each value, if its odd then
        update oddCount
        
        but here we will optimize code using some MATH concepts
         */
        //if low is even then incr by 1
        if (low % 2 == 0) {
            low++;
        }
        int oddCount = low > high ? 0 : ((high - low) / 2) + 1;
        //output
        System.out.println("Odd count in interval range : " + oddCount);
    }

    public void minTimeToCompleteTrips(int[] time, int totalTrips) {
        //https://leetcode.com/problems/minimum-time-to-complete-trips/description/
        //based BINARY SEARCH
        long start = 0;
        long end = 100000000000000L;
        while (end > start) {
            long req = start + (end - start) / 2;

            long trips = 0;
            for (int val : time) {
                trips += req / val;
            }

            if (trips < totalTrips) {
                start = req + 1;
            } else {
                end = req;
            }
        }
        //output
        System.out.println("Min time to compelete trips: " + start);
    }

    public void maxSubarraySumWithAtmostOneDeletion(int[] arr) {
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/solutions/377397/intuitive-java-solution-with-explanation/
        //based on KADEN'S Algo
        int n = arr.length;
        int oneDelete = 0;
        int noDelete = arr[0];
        int maxSum = arr[0];

        for (int i = 1; i < n; i++) {
            oneDelete = Math.max(oneDelete + arr[i], noDelete);
            noDelete = Math.max(noDelete + arr[i], arr[i]);
            maxSum = Math.max(maxSum, Math.max(oneDelete, noDelete));
        }
        //output
        System.out.println("Max subarray sum with atmost one deletion: " + maxSum);
    }

    private int successfulPairsOfSpellsAndPotions_BinarySearch(int[] potions, long spell, long success) {

        int m = potions.length;
        int start = 0;
        int end = m - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //if successful pair starts from starting side of potions[]
            //here if successful pairs starts from first index 0 of potions with spell
            //then there will be no mid - 1 in that case mid == 0 will be checked
            //otherwise potions[mid - 1] with spell should be less than success
            //((long) potions[mid - 1] * spell < success)
            //AND potions[mid] with spell should be greater or equal to success
            if (((mid == 0 || (long) potions[mid - 1] * spell < success) && (long) potions[mid] * spell >= success)
                    //if successful pair starts from end side of potions[]
                    //here if successful pairs starts from last index m - 1 of potions with spell
                    //then there will be no mid + 1 in that case mid == m - 1 will be checked
                    //otherwise potions[mid + 1] with spell should be less than success
                    //((long) potions[mid + 1] * spell < success)
                    //AND potions[mid] with spell should be greater or equal to success
                    || ((mid == m - 1 || (long) potions[mid + 1] * spell < success) && (long) potions[mid] * spell >= success)) {

                //either of the above two cond should match to say we have a successful pair
                return mid;
            } else if (success <= (long) potions[mid] * spell) {
                //if curr potion[mid] with spell is already a successful pair
                //means (success <= (long) potions[mid] * spell) then we try to
                //reduce end ptr to find a starting of successful pair
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        //no successful pair found
        return -1;
    }

    public void successfulPairsOfSpellsAndPotions(int[] spells, int[] potions, long success) {
        //https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/
        //based on BINARY SEARCH
        int n = spells.length;
        int m = potions.length;
        int[] countPairs = new int[n];
        Arrays.sort(potions);
        for (int i = 0; i < n; i++) {
            int foundIndex = successfulPairsOfSpellsAndPotions_BinarySearch(potions, spells[i], success);
            //foundIndex == -1 means there is not successful pair found for curr
            //spell[i] with potions[]
            countPairs[i] = foundIndex == -1 ? 0 : m - foundIndex;
        }
        //output
        System.out.println("Successful pairs of spells and potions: " + Arrays.toString(countPairs));
    }

    private int smallerSumThanEachValueInArray_BinarySearch(int[] nums, int find) {
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            int mid = start + (end - start) / 2;

            //the can be duplicated values in nums[] so we need to find the first
            //occuerence of 'find'
            if ((mid == 0 || nums[mid - 1] < find) && nums[mid] == find) {
                return mid;
            } else if (nums[mid] < find) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return -1;
    }

    public void smallerSumThanEachValueInArray(int[] nums) {
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        //based on BINARY SEARCH, findFirstOccurenceKInSortedArray()
        int n = nums.length;
        int[] originalNums = nums.clone();
        long[] result = new long[n];
        long[] prefixSumArr = new long[n];
        int prefixSum = 0;

        //we will sort the nums[] and precompute its prefix sum array, this
        //prefix sum array will help us find the sum of inetgers smaller than
        //the each value in originalNums[i] easily
        Arrays.sort(nums);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            prefixSumArr[i] = prefixSum;
        }

        for (int i = 0; i < n; i++) {
            //now originalNums[] & nums[] are both the same array having same values
            //the diff is that nums[] is now sorted only to compute prefix sum array
            //since, both array are same then any value of originalNums[i] will also
            //be present in nums[] in sorted manner, we can exactly find the first
            //occuerence of the originalNum[i] == find value in sorted nums[], that
            //way, to the left this 'index' (means [0 to index - 1]) are the elements
            //which are smaller than 'find' value and (index - 1) on prefixSumArr will
            //give the sum of integers. Except for index = 0 because there are no elements
            //before this index hence sum of integers is always 0 for first index
            int find = originalNums[i];
            int index = smallerSumThanEachValueInArray_BinarySearch(nums, find);
            //also to note, as its clear that both originalNums[] & nums[] are same arr
            //so finding a value from originalNums[i] in nums[] will always get us a valid
            //index hence index == -1 is not possible in this case
            //And, results[] should be based on values present in originalNums[]
            result[i] = (index == 0) ? 0 : prefixSumArr[index - 1];
        }
        //output
        System.out.println("Sum of integers for each value smaller than nums[i] : "
                + Arrays.toString(result));
    }

    public void smallerSumThanEachValueInArray_HashMapBased(int[] nums) {
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        //based on HASHMAP, O(1) for search the first-occuerence of elements in 
        //original nums[]
        int n = nums.length;
        int[] originalNums = nums.clone();
        Map<Integer, Integer> sortedElementIndex = new HashMap<>();
        long[] result = new long[n];
        long[] prefixSumArr = new long[n];
        int prefixSum = 0;

        //we will sort the nums[] and precompute its prefix sum array, this
        //prefix sum array will help us find the sum of inetgers smaller than
        //each value in originalNums[i] easily
        //also store the unique array element in hashmap and only first-occuerence
        //index of that element will be stored (similar to what we doing with
        //binary search)
        Arrays.sort(nums);
        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            prefixSumArr[i] = prefixSum;
            //store first-occuerence index of nums[i], if we have duplicates their
            //first-occuerence index will only be stored
            sortedElementIndex.putIfAbsent(nums[i], i);
        }

        for (int i = 0; i < n; i++) {
            //first-occuerence of originalNums[i] from the sorted element map
            int index = sortedElementIndex.get(originalNums[i]);
            result[i] = (index == 0) ? 0 : prefixSumArr[index - 1];
        }
        //output
        System.out.println("Sum of integers for each value smaller than nums[i] (HashMap Based): "
                + Arrays.toString(result));
    }

    public void nearestSmallerTower(int[] heights) {
        //https://practice.geeksforgeeks.org/problems/a520c08a8ea9b617be25c38b0fc2fe057e889253/1
        //based on nearest smaller value in left and in right
        int n = heights.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];

        //nearest smaller value in left
        //this will fill a smaller tower present in left of the curr heights[i]
        //and fill that smaller tower's index in result[i]
        for (int i = 0; i < n; i++) {

            int height = heights[i];

            while (!stack.isEmpty() && heights[stack.peek()] >= height) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(i);
        }

        stack.clear();

        //nearest smaller value in right
        //this will fill a smaller tower present in right of the curr heights[i]
        //and fill that smaller tower's index in result[i] but here's a catch
        //we have already calculated smaller in left side now we have to choose
        //which one to pick from, left or right smaller towers
        for (int i = n - 1; i >= 0; i--) {

            int height = heights[i];

            while (!stack.isEmpty() && heights[stack.peek()] >= height) {
                stack.pop();
            }

            //if the stack is empty, means for curr heights[i] there is no smaller
            //tower in right but we might have a smaller tower to curr heights[i]
            //in its left side, so keep that only
            //else if stack is not empty
            if (!stack.isEmpty()) {
                //if for curr heights[i] there was no smaller tower in left side
                //because currently result[i] == -1 calculated for left side but
                //here we do have a smaller tower in its right so update result[i] 
                if (result[i] == -1) {
                    result[i] = stack.peek();
                } else {
                    //1. If two smaller towers are at the same distance, pick the smallest tower.
                    //2. If two towers have the same height then we choose the one with a smaller index.
                    if (Math.abs(result[i] - i) == Math.abs(i - stack.peek())) {
                        //if from curr heights[i] the dist to smaller tower in its
                        //left and in its right is same then we check if the
                        //height of the right side tower(heights[stack.peek()]) is
                        //smaller than left side tower(heights[result[i]]) then only
                        //update result[i] otherwise result[i] is already
                        //holding the smaller tower index from its left side
                        if (heights[result[i]] > heights[stack.peek()]) {
                            result[i] = stack.peek();
                        }
                    } else if (Math.abs(result[i] - i) > Math.abs(i - stack.peek())) {
                        //if the dist of smaller tower in curr heights[i] right side
                        //is smaller than the dist of smaller tower in its left then
                        //update the index of right side tower in result[i] that is
                        //also closer to curr heights[i]
                        result[i] = stack.peek();
                    }
                }
            }
            stack.push(i);
        }
        //output
        System.out.println("Nearest smallest tower : " + Arrays.toString(result));
    }

    public void nearestGreaterElementFour(int[] nums) {
        //https://leetcode.com/problems/next-greater-element-iv/description/
        //https://leetcode.com/problems/next-greater-element-iv/solutions/2756668/java-c-python-one-pass-stack-solution-o-n/
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> stack = new Stack<>();
        Stack<Integer> secondGreater = new Stack<>();
        Stack<Integer> temp = new Stack<>();
        for (int i = 0; i < n; i++) {

            int val = nums[i];

            while (!secondGreater.isEmpty() && nums[secondGreater.peek()] < val) {
                result[secondGreater.pop()] = val;
            }

            while (!stack.isEmpty() && nums[stack.peek()] < val) {
                temp.push(stack.pop());
            }

            while (!temp.isEmpty()) {
                secondGreater.push(temp.pop());
            }

            stack.push(i);
        }
        //output
        System.out.println("Nearest Greater Element Four : " + Arrays.toString(result));
    }

    public void minOperationToReduceXToZero(int[] nums, int X) {
        //https://leetcode.com/problems/minimum-operations-to-reduce-row-to-zero/description/
        //based on SLIDING WINDOW
        /*
        We need to find values form nums[] from its left or right side whose values
        if reduced from X should make it 0.
        
        intution:
        rather than finding a window of subarray whose sum is X, 
        find a window of subarray whose sum is (arrSum - X) and maximize it
        
        ex: nums[] = [3,2,20,1,1,3], X = 10
        we take values from left = [3,2] right = [1,1,3] one by one count to
        operation 5 and sum becomes X = 10
        
        if we find a sum of (arrSum - X) in nums[] then the sum of remaining values
        will be X
        ==> X + (arrSum - X) = arrSum
        
        subarray window where its currSum equal to (arrSum - X), if this window is
        maximized then operation to pick values from left or right and their sum
        becomes X will be minimized.
        
         */
        int n = nums.length;
        int start = 0;
        int end = 0;
        int arrSum = 0;
        int currSum = 0;
        //max length of a subarray whose sum is equal to arrSum - X
        int maxLen = -1;

        for (int val : nums) {
            arrSum += val;
        }

        while (end < n) {

            currSum += nums[end];

            while (end >= start && currSum > arrSum - X) {
                currSum -= nums[start++];
            }

            if (currSum == arrSum - X) {
                maxLen = Math.max(maxLen, end - start + 1);
            }

            end++;
        }
        //output
        //maxLen is max length where sum is (arrSum - X)
        //n - maxLen is the left over elements whose sum is X and is minimized
        int minOprn = maxLen == -1 ? -1 : n - maxLen;
        System.out.println("Min  operation to reduce X to zero : " + minOprn);
    }

    public void prefixCommonArrayOfTwoArrays(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/
        //explanation: https://youtu.be/m6s9dBCBocQ
        /*
        It is guaranteed that nums1 and nums2 are both a permutation of n integers.
        
        intution:
        nums1 = [1,3,2,4], nums2 = [3,1,2,4]
        
        #1. i = 0
        freq[nums1[i]]++ ==> freq[1]++ = {1 = 1}
        if(freq[1] == 2) //BUT freq[1] = 1 means 1 exists only in one array at this time
        
        freq[nums2[i]]++ ==> freq[3]++ = {3 = 1}
        if(freq[1] == 2) //BUT freq[3] = 1 means 3 exists only in one array at this time
        
        #2. i = 1
        freq[nums1[i]]++ ==> freq[3]++ = {1 = 1, 3 = 2}
        //at this point 3 exists in both the array
        if(freq[1] == 2) ==> (freq[3] == 2) count++ ==> 1
        
        freq[nums2[i]]++ ==> freq[1]++ = {1 = 2, 3 = 2}
        //at this point 1 exists in both the array
        if(freq[1] == 2) ==> (freq[1] == 2) count++ ==> 2
        
        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;
        
        #3. i = 2
        freq[nums1[i]]++ ==> freq[2]++ = {1 = 1, 3 = 2, 2 = 1}
        if(freq[2] == 2) //2 exists only in nums1[]
        
        freq[nums2[i]]++ ==> freq[2]++ = {1 = 2, 3 = 2, 2 = 2}
        //at this point 2 exists in both the array
        if(freq[2] == 2) ==> (freq[2] == 2) count++ ==> 3
        
        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;
        
        #4. i = 3
        freq[nums1[i]]++ ==> freq[4]++ = {1 = 1, 3 = 2, 2 = 2, 4 = 1}
        if(freq[4] == 2) //4 exists only in nums1[]
        
        freq[nums2[i]]++ ==> freq[4]++ = {1 = 2, 3 = 2, 2 = 2, 4 = 2}
        //at this point 4 exists in both the array
        if(freq[4] == 2) ==> (freq[4] == 2) count++ ==> 4
        
        //at this point, either of value from nums1 or nums2 has count 2 means
        //they exists as common prefix in both arrays till index = i
        commonPrefixCount[i] = count;
        
         */
        int n = nums1.length;
        int[] commonPrefixCount = new int[n];
        int[] freq = new int[n + 1];
        int count = 0;
        for (int i = 0; i < n; i++) {
            freq[nums1[i]]++;
            if (freq[nums1[i]] == 2) {
                count++;
            }

            freq[nums2[i]]++;
            if (freq[nums2[i]] == 2) {
                count++;
            }

            commonPrefixCount[i] = count;
        }
        //output
        System.out.println("Prefix common arrays : " + Arrays.toString(commonPrefixCount));
    }

    private int subseqSatisfyGivenSumCond_BinarySearch(int[] nums, int find) {
        int n = nums.length;
        int start = 0;
        int end = n - 1;
        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (nums[mid] <= find) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return start;
    }

    public void subseqSatisfyGivenSumCond_1(int[] nums, int target) {
        //.........................T: O(N * LogN), where N is nums[] length,
        ////here O(N * LogN) comes from the sorting of nums[]
        //also, O(N) comes from for(start) loop and inside it we performing binary
        //search that takes O(LogN) in searching the value hence O(N * LogN)
        //makes it like O(SORTING + LOOPINP) ==> O(N * LogN + N * LogN) ==> O(N * LogN)
        //.........................S: O(N), for power[]
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/editorial/
        //based on BINARY SEARCH
        int n = nums.length;
        int mod = 1000000007;
        int subseq = 0;

        Arrays.sort(nums);

        //to generate possible subsequneces of n values in arr[], it would take
        //2^n time complexity, how?
        //for a given values in nums[], if you try to form subseq of them, you have
        //2 choices to make, either to pick or don't pick the valueF
        //also Math.pow() will also give TLE, so here we 
        //have to pre compute the power of 2 as power[i] = power[i - 1] * 2 where
        //i represents the power
        int[] preComputePowerOf2 = new int[n];

        //here i = 0, means 2 ^ i ==> 2 ^ 0 ==> 1
        //in loop below,
        //for i == 1, 2 ^ 1 ==> 2 but this can written as (2 ^ 0) * 2 ==> 2
        //also, for i == 2, 2 ^ 2 ==> 4 but this can be written as (2 ^ 1) * 2 ==> 4
        //also, for i == 3, 2 ^ 3 ==> 8 but this can be written as (2 ^ 2) * 2 ==> 8
        //also, for i == 4, 2 ^ 4 ==> 16 but this can be written as (2 ^ 3) * 2 ==> 16
        //to conclude this observation, here to calculate a power of 2 ^ i we need only
        //power of (2 ^ (i - 1)) * 2 ==> preComputePowerOf2[i] = preComputePowerOf2[i - 1] * 2
        preComputePowerOf2[0] = 1;
        for (int i = 1; i < n; i++) {
            preComputePowerOf2[i] = (preComputePowerOf2[i - 1] * 2) % mod;
        }

        for (int start = 0; start < n; start++) {
            int end = subseqSatisfyGivenSumCond_BinarySearch(nums, target - nums[start]) - 1;
            if (end < start) {
                break;
            }
            subseq = (subseq + preComputePowerOf2[end - start]) % mod;
        }
        //output
        System.out.println("Subsequence that staify the given sum condition : " + subseq);
    }

    public void subseqSatisfyGivenSumCond_2(int[] nums, int target) {
        //.........................T: O(N * LogN), where N is nums[] length,
        //here O(N * LogN) directly comes from the sorting of nums[]
        //.........................S: O(N), for power[]
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/editorial/
        //explanation: https://youtu.be/eGqs55VTP3I
        //based on TWO POINTER, easy to understand & faster as compared to above
        //binary search approach
        int n = nums.length;
        int mod = 1000000007;
        int subseq = 0;
        int start = 0;
        int end = n - 1;

        Arrays.sort(nums);

        //to generate possible subsequneces of n values in arr[], it would take
        //2^n time complexity, how?
        //for a given values in nums[], if you try to form subseq of them, you have
        //2 choices to make, either to pick or don't pick the valueF
        //also Math.pow() will also give TLE, so here we 
        //have to pre compute the power of 2 as power[i] = power[i - 1] * 2 where
        //i represents the power
        int[] preComputePowerOf2 = new int[n];

        //here i = 0, means 2 ^ i ==> 2 ^ 0 ==> 1
        //in loop below,
        //for i == 1, 2 ^ 1 ==> 2 but this can written as (2 ^ 0) * 2 ==> 2
        //also, for i == 2, 2 ^ 2 ==> 4 but this can be written as (2 ^ 1) * 2 ==> 4
        //also, for i == 3, 2 ^ 3 ==> 8 but this can be written as (2 ^ 2) * 2 ==> 8
        //also, for i == 4, 2 ^ 4 ==> 16 but this can be written as (2 ^ 3) * 2 ==> 16
        //to conclude this observation, here to calculate a power of 2 ^ i we need only
        //power of (2 ^ (i - 1)) * 2 ==> preComputePowerOf2[i] = preComputePowerOf2[i - 1] * 2
        preComputePowerOf2[0] = 1;
        for (int i = 1; i < n; i++) {
            preComputePowerOf2[i] = (preComputePowerOf2[i - 1] * 2) % mod;
        }

        //this loop in linear (O(N)) as compared to above approach with binary search
        //which was (O(LogN)) for all the N values in nums[] makes it to (O(N * LogN))
        while (end >= start) {
            //as required in question, we need our min & max values from a subseq
            //to have a sum less than or equal to target, since we sorted our array
            //we know that our min is at start ptr and max is at end ptr.
            //Here we will pick these two min & max values, if it matches the cond
            //we will calculate our subseqs that lies in range of (start to end]
            //start non-inclusive as this min ==> nums[start] is always a fixed value
            //so the remaining values from the ranges becomes (end - start)
            //this (end - start) represents the range of nums we can pick & don't pick
            //in our subseq hence form 2 ^ (end - start) subsequences
            //We could have used Math.pow(2, end - start) but that will errors because
            //this power can be very large to compute so use pre computed power[]
            if (nums[start] + nums[end] <= target) {
                subseq = (subseq + preComputePowerOf2[end - start]) % mod;
                start++;
            } else {
                //if(nums[start] + nums[end] > target), then needs adjust the end ptr
                //as it holds the max value
                end--;
            }
        }

        //output
        System.out.println("Subsequence that staify the given sum condition : " + subseq);
    }

    public boolean checkIfArrayIsSortedAndRotated(int[] nums) {
        //https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/
        /*
        nums[] = [3,4,5,1,2]
        here the intution is count the dips/valleys
        ..............5.....2
        ............./.\.../
        ............4....1
        .........../
        ..........3  
        
        see 3 -> 4 -> 5 is an increasing trend
        then 5 -> 1 is decrease/ dip
        then 1 -> 2 again increase
        
        also need to check that
        nums[0] < nums[n - 1] that is covered as nums[i] > nums[(i + 1) % n]
        
        now in a sorted and single time roatated array this dip should be <= 1
        so if countDip > 1 return false as there are more than 1 rotation
        
         */
        int n = nums.length;
        int countDip = 0;
        for (int i = 0; i < n; i++) {

            if (nums[i] > nums[(i + 1) % n]) {
                countDip++;
            }

            if (countDip > 1) {
                return false;
            }
        }
        return true;
    }

    private int longestValidObstacleCourseAtEachPosition_BinarySearch(int[] memoLIS, int find) {
        int n = memoLIS.length;
        int start = 0;
        int end = n - 1;
        while (end >= start) {
            int mid = start + (end - start) / 2;
            if (memoLIS[mid] <= find) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return start;
    }

    public void longestValidObstacleCourseAtEachPosition(int[] obstacles) {
        //https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description/
        //explanation: https://youtu.be/sUtUgMW2kMY | https://youtu.be/Xq9VT7p0lic
        //based on BINARY SEARCH, LONGEST INCREASING SUBSEQUENCE
        /*
        Exact logic of longestIncreasingSubsequence_DP_Memoization() will solve this
        question, but this question requires optimization on LIS hence for larger
        input value LIS will throw TLE
        
        in actual LIS algo, what memoLIS will means
        index:      0      1     2     3
        memoLIS[] = [Len1, Len2, Len3, Len4]
        
        for a particular 'index' there exist a subseq as long as 'Len'
        means memoLIS[index] == memoLIS[3] == Len4
        
        ex: nums[] = [1,3,2,4]
        memoLIS[] = [1, 2, 2, 3]
        memoLIS[0] == 1 ==> subseq ==> {1}
        memoLIS[1] == 2 ==> subseq ==> {1 < 3}
        memoLIS[2] == 2 ==> subseq ==> {1 < 2}
        memoLIS[3] == 3 ==> subseq ==> {1 < 3 < 4} OR {1 < 2 < 4}
        
        for this question we have to modify the LIS logic a little bit
        index:      0                 1                2                3                4
        memoLIS[] = [prevSmallerNum1, prevSmallerNum2, prevSmallerNum3, prevSmallerNum4, prevSmallerNum5]
        
        here the 'index' of memoLIS[] represent the length of the longest subseq
        means index ==> 0 ==> (0 + 1) = 1 ==> any subseq of length 1
        means index ==> 1 ==> (1 + 1) = 2 ==> any subseq of length 2
        means index ==> 2 ==> (2 + 1) = 3 ==> any subseq of length 3
        means index ==> 3 ==> (3 + 1) = 4 ==> any subseq of length 4
        means index ==> 4 ==> (4 + 1) = 5 ==> any subseq of length 5
        
        each value in memoLIS[index] will have prev smaller num of the subseq
         */
        int n = obstacles.length;
        int[] result = new int[n];
        int[] memoLIS = new int[n];
        Arrays.fill(memoLIS, (int) (10e9));
        for (int i = 0; i < n; i++) {
            int val = obstacles[i];
            int index = longestValidObstacleCourseAtEachPosition_BinarySearch(memoLIS, val);
            result[i] = index + 1;
            memoLIS[index] = val;
        }
        //output
        System.out.println("Longest valid obstacles course at each position : " + Arrays.toString(result));
    }

    public void parsingBooleanExpression(String expression) {
        //https://leetcode.com/problems/parsing-a-boolean-expression/description/
        //based on STACK
        Stack<Character> operatorsStack = new Stack<>();
        Stack<Character> expressionsStack = new Stack<>();

        for (char ch : expression.toCharArray()) {
            if (ch == ',') {
                continue;
            } else if (ch == '&' || ch == '|' || ch == '!') {
                //put curr operator as 'chr' in operators stack
                operatorsStack.push(ch);
            } else if (ch == ')') {
                //here we will process the expression block from the expression
                //string
                //pick the operator need to apply
                char operator = operatorsStack.pop();
                //to start our expressions calculations we need to first initialize
                //our currExpression with the curr peek() value from expressionsStack
                //and also remove it from the stack
                boolean currExpression = expressionsStack.pop() == 't';
                //if the below while() loop ever run then isLooped will become true
                boolean isLooped = false;
                //process the remaining 't', 'f' values in the expressionsStack
                //(if any, as there can be only single 't' or 'f' in a expression block)
                //loop on expressionsStack until we find an opening bracket '('
                //process all the expressions in between
                while (!expressionsStack.isEmpty() && expressionsStack.peek() != '(') {
                    isLooped = true;
                    switch (operator) {
                        case '&':
                            currExpression &= (expressionsStack.pop() == 't');
                            break;
                        case '|':
                            currExpression |= (expressionsStack.pop() == 't');
                            break;
                        case '!':
                            currExpression = !(expressionsStack.pop() == 't');
                            break;
                    }
                }

                //pop the opening bracket '(' in the expressions stack
                expressionsStack.pop();

                //edge case like : !(subExpr) ==> ex: !(t) ==> f
                //since inside bracket (t) there is single value 't' that will
                //already be popped before the while() in 'currExpression' hence
                //after popping, that while() will not work as expressionStack.peek()
                //will have only '(' and loop will break so 'isLooped' will remain
                //false but due to this the operator == '!' will not be processed
                //so need to handle this edge case
                if (!isLooped && operator == '!') {
                    currExpression = !currExpression;
                }

                //add the processed expression 'currExpression' back into expression stack
                expressionsStack.push(currExpression ? 't' : 'f');

            } else {
                //here we put all other things, '(', 't', 'f'
                expressionsStack.push(ch);
            }
        }
        //output
        boolean expressionResult = expressionsStack.peek() == 't';
        System.out.println("Parsing boolean expression : " + expressionResult);
    }

    public void binarySubarraySumEqualToGoal(int[] binary, int goal) {
        //https://leetcode.com/problems/binary-subarrays-with-sum/description/
        int n = binary.length;
        int[] prefixSumArr = new int[n + 1];
        int prefixSum = 0;
        for (int i = 0; i < n; i++) {
            prefixSum += binary[i];
            prefixSumArr[i + 1] = prefixSum;
        }

        Map<Integer, Integer> freq = new HashMap<>();
        int subarr = 0;
        for (int sum : prefixSumArr) {
            subarr += freq.getOrDefault(sum, 0);
            freq.put(sum + goal, freq.getOrDefault(sum + goal, 0) + 1);
        }
        //output
        System.out.println("Binary subarray sum equal to goal : " + subarr);
    }

    public void longestTurbulentSubarray(int[] nums) {
        //https://leetcode.com/problems/longest-turbulent-subarray/description/
        //explanation: https://youtu.be/V_iHUhR8Dek
        //based on SLIDING WINDOW
        int n = nums.length;
        //any single element in nums[] will be considered as turbulent subarr of
        //length 1
        int longestTurbulentSubarr = 1;
        int start = 0;
        int end = 1;
        //default prev turbulent sign
        char prev = '.';

        while (end < n) {
            //if prev turbulent sign was either default or '<' then curr must be
            //followed with '>'
            if ((prev == '.' || prev == '<') && nums[end - 1] > nums[end]) {
                longestTurbulentSubarr = Math.max(longestTurbulentSubarr, (end - start + 1));
                end++;
                //as currently we checking a turbulent sign of '>' in
                //nums[end - 1] > nums[end] so for next time prev turbulent sign
                //should be this sign '>'
                prev = '>';
            } //if prev turbulent sign was either default or '>' then curr must be
            //followed with '<'
            else if ((prev == '.' || prev == '>') && nums[end - 1] < nums[end]) {
                longestTurbulentSubarr = Math.max(longestTurbulentSubarr, (end - start + 1));
                end++;
                //as currently we checking a turbulent sign of '<' in
                //nums[end - 1] < nums[end] so for next time prev turbulent sign
                //should be this sign '<'
                prev = '<';
            } else {
                //case where nums[end - 1] == nums[end]
                end = nums[end - 1] == nums[end] ? end + 1 : end;
                start = end - 1;
                prev = '.';
            }
        }
        //output
        System.out.println("Longest turbulent subarray : " + longestTurbulentSubarr);
    }

    public void mostProfitAssigningWork(int[] difficulties, int[] profits, int[] workers) {
        //https://leetcode.com/problems/most-profit-assigning-work/description/
        int n = workers.length;
        int m = profits.length;

        int[][] difficultyWithProfit = new int[m][2];
        for (int i = 0; i < m; i++) {
            difficultyWithProfit[i] = new int[]{difficulties[i], profits[i]};
        }

        //sort in increasing order of difficulty in the difficultyWithProfit[i][0]
        Arrays.sort(difficultyWithProfit, (a, b) -> a[0] - b[0]);
        //sort in increasing order of worker ability
        Arrays.sort(workers);

        int maxProfit = 0;
        int currMaxProfit = 0;
        int index = 0;

        for (int ability : workers) {
            while (index < n && difficultyWithProfit[index][0] <= ability) {
                currMaxProfit = Math.max(currMaxProfit, difficultyWithProfit[index][1]);
                index++;
            }
            maxProfit += currMaxProfit;
        }
        //output
        System.out.println("Most profit assiging work : " + maxProfit);
    }

    public boolean subarraysHavingEqualSum(int[] nums) {
        //https://leetcode.com/problems/find-subarrays-with-equal-sum/description/
        //based on SLIDING WINDOW
        /*
        determine whether there exist two subarrays of length 2 with equal sum.
        Note that the two subarrays must begin at different indices
         */
        int n = nums.length;
        Set<Integer> subarrSumsSeen = new HashSet<>();
        //as given subarray/ window length is required 2 hence k = 2
        int kLength = 2;
        //take the initial sum of subarray of size k from nums[0 to k - 1]
        int currKLenSum = 0;
        int index = 0;
        for (; index < kLength; index++) {
            currKLenSum += nums[index];
        }

        //the first subarray sum of length k is calculated as 'currKLenSum'
        //put that in set which behaves as 'seen' set
        subarrSumsSeen.add(currKLenSum);

        //starting SLIDING WINDOW
        //where start is 0 and end will start from 'index' that is k-th index
        int start = 0;
        int end = index;

        while (end < n) {

            //maintain a window of k length and k-length-subarray sum as 'currKLenSum'
            currKLenSum += nums[end];
            currKLenSum -= nums[start];

            start++;
            end++;

            //if the curr k len window subarray sum as 'currKLenSum' is already
            //seen then that means there exist two subarrays having same sum
            if (subarrSumsSeen.contains(currKLenSum)) {
                return true;
            }
            //put the curr k len window subarray sum
            subarrSumsSeen.add(currKLenSum);
        }
        return false;
    }

    public void countGoodMeals(int[] nums) {
        //https://leetcode.com/problems/count-good-meals/description/
        //https://leetcode.com/problems/count-good-meals/solutions/999119/java-hashmap-two-sum-o-n/
        //based on twoSum()
        int n = nums.length;
        int mod = 1000000007;
        int pairs = 0;
        Map<Integer, Integer> freq = new HashMap<>();

        for (int val : nums) {

            int powerOfTwo = 1;
            for (int power = 0; power < 22; power++) {

                pairs += freq.getOrDefault(powerOfTwo - val, 0);
                pairs %= mod;

                powerOfTwo *= 2;
            }
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }
        //output
        System.out.println("Count good meals : " + pairs);
    }

    public void oddEvenJumps(int[] nums) {
        //https://leetcode.com/problems/odd-even-jump/description/
        //https://leetcode.com/problems/odd-even-jump/solutions/217981/java-c-python-dp-using-map-or-stack/
        int n = nums.length;
        boolean[] higher = new boolean[n];
        boolean[] lower = new boolean[n];

        higher[n - 1] = lower[n - 1] = true;

        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(nums[n - 1], n - 1);

        //1 because if we pick index ==> n - 1 that is also good starting index
        //to reach end
        int goodStartingIndexCount = 1;

        for (int i = n - 2; i >= 0; i--) {

            Map.Entry<Integer, Integer> high = map.ceilingEntry(nums[i]);
            Map.Entry<Integer, Integer> low = map.floorEntry(nums[i]);

            if (high != null) {
                higher[i] = lower[high.getValue()];
            }

            if (low != null) {
                lower[i] = higher[low.getValue()];
            }

            if (higher[i]) {
                goodStartingIndexCount++;
            }

            map.put(nums[i], i);
        }
        //output
        System.out.println("Odd even jumps : " + goodStartingIndexCount);
    }

    public void minAreaRectangle(int[][] points) {
        //...............T: O(N ^ 2), N is length of points[][]
        //https://leetcode.com/problems/minimum-area-rectangle/description/
        //<x, List<y>>
        Map<Integer, Set<Integer>> pointsMap = new HashMap<>();
        for (int[] point : points) {
            int x = point[0];
            int y = point[1];

            pointsMap.putIfAbsent(x, new HashSet<>());
            pointsMap.get(x).add(y);
        }

        int minArea = Integer.MAX_VALUE;

        for (int[] point1 : points) {

            int x1 = point1[0];
            int y1 = point1[1];

            for (int[] point2 : points) {

                int x2 = point2[0];
                int y2 = point2[1];

                /*
                
                skip, if both the point1 & point2 lie either on same x-axis or
                y-axis
                we will not consider such points because we are looking of those
                points as p1 & p2 that are currently diagonal to each other,
                from those points we can make two other points 'D' & 'B' as
                explained below

                1.
                ......p1(x1, y1)------------------p2(x2, y2) here x1 == x2

                2.
                ................p1(x1, y1)
                ................|
                ................|
                ................|
                ................p2(x2, y2) here y1 == y2
               
                 */
                if (x2 == x1 || y2 == y1) {
                    continue;
                }

                /*
                
                assume that p1 and p2 are two diagonal points of a rectangle
                then there must exist two points 'D'(x1, y2) and 'B'(x2, y1)
                from points p1 & p2 hence these 4 points together will from
                a rectangle and then we can calculate its length * breadth
                for area
                
                ...D = (p1.x, p2.y) ==> (x1, y2)
                .......D----------p2 = (x2, y2)
                .......|          |
                .......|          |
                .......|          |
                ......p1----------B = (p2.x, p1.y) ==> (x2, y1)
                ...p1 = (x1, y1)

                area = length * breadth
                ==>
                length = abs(p2.x - p1.x) ==> abs(x2 - x1)
                breadth = abs(p2.y - p1.y) ==> abs(y2 - y1)
                
                 */
                if (pointsMap.get(x1).contains(y2) && pointsMap.get(x2).contains(y1)) {
                    minArea = Math.min(minArea, Math.abs(x2 - x1) * Math.abs(y2 - y1));
                }
            }
        }
        //output
        minArea = minArea == Integer.MAX_VALUE ? 0 : minArea;
        System.out.println("Min area of rectangle : " + minArea);
    }

    public void maxValueOfEquation(int[][] points, int k) {
        //https://leetcode.com/problems/max-value-of-equation/description/
        //based on SLIDING WINDOW
        /*
        
        Given:
        sorted by the x-values, where points[i] = [xi, yi] such that xi < xj for all 1 <= i < j <= 
        points.length. You are also given an integer k.

        Return the maximum value of the equation yi + yj + |xi - xj| where |xi - xj| <= k and 1 <=
        i < j <= points.length.

        intuition: 
        
        maximize this equation yi + yj + |xi - xj|
        ==> |xi - xj| is always positive 
        ==> also given that xi < xj for all 1 <= i < j <= points.length
        so to make |xi - xj| positive without abs() we can simply rephrase this as
        |xi - xj| = xj - xi >= 0 as given xi < xj (bigger(xj) - smaller(xi) > 0)

        ==> yi + yj + |xi - xj|
        ==> yi + yj + xj - xi
        ==> (yi - xi) + (xj + yj)

        in our Queue we will store 2 things as Pair class
        1. diff = (yi - xi)
        2. xI = xi

        from our j-loop we will have (xj + yj) but inorder to max the result
        we also need to maximize this diff (yi - xi)

        so using Deque we check 2 things:
        1. xj - xi > k, poll if first xi(s) from queue, are out of range ( > k)
        2. (yi - xi) keep this diff as we increament our j-th index but inorder
        to maximize this diff part we might have to poll the min diff(s) already
        in the queue
        
         */
        class Pair {

            //(yi - xi)
            int diff;
            //xi
            int xI;

            public Pair(int diff, int xI) {
                this.diff = diff;
                this.xI = xI;
            }

        }

        int n = points.length;
        Deque<Pair> queue = new LinkedList<>();
        int maxValue = Integer.MIN_VALUE;

        for (int j = 0; j < n; j++) {

            int xJ = points[j][0];
            int yJ = points[j][1];

            //poll first xi(s), if xj - xi > k
            while (!queue.isEmpty() && xJ - queue.peekFirst().xI > k) {
                queue.pollFirst();
            }

            //check for max equation value
            if (!queue.isEmpty()) {
                //queue.peekFirst().diff + (xJ + yJ) ==> (yi - xi) + (xj + yj)
                maxValue = Math.max(maxValue, queue.peekFirst().diff + (xJ + yJ));
            }

            //(yJ - xJ) > queue.peekLast().diff ==> curr diff(yj - xj) > prev diff(yi - xi)
            //then inorder to maximize the sum of equation we will poll the smaller
            //prev diff(s)(==> yi - xi) from queue
            while (!queue.isEmpty() && (yJ - xJ) > queue.peekLast().diff) {
                queue.pollLast();
            }

            //saving curr {(yj - xj), xj} in pair so for next j-th index this curr
            //pair will act as i-th index as i < j as per question
            queue.add(new Pair((yJ - xJ), xJ));
        }
        //output
        System.out.println("Max value of equation : " + maxValue);
    }

    public void minOperationsToMakeASubseq(int[] target, int[] nums) {
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/description/
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/solutions/999153/java-c-python-lcs-to-lis/
        /*
        this question is classic case for longest common subeq between two arrays
        but the same lcs() logic will give TLE. We will have to apply modified
        version of longest increasing subseq logic here
        this logic will not check the longest increasing element sequence BUT
        we will check longest increasing index order
        
        logic:
        given that target[] will always have distinct elements(==> no duplicates)
        
        target = [6,4,8,1,3,2], nums = [4,7,6,2,3,8,6,1]
        
        targetIndexMap = {6 = 0, 4 = 1, 8 = 2, 1 = 3, 3 = 4, 2 = 5}
        
        longestIncrIndex = {} ==> TreeSet will contain indexes in sorted order
        
        for(val : nums[]):
        
        ##1.....................
        val = 4
        
        if(!targetIndexMap[4]) FAIL
        
        if(longestIncrIndex.isEmpty) YES
        ==> index of targetIndexMap[4] = 1 to be added in longest-incr-index
        
        longestIncrIndex.add(targetIndexMap[4]) ==> longestIncrIndex.add(1) ==> {1} 
        
        continue
        
        ##2.....................
        val = 7
        
        if(!targetIndexMap[7]) YES
        ==> continue
        
        ##3.....................
        val = 6
        
        if(!targetIndexMap[6]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[6]) FAIL
        ==> **treeset.last() gives last (highest) value in the treeset
        ==> 1 < 0 ==> we already have index 1, ideally we should have a higher
        ==> index value than 1 but we got index of targetIndexMap[6] = 0 hence
        ==> with index = 0 we can't make longest incr index
        
        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[6]) ==> 1
        ==> **treeset.ceiling(val) gives a value greater or equal to given 'val',
        ==> **if present otherwise null
        
        longestIncrIndex.remove(higherTargetIndex) ==> {}
        
        longestIncrIndex.add(targetIndexMap[6]) ==> longestIncrIndex.add(0) ==> {0}
        
        ##4.....................
        val = 2
        
        if(!targetIndexMap[2]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[6]) ==> (0 < 5)
        ==> 0 < 5 ==> we already have index 0 and current index of targetIndexMap[2]
        ==> is 5 which is making it longest incr index, hence we will add this index
        
        longestIncrIndex.add(targetIndexMa[2]) ==> longestIncrIndex.add(5) ==> {0, 5}
        
        continue
        
        ##5.....................
        val = 3
        
        if(!targetIndexMap[3]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[3]) FAIL
        ==> 5 < 4 ==> we already have index 5, ideally we should have a higher
        ==> index value than 5 but we got index of targetIndexMap[3] = 4 hence
        ==> with index = 4 we can't make longest incr index
        
        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[3]) ==> 5
        
        longestIncrIndex.remove(higherTargetIndex) ==> {0}
        
        longestIncrIndex.add(targetIndexMap[3]) ==> longestIncrIndex.add(4) ==> {0, 4}
        
        ##6.....................
        val = 8
        
        if(!targetIndexMap[8]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[8]) FAIL
        ==> 4 < 2 ==> we already have index 4, ideally we should have a higher
        ==> index value than 4 but we got index of targetIndexMap[8] = 2 hence
        ==> with index = 4 we can't make longest incr index
        
        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[8]) ==> 4
        
        longestIncrIndex.remove(higherTargetIndex) ==> {0}
        
        longestIncrIndex.add(targetIndexMap[8]) ==> longestIncrIndex.add(4) ==> {0, 2}
       
        ##7.....................
        val = 6
        
        if(!targetIndexMap[6]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[6]) FAIL
        ==> 2 < 0 ==> we already have index 2, ideally we should have a higher
        ==> index value than 2 but we got index of targetIndexMap[6] = 0 hence
        ==> with index = 2 we can't make longest incr index
        
        higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap[6]) ==> 0
        ==> **treeset.ceiling(val) gives a value greater or equal to given 'val',
        ==> **if present otherwise null
        ==> here 'val' = targetIndexMap[6] = 0 so treeset.ceiling(0) ==> 0
        
        longestIncrIndex.remove(higherTargetIndex) ==> {2}
        
        longestIncrIndex.add(targetIndexMap[6]) ==> longestIncrIndex.add(0) ==> {0, 2}
        
        ##8.....................
        val = 1
        
        if(!targetIndexMap[1]) FAIL
        
        if(longestIncrIndex.last < targetIndexMap[6]) ==> (2 < 3)
        ==> 2 < 3 ==> we already have index 2 and current index of targetIndexMap[1]
        ==> is 3 which is making it longest incr index, hence we will add this index
        
        longestIncrIndex.add(targetIndexMa[1]) ==> longestIncrIndex.add(3) ==> {0, 2, 3}
        
        continue
        
        ....END....
        
        longestIncrIndex = {0, 2, 3} ==> size() => 3
        
        result = targetLen - longestIncrIndex.size
        
         */

        int targetLen = target.length;

        Map<Integer, Integer> targetIndexMap = new HashMap<>();
        for (int i = 0; i < targetLen; i++) {
            targetIndexMap.put(target[i], i);
        }

        TreeSet<Integer> longestIncrIndex = new TreeSet<>();

        for (int val : nums) {

            if (!targetIndexMap.containsKey(val)) {
                continue;
            }

            //last() = last/highest index in set < curr index of 'val' in target[]
            if (longestIncrIndex.isEmpty() || longestIncrIndex.last() < targetIndexMap.get(val)) {
                longestIncrIndex.add(targetIndexMap.get(val));
                continue;
            }

            int higherTargetIndex = longestIncrIndex.ceiling(targetIndexMap.get(val));
            longestIncrIndex.remove(higherTargetIndex);
            longestIncrIndex.add(targetIndexMap.get(val));
        }
        //output
        int minOperation = targetLen - longestIncrIndex.size();
        System.out.println("Min operations to make subseq : " + minOperation);
    }

    public void rotateMatrixClockWise90Deg(int[][] mat) {
        //https://leetcode.com/problems/rotate-image
        int col = mat[0].length;

        int left = 0;
        int right = col - 1;

        while (right > left) {
            //(right - left is amount of element need to take)
            for (int i = 0; i < (right - left); i++) {
                int top = left;
                int bottom = right;

                /*
                
                 top-[left + i]  ---> [top + i]-right
                 /\                             |
                 |   Clock dir                  |
                 |                             \/
                 [bottom - i]-left <---- bottom-[right - i]
                
                 */
                //save top-left corner value
                int topLeftCornerValue = mat[top][left + i];
                //in top-left put bottom-left value
                mat[top][left + i] = mat[bottom - i][left];
                //in bottom-left put bottom-right value
                mat[bottom - i][left] = mat[bottom][right - i];
                //in bottom-right put top-right value
                mat[bottom][right - i] = mat[top + i][right];
                //in top-right put top-left value
                mat[top + i][right] = topLeftCornerValue;
            }
            left++;
            right--;
        }

        //output
        System.out.println("N * N matrix 90deg clockwise rotation: ");
        for (int[] r : mat) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    public void rotateMatrixAntiClockWise90Deg(int[][] mat) {

        int row = mat.length;
        int col = mat[0].length;

        int left = 0;
        int right = col - 1;

        while (right > left) {

            for (int i = 0; i < (right - left); i++) {
                int top = left;
                int bottom = right;

                /*
                
                 [top + i]-left  <--- top-[right - i]
                 |                              /\
                 |   AntiClock dir              |
                 \/                             |
                 bottom-[left + i] ----> [bottom - i]-right
                
                 */
                //save top-left corner value
                int topLeftCornerValue = mat[top + i][left];
                //in top-right put top-right value
                mat[top + i][left] = mat[top][right - i];
                //in top-right put bottom-right value
                mat[top][right - i] = mat[bottom - i][right];
                //in bottom-right put bottom-left value
                mat[bottom - i][right] = mat[bottom][left + i];
                //in bottom-left put top-left value
                mat[bottom][left + i] = topLeftCornerValue;
            }
            left++;
            right--;
        }

        //output
        System.out.println("N * N matrix 90deg anticlockwise rotation: ");
        for (int[] r : mat) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    private int areaPerRow(int[] hist) {

        //same as laregstAreaHistogram method
        Stack<Integer> stack = new Stack<>();
        int n = hist.length;
        int maxArea = 0;
        int top;
        int areaWithTop;
        int i = 0;
        while (i < n) {

            if (stack.isEmpty() || hist[stack.peek()] <= hist[i]) {
                stack.push(i++);
            } else {
                top = stack.pop();
                areaWithTop = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
                maxArea = Math.max(maxArea, areaWithTop);
            }
        }

        while (!stack.isEmpty()) {
            top = stack.pop();
            areaWithTop = hist[top] * (stack.isEmpty() ? i : i - stack.peek() - 1);
            maxArea = Math.max(maxArea, areaWithTop);
        }

        return maxArea;
    }

    public void maxAreaOfRectangleInBinaryMatrix(int[][] mat) {
        //https://leetcode.com/problems/maximal-rectangle
        //problem statment & sol: https://www.geeksforgeeks.org/maximum-size-rectangle-binary-sub-matrix-1s/
        //explanation: https://youtu.be/dAVF2NpC3j4
        //find max area of per row int the matrix
        //each row in the matrix is histogram
        //use max area histogram
        int R = mat.length;
        int C = mat[0].length;

        int maxArea = areaPerRow(mat[0]);

        for (int r = 1; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (mat[r][c] == 1) {
                    mat[r][c] += mat[r - 1][c];
                }
            }
            maxArea = Math.max(maxArea, areaPerRow(mat[r]));
        }

        //output:
        System.out.println("Max area in binary matrix: " + maxArea);
    }

    public void maximumOnesInRowOfABinarySortedMatrix_1(int[][] mat) {

        //.....................................T; O(M*N)
        //problem statement: https://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/
        int maxOnes = 0;
        int index = 0;
        for (int i = 0; i < mat.length; i++) {

            int onePerRow = areaPerRow(mat[i]);
            if (maxOnes < onePerRow) {
                maxOnes = onePerRow;
                index = i;
            }
        }
        //output;
        System.out.println("Max 1(s) found at index: " + (maxOnes == 0 ? -1 : index) + " counts of is are: " + maxOnes);
    }

    public void maximumOnesInRowOfABinarySortedMatrix_2(int[][] mat) {

        //............................T: O(M.LogN)
        //OPTIMISED
        int maxOnes = 0;
        int index = 0;
        for (int r = 0; r < mat.length; r++) {
            int C = mat[r].length;
            int firstIndexOfOne = findFirstOccurenceKInSortedArray(mat[r], 1, 0, C - 1, C);

            //if no index is found
            if (firstIndexOfOne == -1) {
                continue;
            }

            int onePerRow = C - firstIndexOfOne;
            if (maxOnes < onePerRow) {
                maxOnes = onePerRow;
                index = r;
            }
        }

        //output;
        System.out.println("Max 1(s) found at index: " + (maxOnes == 0 ? -1 : index) + " counts of is are: " + maxOnes);
    }

    public void findAValueInRowWiseSortedMatrix(int[][] mat, int K) {
        //https://leetcode.com/problems/search-a-2d-matrix-ii/
        int M = mat.length;
        int N = mat[0].length;

        int i = 0;
        int j = N - 1;

        //search starts from top right corner
        while (i < M && j >= 0) {

            if (mat[i][j] == K) {
                System.out.println("Found at: " + i + ", " + j);
                return;
            } else if (K < mat[i][j]) {
                j--;
            } else {
                i++;
            }
        }

        //K is not there in the matrix at all
        System.out.println("Not found");
    }

    public void spiralMatrixTraversal(int[][] mat) {
        //https://leetcode.com/problems/spiral-matrix/description/
        //https://leetcode.com/problems/spiral-matrix-ii/description/
        //https://leetcode.com/problems/spiral-matrix-iv/description/
        List<Integer> result = new ArrayList<>();

        int R = mat.length;
        int C = mat[0].length;

        int top = 0; // top row
        int bottom = R - 1; //bottom row
        int left = 0; //left col
        int right = C - 1; //right col
        int totalElement = R * C;

        //with each row and col processing we will shrink the matrix bounds (top++, bottom--, left++, right--)
        //result list is going to hold all the elements in the matrix
        while (result.size() < totalElement) {

            //get the top row from left to right
            for (int i = left; i <= right && result.size() < totalElement; i++) {
                result.add(mat[top][i]); //top row and ith col left to right
            }
            top++; //since we traversed top row now to next row next time.

            //top to bottom but right col
            for (int i = top; i <= bottom && result.size() < totalElement; i++) {
                result.add(mat[i][right]); //top to bottom but right col
            }
            right--; //now till here we have traversed the very right col of mat. for next time right col is prev

            //right to left but bottom row only
            for (int i = right; i >= left && result.size() < totalElement; i--) {
                result.add(mat[bottom][i]); //bottom row from right to left
            }
            bottom--; //completed bottom row also next time bottom to be prev one

            //bottom to top but only left col
            for (int i = bottom; i >= top && result.size() < totalElement; i--) {
                result.add(mat[i][left]); //left col
            }
            left++; //for next itr left will be moved ahead
        }

        //output:
        System.out.println("Spiral matrix: " + result);
    }

    public void spriralMatrixTraversalThree(int ROW, int COL, int rStart, int cStart) {
        //https://leetcode.com/problems/spiral-matrix-iii/description/
        int totalElements = ROW * COL;
        int[][] matrix = new int[totalElements][2];
        int[][] dirs = {
            //move right if dir is 0
            {0, 1},
            //move down if dir is 1
            {1, 0},
            //move left if dir is 2
            {0, -1},
            //move up if dir is 2
            {-1, 0}
        };

        int row = rStart;
        int col = cStart;

        //initially to move right from row & col, thats why dir is initially 0
        int dir = 0;
        int len = 0;
        int index = 0;

        matrix[index++] = new int[]{row, col};

        while (index < totalElements) {

            //for the dir == RIGHT OR dir == LEFT, we need to incr the elements
            //picking up len by 1
            if (dir == 0 || dir == 2) {
                len++;
            }

            //will pick all the elements(upto curr len) in the curr 'dir',
            //once the picking process is complete in curr 'dir', then we will
            //change the 'dir'
            for (int pick = 0; pick < len; pick++) {
                row += dirs[dir][0];
                col += dirs[dir][1];

                //if the new row & col is not 'isOutOfBounds'
                if (!(row < 0 || row >= ROW || col < 0 || col >= COL)) {
                    matrix[index++] = new int[]{row, col};
                }
            }

            //change the dir
            dir = (dir + 1) % 4;
        }
        //output
        System.out.println("Spiral matrix three all the coords : ");
        for (int[] coord : matrix) {
            System.out.println(Arrays.toString(coord));
        }
    }

    public void diagonalMatrixTraversal(int[][] mat) {

        int R = mat.length;
        int C = mat[0].length;
        int x = 0;
        int y = 0;
        boolean isGoingUp = true;
        int totalElements = R * C;
        int element = 0;
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> diagonal = new ArrayList<>();
        while (element < totalElements) {

            if (isGoingUp) {

                while (x >= 0 && y < C) {
                    diagonal.add(mat[x][y]);
                    x--;
                    y++;
                    element++;
                }

                if (x < 0 && y <= C - 1) {
                    x = 0;
                }

                if (y == C) {
                    x += 2;
                    y--;
                }
            } else {

                while (x < R && y >= 0) {
                    diagonal.add(mat[x][y]);
                    x++;
                    y--;
                    element++;
                }

                if (x <= R - 1 && y < 0) {
                    y = 0;
                }

                if (x == R) {
                    y += 2;
                    x--;
                }
            }

            isGoingUp = !isGoingUp;
            result.add(diagonal);
            diagonal = new ArrayList<>();
        }

        //output:
        System.out.println("Diagonal matrix: " + result);
    }

    public void sumOfElementsInMatrixExceptGivenRowAndCol(int[][] matrix, int[][] rowAndCol) {

        //OPTIMISED
        //..........................T: O((R * C) + n) where n = rowAndCol.length
        //..........................S: O(R + C) because rowSum and colSum array of size R & C respec
        //https://www.geeksforgeeks.org/find-sum-of-all-elements-in-a-matrix-except-the-elements-in-given-row-andor-column-2/
        int R = matrix.length;
        int C = matrix[0].length;

        int[] rowSum = new int[R];
        int[] colSum = new int[C];

        int sumOfElements = 0;

        for (int x = 0; x < R; x++) {
            for (int y = 0; y < C; y++) {
                sumOfElements += matrix[x][y]; //total sum of elements of matrix
                rowSum[x] += matrix[x][y]; //all the sum of elements in current row row
                colSum[y] += matrix[x][y]; //all the sum of elements in current col col
            }
        }

        for (int[] except : rowAndCol) {

            int row = except[0];
            int col = except[1];
            int sumWithoutRowAndCol = sumOfElements - rowSum[row] - colSum[col] + matrix[row][col];
            System.out.println("Sum of elements except row: " + row + " & col: " + col + " sum: " + sumWithoutRowAndCol);
        }
    }

    public void sortTheMatrixDiagonally(int[][] mat) {

        //.................................T: O(R * C) 
        //DATA STRUCTURE BASED SORTING
        //https://leetcode.com/problems/sort-the-matrix-diagonally/
        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();
        int R = mat.length;
        int C = mat[0].length;

        //actual:
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                System.out.print(mat[r][c] + "\t");
            }
            System.out.println();
        }

        //All the elements in the diagonal lie at same location of r - c
        //map key will have all r - c locations of diagonal and inside a priority queue(minHeap)
        //which will keep elements of that diagonal in sorted order as we add it in.
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {

                map.putIfAbsent(r - c, new PriorityQueue<>());
                map.get(r - c).add(mat[r][c]);
            }
        }
        //generate the matrix from the data structure
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                mat[r][c] = map.get(r - c).poll();
            }
        }

        //output:
        System.out.println("Diagonally sorted matrix");
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                System.out.print(mat[r][c] + "\t");
            }
            System.out.println();
        }
    }

    public void minimumPathSumInGrid(int[][] grid) {
        //https://leetcode.com/problems/minimum-path-sum/
        int R = grid.length;
        int C = grid[0].length;

        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (r == 0 && c == 0) {
                    //skip the top-left corner
                    continue;
                } else if (r == 0) {
                    //curr row,col to be added with same-row, prev-col
                    grid[r][c] += grid[r][c - 1];
                } else if (c == 0) {
                    //curr row,col to be added with prev-row, same-col
                    grid[r][c] += grid[r - 1][c];
                } else {
                    //curr row,col to be added with min((prev-row, same-col) OR (same-row, prev-sol)) 
                    grid[r][c] += Math.min(grid[r - 1][c], grid[r][c - 1]);
                }
            }
        }
        //output
        System.out.println("Min path sum in grid from top-left to bottom-right: " + grid[R - 1][C - 1]);
    }

    public int triangleMinPathSumTopToBottom(List<List<Integer>> triangle) {
        //https://leetcode.com/problems/triangle/
        //explanation: https://youtu.be/OM1MTokvxs4
        int size = triangle.size();
        if (size == 1) {
            return triangle.get(0).get(0);
        }
        int secondLastRow = size - 2;
        //find the min values from the end rows and proceed from bottom to top
        //add each min value to curr row value
        for (int row = secondLastRow; row >= 0; row--) {

            int rowBelowCurr = row + 1;
            List<Integer> rowBelowCurrList = triangle.get(rowBelowCurr);
            List<Integer> currRowList = triangle.get(row);
            int currRowSize = currRowList.size();

            for (int c = 0; c < currRowSize; c++) {

                int currRowValue = currRowList.get(c);

                int firstChild = rowBelowCurrList.get(c);
                int secondChild = rowBelowCurrList.get(c + 1);

                int minOfTwoChild = Math.min(firstChild, secondChild);
                currRowList.set(c, currRowValue + minOfTwoChild);
            }
        }
        return triangle.get(0).get(0);
    }

    public int maxPathSumInMatrixFromFirstRowToLastRow(int[][] matrix) {
        //https://www.codingninjas.com/codestudio/problems/maximum-path-sum-in-the-matrix_797998?leftPanelTab=0
        //based on triangleMinPathSumTopToBottom
        int ROW = matrix.length;
        int COL = matrix[0].length;
        int maxPathSum = 0;

        if (ROW == 1) {
            for (int c = 0; c < COL; c++) {
                maxPathSum = Math.max(maxPathSum, matrix[0][c]);
            }
            return maxPathSum;
        }

        int secondLastRow = ROW - 2;
        //find the max values from the end rows and proceed from bottom to top
        //add each max values to curr row value
        for (int r = secondLastRow; r >= 0; r--) {
            int[] listBelowCurrRow = matrix[r + 1];
            for (int c = 0; c < COL; c++) {

                //default values
                int firstPos = Integer.MIN_VALUE;
                int midPos = Integer.MIN_VALUE;
                int secondPos = Integer.MIN_VALUE;

                //getting values for all 3 positions in the below row from
                //curr col c
                if (c - 1 >= 0) {
                    firstPos = listBelowCurrRow[c - 1];
                }
                midPos = listBelowCurrRow[c];
                if (c + 1 < COL) {
                    secondPos = listBelowCurrRow[c + 1];
                }

                //updating the curr value at matrix[r][c] with the max of all the 3
                //positions in the below row
                matrix[r][c] += Math.max(firstPos,
                        Math.max(midPos, secondPos));

                //at very top row == 0, calculate all the possible
                //max path sum in that row in all its col
                if (r == 0) {
                    maxPathSum = Math.max(maxPathSum, matrix[r][c]);
                }
            }
        }
        return maxPathSum;
    }

    public void rangeAdditionTwo(int m, int n, int[][] ops) {
        //https://leetcode.com/problems/range-addition-ii/
        //https://leetcode.com/problems/range-addition-ii/discuss/2759204/Java-Solution-oror-6-line-only-oror-Fast-oror-Easy
        int row = m;
        int col = n;
        for (int[] op : ops) {
            row = Math.min(row, op[0]);
            col = Math.min(col, op[1]);
        }
        //output
        System.out.println("Range addition two: " + (row * col));
    }

    public void smallestRectangleEnclosingBlackPixels(int[][] image) {
        //https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/
        //https://www.lintcode.com/problem/600/

        /*
         ....-----
         [[0, 0, 1, 0]]
         [[0, 1, 1, 0]]
         [[0, 1, 0, 0]]
         ....-----
         All black pixel region is covered under ---- which is this
         [[0,1]]
         [[1,1]]
         [[1,0]]
         //across the row
         topRow = 0 as first '1' is observed at image(0, 2)
         bottomRow = 2 as last '1' is observed at image(2, 1)
         //accross the col
         leftCol = 1 as first '1' is observed at image(1, 1)
         rightCol = 2 as last '1' is observed at image(1, 2)
         */
        int ROW = image.length;
        int COL = image[0].length;

        //topRow and leftCol are the initial row and col
        //point where we found the 1(black pixel)
        //that topRow and leftCol will enclose all these black pixels
        int topRow = ROW - 1;
        int leftCol = COL - 1;
        //bottomRow and rightCol are the last row and col
        //point where we found the 1(black pixel)
        //that bottomRow and rightCol will enclose all these black pixels
        int bottomRow = 0;
        int rightCol = 0;

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                if (image[row][col] == 1) {
                    topRow = Math.min(topRow, row);
                    bottomRow = Math.max(bottomRow, row);

                    leftCol = Math.min(leftCol, col);
                    rightCol = Math.max(rightCol, col);
                }
            }
        }

        //simialr like lengths be like end - start + 1
        int length = bottomRow - topRow + 1;
        int breadth = rightCol - leftCol + 1;

        int areaThatEncloseAllBlackPixels = length * breadth;
        //output
        System.out.println("Area that enclose all balck pixels: " + areaThatEncloseAllBlackPixels);
    }

    private boolean checkIfMoveIsLegal_IsOutOfBound(int row, int col, int ROW, int COL) {
        return row < 0 || row >= ROW || col < 0 || col >= COL;
    }

    private boolean checkIfMoveIsLegal_IsLegal(
            String[][] board, int row, int col,
            String color, int[] dir) {

        int ROW = board.length;
        int COL = board[0].length;
        //passed in row and col already have start point with
        //given color so need now to find a end point with same color
        //so we can simply start from next point in same dir
        row += dir[0];
        col += dir[1];

        int length = 1;

        while (!checkIfMoveIsLegal_IsOutOfBound(row, col, ROW, COL)) {
            //incr length for good line
            length++;
            String currCell = board[row][col];
            //if in the curr path in given dir[] from given row and col
            //we see any empty space(.) then that path is not valid
            if (currCell.equals(".")) {
                return false;
            }
            //if in the curr path in given dir[] from given row and col
            //we see same color in the endpoint then that path is a good line
            //like start point = [B W...W B] OR [W B...B W] == end point same as start
            if (currCell.equals(color)) {
                //but that good line should have a lenght of atleast 3
                return length >= 3;
            }
            //update row and col, straight in given dir[]
            row += dir[0];
            col += dir[1];
        }
        return false;
    }

    public void checkIfMoveIsLegal(String[][] board, int row, int col, String color) {
        //https://leetcode.com/problems/check-if-move-is-legal/
        //explanation: https://youtu.be/KxK33AcQZpQ
        board[row][col] = color;
        //need to check in all 8 dirs
        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
            {-1, -1},
            {-1, 1},
            {1, -1},
            {1, 1}
        };

        for (int[] dir : dirs) {
            //move curr row and col in same curr dir[]
            //and check if in that particular dir move is legal or not
            //if from any one dir we get legal move == true, answer is legal
            //for each dir we will be starting from same row and col point
            if (checkIfMoveIsLegal_IsLegal(board, row, col, color, dir)) {
                System.out.println("Move is legal");
                return;
            }
        }
        System.out.println("Move is not legal");
    }

    public void islandPerimeter(int[][] grid) {
        //https://leetcode.com/problems/island-perimeter/
        /*
         4-edged perimeter
         -----
         | 1 |
         -----
        
         if curr cell also have cell at upper row
         total perimeter for both cell are 8 but we see
         there is common edge in between that should be removed (i.e -2)
         -----
         | 1 |
         -----
         -----
         | 1 |
         -----
         like this and now the actual perimeter will be 6
         -----
         | 1 |
         | 1 |
         -----
        
         if curr cell also have cell at left col
         total perimeter for both cell are 8 but we see
         there is common edge in between that should be removed (i.e -2)
         ----- -----
         | 1 | | 1 |
         ----- -----
         like this and now the actual perimeter will be 6
         ----- ----
         | 1    1 |
         ----- ----
         */
        int ROW = grid.length;
        int COL = grid[0].length;

        int perimeter = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                //a single cell of 1 is 4-edged island
                if (grid[r][c] == 1) {
                    perimeter += 4;

                    //if upper cell also has 1 that means the curr cell and
                    //cell above will form 6-edged perimeter and both of them sharing
                    //one edge in common so removing the common edge from both cell
                    if (r > 0 && grid[r - 1][c] == 1) {
                        perimeter -= 2;
                    }
                    //if left cell also has 1 that means the curr cell and
                    //cell at left will form 6-edged perimeter and both of them sharing
                    //one edge in common so removing the common edge from both cell
                    if (c > 0 && grid[r][c - 1] == 1) {
                        perimeter -= 2;
                    }
                }
            }
        }
        //output:
        System.out.println("Island perimeter: " + perimeter);
    }

    public void rangeSumQuery2D(int[][] matrix, int[][] queries) {
        //https://leetcode.com/problems/range-sum-query-2d-immutable/
        //explanation: https://youtu.be/KE8MQuwE2yA
        int ROW = matrix.length;
        int COL = matrix[0].length;

        //convert matrix to prefix sum matrix
        for (int r = 0; r < ROW; r++) {
            int prefix = 0;
            for (int c = 0; c < COL; c++) {
                prefix += matrix[r][c];
                int aboveRow = r - 1 < 0 ? 0 : matrix[r - 1][c];
                matrix[r][c] = prefix + aboveRow;
            }
        }

        List<Integer> queriesSum = new ArrayList<>();
        for (int[] query : queries) {

            int topLeftRow = query[0];
            int topLeftCol = query[1];
            int bottomRightRow = query[2];
            int bottomRightCol = query[3];

            int bottomRightSum = matrix[bottomRightRow][bottomRightCol];
            int aboveRowSum = topLeftRow - 1 < 0 ? 0 : matrix[topLeftRow - 1][bottomRightCol];
            int leftColSum = topLeftCol - 1 < 0 ? 0 : matrix[bottomRightRow][topLeftCol - 1];
            int cornerValAboveTopLeft = (topLeftRow - 1 < 0 || topLeftCol - 1 < 0)
                    ? 0
                    : matrix[topLeftRow - 1][topLeftCol - 1];
            int sum = bottomRightSum - aboveRowSum - leftColSum + cornerValAboveTopLeft;
            queriesSum.add(sum);
        }
        //output
        System.out.println("Range sum queries in 2D: " + queriesSum);
    }

    public int kThSmallestElementInSortedMatrix(int[][] matrix, int k) {
        //..................................S: O(N.LogN), N = matrix ROW, COL
        //https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = matrix.length;
        int COL = matrix[0].length;

        PriorityQueue<Cell> minHeap = new PriorityQueue<>(
                (a, b) -> matrix[a.row][a.col] - matrix[b.row][b.col]);

        for (int r = 0; r < ROW; r++) {
            minHeap.add(new Cell(r, 0));
        }

        while (!minHeap.isEmpty()) {
            k--;
            Cell currCell = minHeap.poll();

            if (k == 0) {
                return matrix[currCell.row][currCell.col];
            }

            if (currCell.col + 1 < COL) {
                currCell.col++;
                minHeap.add(currCell);
            }
        }
        return -1;
    }

    public void equalRowAndColPairs(int[][] grid) {
        //https://leetcode.com/problems/equal-row-and-column-pairs/
        //grid == n * n ==> ROW == COL
        int n = grid.length;
        String[] rows = new String[n];
        String[] cols = new String[n];

        //for each row r, create a row wise string 
        for (int r = 0; r < n; r++) {
            //if curr row[r] is null assign it with empty string, where we can
            //concatenate all the grid[r][c] falling on row r
            if (rows[r] == null) {
                rows[r] = "";
            }
            //for each col c, create a col wise string 
            for (int c = 0; c < n; c++) {
                //if curr col[c] is null assign it with empty string, where we can
                //concatenate all the grid[r][c] falling on col c
                if (cols[c] == null) {
                    cols[c] = "";
                }
                //',' is appended to handle cases [[11,1][1,11]]
                rows[r] += grid[r][c] + ",";
                cols[c] += grid[r][c] + ",";
            }
        }

        int pairs = 0;
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                if (rows[r].equals(cols[c])) {
                    pairs++;
                }
            }
        }
        //output
        System.out.println("Pairs where row and col are same: " + pairs);
    }

    private int gameOfLife_GetAlivePopulationAround(int[][] board,
            int row, int col, Map<String, Integer> state, int[][] dirs) {
        int alive = 0;
        for (int[] dir : dirs) {
            int newRow = row + dir[0];
            int newCol = col + dir[1];
            //if isOutOfBounds
            if (newRow < 0 || newRow >= board.length
                    || newCol < 0 || newCol >= board[0].length) {
                continue;
            }
            int neighbour = board[newRow][newCol];
            //why we are checking "ALIVE_TO_DEAD"? because the board is maintaing
            //intermediate state of cells that was alive and now dead Or vice versa
            //(acc to rules). Since state.get("ALIVE_TO_DEAD") == 3 is a state
            //that tells the cell was ALIVE initially so we need to actually consider
            //this initial state
            if (neighbour == state.get("STAYS_ALIVE") || neighbour == state.get("ALIVE_TO_DEAD")) {
                alive++;
            }
        }
        return alive;
    }

    public void gameOfLife(int[][] board) {
        //https://leetcode.com/problems/game-of-life/
        //exlanation: https://youtu.be/T9Y82JH4-pY
        /*
        The board is made up of an m row n grid of cells, where each cell has an
        initial state: live (represented by a 1) or dead (represented by a 0).
        Each cell interacts with its eight neighbors (horizontal, vertical,
        diagonal) using the following four rules (taken from the above Wikipedia article):

        1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
        2. Any live cell with two or three live neighbors lives on to the next generation.
        3. Any live cell with more than three live neighbors dies, as if by over-population.
        4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
         */

        int ROW = board.length;
        int COL = board[0].length;

        //actual:
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
        System.out.println();

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
            {-1, -1},
            {-1, 1},
            {1, -1},
            {1, 1}
        };
        //intermediate state of population
        Map<String, Integer> state = new HashMap<>();
        state.put("STAYS_DEAD", 0); // acc to rule 0 -> 0
        state.put("STAYS_ALIVE", 1); // acc to rule 1 -> 1
        state.put("DEAD_TO_ALIVE", 2); // acc to rule 0 -> 1
        state.put("ALIVE_TO_DEAD", 3); // acc to rule 1 -> 0

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                int populationAroundCurrPerson = gameOfLife_GetAlivePopulationAround(board, r, c, state, dirs);

                //1. Any live cell with fewer than two live neighbors dies as if caused by under-population.
                //3. Any live cell with more than three live neighbors dies, as if by over-population.
                if (board[r][c] == 1
                        && (populationAroundCurrPerson < 2 || populationAroundCurrPerson > 3)) {
                    board[r][c] = state.get("ALIVE_TO_DEAD"); //live cell now dead
                } else if (board[r][c] == 0 && populationAroundCurrPerson == 3) {
                    //4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
                    board[r][c] = state.get("DEAD_TO_ALIVE"); //dead cell now alive
                }
            }
        }

        //changing state back to result
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (board[r][c] == state.get("ALIVE_TO_DEAD")) {
                    board[r][c] = 0;
                } else if (board[r][c] == state.get("DEAD_TO_ALIVE")) {
                    board[r][c] = 1;
                }
            }
        }
        //output
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
        System.out.println();
    }

    private int largestImageOverlap_Convolute(int[][] img1, int[][] img2Padded, int xShift, int yShift) {
        int result = 0;
        for (int row = 0; row < img1.length; row++) {
            for (int col = 0; col < img1.length; col++) {
                result += img1[row][col] * img2Padded[row + yShift][col + xShift];
            }
        }
        return result;
    }

    public void largestImageOverlap(int[][] img1, int[][] img2) {
        //https://leetcode.com/problems/image-overlap/
        //https://leetcode.com/problems/image-overlap/solution/
        int N = img1.length;
        int maxOverLaps = 0;
        int[][] img2Padded = new int[3 * N - 2][3 * N - 2];
        for (int row = 0; row < N; row++) {
            for (int col = 0; col < N; col++) {
                img2Padded[row + N - 1][col + N - 1] = img2[row][col];
            }
        }

        for (int xShift = 0; xShift < 2 * N - 1; xShift++) {
            for (int yShift = 0; yShift < 2 * N - 1; yShift++) {
                maxOverLaps = Math.max(maxOverLaps,
                        largestImageOverlap_Convolute(img1, img2Padded, xShift, yShift));
            }
        }
        //output
        System.out.println("Largest image overlap between two images: " + maxOverLaps);
    }

    public int largestAreaInMatrixBetweenKBlockedRowCols(int n, int m, int[][] blocked) {
        //https://practice.geeksforgeeks.org/problems/enemy/1
        int k = blocked.length;
        if (k == 0) {
            return n * m;
        }

        List<Integer> rows = new ArrayList<>();
        List<Integer> cols = new ArrayList<>();

        rows.add(0);
        cols.add(0);

        rows.add(n + 1);
        cols.add(m + 1);

        for (int[] block : blocked) {
            rows.add(block[0]);
            cols.add(block[1]);
        }

        Collections.sort(rows);
        Collections.sort(cols);

        int maxRowEdge = 0;
        int maxColEdge = 0;

        for (int i = 0; i < rows.size() - 1; i++) {
            maxRowEdge = Math.max(maxRowEdge, rows.get(i + 1) - rows.get(i) - 1);
        }

        for (int i = 0; i < cols.size() - 1; i++) {
            maxColEdge = Math.max(maxColEdge, cols.get(i + 1) - cols.get(i) - 1);
        }

        return maxRowEdge * maxColEdge;
    }

    public void countUnguardedCellsInGrid(int m, int n, int[][] guards, int[][] walls) {
        //https://leetcode.com/problems/count-unguarded-cells-in-the-grid/
        Set<String> guardSet = new HashSet<>();
        Set<String> wallSet = new HashSet<>();
        Set<String> visited = new HashSet<>();

        int totalCell = m * n;
        //blocked cells are those where there is either wall or guard
        int blockedCell = guards.length + walls.length;

        for (int[] guard : guards) {
            guardSet.add(guard[0] + "," + guard[1]);
        }

        for (int[] wall : walls) {
            wallSet.add(wall[0] + "," + wall[1]);
        }

        //all the unique cells that are visible by a single guard
        int visibleCell = 0;

        for (int[] guard : guards) {

            int currRow = guard[0];
            int currCol = guard[1];

            //UP - NORTH
            currRow -= 1;
            while (currRow >= 0) {
                //seeing cells straight in NORTH dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }
                //maintaining the unique visible cell count
                //means a cell is previously seen by another guard then dont
                //count that cell again if seen by any other guard
                if (!visited.contains(currRow + "," + currCol)) {
                    visibleCell++;
                }
                visited.add(currRow + "," + currCol);
                currRow--;
            }

            //DOWN - SOUTH
            currRow = guard[0] + 1;
            while (currRow < m) {
                //seeing cells straight in SOUTH dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }
                //maintaining the unique visible cell count
                //means a cell is previously seen by another guard then dont
                //count that cell again if seen by any other guard
                if (!visited.contains(currRow + "," + currCol)) {
                    visibleCell++;
                }
                visited.add(currRow + "," + currCol);
                currRow++;
            }

            //LEFT - WEST
            currRow = guard[0];
            currCol = guard[1] - 1;
            while (currCol >= 0) {
                //seeing cells straight in WEST dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }
                //maintaining the unique visible cell count
                //means a cell is previously seen by another guard then dont
                //count that cell again if seen by any other guard
                if (!visited.contains(currRow + "," + currCol)) {
                    visibleCell++;
                }
                visited.add(currRow + "," + currCol);
                currCol--;
            }

            //RIGHT - EAST
            currCol = guard[1] + 1;
            while (currCol < n) {
                //seeing cells straight in EAST dir and if we encounter
                //any wall or another guard, stop there only and break
                if (guardSet.contains(currRow + "," + currCol)
                        || wallSet.contains(currRow + "," + currCol)) {
                    break;
                }
                //maintaining the unique visible cell count
                //means a cell is previously seen by another guard then dont
                //count that cell again if seen by any other guard
                if (!visited.contains(currRow + "," + currCol)) {
                    visibleCell++;
                }
                visited.add(currRow + "," + currCol);
                currCol++;
            }
        }
        //output
        System.out.println("Unguarded cells: " + (totalCell - (visibleCell + blockedCell)));
    }

    public int firstCompletelyPaintedRowOrCol(int[] paint, int[][] matrix) {
        //https://leetcode.com/problems/first-completely-painted-row-or-column/description/
        /*
        
        num in paint[] is also contained in matrix[r][c] 
        so paint[i] = matrix[r][c] = num and all the num value in both paint[]
        and matrix[][] are unique as num is one of these values [1 to ROW * COL]
        
        This question requires that we should return an index 'i' from paint[]
        where uptil this i-th index either a row or col in matrix must have been
        completely painted.
        
        we know that we have rows = ROW and each contains cells that counts to COL
        similarly we have cols = COL and each contains cells that counts to ROW
        
        //hence each unpaintedCellsInEachRow has cell equals to COL
        row1 = [COL]
        row2 = [COL]
        row3 = [COL]
        
        //hence each unpaintedCellsInEachCol has cell equals to ROW
        col1    col2    col3
        [ROW]   [ROW]   [ROW]
        
        each time we get a num from paint[i] then num in matrix must be painted
        that num in matrix[][] is store in numCellsMap as int[]{row, col}
        
        then this num = matrix[][] = cells(row, col) should be painted in
        unpaintedCellsInEachRow on row
        and 
        unpaintedCellsInEachCol on col
        
        if at any time
        unpaintedCellsInEachRow[row] == 0
        or unpaintedCellsInEachCol[col] == 0
        means we have painted either a row or col in matrix[][]
        return that 'i'
        
         */
        int len = paint.length;

        int ROW = matrix.length;
        int COL = matrix[0].length;

        int[] unpaintedCellsInEachRow = new int[ROW];
        Arrays.fill(unpaintedCellsInEachRow, COL);

        int[] unpaintedCellsInEachCol = new int[COL];
        Arrays.fill(unpaintedCellsInEachCol, ROW);

        //<num, Cell(r, c)>
        Map<Integer, int[]> numCellsMap = new HashMap<>();

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                numCellsMap.put(matrix[r][c], new int[]{r, c});
            }
        }

        for (int i = 0; i < len; i++) {

            int num = paint[i];

            int[] currCell = numCellsMap.get(num);

            int row = currCell[0];
            int col = currCell[1];

            unpaintedCellsInEachRow[row]--;
            if (unpaintedCellsInEachRow[row] == 0) {
                return i;
            }

            unpaintedCellsInEachCol[col]--;
            if (unpaintedCellsInEachCol[col] == 0) {
                return i;
            }
        }
        return len - 1;
    }

    public String reverseString(String str) {

        int len = str.length();
        char[] ch = str.toCharArray();

        //.....................reverse by length
        //.....................O(N)
        for (int i = 0; i < len / 2; i++) {
            char temp = ch[i];
            ch[i] = ch[len - i - 1];
            ch[len - i - 1] = temp;
        }

        //output
        System.out.println("output reverse by length: " + String.valueOf(ch));

        //....................reverse by two pointer
        //....................O(N)
        int f = 0;
        int l = len - 1;
        ch = str.toCharArray();

        while (f < l) {

            char temp = ch[f];
            ch[f] = ch[l];
            ch[l] = temp;
            f++;
            l--;

        }

        //output
        System.out.println("output reverse by two pointer: " + String.valueOf(ch));

        //............................reverse by STL
        String output = new StringBuilder(str)
                .reverse()
                .toString();
        System.out.println("output reverse by STL: " + output);

        return output;

    }

    public boolean isStringPallindrome(String str) {
        return str.equals(reverseString(str));
    }

    public boolean isStringPallindrome(String str, int start, int end) {
        //based on two pointers
        while (end > start) {
            if (str.charAt(start) != str.charAt(end)) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }

    public void printDuplicatesCharInString(String str) {
        System.out.println("For: " + str);

        Map<Character, Integer> countMap = new HashMap<>();
        for (char c : str.toCharArray()) {
            countMap.put(c, countMap.getOrDefault(c, 0) + 1);
        }

        countMap.entrySet().stream()
                .filter(e -> e.getValue() > 1)
                .forEach(e -> System.out.println(e.getKey() + " " + e.getValue()));

    }

    public void romanStringToDecimal(String str) {

        //actual
        System.out.println("roman: " + str);

        Map<Character, Integer> roman = new HashMap<>();
        roman.put('I', 1);
        roman.put('V', 5);
        roman.put('X', 10);
        roman.put('L', 50);
        roman.put('C', 100);
        roman.put('D', 500);
        roman.put('M', 1000);

        int decimal = 0;
        for (int i = 0; i < str.length(); i++) {

            char c = str.charAt(i);
            if (i > 0 && roman.get(str.charAt(i - 1)) < roman.get(c)) {
                decimal += roman.get(c) - 2 * roman.get(str.charAt(i - 1));
            } else {
                decimal += roman.get(c);
            }
        }

        //output
        System.out.println("Decimal: " + decimal);
    }

    public void integerToRomanString(int num) {

        Map<Integer, String> map = new HashMap<>();
        map.put(null, "");
        map.put(0, "");
        map.put(1, "I");
        map.put(2, "II");
        map.put(3, "III");
        map.put(4, "IV");
        map.put(5, "V");
        map.put(6, "VI");
        map.put(7, "VII");
        map.put(8, "VIII");
        map.put(9, "IX");
        map.put(10, "X");
        map.put(20, "XX");
        map.put(30, "XXX");
        map.put(40, "XL");
        map.put(50, "L");
        map.put(60, "LX");
        map.put(70, "LXX");
        map.put(80, "LXXX");
        map.put(90, "XC");
        map.put(100, "C");
        map.put(200, "CC");
        map.put(300, "CCC");
        map.put(400, "CD");
        map.put(500, "D");
        map.put(600, "DC");
        map.put(700, "DCC");
        map.put(800, "DCCC");
        map.put(900, "CM");
        map.put(1000, "M");
        map.put(2000, "MM");
        map.put(3000, "MMM");
        int actualNum = num;
        int pow = 0;
        StringBuilder sb = new StringBuilder();
        while (num != 0) {

            // System.out.println(num +" -- " +(Math.pow(10, mul) * (num%10))+" -- "+map.get((int)(Math.pow(10, mul++) * (num%10))));
            int remainder = num % 10;
            int tens = (int) Math.pow(10, pow++);
            sb.insert(0, map.get((int) (tens * remainder)));
            num /= 10;
        }
        //output
        System.out.println("Given " + actualNum + " as roman string: " + sb.toString());
    }

    public void longestCommonSubsequence(String a, String b) {

        //memoization
        int[][] memo = new int[a.length() + 1][b.length() + 1];
        //base cond
        for (int[] x : memo) {
            Arrays.fill(x, 0);
        }

        for (int x = 1; x < a.length() + 1; x++) {
            for (int y = 1; y < b.length() + 1; y++) {
                if (a.charAt(x - 1) == b.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x - 1][y], memo[x][y - 1]);
                }
            }
        }

        int l = a.length();
        int m = b.length();
        StringBuilder sb = new StringBuilder();
        while (l > 0 && m > 0) {

            if (a.charAt(l - 1) == b.charAt(m - 1)) {
                sb.insert(0, a.charAt(l - 1));
                l--;
                m--;
            } else {

                if (memo[l - 1][m] > memo[l][m - 1]) {
                    l--;
                } else {
                    m--;
                }
            }
        }

        //output
        System.out.println("Longest common subseq: " + sb.toString());
    }

    public String countAndSay_Helper(int n) {

        //https://leetcode.com/problems/count-and-say/
        //base cond
        if (n == 1) {
            return "1";
        }

        String ans = countAndSay_Helper(n - 1);

        StringBuilder sb = new StringBuilder();
        char ch = ans.charAt(0);
        int counter = 1;
        //for i==ans.length() i.e very last itr of loop
        //this itr will only invoke else cond below
        for (int i = 1; i <= ans.length(); i++) {
            //i<ans.length() bound the calculations upto string length
            if (i < ans.length() && ans.charAt(i) == ch) {
                counter++;
            } else {
                sb.append(counter).append(ch);
                //i<ans.length() bound the calculations upto string length
                if (i < ans.length()) {
                    ch = ans.charAt(i);
                }
                counter = 1;
            }
        }
        return sb.toString();
    }

    public void countAndSay(int n) {
        System.out.println("Count and say: " + countAndSay_Helper(n));
    }

    public void removeConsecutiveDuplicateInString(String str) {

        //https://www.geeksforgeeks.org/remove-consecutive-duplicates-string/
        char[] ch = str.toCharArray();
        int start = 0;
        int end = 1;

        while (end < ch.length) {

            if (ch[start] != ch[end]) {
                ch[start + 1] = ch[end];
                start++;
            }
            end++;
        }

        System.out.println("output: " + String.valueOf(ch, 0, start + 1));
    }

    private void printSentencesFromCollectionOfWords_Propagte_Recursion(String[][] words,
            int m, int n,
            String[] output) {
        // Add current word to output array
        output[m] = words[m][n];

        // If this is last word of 
        // current output sentence, 
        // then print the output sentence
        if (m == words.length - 1) {
            for (int i = 0; i < words.length; i++) {
                System.out.print(output[i] + " ");
            }
            System.out.println();
            return;
        }

        // Recur for next row
        for (int i = 0; i < words.length; i++) {
            if (!"".equals(words[m + 1][i]) && m < words.length) {
                printSentencesFromCollectionOfWords_Propagte_Recursion(words, m + 1, i, output);
            }
        }
    }

    public void printSentencesFromCollectionOfWords(String[][] words) {

        //https://www.geeksforgeeks.org/recursively-print-all-sentences-that-can-be-formed-from-list-of-word-lists/
        String[] output = new String[words.length];

        // Consider all words for first 
        // row as starting points and
        // print all sentences
        for (int i = 0; i < words.length; i++) {
            if (words[0][i] != "") {
                printSentencesFromCollectionOfWords_Propagte_Recursion(words, 0, i, output);
            }
        }
    }

    public void longestPrefixAlsoSuffixInString_KMPAlgo(String s) {

        int n = s.length();
        int[] lps = new int[n];
        int prefixIndex = 0, suffixIndex = 1;
        while (suffixIndex < n) {
            if (s.charAt(prefixIndex) == s.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }

        System.out.println("Length of longest prefix: " + prefixIndex);
        System.out.println("Longest prefix substring: " + (prefixIndex == 0 ? "" : s.substring(0, prefixIndex)));
    }

    public String reorganizeString(String S) {
        //https://leetcode.com/problems/reorganize-string/
        int N = S.length();
        Map<Character, Long> map = S.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        PriorityQueue<Character> heap = new PriorityQueue<>(
                //if freq are same for two char
                //sort then alphabetically else max freq first
                (e1, e2) -> map.get(e1) == map.get(e2)
                ? e1 - e2
                : (int) (map.get(e2) - map.get(e1))
        );

        //check all unique char in string S and put it in heap
        //alternatively stream api : for(char chr :  S.chars().mapToObj(c -> (char)c).collect(Collectors.toSet()))
        for (char ch : map.keySet()) {
            if (map.get(ch) > (N + 1) / 2) {
                return "";
            }
            heap.add(ch);
        }

        StringBuilder sb = new StringBuilder();
        while (heap.size() >= 2) {

            char chA = heap.poll();
            char chB = heap.poll();

            sb.append(chA);
            sb.append(chB);

            map.put(chA, map.get(chA) - 1);
            if (map.get(chA) > 0) {
                heap.add(chA);
            }

            map.put(chB, map.get(chB) - 1);
            if (map.get(chB) > 0) {
                heap.add(chB);
            }
        }

        if (!heap.isEmpty()) {
            sb.append(heap.poll());
        }

        return sb.toString();
    }

    public void longestCommonPrefix(String[] strs) {

        //https://leetcode.com/problems/longest-common-prefix/
        if (strs == null || strs.length == 0) {
            return;
        }

        if (strs.length == 1) {
            System.out.println("Longest common prefix in list of strings: " + strs[0]);
            return;
        }

        String str = strs[0]; // first string as starting point
        String result = str;
        int index = 0;
        for (int i = 1; i < strs.length; i++) {
            String s = strs[i];
            int minLen = Math.min(s.length(), str.length());
            while (index < minLen && str.charAt(index) == s.charAt(index)) {
                index++;
            }
            String pref = str.substring(0, index);
            if (pref.length() < result.length()) {
                result = pref;
            }
            index = 0;
        }
        System.out.println("Longest common prefix in list of strings: " + result);
    }

    public void secondMostOccuringWordInStringList(String[] list) {

        Map<String, Integer> map = new HashMap<>();
        for (String s : list) {
            map.put(s, map.getOrDefault(s, 0) + 1);
        }

        PriorityQueue<Map.Entry<String, Integer>> minHeap = new PriorityQueue<>(
                (e1, e2) -> e1.getValue() - e2.getValue()
        );

        for (Map.Entry<String, Integer> e : map.entrySet()) {
            minHeap.add(e);
            if (minHeap.size() > 2) {
                minHeap.poll();
            }
        }

        System.out.println("Second most occuring word: " + minHeap.poll().getKey());
    }

    public boolean checkIsomorphicStrings_1(String s1, String s2) {

        int m = s1.length();
        int n = s2.length();

        if (m != n) {
            System.out.println("Not isomorphic strings");
            return false;
        }

        int SIZE = 256; //to handle numric & alphabetic ascii ranges
        boolean[] marked = new boolean[SIZE];
        int[] map = new int[SIZE];
        Arrays.fill(map, -1);

        for (int i = 0; i < m; i++) {
            if (map[s1.charAt(i)] == -1) {

                if (marked[s2.charAt(i)] == true) {
                    return false;
                }

                marked[s2.charAt(i)] = true;
                map[s1.charAt(i)] = s2.charAt(i);

            } else if (map[s1.charAt(i)] != s2.charAt(i)) {
                return false;
            }
        }

        return true;
    }

    public boolean checkIsomorphicStrings_2(String s1, String s2) {

        //........................T: O(N)
        //EASIER EXPLAINATION
        int m = s1.length();
        int n = s2.length();

        if (m != n) {
            System.out.println("Not isomorphic strings");
            return false;
        }

        Map<Character, Character> map = new HashMap<>();
        for (int i = 0; i < m; i++) {
            char sChar = s1.charAt(i);
            char tChar = s2.charAt(i);

            if (map.containsKey(sChar) && map.get(sChar) != tChar) {
                return false;
            }
            map.put(sChar, tChar);
        }

        map.clear();

        for (int i = 0; i < m; i++) {
            char sChar = s1.charAt(i);
            char tChar = s2.charAt(i);

            if (map.containsKey(tChar) && map.get(tChar) != sChar) {
                return false;
            }
            map.put(tChar, sChar);
        }

        return true;
    }

    public int transformOneStringToAnotherWithMinOprn(String src, String target) {

        //count if two strings are same length or not
        int m = src.length();
        int n = target.length();

        if (m != n) {
            //if length are not same, strings can't be transformed
            return -1;
        }

        //check if the two strings contain same char and their count should also be same
        int[] charCount = new int[256];
        for (int i = 0; i < m; i++) {

            charCount[src.charAt(i)]++;
            charCount[target.charAt(i)]--;
        }

        //if same char are there and count are equal then charCount should have been balanced out to 0
        for (int count : charCount) {
            if (count != 0) {
                return -1;
            }
        }

        int srcIndex = m - 1;
        int targetIndex = n - 1;

        int result = 0;

        while (srcIndex >= 0) {

            if (src.charAt(srcIndex) == target.charAt(targetIndex)) {
                targetIndex--;
            } else {
                result++;
            }

            srcIndex--;
        }

        return result;
    }

    public void arrangeAllWordsAsTheirAnagrams(List<String> words) {

        Map<String, List<String>> anagramGroups = new HashMap<>();
        for (String str : words) {

            char[] ch = str.toCharArray();
            Arrays.sort(ch);
            String sortedString = String.valueOf(ch);

            anagramGroups.putIfAbsent(sortedString, new ArrayList<>());
            anagramGroups.get(sortedString).add(str);
        }

        //output:
        System.out.println("Output: " + anagramGroups);
    }

    public void characterAddedAtFrontToMakeStringPallindrome(String str) {

        //https://www.geeksforgeeks.org/minimum-characters-added-front-make-string-palindrome/
        int charCount = 0;
        while (str.length() > 0) {

            if (isStringPallindrome(str)) {
                break;
            } else {
                charCount++;
                //removing 1 char from end until we get a subtring which is pallindrome
                //the no of char removed (charCount) is the number that needs to be added at front
                str = str.substring(0, str.length() - 1);
            }
        }

        //output:
        System.out.println("No. of character to be added at front to make it pallindrome: " + charCount);
    }

    public void shortestPallindrome(String s) {
        //https://leetcode.com/problems/shortest-palindrome
        //https://leetcode.com/problems/longest-happy-prefix/
        //another approach to characterAddedAtFrontToMakeStringPallindrome()
        //KMP-LPS approach
        String rev = new StringBuilder(s).reverse().toString();
        String str = s + "#" + rev;
        int N = str.length();
        int n = s.length();

        int[] lps = new int[N];
        int prefixIndex = 0;
        int suffixIndex = 1;

        while (suffixIndex < N) {
            if (str.charAt(prefixIndex) == str.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }
        //output
        String shortestPallindrome = rev.substring(0, n - lps[N - 1]) + s;
        System.out.println("Shortest pallindrome required to be formed: " + shortestPallindrome);
    }

    public boolean checkIfOneStringRotationOfOtherString(String str1, String str2) {
        return (str1.length() == str2.length())
                && ((str1 + str1).indexOf(str2) != -1);
    }

    private int countOccurenceOfGivenStringInCharArray_Count = 0;

    private void countOccurenceOfGivenStringInCharArray_Helper(char[][] charArr, int x, int y,
            int startPoint, String str, StringBuilder sb) {

        if (sb.toString().equals(str)) {
            //once set of string is found reset stringbuilder
            sb.setLength(0);
            countOccurenceOfGivenStringInCharArray_Count++;
            return;
        }

        if (x < 0 || x >= charArr.length || y < 0 || y >= charArr[0].length
                || startPoint >= str.length()
                || charArr[x][y] != str.charAt(startPoint)
                || charArr[x][y] == '-') {
            return;
        }

        char original = charArr[x][y];
        sb.append(charArr[x][y]);
        charArr[x][y] = '-';

        //UP
        countOccurenceOfGivenStringInCharArray_Helper(charArr, x - 1, y, startPoint + 1, str, sb);

        //Down
        countOccurenceOfGivenStringInCharArray_Helper(charArr, x + 1, y, startPoint + 1, str, sb);

        //Left
        countOccurenceOfGivenStringInCharArray_Helper(charArr, x, y - 1, startPoint + 1, str, sb);

        //Right
        countOccurenceOfGivenStringInCharArray_Helper(charArr, x, y + 1, startPoint + 1, str, sb);

        charArr[x][y] = original;
    }

    public void countOccurenceOfGivenStringInCharArray(char[][] charArr, String str) {
        //https://leetcode.com/problems/word-search/
        countOccurenceOfGivenStringInCharArray_Count = 0; //reset/init
        StringBuilder sb = new StringBuilder();
        int N = charArr.length;
        int startPoint = 0;
        for (int x = 0; x < N; x++) {
            for (int y = 0; y < N; y++) {
                countOccurenceOfGivenStringInCharArray_Helper(charArr, x, y, startPoint, str, sb);
            }
        }

        //output
        System.out.println("Count of the given string is: " + countOccurenceOfGivenStringInCharArray_Count);
    }

    private void printAllSubSequencesOfAString_Helper(String str, int start, int N,
            String current, Set<String> subseq) {

        if (start == N) {
            subseq.add(current);
            return;
        }

        for (int i = start; i < N; i++) {
            printAllSubSequencesOfAString_Helper(str, i + 1, N, current + str.charAt(i), subseq);
            printAllSubSequencesOfAString_Helper(str, i + 1, N, current, subseq);
        }
    }

    public void printAllSubSequencesOfAString(String str) {

        int N = str.length();
        Set<String> subseq = new HashSet<>();
        printAllSubSequencesOfAString_Helper(str, 0, N, "", subseq);

        //output:
        System.out.println("All possible subsequences of string: " + subseq);
    }

    public boolean balancedParenthesisEvaluation(String s) {
        //https://leetcode.com/problems/valid-parentheses/
        Stack<Character> stack = new Stack<>();
        for (char ch : s.toCharArray()) {

            if (ch == '{' || ch == '[' || ch == '(') {
                stack.push(ch);
            } else if (!stack.isEmpty() && stack.peek() == '(' && ch == ')') {
                stack.pop();
            } else if (!stack.isEmpty() && stack.peek() == '{' && ch == '}') {
                stack.pop();
            } else if (!stack.isEmpty() && stack.peek() == '[' && ch == ']') {
                stack.pop();
            } else {
                return false;
            }
        }

        return stack.isEmpty();
    }

    public void firstNonRepeatingCharacterFromStream(String stream) {
        //LinkedHashSet is better use as compared to ArrayList
        //because arraylist.contains() is O(N) for searching a value
        //but linkedhashset.contains() is O(1) for searching a value
        Set<Character> linkedHashSet = new LinkedHashSet<>();
        Set<Character> visited = new HashSet<>();
        for (int i = 0; i < stream.length(); i++) {
            char ch = stream.charAt(i);
            if (!visited.contains(ch)) {

                if (linkedHashSet.contains(ch)) {
                    linkedHashSet.remove((Character) ch);
                    visited.add(ch);
                } else {
                    linkedHashSet.add(ch);
                }
            }

            System.out.println("First non repeating character till " + stream.substring(0, i + 1));
            System.out.println((linkedHashSet.isEmpty() ? "#" : linkedHashSet.iterator().next() + ""));
        }
    }

    public boolean wordBreak_Recursive(String str, Set<String> set) {

        //https://www.geeksforgeeks.org/word-break-problem-dp-32/
        int n = str.length();
        if (n == 0 || set.contains(str)) {
            return true;
        }

        for (int i = 1; i <= n; i++) {
            if (set.contains(str.substring(0, i)) && wordBreak_Recursive(str.substring(i, n), set)) {
                return true;
            }
        }
        return false;
    }

    public boolean wordBreak_DP_Problem(String str, Set<String> set) {
        //https://leetcode.com/problems/word-break/
        //https://leetcode.com/problems/word-break/discuss/1068441/Detailed-Explanation-of-Top-Down-and-Bottom-Up-DP
        //similar to longestIncreasingSubseq()
        boolean[] memo = new boolean[str.length() + 1];
        //base cond
        memo[0] = true; // str with no length is also true

        for (int i = 1; i <= str.length(); i++) {
            for (int j = 0; j < i; j++) {
                if (set.contains(str.substring(j, i)) && memo[j]) {
                    memo[i] = true;
                    break;
                }
            }
        }
        return memo[str.length()];
    }

    public void longestSubstringWithoutRepeatingChar(String str) {

        //SLIDING WINDOW ALGO
        //https://leetcode.com/problems/longest-substring-without-repeating-characters/
        int n = str.length();
        int start = 0;
        int end = 0;
        int maxLen = 0;
        Map<Character, Integer> freq = new HashMap<>();
        String substr = "";
        while (end < n) {

            char chEnd = str.charAt(end);

            freq.putIfAbsent(chEnd, 0);

            if (freq.get(chEnd) < 1) {

                freq.put(chEnd, freq.get(chEnd) + 1);

                if (maxLen < (end - start + 1)) {
                    maxLen = end - start + 1;
                    substr = str.substring(start, start + maxLen);
                }
                end++;
            } else {
                char chStart = str.charAt(start);
                freq.put(chStart, freq.get(chStart) - 1);
                start++;
            }
        }

        //output:
        System.out.println("Longest subtring without repeating char: " + maxLen + " (" + substr + ")");
    }

    public void minimumWindowSubstring(String s, String t) {

        //Explanation: https://www.youtube.com/watch?v=nMaKzLWceFg&feature=youtu.be
        //SLIDING WINDOW ALGO
        //prepare the count map for string t 
        //to know how many char we need to find in string s
        Map<Character, Integer> tMap = new HashMap<>();
        for (char ch : t.toCharArray()) {
            tMap.put(ch, tMap.getOrDefault(ch, 0) + 1);
        }

        int tCount = 0;
        int start = 0;
        int end = 0;
        int minLenWindow = Integer.MAX_VALUE;
        int substrIndex = 0;
        int N = s.length();
        while (end < N) {

            char chEnd = s.charAt(end);
            //each we find the char in string s that is also in string t
            //we decreament the count of that char from map
            //to know how much of that char (chEnd) we needed and how much we have found
            if (tMap.containsKey(chEnd)) {
                //we choose 1 char from string s that is also in string t
                //so we will reduce the freq of this char, freq of this char >= 0
                //shows how much char is req before we found some extra occurences
                //of this char in string s because we don't care about the extra chars
                //only char[freq to 0]
                tMap.put(chEnd, tMap.get(chEnd) - 1);
                //eacg time we are reduciing freq we are taking a char so tCount++
                //below if block won't consider any extra occuerences of this char
                if (tMap.get(chEnd) >= 0) {
                    tCount++;
                }
            }

            //below while loop with cond tCount == t.length()
            //signifies that now we have all char of string t in string s
            //we can calculate window and at same time try to minimize the window size
            while (tCount == t.length()) {

                if (minLenWindow > (end - start + 1)) {
                    minLenWindow = end - start + 1;
                    substrIndex = start;
                }

                //adjust the start pointer now
                char chStart = s.charAt(start);
                if (tMap.containsKey(chStart)) {
                    tMap.put(chStart, tMap.get(chStart) + 1);
                    if (tMap.get(chStart) > 0) {
                        tCount--;
                    }
                }
                start++;
            }
            end++;
        }

        //output:
        String output = minLenWindow > s.length() ? "" : s.substring(substrIndex, substrIndex + minLenWindow);
        System.out.println("Min window substring containg all char of string t in string s: "
                + (minLenWindow > s.length() ? -1 : minLenWindow) + " : "
                + output);
    }

    public void countAllOccurencesOfPatternInGivenString(String txt, String pat) {
        //........................T: O(N)
        //https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
        //SLIDING WINDOW
        Map<Character, Integer> patMap = new HashMap<>();
        for (char chPat : pat.toCharArray()) {
            patMap.put(chPat, patMap.getOrDefault(chPat, 0) + 1);
        }

        int totalOccurences = 0;
        int patCharCount = 0;
        int patLen = pat.length();
        int txtLen = txt.length();
        int start = 0;
        int end = 0;
        List<Integer> occuerencesIndex = new ArrayList<>();
        List<String> occuerencesSubstring = new ArrayList<>();
        while (end < txtLen) {

            char chEnd = txt.charAt(end);
            if (patMap.containsKey(chEnd)) {
                patMap.put(chEnd, patMap.get(chEnd) - 1);
                if (patMap.get(chEnd) >= 0) {
                    patCharCount++;
                }
            }

            //once window for pattern is reached
            //balance out by moving this window
            //and removing start from patCharCount
            while ((end - start + 1) == patLen) {
                //if the curr window also contains the same char as
                //that of pattern string (patCharCount == patLen)
                if (patCharCount == patLen) {
                    totalOccurences++;
                    occuerencesIndex.add(start);
                    occuerencesSubstring.add(txt.substring(start, start + patLen));
                }

                char chStart = txt.charAt(start);
                if (patMap.containsKey(chStart)) {
                    patMap.put(chStart, patMap.get(chStart) + 1);
                    if (patMap.get(chStart) > 0) {
                        patCharCount--;
                    }
                }
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Total occurences: " + totalOccurences);
        System.out.println("All the indexes: " + occuerencesIndex);
        System.out.println("All the substring of anagrams: " + occuerencesSubstring);
    }

    public void partitionLabels(String str) {

        //problem: https://leetcode.com/problems/partition-labels/
        //explanation: https://youtu.be/5NCjHqx2v-k
        List<Integer> result = new ArrayList<>();
        List<String> substring = new ArrayList<>();
        int n = str.length();
        Map<Character, Integer> lastIndexes = new HashMap<>();
        for (int i = 0; i < n; i++) {
            lastIndexes.put(str.charAt(i), i);
        }

        int start = 0;
        int end = 0;
        int maxEnd = 0;
        while (end < n) {
            maxEnd = Math.max(maxEnd, lastIndexes.get(str.charAt(end)));
            if (end == maxEnd) {
                int partitionLen = end - start + 1;
                result.add(partitionLen);
                substring.add(str.substring(start, start + partitionLen));
                start = end + 1;
            }
            end++;
        }

        //output:
        System.out.println("All the partition lengths: " + result + " \nPartition strings: " + substring);
    }

    public void longestRepeatingCharacterByKReplacement(String str, int K) {
        //https://leetcode.com/problems/longest-repeating-character-replacement/
        //explanation: https://youtu.be/gqXU1UyA8pk
        //SLIDING WINDOW
        int[] charFreq = new int[26];
        int start = 0;
        int end = 0;
        int maxLen = 0;
        int mostFreqCharTill = 0;
        int n = str.length();
        while (end < n) {

            char chEnd = str.charAt(end);
            charFreq[chEnd - 'A']++;

            mostFreqCharTill = Math.max(mostFreqCharTill, charFreq[chEnd - 'A']);
            //let suppose curr win len (end - start + 1) has substr = ..."BABB"...
            //mostFreqCharTill = charFreq[B] = 3
            //now see out these BABB if you leave mostFreqChar(B) you are left with
            //A's like this winLen = 4, B = 3, A = 1
            //then winLen - mostFreqChar(B) ==> 4 - 3 = 1(i.e freq of A)
            //now you just have replace them, least freq chars (which we are allowed replace only K) 
            //if these least freq char are more than K we must minimize our win
            while ((end - start + 1) - mostFreqCharTill > K) {
                charFreq[str.charAt(start) - 'A']--;
                start++;
            }

            maxLen = Math.max(maxLen, end - start + 1);
            end++;
        }

        //output:
        System.out.println("Max length: " + maxLen);
    }

    public void minWhiteBlockChangeToBlackBlockInKLength(String blocks, int k) {
        //https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/
        //based on SLIDING WINDOW & longestRepeatingCharacterByKReplacement()
        int n = blocks.length();
        int start = 0;
        int end = 0;
        int minWhiteBlockChange = Integer.MAX_VALUE;
        int mostFreqBlackBlocks = 0;
        Map<Character, Integer> freq = new HashMap<>();

        while (end < n) {
            char chEnd = blocks.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);
            if (chEnd == 'B') {
                mostFreqBlackBlocks = Math.max(mostFreqBlackBlocks, freq.get(chEnd));
            }

            //in the given window, find the diff between total char(winLen) - mostFreqBlackBlock
            if (end - start + 1 == k) {
                minWhiteBlockChange = Math.min(minWhiteBlockChange,
                        //winLen - mostFreqBlackblock
                        //will give the least white blocks exist in the curr winLen
                        //track in all the win of size k, where are the least freq white blocks
                        (end - start + 1) - mostFreqBlackBlocks);
                char chStart = blocks.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                start++;
            }
            end++;
        }
        //output
        System.out.println("Min white block change to have k consecutive black blocks: " + minWhiteBlockChange);
    }

    public void maximizeConfusionInExam(String answerKey, int k) {
        //https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
        //vased on SLIDING WINDOW
        //& minWhiteBlockChangeToBlackBlockInKLength() & longestRepeatingCharacterByKReplacement()
        /*
        intuition here is to check 
        1. if we replace original 'F' aswers with wrong = 'T' values then how long
        of a consecutive length of T(s) we can generate
        
        2. if we replace original 'T' aswers with wrong = 'F' values then how long
        of a consecutive length of F(s) we can generate
        
        need to pick the maxLen from both 1. and 2. points hence need to do
        2 sliding window from both the above mentioned 2 cases
        
         */
        int n = answerKey.length();
        int[] freq = new int[26];
        int mostFreq = 0;
        int maxLen = 0;
        int start = 0;
        int end = 0;

        //1. here in this while() loop, we will check how many original answers with
        //'F' values can be replaced with wrong 'T' to generate max confusions == maxLen
        while (end < n) {

            char chEnd = answerKey.charAt(end);
            int chEndIndex = chEnd - 'A';
            freq[chEndIndex]++;

            if (chEnd == 'T') {
                mostFreq = Math.max(mostFreq, freq[chEndIndex]);
            }

            while ((end - start + 1) - mostFreq > k) {
                char chStart = answerKey.charAt(start);
                int chStartIndex = chStart - 'A';
                freq[chStartIndex]--;
                start++;
            }

            maxLen = Math.max(maxLen, (end - start + 1));

            end++;
        }

        start = 0;
        end = 0;
        mostFreq = 0;
        freq = new int[26];

        //2. here in this while() loop, we will check how many original answers with
        //'T' values can be replaced with wrong 'F' to generate max confusions == maxLen
        while (end < n) {

            char chEnd = answerKey.charAt(end);
            int chEndIndex = chEnd - 'A';
            freq[chEndIndex]++;

            if (chEnd == 'F') {
                mostFreq = Math.max(mostFreq, freq[chEndIndex]);
            }

            while ((end - start + 1) - mostFreq > k) {
                char chStart = answerKey.charAt(start);
                int chStartIndex = chStart - 'A';
                freq[chStartIndex]--;
                start++;
            }
            maxLen = Math.max(maxLen, (end - start + 1));
            end++;
        }

        //output
        System.out.println("Maximize confusion in exam : " + maxLen);
    }

    private void generateBalancedParenthesis_Helper(int n, String curr, int open, int close, List<String> result) {

        //any req parenthesis of size n needs 2 * n parenthesis to balance
        //ex: if n = 1 => "{" to balance it need "}" which "{}" is n * 2
        if (curr.length() == 2 * n) {
            result.add(curr);
            return;
        }

        if (open < n) {
            generateBalancedParenthesis_Helper(n, curr + "{", open + 1, close, result);
        }

        if (close < open) {
            generateBalancedParenthesis_Helper(n, curr + "}", open, close + 1, result);
        }
    }

    public void generateBalancedParenthesis(int n) {
        //https://leetcode.com/problems/generate-parentheses
        //https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/
        List<String> result = new ArrayList<>();
        generateBalancedParenthesis_Helper(n, "", 0, 0, result);
        //output:
        System.out.println("All balanced parenthesis: " + result);
    }

    public void scoreOfParenthesis(String str) {

        //https://leetcode.com/problems/score-of-parentheses
        //explanatin: https://youtu.be/jfmJusJ0qKM
        int score = 0;
        Stack<Integer> stack = new Stack<>();
        for (char ch : str.toCharArray()) {

            if (ch == '(') {
                stack.push(score);
                score = 0;
            } else {
                score = stack.pop() + Math.max(score * 2, 1);
            }
        }

        //output:
        System.out.println("Score: " + score);
    }

    public void minimumCharRemovalToMakeValidParenthesis(String str) {

        //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses
        class CharIndex {

            char ch;
            int index;

            public CharIndex(char ch, int index) {
                this.ch = ch;
                this.index = index;
            }
        }

        StringBuilder sb = new StringBuilder();
        Stack<CharIndex> stack = new Stack<>();
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            sb.append(c);
            if (c == '(' || c == ')') {

                if (!stack.isEmpty() && stack.peek().ch == '(' && c == ')') {
                    stack.pop();
                } else {
                    stack.push(new CharIndex(c, i));
                }
            }
        }

        while (!stack.isEmpty()) {
            sb.deleteCharAt(stack.pop().index);
        }

        //output:
        System.out.println("Balanced string: " + sb.toString());
    }

    public boolean repeatedSubstringPattern(String str) {

        //https://leetcode.com/problems/repeated-substring-pattern/
        //explanantion: https://youtu.be/bClIZj66dVE
        int len = str.length();
        for (int i = len / 2; i >= 1; i--) {

            if (len % i == 0) {

                int numRepeats = len / i;
                String sub = str.substring(0, i);
                StringBuilder sb = new StringBuilder();
                for (int j = 0; j < numRepeats; j++) {
                    sb.append(sub);
                }

                if (sb.toString().equals(str)) {
                    return true;
                }
            }
        }

        return false;
    }

    private int longestPallindromicSubstring_ExpandFromMiddle(String str, int left, int right) {

        if (str == null || left > right) {
            return 0;
        }

        while (left >= 0 && right < str.length() && str.charAt(left) == str.charAt(right)) {
            left--;
            right++;
        }

        //total pallindromic char b/w left and right
        return right - left - 1;
    }

    public void longestPallindromicSubstring(String str) {

        //.....................T: O(N^2)
        //https://leetcode.com/problems/longest-palindromic-substring/
        //https://leetcode.com/problems/palindromic-substrings/
        //explanation: https://youtu.be/y2BD4MJqV20
        int start = 0;
        int end = 0;

        for (int i = 0; i < str.length(); i++) {

            //case to handle odd length string 
            //there will be exactly one middle char in that
            //ex: "racecar" middle char is 'e' 
            int len1 = longestPallindromicSubstring_ExpandFromMiddle(str, i, i);
            //case to handle even length string
            //the middle will in b/w the two char of (str.length / 2)  and ((str.length /2) + 1)
            //ex: "aabbaa" middle char will be in b/w b|b
            int len2 = longestPallindromicSubstring_ExpandFromMiddle(str, i, i + 1);

            int len = Math.max(len1, len2);

            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + (len / 2);
            }
        }

        //output:
        System.out.println("Longest pallindromic substring: " + str.substring(start, end + 1));
    }

    public boolean stringComparisionAfterProcessingBackspaceChar(String a, String b) {

        //.............................T: O(M+N)
        //.............................S: O(1)
        //https://leetcode.com/problems/backspace-string-compare/solution/
        int i = a.length() - 1;
        int j = b.length() - 1;

        int skipA = 0;
        int skipB = 0;

        while (i >= 0 || j >= 0) {

            while (i >= 0) {
                if (a.charAt(i) == '#') {
                    skipA++;
                    i--;
                } else if (skipA > 0) {
                    skipA--;
                    i--;
                } else {
                    break;
                }
            }

            while (j >= 0) {
                if (b.charAt(j) == '#') {
                    skipB++;
                    j--;
                } else if (skipB > 0) {
                    skipB--;
                    j--;
                } else {
                    break;
                }
            }

            if (i >= 0 && j >= 0 && a.charAt(i) != b.charAt(j)) {
                return false;
            }

            //if one string length is smaller than others or run out of characters than the
            //other string
            if ((i >= 0) != (j >= 0)) {
                return false;
            }

            i--;
            j--;
        }
        return true;
    }

    public void stringZigZag(String str, int row) {

        if (row == 1) {
            //edge case
            System.out.println("String zig zag: " + str);
            return;
        }

        String[] zigZag = new String[row];
        Arrays.fill(zigZag, "");

        int iRow = 0;
        boolean isGoingDown = true;

        for (int i = 0; i < str.length(); i++) {

            zigZag[iRow] += str.charAt(i);

            if (isGoingDown) {
                iRow++;
            } else {
                iRow--;
            }

            if (iRow == row - 1) {
                isGoingDown = false;
            } else if (iRow == 0) {
                isGoingDown = true;
            }
        }

        StringBuilder sb = new StringBuilder();
        for (String s : zigZag) {
            sb.append(s);
        }

        //output
        System.out.println("String zig zag: " + sb.toString());
    }

    private List<String> stepsToOpenTheLock_AllCombinations(String originalLockStr,
            Set<String> deadEnd, Set<String> visitedCombination) {

        List<String> allCombinations = new ArrayList<>();

        for (int wheelNumber = 0; wheelNumber < 4; wheelNumber++) {

            char[] lockStrClone = String.valueOf(originalLockStr).toCharArray();

            //backwards combinations 2->1, 8->7 so on...
            if (lockStrClone[wheelNumber] == '0') {
                lockStrClone[wheelNumber] = '9';
            } else {
                lockStrClone[wheelNumber] = (char) ((int) lockStrClone[wheelNumber] - 1);
            }

            String newLockStr = String.valueOf(lockStrClone);

            //new lock string pattern should not be a dead end pattern
            //and should not be a already-generated-pattern 
            //(Set->add(data) returns true if data is not already present else returns false) 
            if (!deadEnd.contains(newLockStr) && visitedCombination.add(newLockStr)) {
                allCombinations.add(newLockStr);
            }

            //upwards combinatons 1->2, 5->6 so on
            lockStrClone = String.valueOf(originalLockStr).toCharArray();
            if (lockStrClone[wheelNumber] < '9') {

                lockStrClone[wheelNumber] = (char) ((int) lockStrClone[wheelNumber] + 1);
                newLockStr = String.valueOf(lockStrClone);

                //new lock string pattern should not be a dead end pattern
                //and should not be a already-generated-pattern 
                //(Set->add(data) returns true if data is not already present else returns false) 
                if (!deadEnd.contains(newLockStr) && visitedCombination.add(newLockStr)) {
                    allCombinations.add(newLockStr);
                }
            }
        }
        return allCombinations;
    }

    public int stepsToOpenTheLock(String[] deadends, String target) {

        //https://leetcode.com/problems/open-the-lock
        //https://leetcode.com/problems/open-the-lock/discuss/1123396/Java-BFS-with-very-detailed-explanations
        String start = "0000";
        Set<String> deadEnd = new HashSet<>(Arrays.asList(deadends));
        Set<String> visitedCombination = new HashSet<>();
        Queue<String> q = new LinkedList<>();

        int steps = 0;

        if (start.equals(target)) {
            return steps;
        }

        if (deadEnd.contains(start)) {
            return -1;
        }

        visitedCombination.add(start);
        q.add(start);

        while (!q.isEmpty()) {

            steps++;
            int size = q.size();

            for (int i = 0; i < size; i++) {

                String lockStr = q.poll();
                List<String> allCombinations = stepsToOpenTheLock_AllCombinations(lockStr, deadEnd, visitedCombination);
                for (String combination : allCombinations) {
                    if (combination.equals(target)) {
                        return steps;
                    }
                    q.add(combination);
                }
            }
        }

        return -1;
    }

    public void longestSubstringWithKUniqueCharacter(String str, int K) {

        //SLIDING WINDOW
        //https://practice.geeksforgeeks.org/problems/longest-k-unique-characters-substring0853/1#
        int n = str.length();
        int start = 0;
        int end = 0;
        int maxLen = 0;
        int index = 0;
        Map<Character, Integer> map = new HashMap<>();

        while (end < n) {

            char chEnd = str.charAt(end);
            map.put(chEnd, map.getOrDefault(chEnd, 0) + 1);

            if (map.size() == K) {
                if (maxLen < end - start + 1) {
                    maxLen = end - start + 1;
                    index = start;
                }
            }

            while (map.size() > K) {
                char chStart = str.charAt(start);
                map.put(chStart, map.get(chStart) - 1);
                if (map.get(chStart) <= 0) {
                    map.remove(chStart);
                }
                start++;
            }
            end++;
        }

        //output:
        System.out.println("Max length substring with K unique char: " + (maxLen == 0 ? -1 : maxLen));
        if (maxLen != 0) {
            System.out.println("Substring with K unique char: " + str.substring(index, index + maxLen));
        }
    }

    public void smallestSubstringWithKUniqueCharacter(String str, int K) {
        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
        int n = str.length();
        Map<Character, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int firstIndex = 0;
        int minLen = n + 1;
        while (end < n) {
            char chEnd = str.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);

            //if in freq map we have got all the K unique char
            //we will try to minimize the window to find the smallest substring
            while (freq.size() == K) {
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    firstIndex = start;
                }

                char chStart = str.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                if (freq.get(chStart) <= 0) {
                    freq.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //output
        if (minLen == n + 1) {
            System.out.println("Smallest substring with K unique character not possible: -1");
            return;
        }
        System.out.println("Smallest substring with K unique character: " + minLen);
        System.out.println("Smallest substring with K unique character substring: "
                + str.substring(firstIndex, firstIndex + minLen));
    }

    public void smallestSubarrayWithKDistinctElements(int[] nums, int K) {
        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
        //based on smallestSubstringWithKUniqueCharacter()
        int n = nums.length;
        Map<Integer, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        int firstIndex = 0;
        int lastIndex = 0;
        int minLen = n + 1;
        while (end < n) {
            int valEnd = nums[end];
            freq.put(valEnd, freq.getOrDefault(valEnd, 0) + 1);

            //if in freq map we have got all the K distinct elements
            //we will try to minimize the window to find the smallest subarray
            while (freq.size() == K) {
                if (end - start + 1 < minLen) {
                    minLen = end - start + 1;
                    firstIndex = start;
                    lastIndex = end;
                }

                int valStart = nums[start];
                freq.put(valStart, freq.getOrDefault(valStart, 0) - 1);
                if (freq.get(valStart) <= 0) {
                    freq.remove(valStart);
                }
                start++;
            }
            end++;
        }
        //output
        if (minLen == n + 1) {
            System.out.println("Smallest subarray with K distinct elements not possible: -1");
            return;
        }
        System.out.println("Smallest subarray with K distinct elements: " + minLen);
        for (int i = firstIndex; i <= lastIndex; i++) {
            System.out.print(nums[i] + " ");
        }
        System.out.println();
    }

    public void largestNumberFromSetOfNumbers(String[] nums) {

        //https://leetcode.com/problems/largest-number/
        //https://practice.geeksforgeeks.org/problems/largest-number-formed-from-an-array1117/1
        //https://www.geeksforgeeks.org/given-an-array-of-numbers-arrange-the-numbers-to-form-the-biggest-number/
        //ex 3, 30, 34, 5, 9
        //int priority queue will have the numbers based on the max(ab, ba) combinations
        //if a  = 3, b = 30 then ab = 330 & ba = 303 max(330, 303) so on
        //a, b are going to store in this camparion only
        PriorityQueue<String> combinations = new PriorityQueue<>((a, b) -> {
            String ab = a + b;
            String ba = b + a;
//            System.out.println(ab + " & " + ba + " compareTo " + ab.compareTo(ba));
            return ab.compareTo(ba) > 0 ? -1 : 1;
        });

        StringBuilder sb = new StringBuilder();

        combinations.addAll(Arrays.asList(nums));

        while (!combinations.isEmpty()) {
            sb.append(combinations.poll());
        }

        //remove any starting zeroes
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }

        //output
        System.out.println("Largest number formed from the given set of numbers: " + sb.toString());
    }

    public long smallestNumber(long num) {
        //https://leetcode.com/problems/smallest-value-of-the-rearranged-number
        boolean isNegative = num < 0;
        //converting the given num to its positive value
        num = Math.abs(num);
        //convert the given num to its char[] arr form
        char[] numArr = String.valueOf(num).toCharArray();
        int n = numArr.length;
        //sorting the char[] arr so that all the smaller digits
        //comes first, we will just need to pick the one by one and form a string
        Arrays.sort(numArr);

        int index = 0;
        StringBuilder smallerNumber = new StringBuilder();

        //in case if our num was negative, then picking the digits from the end
        //will give us the smaller number
        //like +5 > +2 but -2 > -5
        //sorted arr[] = [2,5] for positive pick from left to right
        //for negative pick from right to left
        if (isNegative) {
            index = n - 1;
            while (index >= 0) {
                smallerNumber.append(numArr[index--]);
            }
            return -1 * Long.parseLong(smallerNumber.toString());
        }

        //we are working for positive num cases, there is a edge case
        //if our inital num had zero in it
        //like 54321000 ==> sorted arr[] = [0,0,0,1,2,3,4,5]
        //now if we simply pick from left to right our numStr will formed as
        //00012345 which is equivalent to 12345 but without zeroes we can't omit
        //all zeroes and we can't keep zeroes in starting
        //so fetch all the zeroes from starting and form zeroes str = "000"
        //below loop will break at index where numArr[index] != '0' that means '1'
        //we will simply put all the zeroes after first non-zero digit (i.e, '1')
        StringBuilder zeroes = new StringBuilder();
        while (index < n && numArr[index] == '0') {
            zeroes.append(numArr[index++]);
        }
        //index here is at first non-zero digit in sorted numArr
        smallerNumber.append(index >= n ? zeroes.toString() : numArr[index] + zeroes.toString());
        //we have considered the first non-zero digit
        //like this "1" + "000" = "1000"
        //now we can start from next index onwards and starting picking
        //digits one by one
        index += 1;
        while (index < n) {
            smallerNumber.append(numArr[index++]);
        }
        return Long.parseLong(smallerNumber.toString());
    }

    public void stringCompression(char[] arr) {
        //https://leetcode.com/problems/string-compression/
        //explanation: https://youtu.be/IhJgguNiYYk
        int n = arr.length;
        int start = 0;
        int end = 0;
        int index = 0;
        while (end < n) {
            start = end;
            while (end < n && arr[start] == arr[end]) {
                end++;
            }
            arr[index++] = arr[start];
            int count = end - start;
            if (count <= 1) {
                continue;
            }
            for (char digit : String.valueOf(count).toCharArray()) {
                arr[index++] = digit;
            }
        }

        //output
        for (int i = 0; i < index; i++) {
            System.out.print(arr[i]);
        }
        System.out.println();
    }

    public int closestStringDistance(List<String> strs, String w1, String w2) {

        //https://practice.geeksforgeeks.org/problems/closest-strings0611/1#
        if (w1.equals(w2)) {
            return 0;
        }
        int n = strs.size();
        int dist = n + 1;
        //find first index of any of the word
        int first = 0;
        int i = 0;
        for (; i < n; i++) {
            if (strs.get(i).equals(w1) || strs.get(i).equals(w2)) {
                first = i;
                break;
            }
        }

        //find other index of other word which is not found
        while (i < n) {

            if (strs.get(i).equals(w1) || strs.get(i).equals(w2)) {
                if (!strs.get(first).equals(strs.get(i)) && (i - first) < dist) {
                    dist = i - first;
                }
                first = i;
            }
            i++;
        }

        return dist;
    }

    public boolean longPressedNames(String name, String typed) {

        //https://leetcode.com/problems/long-pressed-name/
        char[] nameCh = name.toCharArray();
        char[] typedCh = typed.toCharArray();

        int i = 0;
        int j = 0;

        while (i < name.length() && j < typed.length()) {

            if (nameCh[i] == typedCh[j]) {
                i++;
                j++;
            } else if (j > 0 && typedCh[j] == typedCh[j - 1]) {
                j++;
            } else {
                return false;
            }
        }

        if (i != name.length()) {
            return false;
        } else {
            while (j < typed.length()) {
                if (typedCh[j] != typedCh[j - 1]) {
                    return false;
                }
                j++;
            }
        }
        return true;
    }

    private void interleavingOfTwoStrings_Helper(
            String str1, String str2, int indexI, int indexJ, StringBuilder sb, List<String> res) {

        if (sb.length() == str1.length() + str2.length()) {
            res.add(sb.toString());
            return;
        }

        if (indexI < str1.length()) {
            sb.append(str1.charAt(indexI));
            interleavingOfTwoStrings_Helper(
                    str1, str2, indexI + 1, indexJ, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }

        if (indexJ < str2.length()) {
            sb.append(str2.charAt(indexJ));
            interleavingOfTwoStrings_Helper(
                    str1, str2, indexI, indexJ + 1, sb, res);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public void interleavingOfTwoStrings(String a, String b) {
        //.............................T: O(2 ^ (M + N)) M = a.length(), N = b.length()
        //https://www.geeksforgeeks.org/print-all-interleavings-of-given-two-strings/
        StringBuilder sb = new StringBuilder();
        List<String> res = new ArrayList<>();
        interleavingOfTwoStrings_Helper(a, b, 0, 0, sb, res);
        //output
        System.out.println("Interleaving of two strings: " + res);
    }

    private void printAllPermutationOfString_Helper(char[] chArr, int index, List<String> res) {

        if (index == chArr.length) {
            res.add(String.valueOf(chArr));
        }

        for (int i = index; i < chArr.length; i++) {

            //swap
            char temp = chArr[index];
            chArr[index] = chArr[i];
            chArr[i] = temp;

            //recursive call
            printAllPermutationOfString_Helper(chArr, index + 1, res);

            //swap back the char to its original place
            //to keep chaArr original before swaping and for next recursive call
            temp = chArr[index];
            chArr[index] = chArr[i];
            chArr[i] = temp;
        }
    }

    public void printAllPermutationOfDistinctCharInString(String str) {
        //.............................T: O(N!) factorial(N), N = str.length()
        //https://leetcode.com/problems/permutations/
        //https://leetcode.com/problems/permutations-ii/
        //explanantion: https://www.youtube.com/watch?v=GuTPwotSdYw
        //we are fixing char at index location perform operations on rest of 
        //remaining chArr so each time N * N-1 * N-2 ....0 = N!
        char[] chArr = str.toCharArray();
        List<String> res = new ArrayList<>();

        printAllPermutationOfString_Helper(chArr, 0, res);

        //output
        System.out.println("All permutation of given string: " + res);
    }

    public void longestSubstringHavingAllVowelsInOrder(String word) {

        //https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/
        /*
         the string only contains char [a,e,i,o,u]
         */
        int maxLen = 0;
        int currLen = 1;
        int vowelCount = 1;
        int n = word.length();

        for (int i = 1; i < n; i++) {
            if (word.charAt(i - 1) == word.charAt(i)) {
                //if curr and prev char is same/repeating
                currLen++;
            } else if (word.charAt(i - 1) < word.charAt(i)) {
                //this if increment vowelCount because
                //actual vowel order is a, e, i, o, u 
                //where a < e < i < o < u (ASCII values)
                vowelCount++;
                currLen++;
            } else {
                //reset both variables when vowel order doesn't matches
                vowelCount = 1;
                currLen = 1;
            }

            if (vowelCount == 5) {
                maxLen = Math.max(maxLen, currLen);
            }
        }

        //output
        System.out.println("Longest substring having all vowels in order: " + maxLen);
    }

    public void arithematicExpressionEvaluationBasicCalculator(String expr) {

        //https://leetcode.com/problems/basic-calculator-ii/
        int n = expr.length();
        int currNum = 0;
        int lastNum = 0;
        int result = 0;

        char opr = '+';

        for (int i = 0; i < n; i++) {
            char ch = expr.charAt(i);
            if (Character.isDigit(ch)) {
                currNum = (currNum * 10) + (ch - '0');
            }

            if (!Character.isDigit(ch) && ch != ' ' || i == n - 1) {
                if (opr == '+' || opr == '-') {
                    result += lastNum;
                    lastNum = (opr == '+') ? currNum : -currNum;
                } else if (opr == '*') {
                    lastNum = lastNum * currNum;
                } else if (opr == '/') {
                    lastNum = lastNum / currNum;
                }
                opr = ch;
                currNum = 0;
            }
        }
        result += lastNum;

        //output
        System.out.println("Evaluation: " + result);
    }

    public void basicCalculator(String str) {
        //https://leetcode.com/problems/basic-calculator/
        //https://leetcode.com/problems/basic-calculator/discuss/2832644/simple-and-easy-solution-in-java-oror-basic-calculatororor
        int n = str.length();
        Stack<Integer> stack = new Stack<>();
        int index = 0;
        int sum = 0;
        int sign = +1;

        while (index < n) {
            char ch = str.charAt(index);
            if (Character.isDigit(ch)) {
                int num = 0;
                while (index < n && Character.isDigit(str.charAt(index))) {
                    num = num * 10 + (str.charAt(index) - '0');
                    index++;
                }
                //loop break when the curr index-th char is not a digit
                //we need to step back one index because index is increamented
                //below then the curr index-th char will be considered in next
                //iteration
                index -= 1;
                num *= sign;
                sum += num;
                sign = +1;
            } else if (ch == '(') {
                stack.push(sum);
                stack.push(sign);
                sum = 0;
                sign = +1;
            } else if (ch == ')') {
                //in the above if-block we added prev sum first & sign later for
                //that prev iteration, now if we reach this if-block we will first
                //pop prevSign & prevSum of prev iteration to curr sum & sign that
                //we have proccessed between curr brackets '()'
                //prevSum prevSign (curr inner expression)
                int prevSign = stack.pop();
                int prevSum = stack.pop();
                //why we are multiplying the curr sum with prevSign? thats based
                //on maths: -(+123) == -123 OR +(-123) == -123 OR +(+123) == 123
                //ex: 1 + (1 + 1) - (1 - 3) ==> + (1 + 1) ==> + (2) ==> +2
                //but - (1 - 3) ==> - (-2) ==> +2 because - * -2 == +2
                sum *= prevSign;
                sum += prevSum;
            } else if (ch == '-') {
                sign = -1;
            }
            index++;
        }
        //output
        System.out.println("Basic calculator expression evaluation: " + sum);
    }

    public void evaluateBracketPatternAndReplaceWithGivenWord(String s, List<List<String>> replaceWith) {

        //https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string
        Map<String, String> map = new HashMap<>();
        for (List<String> list : replaceWith) {
            map.put(list.get(0), list.get(1));
        }

        boolean bracketStart = false;
        String key = "";
        StringBuilder sb = new StringBuilder();
        int i = 0;
        int n = s.length();

        while (i < n) {
            char ch = s.charAt(i++);

            //all such char which are not of pattern : (SomeChar)
            if (Character.isAlphabetic(ch) && bracketStart == false) {
                sb.append(ch);
            } else if (Character.isAlphabetic(ch) && bracketStart == true) {
                //all such char which are part of pattern : (SomeChar)
                //key = SomeChar not including (, )
                key += ch;
            } else if (ch == '(') {
                //if bracket starts
                bracketStart = true;
            } else if (bracketStart == true && ch == ')') {
                //if bracket flag is true and ending bracket has arrived
                //means at this point, key = SomeChar has been formed
                String replace = map.getOrDefault(key, "?"); //if key is not provided, replace with ?
                sb.append(replace);
                key = ""; //reset for next key generation
                bracketStart = false; //reset to find next bracket start
            }
        }

        //output
        System.out.println("Bracket pattern evaluated: " + sb.toString().trim());
    }

    private void allPhoneDigitLetterCombinations_Helper(String digits,
            int digitIndex, String curr,
            Map<Integer, String> map, List<String> combinations) {

        if (digitIndex == digits.length()) {
            combinations.add(curr);
            return;
        }

        //letters in digit of digits in phone keypad
        String keyChars = map.get(digits.charAt(digitIndex) - '0');
        for (char ch : keyChars.toCharArray()) {
            allPhoneDigitLetterCombinations_Helper(digits,
                    digitIndex + 1, curr + ch,
                    map, combinations);
        }
    }

    public void allPhoneDigitLetterCombinations(String digits) {

        //https://leetcode.com/problems/letter-combinations-of-a-phone-number
        /*
         think of keypad based phones, letters are arranged in some number of keypad
         digits provided, form all combinations of letters from each digit in digits
         */
        List<String> combinations = new ArrayList<>();

        if (digits.length() == 0) {
            return;
        }

        //representation of phone keypad
        Map<Integer, String> map = new HashMap<>();
        map.put(2, "abc");
        map.put(3, "def");
        map.put(4, "ghi");
        map.put(5, "jkl");
        map.put(6, "mno");
        map.put(7, "pqrs");
        map.put(8, "tuv");
        map.put(9, "wxyz");

        allPhoneDigitLetterCombinations_Helper(digits, 0, "", map, combinations);

        //output
        System.out.println("All combinations as the digits given: ");
        combinations.stream().forEach(s -> System.out.print(s + " "));
        System.out.println();
    }

    public boolean checkIfOneCharSwapMakeStringEqual(String s1, String s2) {

        //https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/
        if (s1.length() != s2.length()) {
            return false;
        }

        int n = s1.length();

        char swapedA = '.';
        char swapedB = '.';
        char swapedC = '.';
        char swapedD = '.';

        int swapCount = 0;

        for (int i = 0; i < n; i++) {

            if (s1.charAt(i) != s2.charAt(i)) {
                swapCount++;
                if (swapCount == 1) {
                    swapedA = s1.charAt(i);
                    swapedB = s2.charAt(i);
                } else if (swapCount == 2) {
                    swapedC = s1.charAt(i);
                    swapedD = s2.charAt(i);
                } else {
                    return false;
                }
            }
        }

        return swapCount == 0
                || (swapedA == swapedD && swapedB == swapedC);
    }

    public void largestSubstringBetweenTwoSameChar(String str) {

        //https://leetcode.com/problems/largest-substring-between-two-equal-characters/
        /*
         ex "abca", two same char a & a, set of char between them bc of len = 2
         */
        int[] startingIndexes = new int[26];
        Arrays.fill(startingIndexes, -1);
        int max = -1;
        int end = 0;
        while (end < str.length()) {
            char ch = str.charAt(end);
            if (startingIndexes[ch - 'a'] == -1) {
                //starting index of any char
                startingIndexes[ch - 'a'] = end;
            } else {
                //char chr is seen more than once in else{} 
                //calculate max set of char b/w curr seen char chr and prev
                //index of same char chr
                //end = index of curr chr - indexes[chr - 'a'] index of same char chr - 1
                max = Math.max(max, end - startingIndexes[ch - 'a'] - 1);
            }
            end++;
        }

        /*
         partitionLabel() approach
         int[] lastCharIndexes = new int[26];
         for(int i = 0; i < s.length(); i++){
         lastCharIndexes[s.charAt(i) - 'a'] = i;
         }
        
         int maxLen = -1;
        
         for(int i = 0; i < s.length(); i++){
         char chr = s.charAt(i);
         int end = lastCharIndexes[chr - 'a'];
         maxLen = Math.max(maxLen, end - i - 1);
         }
        
         return maxLen;
         */
        //output
        System.out.println("Largest subtring of chars between two same char: " + max);
    }

    public boolean determineIfTwoStringCanBeMadeClose(String str1, String str2) {

        //https://leetcode.com/problems/determine-if-two-strings-are-close/
        if (str1.length() != str2.length()) {
            return false;
        }

        Map<Character, Integer> str1Map = new HashMap<>();
        for (char c : str1.toCharArray()) {
            str1Map.put(c, str1Map.getOrDefault(c, 0) + 1);
        }

        Map<Character, Integer> str2Map = new HashMap<>();
        for (char c : str2.toCharArray()) {
            str2Map.put(c, str2Map.getOrDefault(c, 0) + 1);
        }

        //same char of str1 should be in str2
        for (char key : str1Map.keySet()) {
            if (!str2Map.containsKey(key)) {
                return false;
            }
        }

        //same char of str2 should be in str1
        for (char key : str2Map.keySet()) {
            if (!str1Map.containsKey(key)) {
                return false;
            }
        }

        //values list of their freq should be equal
        List<Integer> str1Val = str1Map.values().stream().sorted().collect(Collectors.toList());
        List<Integer> str2Val = str2Map.values().stream().sorted().collect(Collectors.toList());

        if (!str1Val.equals(str2Val)) {
            return false;
        }
        return true;
    }

    public void minCharacterRequiredToMakeStringTAnagramOfS(String s, String t) {
        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/
        Map<Character, Long> sMap = s.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        Map<Character, Long> tMap = t.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));

        //if freq of a char in t is less than the freq of same char in s
        //freq(t.char, defaultIfSameCharNotPresent = 0) < freq(s.char)
        //req chars will be freq(s.char) - freq(t.char, defaultIfSameCharNotPresent = 0)
        long req = 0;
        for (char key : sMap.keySet()) {
            long freqT = tMap.getOrDefault(key, 0l);
            if (freqT < sMap.get(key)) {
                req += sMap.get(key) - freqT;
            }
        }

        //output
        System.out.println("Minimum character required to make string t anagram of s: " + req);
    }

    public void minCharacterRemovedToMakeStringTAndSAnagrams(String s, String t) {

        //https://www.geeksforgeeks.org/remove-minimum-number-characters-two-strings-become-anagram/
        //OPTIMISED from above link
        Map<Character, Long> sMap = s.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));
        //reduce the freq of char of string t from freq Map(sMap) of string s
        //this reduce will balance all the common char of both strings(anagrams)
        //all the char left in map should be removed, where String T & S are anagrams
        for (char ch : t.toCharArray()) {
            sMap.put(ch, sMap.getOrDefault(ch, 0l) - 1l);
        }

        long removed = 0;
        for (char c = 'a'; c <= 'z'; c++) {
            removed += Math.abs(sMap.getOrDefault(c, 0l));
        }

        //output
        System.out.println("Minimum character removed to make string t & s anagrams: " + removed);
    }

    public void convertPostfixToInfixExpression(String postfix) {

        //https://www.geeksforgeeks.org/postfix-to-infix/
        //Approach similar to postfix expression evaluation
        Stack<String> stack = new Stack<>();

        for (char ch : postfix.toCharArray()) {

            if (Character.isLetterOrDigit(ch)) {
                stack.push(ch + "");
            } else {
                String c2 = stack.pop();
                String c1 = stack.pop();

                String str = "(";
                str += c1;
                str += ch;
                str += c2;
                str += ")";
                stack.push(str);
            }
        }

        //output
        System.out.println("Infix expression: " + stack.peek());
    }

    private int convertInfixToPostfixExpression_OperatorPrecedence(char ch) {
        switch (ch) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return -1;
        }
    }

    public void convertInfixToPostfixExpression(String infix) {

        Stack<Character> bracketsAndOperatorStack = new Stack<>();
        StringBuilder sb = new StringBuilder();

        for (char ch : infix.toCharArray()) {

            if (Character.isLetterOrDigit(ch)) {
                sb.append(ch);
            } else if (ch == '(') {
                bracketsAndOperatorStack.push(ch);
            } else if (ch == ')') {
                while (!bracketsAndOperatorStack.isEmpty() && bracketsAndOperatorStack.peek() != '(') {
                    sb.append(bracketsAndOperatorStack.pop());
                }
                //this pop is to remove the '(' that broke the while loop above
                bracketsAndOperatorStack.pop();
            } else {
                while (!bracketsAndOperatorStack.isEmpty()
                        && convertInfixToPostfixExpression_OperatorPrecedence(ch)
                        <= convertInfixToPostfixExpression_OperatorPrecedence(bracketsAndOperatorStack.peek())) {
                    sb.append(bracketsAndOperatorStack.pop());
                }
                bracketsAndOperatorStack.push(ch);
            }
        }

        while (!bracketsAndOperatorStack.isEmpty()) {
            sb.append(bracketsAndOperatorStack.pop());
        }

        //output
        System.out.println("Postfix expression: " + sb.toString());
    }

    public void flipStringToMonotoneIncrease(String str) {
        //https://leetcode.com/problems/flip-string-to-monotone-increasing/
        //explanation: https://youtu.be/NlTjorKsn-Y
        /*
         A string of '0's and '1's is monotone increasing if it consists of some 
         number of '0's (possibly 0), followed by some number of '1's 
         (also possibly 0.)
         //example of monotones
         ex: 00000
         ex: 11111
         ex: 00011
         */
        int one = 0;
        int flip = 0;
        for (char ch : str.toCharArray()) {
            //count 1's that are coming after the consecutive 0's(possibly none)
            //intutions says that any 0 coming after 1s those will be counted in flip++
            //if no 1 has been counted so far one will remain 0 indicating
            //we don't need to do any flips ==> flips = min(one, flip)
            if (ch == '1') {
                one++;
            } else {
                flip++;
            }
            flip = Math.min(one, flip);
        }

        //output
        System.out.println("Min flip of either 0 or 1 to create monotone string: " + flip);
    }

    public void minDeletionCostToAvoidRepeatingChar(String str, int[] cost) {

        //https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/
        /*
         ex: "abaac", cost[] = {1,2,3,4,5}
         delete char = 'a' from index 2 which cost[2] = 3 and by that str will be
         abac ('a' at index 2 removed) and there are no char repeating after itself
         */
        int n = str.length();
        int res = 0;
        for (int i = 0; i < n - 1; i++) {
            if (str.charAt(i) == str.charAt(i + 1)) {
                if (cost[i] < cost[i + 1]) {
                    res += cost[i]; //min(cost[i], cost[i + 1]) = cost[i]
                } else {
                    res += cost[i + 1]; //min(cost[i], cost[i + 1]) = cost[i + 1]
                    //since here in else block the cost[i + 1] < cost[i]
                    //updating cost[i + 1] with greater cost[i] signifies that we have
                    //deleted a char with min cost (here cost[i + 1]) but we still
                    //have a char with a value cost[i], incase we found a same char at s[(i + 1) + 1]
                    //ex: s = "aaa" cost[4,1,1] first mid 'a' will be deleted
                    //as s[0] == 'a' have cost[0] == 4 && s[0 + 1] == 'a' have cost[0 + 1] == 1
                    //minCost = 1 but at the same time update cost[0 + 1] = cost[0] == 4
                    //meaning s[0 + 1] & cost[0 + 1] is deleted
                    cost[i + 1] = cost[i];
                }
            }
        }

        //output:
        System.out.println("Deletion cost: " + res);
    }

    public void removeAdjacentDuplicateKCharInString(String str, int K) {

        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string
        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/
        class Pair {

            char chr;
            int count;

            public Pair(char ch, int count) {
                this.chr = ch;
                this.count = count;
            }
        }

        Stack<Pair> stack = new Stack();
        for (char ch : str.toCharArray()) {

            //count the freq of chars in stack seq
            if (!stack.isEmpty() && stack.peek().chr == ch) {

                stack.push(new Pair(ch, stack.peek().count + 1));

            } else {

                stack.push(new Pair(ch, 1));
            }

            //the freq of a char in stack seq reaches 'k' start removing it
            if (!stack.isEmpty() && stack.peek().count == K) {
                while (!stack.isEmpty() && stack.peek().chr == ch) {
                    stack.pop();
                }
            }

        }

        String res = "";
        while (!stack.isEmpty()) {
            res = stack.pop().chr + res;
        }

        //output
        System.out.println("Remove K adjacent char and print remaining: " + res);
    }

    public int minSwapRequiredToMakeBinaryStringAlternate(String binaryString) {
        //..................................T: O(N), N = length of string
        //..................................S: O(1), countArr[2][2], 4 storage area in arr
        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/
        //Sol: https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/discuss/1990131/Java-counting

        /*
         row\col    count 0, count 1
         evenIndex 0[   0        0  ]             
         oddIndex  1[   0        0  ]   
         */
        int evenIndex = 0;
        int oddIndex = 1;
        int[][] countZeroAndOne = new int[2][2];
        for (int i = 0; i < binaryString.length(); i++) {
            char ch = binaryString.charAt(i);
            countZeroAndOne[i % 2][ch - '0']++;
        }

        if ((countZeroAndOne[evenIndex][0] == 0 && countZeroAndOne[oddIndex][1] == 0)
                || (countZeroAndOne[evenIndex][1] == 0 && countZeroAndOne[oddIndex][0] == 0)) {
            return 0;
        }

        if ((countZeroAndOne[evenIndex][0] != countZeroAndOne[oddIndex][1])
                && (countZeroAndOne[evenIndex][1] != countZeroAndOne[oddIndex][0])) {
            return -1;
        }

        int res1 = countZeroAndOne[evenIndex][0] == countZeroAndOne[oddIndex][1]
                ? countZeroAndOne[evenIndex][0]
                : Integer.MAX_VALUE;

        int res2 = countZeroAndOne[evenIndex][1] == countZeroAndOne[oddIndex][0]
                ? countZeroAndOne[evenIndex][1]
                : Integer.MAX_VALUE;

        return Math.min(res1, res2);
    }

    public void minimumIndexSumOfTwoStringArray(String[] list1, String[] list2) {
        //................................T: O(M + N), M = list1.length, N = list2.length
        //................................S: O(M), hashmap for list1
        //https://leetcode.com/problems/minimum-index-sum-of-two-lists/
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < list1.length; i++) {
            map.put(list1[i], i);
        }

        List<String> strs = new ArrayList<>();
        int minIndexSum = Integer.MAX_VALUE;
        for (int i = 0; i < list2.length && i <= minIndexSum; i++) {
            if (map.containsKey(list2[i])) {
                int currIndexSum = map.get(list2[i]) + i;
                if (currIndexSum < minIndexSum) {
                    minIndexSum = currIndexSum;
                    strs.clear();
                    strs.add(list2[i]);
                } else if (currIndexSum == minIndexSum) {
                    strs.add(list2[i]);
                }
            }
        }
        //Output
        //return  strs.toArray(new String[strs.size()]);
        System.out.println("Min index sum: " + strs);
    }

    public int firstUniqueCharacterInString(String str) {
        //https://leetcode.com/problems/first-unique-character-in-a-string/
        Map<Character, Long> freq = str.chars().mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(
                        Function.identity(),
                        Collectors.counting()
                ));
        for (int i = 0; i < str.length(); i++) {
            if (freq.get(str.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }

    private boolean substringWithConcatenationsOfGivenWords_Check(int index, String str,
            int lengthPerWord,
            int subStringLength,
            int wordsLength,
            Map<String, Integer> wordsCounter) {

        Map<String, Integer> remaining = new HashMap<>(wordsCounter);
        int wordsUsed = 0;

        for (int i = index; i < index + subStringLength; i += lengthPerWord) {
            String sub = str.substring(i, i + lengthPerWord);
            if (remaining.getOrDefault(sub, 0) != 0) {
                remaining.put(sub, remaining.get(sub) - 1);
                wordsUsed++;
            } else {
                return false;
            }
        }
        return wordsUsed == wordsLength;
    }

    public void substringWithConcatenationsOfGivenWords(String str, String[] words) {
        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/
        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution/
        //BRUTE FORCE approach
        //make below variable global so that there is no need to pass them as 
        //method paramters
        int N = str.length();
        int wordsLength = words.length;
        //length of each word will be same in given words[]
        int lengthPerWord = words[0].length();
        //total length of the string formed from concatenating the words in words[]
        int subStringLength = wordsLength * lengthPerWord;
        Map<String, Integer> wordsCounter = new HashMap<>();

        List<Integer> indexes = new ArrayList<>();

        for (String word : words) {
            wordsCounter.put(word, wordsCounter.getOrDefault(word, 0) + 1);
        }

        //all substrings of size subStringLength in given str
        for (int i = 0; i < N - subStringLength + 1; i++) {
            if (substringWithConcatenationsOfGivenWords_Check(i, str,
                    lengthPerWord,
                    subStringLength,
                    wordsLength,
                    wordsCounter)) {
                indexes.add(i);
            }
        }
        //output
        System.out.println("Indexes of all the subtrings that contains concatenations of given words[](word can be in jumbled ordered) "
                + indexes);
    }

    public void maximumWordsThatYouCanType(String text, String brokenLetters) {
        //https://leetcode.com/problems/maximum-number-of-words-you-can-type/
        Set<Character> brokenLetterSet = brokenLetters
                .chars()
                .mapToObj(ch -> (char) ch)
                .collect(Collectors.toSet());

        String[] splitWords = text.split(" ");
        int brokenWordCount = 0;

        //using standard lib indexOf()
//        for (String word : splitWords) {
//            for (char brokenChar : brokenChars) {
//                if (word.indexOf(brokenChar) >= 0) {
//                    brokenWordCount++;
//                    break;
//                }
//            }
//        }
        for (String word : splitWords) {
            //check if the chars of curr word is there in brokenLetterSet
            //because if that char exist in set then this curr word is also
            //broken hence increase brokenWordCount and break as we found a 
            //broken char
            for (char charInWord : word.toCharArray()) {
                if (brokenLetterSet.contains(charInWord)) {
                    brokenWordCount++;
                    break;
                }
            }
        }

        //output
        //Maximum Number of Words You Can Type = Total Words You Have - All Broken Words
        int wordsCanBeTyped = splitWords.length - brokenWordCount;
        System.out.println("Maxmum words that you can type : " + wordsCanBeTyped);
    }

    public boolean checkIfParenthesisStringCanBeValid(String s, String locked) {
        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/
        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/discuss/1905993/Keep-a-Range-1-Pass-O(n)-Java
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        int max = 0;
        int min = 0;

        for (int i = 0; i < n; i++) {
            max += locked.charAt(i) == '0' || s.charAt(i) == '(' ? 1 : -1;
            min += locked.charAt(i) == '0' || s.charAt(i) == ')' ? -1 : 1;
            if (max < 0) {
                return false;
            }
            min = Math.max(0, min);
        }
        return min == 0;
    }

    public void largestOddNumInGivenNumString(String numString) {
        //https://leetcode.com/problems/largest-odd-number-in-string/
        int n = numString.length();
        int lastChar = numString.charAt(n - 1);
        int lastDigit = lastChar - '0';

        //if last digit of a num is odd then the whole num is odd itself
        //ex: 7, 27, 427,...so on
        if (lastDigit % 2 == 1) {
            System.out.println("Largest odd number in given num string: " + numString);
            return;
        }

        //we already checked lastDigit above, it was not odd
        //so start end from second last char index
        int end = n - 2;
        //loop until we reach a odd char/digit from end
        while (end >= 0 && (numString.charAt(end) - '0') % 2 != 1) {
            end--;
        }
        //output
        //end-index at which we will find the first odd chr/digit from end
        //0 to that end-index will be our largest odd string
        System.out.println("Largest odd number in given num string: " + numString.substring(0, end + 1));
    }

    public void smallestStringWithGivenLengthNAndCharSumValueK(int n, int k) {
        //https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/
        char[] smallestString = new char[n];
        //lexicographically smallest string of length n can be full of 'a'
        Arrays.fill(smallestString, 'a');
        //we have taken n length string full of 'a'
        k = k - n;
        int index = n - 1;
        while (index >= 0 && k > 0) {
            int minAscii = Math.min(25, k); // at max we can choose 25 == z
            smallestString[index--] = (char) (minAscii + 'a');
            k -= minAscii;
        }
        //output
        System.out.println("Lexicographically smallest string of length n and char sum k: "
                + String.valueOf(smallestString));
    }

    public void replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar(String str) {
        //https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/
        int n = str.length();

        char[] arr = str.toCharArray();
        for (int i = 0; i < n; i++) {

            if (arr[i] == '?') {

                int left = i - 1;
                int right = i + 1;

                char leftCh = '.';
                char rightCh = '.';

                if (left >= 0) {
                    leftCh = arr[left];
                }

                if (right < n) {
                    rightCh = arr[right];
                }

                //generate a new char from leftCh + 1 (next Acsii value as char)
                //if that is a valid char use that char at ith '?' otherwise default 'a'
                char candidateChar = (char) (leftCh + 1);
                arr[i] = Character.isAlphabetic(candidateChar) ? candidateChar : 'a';

                //if it happens to be that our newly generated char at ith
                //pos is also similar to its rightCh char, we have choose a new 
                //candidate char which will be rightCh + 1 (next Acsii value as char)
                if (arr[i] == rightCh) {
                    candidateChar = (char) (rightCh + 1);
                    arr[i] = Character.isAlphabetic(candidateChar) ? candidateChar : 'a';
                }
            }
        }
        //output
        System.out.println("Removing ? and no consecutive char are repeating: "
                + String.valueOf(arr));
    }

    public String simplifyPath(String path) {
        //https://leetcode.com/problems/simplify-path/
        //https://leetcode.com/problems/crawler-log-folder/
        //explanation: https://youtu.be/qYlHrAKJfyA
        path += "/";
        Stack<String> filesOrDirs = new Stack<>();
        StringBuilder canonicalPath = new StringBuilder();
        String currFilesOrDirs = "";
        for (char ch : path.toCharArray()) {

            if (ch == '/') {

                if (currFilesOrDirs.equals("..")) {
                    //".." represent as move to parent dir in filesysytem
                    //so poping means removing curr file or dir and moving to parent file or dir
                    if (!filesOrDirs.isEmpty()) {
                        filesOrDirs.pop();
                    }
                } else if (!currFilesOrDirs.equals("") && !currFilesOrDirs.equals(".")) {
                    //cases when there // there will be currFilesOrDirs == "" and
                    //"." represent as current working dir, we don't to do anything with that
                    //if currFilesOrDirs is none of that, push in stack
                    filesOrDirs.push(currFilesOrDirs);
                }
                //reset
                currFilesOrDirs = "";
            } else {
                currFilesOrDirs += ch;
            }
        }

        if (filesOrDirs.isEmpty()) {
            return "/";
        }

        while (!filesOrDirs.isEmpty()) {
            canonicalPath.insert(0, "/" + filesOrDirs.pop());
        }
        return canonicalPath.toString();
    }

    public void findCommonCharacters(String[] words) {
        //https://leetcode.com/problems/find-common-characters/
        //https://leetcode.com/problems/intersection-of-two-arrays-ii/
        //https://leetcode.com/problems/find-the-difference-of-two-arrays/
        List<Character> result = new ArrayList<>();
        int[] minFreq = new int[26];
        Arrays.fill(minFreq, Integer.MAX_VALUE);
        for (String word : words) {
            //calculate freq of each charater in the curr word
            int[] currFreq = new int[26];
            for (char ch : word.toCharArray()) {
                currFreq[ch - 'a']++;
            }

            //choose min of freq of each char from curr word or any prev words
            for (int i = 0; i < 26; i++) {
                minFreq[i] = Math.min(
                        minFreq[i],
                        currFreq[i]
                );
            }
        }

        for (int i = 0; i < 26; i++) {
            int freq = minFreq[i];
            while (freq != 0) {
                result.add((char) (i + 'a'));
                freq--;
            }
        }
        //output
        System.out.println("All common chars from the given words[]: " + result);
    }

    private int[] wordSubsets_WordFreq(String word) {
        int[] freq = new int[26];
        for (char ch : word.toCharArray()) {
            freq[ch - 'a']++;
        }
        return freq;
    }

    public void wordSubsets(String[] wordsA, String[] wordsB) {
        //https://leetcode.com/problems/word-subsets/
        //somewhat based on findCommonCharacters()
        List<String> result = new ArrayList<>();
        int[] maxFreq = new int[26];
        //all the words in wordsB, calculate each words freq and create max freq
        //array, this max Freq array will tell the amount of char[i] in maxFreq[i]
        //need from each word in wordsA.
        for (String b : wordsB) {
            int[] bFreq = wordSubsets_WordFreq(b);
            for (int i = 0; i < 26; i++) {
                maxFreq[i] = Math.max(maxFreq[i], bFreq[i]);
            }
        }

        for (String a : wordsA) {
            int[] aFreq = wordSubsets_WordFreq(a);
            boolean inValid = false;
            for (int i = 0; i < 26; i++) {
                //if the curr i-th char freq in aFreq is less that what we need
                //as subset i.e maxFreq[i] that means that word a is invalid
                //try another word.
                //in short, in order to curr word a to be in our result,
                //all of its char should have min freq value as that of maxFreq
                if (aFreq[i] < maxFreq[i]) {
                    inValid = true;
                    break;
                }
            }
            if (!inValid) {
                result.add(a);
            }
        }
        //output
        System.out.println("All words where word from wordsB is subset in words from wordsA: " + result);
    }

    public void searchSuggestionSystem_TrieBased(String[] words, String search) {
        //https://leetcode.com/problems/search-suggestions-system/
        //https://practice.geeksforgeeks.org/problems/phone-directory4628/1
        class TrieNode {

            Map<Character, TrieNode> map;
            List<String> words;

            public TrieNode() {
                map = new HashMap<>();
                words = new ArrayList<>();
            }
        }

        class TrieUtil {

            private TrieNode ROOT;
            //this map is used for output purpose, not req by question
            Map<String, List<String>> wordsPerSearchedChar;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
                this.wordsPerSearchedChar = new HashMap<>();
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                for (char ch : word.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.words.add(word);
                    } else {
                        TrieNode node = new TrieNode();
                        node.words.add(word);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            void prefixSearch(String search, List<List<String>> result) {

                TrieNode currNode = ROOT;

                String searchPrefix = "";

                for (char ch : search.toCharArray()) {

                    searchPrefix += ch;

                    if (currNode != null && currNode.map.containsKey(ch)) {

                        currNode = currNode.map.get(ch);
                        result.add(currNode.words.subList(0, Math.min(3, currNode.words.size())));

                    } else {
                        result.add(Collections.emptyList());
                        //making it null, because here it is a prefix mismatch from 'ch'
                        //hence further no list addition should take place other than
                        //empty list
                        currNode = null;
                    }

                    this.wordsPerSearchedChar.put(searchPrefix, result.get(result.size() - 1));
                }
            }
        }

        int n = words.length;
        List<List<String>> result = new ArrayList<>();

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        //sort the words list before adding to trie because if we add sorted list
        //then each word will also be added in sorted manner in trienode.words list
        Arrays.sort(words);

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        trieUtil.prefixSearch(search, result);

        //output
        System.out.println("Search suggestions system: " + result);
        System.out.println("Search suggestions system words per char: " + trieUtil.wordsPerSearchedChar);
    }

    public void searchSuggestionSystem(String[] words, String search) {
        //https://leetcode.com/problems/search-suggestions-system/
        //explanation: https://youtu.be/D4T2N0yAr20

        int n = words.length;
        //this map is used for output purpose, not req by question
        Map<Character, List<String>> wordsPerSearchedChar = new HashMap<>();
        List<List<String>> result = new ArrayList<>();
        //sort lexicographically order
        Arrays.sort(words);
        int reqAtMost = 3;
        int start = 0;
        int end = n - 1;

        for (int i = 0; i < search.length(); i++) {
            char searchChar = search.charAt(i);
            List<String> curr = new ArrayList<>();

            while (end >= start
                    //cond is to skip all those words from start which are
                    //1. smaller than our search word ex: search = "apple", word[start] = "app"
                    //at i = 3 search[3] = l where i >= "app".length()
                    //2. the curr searchChar at ith pos is not matching with the ith char 
                    //of word[start].charAt(i) ex search = "apple", word[start] = "ape"
                    //at i = 2 searchChar = p !=  word[start].charAt(i) = e
                    && (i >= words[start].length()
                    || words[start].charAt(i) != searchChar)) {
                start++;
            }

            while (end >= start
                    //cond is to skip all those words from end which are
                    //1. smaller than our search word ex: search = "apple", word[end] = "app"
                    //at i = 3 search[3] = l where i >= "app".length()
                    //2. the curr searchChar at ith pos is not matching with the ith char 
                    //of word[end].charAt(i) ex search = "apple", word[end] = "ape"
                    //at i = 2 searchChar = p !=  word[end].charAt(i) = e
                    && (i >= words[end].length()
                    || words[end].charAt(i) != searchChar)) {
                end--;
            }

            //we need atmost 3 words but if we get any less amount then consume that much
            int wordsToConsume = Math.min(reqAtMost, end - start + 1);
            for (int j = 0; j < wordsToConsume; j++) {
                curr.add(words[start + j]);
            }
            result.add(curr);
            //map is used for output purpose only
            wordsPerSearchedChar.put(searchChar, curr);
        }
        //output
        System.out.println("Search suggestions system: " + result);
        System.out.println("Search suggestions system words per char: " + wordsPerSearchedChar);
    }

    public int maximumLengthOfSubstringThatExistsAsSubseqInOtherString(String main, String curr) {
        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
        int currLenCovered = 0;
        int mainLen = main.length();
        for (int i = 0; i < mainLen; i++) {
            if (currLenCovered == curr.length()) {
                break;
            }
            if (main.charAt(i) == curr.charAt(currLenCovered)) {
                currLenCovered++;
            }
        }
        //output
        String substr = curr.substring(0, currLenCovered);
        System.out.println("Maximum length of substring exists as subseq in main string: "
                + currLenCovered + " substr " + substr);
        return currLenCovered;
    }

    public boolean isSubsequence(String main, String curr) {
        //https://leetcode.com/problems/is-subsequence/
        //https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/
        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
        //https://practice.geeksforgeeks.org/problems/find-patterns0606/1
        int currLenCovered = 0;
        int mainLen = main.length();
        int currLen = curr.length();
        for (int i = 0; i < mainLen; i++) {
            if (currLenCovered == currLen) {
                return true;
            }
            if (main.charAt(i) == curr.charAt(currLenCovered)) {
                currLenCovered++;
            }
        }
        return currLen == currLenCovered;
    }

    public void partitionsInCurrStringWherePrefixExistsAsSubseqInMainString(String main, String curr) {
        //MY GOOGLE INTERVIEW QUESTION
        /*
         main = "aaaabbc"
         curr = "abcbbabc"
         partition in curr string should be 3 as abc | bb | abc
         */
        int partitions = 0;
        String prefixStr = curr;
        int prefixLengthCurrCovered = 0;
        Set<String> cache = new HashSet<>();
        while (prefixStr.length() > 0) {
            //checks if prefixStr is already processed before then we don't 
            //need to call the below fun again for same
            //ex: curr = "abcbbabc" first prefix abc will again going
            //to be checked later after bb
            if (cache.contains(prefixStr)) {
                prefixLengthCurrCovered = prefixStr.length();
                prefixStr = prefixStr.substring(prefixLengthCurrCovered);
                partitions++;
                continue;
            }
            //if prefixStr is not cached previously
            //we must find a prefix in curr that exists as subseq in main
            prefixLengthCurrCovered = maximumLengthOfSubstringThatExistsAsSubseqInOtherString(
                    main, prefixStr);
            //if any prefix is not present as subseq the length will return as 0
            //that means we can't divide curr string
            if (prefixLengthCurrCovered == 0) {
                System.out.println("No partition is possible");
                return;
            }
            //if any prefix of curr found as subseq cache what prefix is that
            //ex: curr = "abcbbabc" first prefix = "abc" exists as subseq in "aaaabbc"
            //save substring(0, prefixLengthCurrCovered) i.e, first "abc" and so on...
            cache.add(prefixStr.substring(0, prefixLengthCurrCovered));
            //remove the prefix that has been found
            //like above first "abc" is found as subseq now reduce our actual prefixStr
            //substring(prefixLengthCurrCovered) ==> "bbabc" and so on...
            prefixStr = prefixStr.substring(prefixLengthCurrCovered);
            //if we can do all this we mean that we have a partition
            partitions++;
        }
        //output
        System.out.println("Partitions of curr string where each substring"
                + " exists as subseq in mains string: " + partitions);
    }

    public void numberOfMatchingSubseq(String main, String[] words) {
        //https://leetcode.com/problems/number-of-matching-subsequences/
        int n = words.length;
        Set<String> alreadyFound = new HashSet<>();
        Set<String> notFound = new HashSet<>();
        int totalMatch = 0;
        for (String word : words) {

            if (notFound.contains(word)) {
                continue;
            } else if (alreadyFound.contains(word)) {
                totalMatch++;
            } else if (isSubsequence(main, word)) {
                totalMatch++;
                alreadyFound.add(word);
            } else {
                notFound.add(word);
            }
        }
        //output
        System.out.println("Total words matches that exists as subseq in main string: " + totalMatch);
    }

    public void appendCharsToMakeStringSubseq(String main, String curr) {
        //https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/
        //based on maximumLengthOfSubstringThatExistsAsSubseqInOtherString()
        int n = curr.length();
        int seqMatched = maximumLengthOfSubstringThatExistsAsSubseqInOtherString(main, curr);
        int amountOfCharsToAppend = n - seqMatched;
        String chars = curr.substring(seqMatched);
        //output
        System.out.println("Number of chars to append in String main to make string curr subseq of main: "
                + amountOfCharsToAppend + " chars include: " + chars);
    }

    public void minimumSwapsToMakeParenthesisStringBalanced(String str) {
        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
        //explanation: https://youtu.be/3YDBT9ZrfaU
        int closingBrackets = 0;
        int maxClosingBrackets = 0;
        for (char bracket : str.toCharArray()) {
            closingBrackets += (bracket == ']') ? 1 : -1;
            maxClosingBrackets = Math.max(maxClosingBrackets, closingBrackets);
        }
        //output
        //each time we make a swap, we will be balance two brackets
        int swaps = (maxClosingBrackets + 1) / 2;
        System.out.println("Min swaps to make parenthesis string balanced : " + swaps);
    }

    public void minimumAdditionsToMakeParenthesisStringValid(String str) {
        //https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
        int balancedBrackets = 0;
        int inserts = 0;
        for (char bracket : str.toCharArray()) {
            balancedBrackets += bracket == '(' ? 1 : -1;
            if (balancedBrackets == -1) {
                inserts++;
                balancedBrackets++;
            }
        }
        //output
        System.out.println("Min additions to make parenthesis string valid: "
                + (balancedBrackets + inserts));
    }

    public boolean areAlienWordsSorted(String[] words, String alienAlphabet) {
        //https://leetcode.com/problems/verifying-an-alien-dictionary/
        //explanation: https://youtu.be/OVgPAJIyX6o

        //save the index of all the char in this alienAlphabet letter set
        int[] alphabetIndex = new int[26];
        for (int i = 0; i < alienAlphabet.length(); i++) {
            char ch = alienAlphabet.charAt(i);
            alphabetIndex[ch - 'a'] = i;
        }

        //iterate over all the adjacent words
        for (int i = 0; i < words.length - 1; i++) {
            //curr and next words are always adjacent
            String currWord = words[i];
            String nextWord = words[i + 1];

            for (int j = 0; j < currWord.length(); j++) {
                //since it is given that the words[] is lexcographically sorted 
                //then in that case these words "app" & "apple" will be sorted like this
                //but edge cases like "apple" & "app" they are not sorted as "app" is small
                //so j loop running on "apple" there will come a iteration
                //where j == 3 >= "app".length() till this point no char mismatch is found
                //it will not be found later on as "app" will have no char to check
                if (j >= nextWord.length()) {
                    return false;
                }

                int currCharIndex = currWord.charAt(j) - 'a';
                int nextCharIndex = nextWord.charAt(j) - 'a';
                if (currCharIndex != nextCharIndex) {
                    //since words are sorted so 
                    //ex curr = "app", next = "cat" they are sorted, first mismatch char is a & c
                    //in normal english index/ascii index value is like a < c 
                    //but suppose curr = "cat", next = "app" was given then c < a is a false condition
                    //similary in given alienAplhabet nextChar should have higer index value than currChar
                    //if this case comes opposite currChar have higer index value than nextChar
                    //then alien word[] dictionary is not sorted.
                    if (alphabetIndex[currCharIndex] > alphabetIndex[nextCharIndex]) {
                        return false;
                    }
                    break;
                }
            }
        }
        return true;
    }

    public void generateNumberFollowingPattern(String pattern) {
        //https://leetcode.com/problems/di-string-match/
        //https://leetcode.com/problems/di-string-match/solution/
        int n = pattern.length();
        int low = 0;
        int high = n;
        int index = 0;
        int[] result = new int[n + 1];
        for (char ch : pattern.toCharArray()) {
            if (ch == 'I') {
                result[index++] = low;
                low++;
            } else {
                result[index++] = high;
                high--;
            }
        }
        result[index] = low;
        //output
        System.out.println(pattern + " number following this pattern: " + Arrays.toString(result));
    }

    public void generateSmallestNumberFromDIString(String pattern) {
        //https://leetcode.com/problems/construct-smallest-number-from-di-string/
        //somewhat based on generateNumberFollowingPattern()
        //number pattern should contain digits[1 to 9]
        //ex: "D" output "21" as 1 is dec from 2
        //ex: "IIDDD" output "126543" as 1 < 2 < 6 > 5 > 4 > 3
        int n = pattern.length();
        int num = 1;
        String numStr = "";
        Stack<Integer> stack = new Stack<>();
        for (char ch : pattern.toCharArray()) {
            if (ch == 'D') {
                stack.push(num);
                num++;
            } else {
                stack.push(num);
                num++;
                while (!stack.isEmpty()) {
                    numStr += stack.pop();
                }
            }
        }
        stack.push(num);
        while (!stack.isEmpty()) {
            numStr += stack.pop();
        }
        System.out.println("Smallest number following given DI pattern: " + numStr);
    }

    public void minMovesToMakeStringPallindrome(String str) {
        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/
        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/discuss/2191696/USING-TWO-POINTER-oror-SIMPLEST-SOLUTION

        int n = str.length();

        char[] charArr = str.toCharArray();

        int start = 0;
        int end = n - 1;

        int swaps = 0;

        while (end > start) {
            //greedily compare start and end char update pointer if they are same
            if (charArr[start] == charArr[end]) {
                start++;
                end--;
                continue;
            }

            int currEnd = end;
            //if the start and end chars are not same, try to find the char
            //equal to charArr[start] from the currEnd
            while (charArr[start] != charArr[currEnd]) {
                currEnd--;
            }

            //currEnd would be the char that match to char[start]
            //adjacentNextIndex = currEnd + 1 == adjacent index
            //swap(currEnd, nextToCurrEnd)
            int nextIndex = currEnd + 1;
            //swap
            char temp = charArr[currEnd];
            charArr[currEnd] = charArr[nextIndex];
            charArr[nextIndex] = temp;

            swaps++;
        }
        //output
        System.out.println("Min moves(swaps) to make the string pallindrome: " + swaps);
    }

    public void largestThreeSameDigitNumInString(String num) {
        //https://leetcode.com/problems/largest-3-same-digit-number-in-string/
        //SLIDING WINDOW approach
        int n = num.length();
        int start = 0;
        int end = 0;
        Map<Character, Integer> counter = new HashMap<>();
        int maxEffectiveNum = Integer.MIN_VALUE;

        String result = "";

        while (end < n) {

            char chEnd = num.charAt(end);
            counter.put(chEnd, counter.getOrDefault(chEnd, 0) + 1);

            //same digit and length to be 3
            //so counter size should remain 1 for a single/same digit process
            //like "777" map['7' = 3] size == 1
            if (counter.size() == 1
                    //window here req to be 3
                    && (end - start + 1) == 3) {

                int currEffectiveNum = chEnd - '0';
                //incase we already have processed "777" 
                //so currEffectiveNum = 7, maxEffectiveNum also be currEffectiveNum == 7
                //later on we see "333"
                //then currEffectiveNum = 3
                //but we already have a maxEffectiveNum as 7
                //so our result will not be updated to "333"
                if (currEffectiveNum > maxEffectiveNum) {
                    maxEffectiveNum = currEffectiveNum;
                    //same digits of length 3
                    result = currEffectiveNum + "" + currEffectiveNum + "" + currEffectiveNum;
                }
            }

            //if we need same digit of length 3
            //incase we added 2 different digit then map.size > 1
            //so we will move our window from start
            while (counter.size() > 1) {
                char chStart = num.charAt(start);
                counter.put(chStart, counter.getOrDefault(chStart, 0) - 1);
                if (counter.get(chStart) <= 0) {
                    counter.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //output
        System.out.println("Largest same digit num of length 3: " + result);
    }

    public void minFlipsToMakeBinaryStringAlternating(String str) {
        //https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
        //explanation: https://youtu.be/MOeuK6gaC2A
        //SLIDING WINDOW approach
        /*
         You are given a binary string s. You are allowed to perform two types of 
         operations on the string in any sequence:

         Type-1: Remove the character at the start of the string s and append 
         it to the end of the string.
         Type-2: Pick any character in s and flip its value, i.e., if its value 
         is '0' it becomes '1' and vice-versa.
         Return the minimum number of type-2 operations you need to perform 
         such that s becomes alternating.
         */

        int actualLen = str.length();

        //to achieve Type-1 operation
        str = str + str;

        int appenedStrlen = str.length();

        String targetAltStr1 = "";
        String targetAltStr2 = "";

        //generate the possible alternating binary strings that is of same length
        //as of our actual str (n)
        for (int i = 0; i < appenedStrlen; i++) {
            targetAltStr1 += i % 2 == 0 ? "0" : "1";
            targetAltStr2 += i % 2 == 0 ? "1" : "0";
        }

        int start = 0;
        int end = 0;

        int bitDiffTarget1 = 0;
        int bitDiffTarget2 = 0;

        int minFlips = appenedStrlen;

        while (end < appenedStrlen) {

            if (str.charAt(end) != targetAltStr1.charAt(end)) {
                bitDiffTarget1++;
            }
            if (str.charAt(end) != targetAltStr2.charAt(end)) {
                bitDiffTarget2++;
            }

            while (end - start + 1 > actualLen) {
                if (str.charAt(start) != targetAltStr1.charAt(start)) {
                    bitDiffTarget1--;
                }
                if (str.charAt(start) != targetAltStr2.charAt(start)) {
                    bitDiffTarget2--;
                }
                start++;
            }

            if (end - start + 1 == actualLen) {
                minFlips = Math.min(minFlips, Math.min(bitDiffTarget1, bitDiffTarget2));
            }
            end++;
        }
        //output
        System.out.println("Min flips to make binary string alternating: " + minFlips);
    }

    private boolean decodedString_IsStringDigit(String str) {
        char ch = str.charAt(0);
        return ch >= '0' && ch <= '9';
    }

    public void decodedString(String expression) {
        //https://leetcode.com/problems/decode-string/
        //explanation: https://youtu.be/qB0zZpBJlh8
        int n = expression.length();
        Stack<String> stack = new Stack<>();
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < n; i++) {
            char ch = expression.charAt(i);

            if (ch == ']') {

                String substr = "";
                //ex stack be like [ '[', 'b', 'c' ] then closing bracket comes ']'
                //then form this inner sub string "bc" until we meet its opening bracket '[' in stack
                while (!stack.isEmpty() && !stack.peek().equals("[")) {
                    substr = stack.pop() + substr;
                }

                //pop the opening bracket '[' from the above loop check
                stack.pop();

                String numStr = "";
                //each decoded string has some num K as "K[substr]", where we need to
                //repeat this substr * K time. In the loop below we will form this num K
                //as numStr
                while (!stack.isEmpty() && decodedString_IsStringDigit(stack.peek())) {
                    numStr = stack.pop() + numStr;
                }

                int num = Integer.parseInt(numStr);
                String repeatSubStrNumTimes = "";
                for (int rep = 0; rep < num; rep++) {
                    repeatSubStrNumTimes += substr;
                }

                //till here we have processed the sub-expression
                //in format "num[substr]", we will push this sub-expression
                stack.push(repeatSubStrNumTimes);

            } else {
                //stringified form of curr char chr
                stack.push(ch + "");
            }
        }

        //forming result from all the processed sub-expressions
        String joined = String.join("", stack);
//        while (!stack.isEmpty()) {
//            sb.insert(0, stack.pop());
//        }

        //output:
//        System.out.println("Decoded string: " + sb.toString());
        System.out.println("Decoded string: " + joined);
    }

    public void reverseSubstringsBetweenParenthesis(String str) {
        //https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
        //somewhat similar to decodedString()
        Stack<String> stack = new Stack<>();
        StringBuilder substr = new StringBuilder();

        for (char ch : str.toCharArray()) {
            if (ch == ')') {

                //reset stringbuilder before processing each inner substrings
                substr.setLength(0);
                while (!stack.isEmpty() && !stack.peek().equals("(")) {
                    substr.append(stack.pop());
                }

                //pop out the '(' from above loop 
                stack.pop();

                stack.push(substr.reverse().toString());

            } else {
                stack.push(String.valueOf(ch));
            }
        }

        substr.setLength(0);
        while (!stack.isEmpty()) {
            substr.append(stack.pop());
        }
        System.out.println("Reverse substrings between parenthesis: " + substr.reverse().toString());
    }

    public boolean validPallindromeTwo(String str) {
        //https://leetcode.com/problems/valid-palindrome-ii/
        //explanation: https://youtu.be/JrxRYBwG6EI
        int n = str.length();
        int start = 0;
        int end = n - 1;

        while (end > start) {
            if (str.charAt(start) == str.charAt(end)) {
                start++;
                end--;
                continue;
            }

            //not include char at start-th index ==> start + 1
            //include end char do end + 1
            String skipStart = str.substring(start + 1, end + 1);
            //skip end char
            String skipEnd = str.substring(start, end);

            return isStringPallindrome(skipStart) || isStringPallindrome(skipEnd);
        }
        return true;
    }

    public void textJustification(String[] words, int maxWidth) {
        //https://leetcode.com/problems/text-justification/
        //https://www.interviewbit.com/problems/justified-text/hints/
        int n = words.length;
        int SPACE_CONSTANT = 1;
        List<String> result = new ArrayList<>();
        int index = 0;
        while (index < n) {

            int lineLength = -1;
            int wordIndex = index;
            while (wordIndex < n
                    && words[wordIndex].length() + SPACE_CONSTANT + lineLength <= maxWidth) {
                lineLength += words[wordIndex].length() + SPACE_CONSTANT;
                wordIndex++;
            }

            StringBuilder sb = new StringBuilder(words[index]);
            int spaces = 1;
            int extras = 0;

            if (wordIndex != index + 1 && wordIndex != n) {
                spaces = (maxWidth - lineLength) / (wordIndex - index - 1) + SPACE_CONSTANT;
                extras = (maxWidth - lineLength) % (wordIndex - index - 1);
            }

            for (int j = index + 1; j < wordIndex; j++) {
                //add min spaces req between two words
                for (int space = 0; space < spaces; space++) {
                    sb.append(" ");
                }
                //if any extra spaces are also req, that should also be added
                if (extras-- > 0) {
                    sb.append(" ");
                }
                //after adding all the spaces, we can add the curr jth word
                sb.append(words[j]);
            }

            int remaining = maxWidth - sb.length();
            while (remaining-- > 0) {
                sb.append(" ");
            }
            result.add(sb.toString());
            index = wordIndex;
        }
        //output
        System.out.println("Text justification: " + result);
    }

    public void positionsOfLargeGroups(String str) {
        //https://leetcode.com/problems/positions-of-large-groups/
        //SLIDING WINDOW approach
        List<List<Integer>> positions = new ArrayList<>();
        int n = str.length();
        Map<Character, Integer> freq = new HashMap<>();
        int start = 0;
        int end = 0;
        while (end < n) {

            char chEnd = str.charAt(end);
            freq.put(chEnd, freq.getOrDefault(chEnd, 0) + 1);

            //size == 2 means we now have discontinuity from a potential large group,
            //in that discontinuity we can add previous group if it was >= 3
            //we are not calculating window length as (end - start + 1) because
            //end is already ahead of large group where we found a discontinuity,
            //so length to be considered here till end - 1
            if (freq.size() == 2) {
                if (end - start >= 3) {
                    positions.add(Arrays.asList(start, end - 1));
                }
            }

            //large group will be of same chars whose freq is >= 3
            //if we have more than 1 char in our freq map, we need to adjust our window
            //to find next coming large groups because if previous was a large groups, it
            //would have been calculated in above if block
            while (freq.size() > 1) {
                char chStart = str.charAt(start);
                freq.put(chStart, freq.getOrDefault(chStart, 0) - 1);
                if (freq.get(chStart) <= 0) {
                    freq.remove(chStart);
                }
                start++;
            }
            end++;
        }
        //this if block is handle cases of str = "aaa", "abcaaaa"
        //here after end > n, we are not able to check the very last large groups of str
        //so need this cond here also
        if (end - start >= 3) {
            positions.add(Arrays.asList(start, end - 1));
        }
        //output
        System.out.println("Positions of all the large groups of strings: " + positions);
    }

    public void positionsOfLargeGroups_Optimized(String str) {
        //https://leetcode.com/problems/positions-of-large-groups/
        //TWO POINTER approach
        List<List<Integer>> positions = new ArrayList<>();
        int n = str.length();
        int start = 0;
        int end = 0;
        while (end < n) {
            if (end == n - 1 || str.charAt(end) != str.charAt(end + 1)) {
                if (end - start + 1 >= 3) {
                    positions.add(Arrays.asList(start, end));
                }
                start = end + 1;
            }
            end++;
        }
        //output
        System.out.println("Positions of all the large groups of strings: " + positions);
    }

    public void minTimeToType(String word) {
        //https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/
        //based on Greedy
        /*
        In a circular keyboard, we can either move clockwise or counter clockwise dir
        to reach a char from the word. To have a min time, choose the min time taken
        to reach the dest char from curr pointer and taking up the dest char counts as 1 unit of time
         */
        char currPointer = 'a';
        int time = 0;
        for (char destChar : word.toCharArray()) {
            //calculating the time taken to reach to dest char from the curr pointer
            int clockwiseTime = Math.abs(currPointer - destChar);
            int counterClockwiseTime = 26 - Math.abs(currPointer - destChar);

            //moving to dest char in less time possible
            time += Math.min(clockwiseTime, counterClockwiseTime);

            //picking that dest char takes 1 unit time;
            time += 1;

            //our curr pointer is now at dest char
            currPointer = destChar;
        }
        //output
        System.out.println("Min time to type the given word from a circular keyboard: " + time);
    }

    public void maxVowelCountInSubstringOfKLength(String str, int k) {
        //https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
        //based on SLIDING WINDOW
        int n = str.length();
        int start = 0;
        int end = 0;
        int maxVowelCount = 0;
        int currVowelCount = 0;

        Set<Character> vowels = new HashSet<>(Arrays.asList('a', 'e', 'i', 'o', 'u'));

        while (end < n) {
            char chEnd = str.charAt(end);
            if (vowels.contains(chEnd)) {
                currVowelCount++;
            }

            if (end - start + 1 == k) {
                maxVowelCount = Math.max(maxVowelCount, currVowelCount);
                char chStart = str.charAt(start);
                if (vowels.contains(chStart)) {
                    currVowelCount--;
                }
                start++;
            }
            end++;
        }
        //output
        System.out.println("max vowel counts in a subtring of size k: " + maxVowelCount);
    }

    public void minAmountOfTimeToCollectGarbage(String[] garbage, int[] travel) {
        //https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
        //explanation: https://youtu.be/xSLisYdX8Co
        //Acc to question, for each garbage type, truck has to start from garbage[0]
        //and in order to pick a single type of garbage, it might have to travel all
        //the houses(i-th) with travel[]
        //so save the total time to travel as prefix sum to find the i-th travel time
        int n = travel.length;
        int travelTimePrefixSum = 0;
        for (int i = 0; i < n; i++) {
            travelTimePrefixSum += travel[i];
            travel[i] = travelTimePrefixSum;
        }

        //after that, need to find the very last i-th house where a particular
        //type of garbage is found(G, P, M), this lastIndex will tell the travel
        //time as travel[lastIndex - 1] till i-th house to find the last instance
        //of that particular garbage
        int glassLastIndex = -1;
        int paperLastIndex = -1;
        int metalLastIndex = -1;

        //Acc to questions, apart from travel time, there is also picking up time
        //that is to pick each type of garbage from [0 to m] houses, it will take
        //1 unit of time. we will simply calculate the total no of garbage of each
        //type * 1 == PickingTime
        int glassPickingTime = 0;
        int paperPickingTime = 0;
        int metalPickingTime = 0;

        int m = garbage.length;
        for (int i = 0; i < m; i++) {
            String house = garbage[i];
            for (char garbageType : house.toCharArray()) {

                if (garbageType == 'G') {
                    //last index or last nouse where Glass garbage found
                    //because truck will have to travel till this house(i) to pick
                    glassLastIndex = i;
                    glassPickingTime++;
                }

                if (garbageType == 'P') {
                    //last index or last nouse where Paper garbage found
                    //because truck will have to travel till this house(i) to pick
                    paperLastIndex = i;
                    paperPickingTime++;
                }

                if (garbageType == 'M') {
                    //last index or last nouse where Metal garbage found
                    //because truck will have to travel till this house(i) to pick
                    metalLastIndex = i;
                    metalPickingTime++;
                }
            }
        }

        //totalTime to pick & travel for each type of garbage
        //why (lastIndex > 0) condition, acc to question, travel[] time is given
        //to reach the (i + 1)-th house from i-th house, so by this to reach
        //house (lastIndex == 0) time is 0 and any house(lastIndex > 0)
        //we can take (lastIndex - 1)-th house time(DRY RUN)
        int totalTimeForGlassGarbage = glassPickingTime + (glassLastIndex > 0 ? travel[glassLastIndex - 1] : 0);
        int totalTimeForPaperGarbage = paperPickingTime + (paperLastIndex > 0 ? travel[paperLastIndex - 1] : 0);
        int totalTimeForMetalGarbage = metalPickingTime + (metalLastIndex > 0 ? travel[metalLastIndex - 1] : 0);

        //output
        System.out.println("Total time to collect garbage by pick & travel: "
                + (totalTimeForGlassGarbage + totalTimeForPaperGarbage + totalTimeForMetalGarbage));
    }

    public void minSuffixFlipInBinaryString(String target) {
        //https://leetcode.com/problems/minimum-suffix-flips/
        /*
        base string acc to quest is of same length as that of target string
        baseString.length == target.length == N
        base string will initially have all the values '0' i.e baseString = "0" * N
         */
        int steps = 0;
        //currState represents the curr char in the baseString
        char currState = '0';
        for (char targetCh : target.toCharArray()) {
            if (targetCh != currState) {
                steps++;
                currState = targetCh;
            }
        }
        //output
        System.out.println("Min suffix flips to make base string equal to target string: " + steps);
    }

    public String longestWordInDictionary(String[] words) {
        //https://leetcode.com/problems/longest-word-in-dictionary/
        Set<String> wordSet = new HashSet<>();
        for (String word : words) {
            wordSet.add(word);
        }

        //sort the words[] as longest length first to smallest at end
        //if lengths are same then sort lexicographically
        Arrays.sort(words, (a, b) -> a.length() == b.length()
                ? a.compareTo(b)
                : b.length() - a.length());

        for (String word : words) {
            //since longest word is the first word now, so possibly it is the 
            //good word, only if all of its prefix substring exists in the wordSet/wors[]
            boolean isGoodWord = true;
            for (int i = 1; i < word.length(); i++) {
                //if for the curr longest word 'word' any prefixSubstring
                //doesn't exists as separate word in words[]/wordSet then it can't
                //be a good word, mark isGoodWord = false and break.
                String prefixSubstring = word.substring(0, i);
                if (!wordSet.contains(prefixSubstring)) {
                    isGoodWord = false;
                    break;
                }
            }
            //if from above loop isGoodWord is still true, its our answer
            if (isGoodWord) {
                return word;
            }
        }
        return "";
    }

    public void minInsertionsToBalanceAParenthesisString(String str) {
        //https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
        str = str.replace("))", "]");
        int openBrackets = 0;
        int balanced = 0;
        for (char bracket : str.toCharArray()) {
            if (bracket == '(') {
                openBrackets++;
            } else {
                if (openBrackets > 0) {
                    balanced += bracket == ')' ? 1 : 0;
                    openBrackets--;
                } else {
                    balanced += bracket == ']' ? 1 : 2;
                }
            }
        }
        //output
        System.out.println("Min insertions to make parenthesis string balanced: " + (balanced + openBrackets * 2));
    }

    public void shiftingLetterTwo_BruteForce(String str, int[][] shifts) {
        //https://leetcode.com/problems/shifting-letters-ii/
        int n = str.length();
        char[] arr = str.toCharArray();
        for (int[] shift : shifts) {

            int startIndex = shift[0];
            int endIndex = shift[1];
            //0 == backward move 1 unit back ex: a -1 == z
            //1 == forward move 1 unit ahead ex: a +1 == b
            int move = shift[2] == 0 ? -1 : 1;
            while (startIndex <= endIndex) {
                int val = ((arr[startIndex] - 'a' + move) % 26 + 26) % 26;
                arr[startIndex] = (char) (val + 'a');
                startIndex++;
            }
        }
        //output
        System.out.println("Shifting letters two: " + String.valueOf(arr));
    }

    public void shiftingLetterTwo(String str, int[][] shifts) {
        //https://leetcode.com/problems/shifting-letters-ii/
        //based on prefixSum
        int n = str.length();
        char[] arr = str.toCharArray();
        int[] moves = new int[n + 1];
        for (int[] shift : shifts) {

            int startIndex = shift[0];
            int endIndex = shift[1];
            //0 == backward move 1 unit back ex: a -1 == z
            //1 == forward move 1 unit ahead ex: a +1 == b
            int move = shift[2] == 0 ? -1 : 1;
            moves[startIndex] += move;
            moves[endIndex + 1] += -move;
        }

        for (int i = 1; i <= n; i++) {
            moves[i] += moves[i - 1];
        }

        for (int i = 0; i < n; i++) {
            int val = ((arr[i] - 'a' + moves[i]) % 26 + 26) % 26;
            arr[i] = (char) (val + 'a');
        }

        //output
        System.out.println("Shifting letters two: " + String.valueOf(arr));
    }

    private boolean pallindromePairs_IsPallindrome(String str, int left, int right) {
        if (left > right) {
            return false;
        }
        while (right > left) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }

    public void pallindromePairs(String[] words) {
        //https://leetcode.com/problems/palindrome-pairs/
        //https://leetcode.com/problems/palindrome-pairs/discuss/2585763/Java-100-149ms-or-HashMap-based-solution-w-Video-Explanation
        int n = words.length;
        List<List<Integer>> pairs = new ArrayList<>();
        Map<String, Integer> indexMap = new HashMap<>();
        //tree set to automatically sort the length of word
        Set<Integer> lengthTreeSet = new TreeSet<>();

        for (int i = 0; i < n; i++) {
            String currWord = words[i];
            indexMap.put(currWord, i);
            lengthTreeSet.add(currWord.length());
        }

        for (int i = 0; i < n; i++) {

            String currWord = words[i];
            int currWordLen = currWord.length();
            String revCurrWord = new StringBuilder(currWord).reverse().toString();

            //if the reverse of currWord exist as distinct word with a distinct
            //index value other than actual currWord
            if (indexMap.containsKey(revCurrWord) && indexMap.get(revCurrWord) != i) {
                pairs.add(Arrays.asList(i, indexMap.get(revCurrWord)));
            }

            for (int length : lengthTreeSet) {

                if (currWordLen == length) {
                    break;
                }

                if (pallindromePairs_IsPallindrome(revCurrWord, 0, currWordLen - length - 1)) {
                    String substr = revCurrWord.substring(currWordLen - length);
                    if (indexMap.containsKey(substr)) {
                        pairs.add(Arrays.asList(i, indexMap.get(substr)));
                    }
                }

                if (pallindromePairs_IsPallindrome(revCurrWord, length, currWordLen - 1)) {
                    String substr = revCurrWord.substring(0, length);
                    if (indexMap.containsKey(substr)) {
                        pairs.add(Arrays.asList(indexMap.get(substr), i));
                    }
                }
            }
        }
        //output
        System.out.println("Pallindrome pairs: " + pairs);
    }

    public void longestPallindromeByConcatenatingTwoLetterWords(String[] words) {
        //https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/
        int n = words.length;
        Map<String, Integer> freq = new HashMap<>();
        for (String word : words) {
            freq.put(word, freq.getOrDefault(word, 0) + 1);
        }

        int wordAndRevLength = 0;
        int singleMiddlePallindromeWordLength = 0;
        int otherPallindromeWordLength = 0;

        for (String word : words) {
            String revWord = new StringBuilder(word).reverse().toString();

            if (word.equals(revWord) && freq.containsKey(word)) {

                //here we have self-pallindrome words
                //like [gg, ll, aa]
                //if a self-pallindrome word is odd in freq
                //1-unit of this word can be made middle pallindrome word of
                //the whole pallindormic word
                if (freq.get(word) % 2 != 0) {
                    //all words are 2 letter words so middle-self-pallindrome word
                    //is also of 2 length long
                    singleMiddlePallindromeWordLength = 2;
                    if (freq.get(word) > 1) {
                        //above we have taken 1-unit of word as middle pallindrome
                        //we can arrange the remaining words after that, freq of
                        //left over words * 2char
                        otherPallindromeWordLength += (freq.get(word) - 1) * 2;
                    }
                } else {
                    otherPallindromeWordLength += freq.get(word) * 2;
                }
                freq.remove(word);
            } else if (freq.containsKey(word) && freq.containsKey(revWord)) {
                //here the the curr word is not a self-pallindromic word, that means 
                //we need to find a counter reverse word of the curr word, if that exist
                //we can pick min of either of the freq i.e, min(freq[word], freq[revWord])
                //min is taken because that much of pallindrome string can be formed
                //lc....cl ==> lcty...ytcl
                int freqWord = freq.get(word);
                int freqRevWord = freq.get(revWord);

                int minTaken = Math.min(freqWord, freqRevWord);

                //2 * minTaken == 2char * min taken of freq[word]
                //2 * minTaken == 2char * min taken of freq[revWord]
                //like 2char * freq[lc] + 2char * freq[cl]
                wordAndRevLength += (2 * minTaken + 2 * minTaken);

                //now since we have consumed minTaken words from either of 
                //word or revWord, we must remove both the words from freq map
                //why remove? because minTake is min freq of either word or revWord
                //and we exactly taking this min freq that means after taking this 
                //either of the word or revWord will loose all of it freq means 
                //freq[word] - minTake == 0  or freq[revWord] - minTake == 0
                //so need to remove that word whoose freq becomes 0 but at the same
                //time its counter/rev word will be of no use for next time
                freq.remove(word);
                freq.remove(revWord);

            }
        }
        //output
        System.out.println("Longest pallindrome by concatenating two letter words: "
                + (wordAndRevLength + otherPallindromeWordLength + singleMiddlePallindromeWordLength));
    }

    public void findAndReplaceInString(String str, int[] indices, String[] sources, String[] targets) {
        //https://leetcode.com/problems/find-and-replace-in-string/
        //based on brute force
        int n = str.length();
        int m = indices.length;

        String[] result = new String[n];
        Arrays.fill(result, "");

        //stringified char arr[]
        for (int i = 0; i < n; i++) {
            result[i] += str.charAt(i);
        }

        for (int i = 0; i < m; i++) {

            int index = indices[i];
            String source = sources[i];
            String target = targets[i];

            int sourceLen = source.length();

            if (str.charAt(index) == source.charAt(0)) {

                int substrLen = Math.min(index + sourceLen, n);
                String substring = str.substring(index, substrLen);
                if (substring.equals(source)) {
                    result[index] = target;
                    for (int j = index + 1; j < substrLen; j++) {
                        result[j] = "";
                    }
                }
            }
        }
        //output
        System.out.println("Replaced sources with target strings: " + String.join("", result));
    }

    public void removeStarsFromString_StackBased(String str) {
        //......................T: O(N + N), N = str.length()
        //first O(N) to process stars in the given string
        //second O(N) to form the result string from the stack
        //https://leetcode.com/problems/removing-stars-from-a-string/
        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
        //this approach was giving TLE
        Stack<Character> stack = new Stack<>();
        for (char ch : str.toCharArray()) {
            if (ch == '*') {
                stack.pop();
            } else {
                stack.push(ch);
            }
        }

        String result = "";
        if (!stack.isEmpty()) {
            while (!stack.isEmpty()) {
                result = stack.pop() + result;
            }
        }
        //output
        System.out.println("Remove stars from string: " + result);
    }

    public void removeStarsFromString(String str) {
        //......................T: O(N), N = str.length()
        //https://leetcode.com/problems/removing-stars-from-a-string/
        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
        //based on removeStarsFromString_StackBased() but OPTIMISED
        //this approach saves the extra O(N) time, for forming the result string back
        //from stack, here StringBuilder behaves as stack and also the result string
        //which is trivial for edge cases like long inputs/string without '*' etc
        StringBuilder sb = new StringBuilder();
        for (char ch : str.toCharArray()) {
            if (ch == '*') {
                //just like the stack approach, when ever we are seeing a '*' char
                //we were popping out the last char added to stack, here also,
                //deleting the last char added to stringbuilder
                sb.deleteCharAt(sb.length() - 1);
            } else {
                sb.append(ch);
            }
        }
        //output
        System.out.println("Remove stars from string: " + sb.toString());
    }

    public void distinctEchoSubstrings(String str) {
        //https://leetcode.com/problems/distinct-echo-substrings/
        //https://leetcode.com/problems/distinct-echo-substrings/discuss/2351050/easy-c%2B%2B-solution-oror-two-pointer
        //BRUTE FORCE
        int n = str.length();
        int half = n / 2;
        Set<String> echoSubstrs = new HashSet<>();
        int currLen = 0;

        while (currLen <= half) {
            int firstStringIndex = 0;
            int secondStringIndex = currLen;
            int matchedChars = 0;

            while (secondStringIndex < n) {
                if (str.charAt(firstStringIndex) == str.charAt(secondStringIndex)) {
                    matchedChars++;
                } else {
                    matchedChars = 0;
                }

                if (matchedChars == currLen) {
                    int echoStringStart = firstStringIndex - currLen + 1;
                    String substr = str.substring(echoStringStart, echoStringStart + currLen);
                    if (!substr.equals("")) {
                        echoSubstrs.add(substr);
                    }
                    matchedChars--;
                }
                firstStringIndex++;
                secondStringIndex++;
            }
            currLen++;
        }
        //output
        System.out.println("Distinct echo substrings: " + echoSubstrs.size());
        System.out.println("Distinct echo substrings: " + echoSubstrs);
    }

    public void findDuplicateFilesInSystem(String[] paths) {
        //https://leetcode.com/problems/find-duplicate-file-in-system/
        //simple BRUTE FORCE
        List<List<String>> filePathsOfCommonContent = new ArrayList<>();
        Map<String, List<String>> commonContents = new HashMap<>();

        for (String path : paths) {

            String[] split = path.split(" ");
            //as per the given input pattern, dir will be at 0-th index
            String dir = split[0];
            int infoLen = split.length;

            for (int i = 1; i < infoLen; i++) {
                //currInfo will be of pattern file-name.ext(file-content)
                String currInfo = split[i];
                //contentBracketIndex will be index of '('
                int contentBracketIndex = currInfo.indexOf('(');
                //from contentBracketIndex, we can fetch the file-name, i.e from
                //[0 to contentBracketIndex - 1]
                String fileName = currInfo.substring(0, contentBracketIndex);
                //from contentBracketIndex, we can fetch the file-content, i.e from
                //[contentBracketIndex + 1 to currInfo.length() - 1]
                //i.e, in between brackets (file-content)
                String fileContent = currInfo.substring(contentBracketIndex + 1, currInfo.length() - 1);

                commonContents.putIfAbsent(fileContent, new ArrayList<>());
                commonContents.get(fileContent).add(dir + "/" + fileName);
            }
        }

        for (String fileContent : commonContents.keySet()) {
            //in order to be in our result, a file content has to be duplicated
            //atleast in 2 files, that why if the count file paths for this content
            //is just 1 that would means it is not duplicate
            if (commonContents.get(fileContent).size() > 1) {
                filePathsOfCommonContent.add(commonContents.get(fileContent));
            }
        }
        //output
        System.out.println("File paths in system having duplicate file content: " + filePathsOfCommonContent);
    }

    public void longestLengthSubstringOfContigousLetters(String str) {
        //https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/
        //based on SLIDING WINDOW
        int n = str.length();
        if (n <= 1) {
            System.out.println("Length of subtring with contigous letter: " + n);
            return;
        }

        int start = 0;
        int end = 0;
        //a single letter char can be considered as contigous letter
        int maxLen = 1;

        while (end < n) {
            //curr letter
            char chEnd = str.charAt(end);
            //initail prev letter to curr letter
            char prevEnd = chEnd;
            //if we can pick end - 1 index then update prevChar with a prev letter
            if (end > 0) {
                prevEnd = str.charAt(end - 1);
            }

            //in order the substring to be contigous letter, every curr letter
            //will always be greater than its prev letter and at most diff between
            //curr and prev letter is 1 like a < b < c
            if (chEnd != prevEnd && chEnd - prevEnd == 1) {
                maxLen = Math.max(maxLen, end - start + 1);
            } else {
                start = end;
            }
            end++;
        }
        //output
        System.out.println("Length of subtring with contigous letter: " + maxLen);
    }

    public void workersGettingAlertsMoreThanTriceInAnHour(
            String[] names, String[] times) {
        //https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/
        int n = names.length;
        List<String> alertees = new ArrayList<>();
        Map<String, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            String worker = names[i];
            String time = times[i];
            map.putIfAbsent(worker, new ArrayList<>());

            //convert time into minutes
            String[] split = time.split(":");
            int HH = Integer.parseInt(split[0]);
            int HHToMin = HH * 60; //1 hr = 60min ==> HH hr = HH * 60min
            int MM = Integer.parseInt(split[1]);
            int totalTimeInMin = HHToMin + MM;

            map.get(worker).add(totalTimeInMin);
        }

        for (String worker : map.keySet()) {
            List<Integer> workerTimes = map.get(worker);
            Collections.sort(workerTimes);

            for (int i = 0; i < workerTimes.size() - 2; i++) {
                //i is the index of curr time of card usage
                //i + 2 is the index of time of card usage at 3 position
                //3rd time and curr time has an overall time diff of
                //less than equals to 1 hr (== 60min), that means this worker
                //has used his card 3times within an hour, so put him in alertees
                if (workerTimes.get(i + 2) - workerTimes.get(i) <= 60) {
                    alertees.add(worker);
                    break;
                }
            }
        }
        //output
        Collections.sort(alertees);
        System.out.println("Workers got alerts for using key-cards 3 or more times in an hour: " + alertees);
    }

    public void pushDominoes(String dominoes) {
        //https://leetcode.com/problems/push-dominoes/
        //https://leetcode.com/problems/push-dominoes/solution/
        int n = dominoes.length();
        char[] arr = dominoes.toCharArray();
        int[] forces = new int[n];

        int force = 0;

        //calculate the rightward(R) force applied from left to right
        //the force will immediately becomes 0 as soon as its encounters
        //leftward(L) force. Acc to physics, force applied initailly will
        //tends to loose its effect as moving ahead until it regains
        //another rightward(R) force OR stopped by leftward(L) force making it 0
        for (int i = 0; i < n; i++) {
            //if seeing a rightward force our force will get regained by n
            if (arr[i] == 'R') {
                force = n;
            } else if (arr[i] == 'L') {
                //if seeing a leftward force but we are moving left to right
                //for calculating rightward force, this leftward force will make 
                //it 0
                force = 0;
            } else {
                //if not gaining any rightward force and not stopped by
                //leftward force means that this domino will see the effect
                //of force applied and also loosed its effect in the movement
                //so that why Math.max(force - 1, 0), force can be -ve
                //that why max with 0
                force = Math.max(force - 1, 0);
            }
            forces[i] = force;
        }

        //calculate the leftward(L) force applied from right to left
        //the force will immediately becomes 0 as soon as its encounters
        //rightward(R) force. Acc to physics, force applied initailly will
        //tends to loose its effect as moving ahead until it regains
        //another leftward(L) force OR stopped by rightward(R) force making it 0
        for (int i = n - 1; i >= 0; i--) {
            //if seeing a leftward force,, our force will get regained by n
            if (arr[i] == 'L') {
                force = n;
            } else if (arr[i] == 'R') {
                //if seeing a rightward force but we are moving right to left
                //for calculating leftward force, this rightward force will make 
                //it 0
                force = 0;
            } else {
                //if not gaining any leftward force and not stopped by
                //rightward force means that this domino will see the effect
                //of force applied and also loosed its effect in the movement
                //so that why Math.max(force - 1, 0), force can be -ve
                //that why max with 0
                force = Math.max(force - 1, 0);
            }

            //earlier we have seen the rightward force, that will be counter
            //balanced by leftward force that why, -= force
            forces[i] -= force;
        }

        StringBuilder sb = new StringBuilder();
        for (int currForce : forces) {
            sb.append(
                    currForce > 0
                            ? 'R'
                            : (currForce < 0 ? 'L' : '.'));
        }
        //output
        System.out.println("Domino effect after applying force: " + sb.toString());
    }

    private boolean longestUncommonSubseqTwo_IsSubseq(String a, String b) {
        int aLen = a.length();
        int bLen = b.length();
        while (aLen > 0 && bLen > 0) {
            int i = a.length() - aLen;
            int j = b.length() - bLen;
            if (a.charAt(i) == b.charAt(j)) {
                aLen--;
            }
            bLen--;
        }
        return aLen == 0;
    }

    public void longestUncommonSubseqTwo(String[] words) {
        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/
        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/discuss/1428729/C%2B%2B-or-JAVA-or-Python3-2-Approaches-oror-Easy-to-Understand
        int n = words.length;
        int maxLen = -1;
        for (int i = 0; i < n; i++) {
            boolean inValid = false;
            for (int j = 0; j < n; j++) {
                if (i == j) {
                    continue;
                }
                if (longestUncommonSubseqTwo_IsSubseq(words[i], words[j])) {
                    inValid = true;
                    break;
                }
            }
            if (!inValid) {
                maxLen = Math.max(maxLen, words[i].length());
            }
        }
        //output
        System.out.println("Longest uncommon subseq: " + maxLen);
    }

    public void numberOfAtoms(String formula) {
        //https://leetcode.com/problems/number-of-atoms/
        Stack<Map<String, Integer>> stack = new Stack<>();
        //appending these brackets to process formula in between
        formula = "(" + formula + ")";
        int n = formula.length();
        StringBuilder result = new StringBuilder();

        int index = 0;

        while (index < n) {

            char ch = formula.charAt(index);

            //Any starting char which is small caps will be an invalid chem
            //only valid are all caps single letter M, K, S.....etc
            //OR first letter caps followed by small letter Ma, Kb, Sc.....etc
            //and in the third else-block we are processing the OR case directly
            if (Character.isAlphabetic(ch) && Character.isLowerCase(ch)) {
                index++;
                continue;
            }

            if (ch == '(') {
                stack.push(new HashMap<>());
            } else if (ch == ')' && stack.size() > 1) {
                //since we have to process two steps in this if-block
                //thats why stack.size() > 1 is req

                //each closing ')' will process the formula in two ways
                //1. (some_chem)some_num
                //the chem composition inside ( ) will be multiplied by some_num
                //2. (some_prev_chem(some_chem)some_num)
                //the step1 solved chem formula will then be merged with its prev
                //chem formula which is additive in natue
                //here we are solving
                //1. (some_chem)some_num
                StringBuilder num = new StringBuilder();
                index += 1;
                while (index < n && Character.isDigit(formula.charAt(index))) {
                    num.append(formula.charAt(index));
                    index++;
                }

                //the above loop will break at a char which is not a digit
                //and also we have index++ below for while() but we still need to
                //consider this curr char for next iteration so taking a step back
                index -= 1;

                int mul = num.length() == 0 ? 1 : Integer.parseInt(num.toString());

                Map<String, Integer> currChemComp = stack.peek();
                for (String chem : currChemComp.keySet()) {
                    currChemComp.put(chem, currChemComp.get(chem) * mul);
                }

                //here we are solving
                //2. (some_prev_chem(some_chem)some_num)
                //we need prev comp so need to pop the curr one from stack
                //though we have the currChemComp above we can use it
                stack.pop();

                Map<String, Integer> prevChemComp = stack.peek();
                for (String chem : currChemComp.keySet()) {
                    //if some chem is also there in prevChemComp, just add both their
                    //atoms else put the chem back to prevChemComp whatever we have
                    //in the currChemComp
                    if (prevChemComp.containsKey(chem)) {
                        prevChemComp.put(chem, prevChemComp.get(chem) + currChemComp.get(chem));
                    } else {
                        prevChemComp.put(chem, currChemComp.get(chem));
                    }
                }
            } else if (Character.isAlphabetic(ch)) {
                //this will fetch the chem formula that would either be
                //1. Single caps letter followed by nums (ex: M, M2, K, K234 etc)
                //2. Single caps letter followed by small letter of the same chem formula
                //followed by nums (ex: Ma, Ma2, Kb, Kb234 etc)
                StringBuilder chem = new StringBuilder(String.valueOf(ch));
                index += 1;
                while (index < n
                        && Character.isAlphabetic(formula.charAt(index))
                        && Character.isLowerCase(formula.charAt(index))) {
                    chem.append(formula.charAt(index));
                    index++;
                }

                //right after a chem formula, we are expecting some num or none.
                //loop and form num string as long as we can have digits
                StringBuilder num = new StringBuilder();
                while (index < n && Character.isDigit(formula.charAt(index))) {
                    num.append(formula.charAt(index));
                    index++;
                }

                //the above loop will break at a char which is not a digit
                //and also we have index++ below for while() but we still need to
                //consider this curr char for next iteration so taking a step back
                index -= 1;

                Map<String, Integer> currChemComp = stack.peek();
                currChemComp.put(chem.toString(),
                        currChemComp.getOrDefault(chem.toString(), 0)
                        + (num.length() == 0 ? 1 : Integer.parseInt(num.toString())));
            }
            index++;
        }
        //output
        Map<String, Integer> processedFormula = stack.peek();
        List<String> chems = new ArrayList<>(processedFormula.keySet());
        Collections.sort(chems);

        for (String chem : chems) {
            result.append(chem)
                    //if a specific chem has an atom == 1, we need not to
                    //print 1 for it just the name of chem only
                    .append(processedFormula.get(chem) == 1
                            ? ""
                            : processedFormula.get(chem));
        }
        System.out.println("Processed chemical formula: " + result.toString());
    }

    public void sentenceSimilarityThree(String sent1, String sent2) {
        //https://leetcode.com/problems/sentence-similarity-iii/

        boolean isSentencesSimilar = true;

        String[] splitSent1 = sent1.split(" ");
        String[] splitSent2 = sent2.split(" ");

        Deque<String> queue1 = new LinkedList<>(Arrays.asList(splitSent1));
        Deque<String> queue2 = new LinkedList<>(Arrays.asList(splitSent2));

        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            //if first words of two sentences are same remove those first words
            if (queue1.peekFirst().equals(queue2.peekFirst())) {
                queue1.removeFirst();
                queue2.removeFirst();
            } else if (queue1.peekLast().equals(queue2.peekLast())) {
                //if last words of two sentences are same remove those last words
                queue1.removeLast();
                queue2.removeLast();
            } else {
                //if no words are same from front and back of the sentences
                //sentences can't be similar
                isSentencesSimilar = false;
                break;
            }
        }
        //output
        System.out.println("Sentence similarity: " + isSentencesSimilar);
    }

    public void sumOfPrefixScoresOfString(String[] words) {
        //https://leetcode.com/problems/sum-of-prefix-scores-of-strings/
        //https://practice.geeksforgeeks.org/problems/geek-and-strings3030/1
        //based on TRIE DATA STRUCTURE
        /*
        Trie data stucture here will be used as prefix tree and will store the count
        of prefixes occured in all the strings in given words[]
        for ex: 
        words[] = ["abc","ab","bc","b"]
        prefixTree: 
        ..............................*
        .............a={2, Map<Char, Node>}, b={2, Map<Char, Node>}
        .............b={2, Map<Char, Node>}, c={1, Map<Char, Node>}
        .............c={1, Map<Char, Node>}
        here a = 2 means prefix a occurs in 2 words i.e, [a]b, [a]bc
        here ab = 2 means prefix ab occurs in 2 words i.e, [ab], [ab]c
        here abc = 1 means prefix abc occurs in 1 words i.e, [abc]
        
        so for given word[i] its score will be no of prefixes of this string occured
        like word[i] =
        "abc" ==> prefix a occurs in 2 string
        "abc" ==> prefix ab occurs in 2 string
        "abc" ==> prefix abc occurs in 1 string
        score[i] = "abc" = 2 + 2 + 1 = 5
        
        like word[i] =
        "ab" ==> prefix a occurs in 2 string
        "ab" ==> prefix ab occurs in 2 string
        score[i] = "ab" = 2 + 2 = 4
        
        like word[i] =
        "bc" ==> prefix b occurs in 2 string
        "bc" ==> prefix bc occurs in 1 string
        score[i] = "bc" = 2 + 1 = 3
        
        like word[i] =
        "b" ==> prefix b occurs in 2 string
        score[i] = "b" = 2 = 2
        
         */
        class TrieNode {

            Map<Character, TrieNode> map;
            int charCount;

            public TrieNode() {
                map = new HashMap<>();
                charCount = 0;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {

                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.charCount++;
                    } else {
                        TrieNode node = new TrieNode();
                        node.charCount = 1;
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            int getCount(String str) {
                TrieNode currNode = ROOT;
                int count = 0;
                for (char ch : str.toCharArray()) {

                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        count += currNode.charCount;
                    }
                }
                return count;
            }

        }

        TrieNode ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        TrieUtil trieUtil = new TrieUtil(ROOT);

        //actual logic
        int n = words.length;
        int[] scores = new int[n];

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        for (int i = 0; i < n; i++) {
            scores[i] = trieUtil.getCount(words[i]);
        }

        //output
        System.out.println("Sum of prefix score of strings: " + Arrays.toString(scores));
    }

    public void trieAddAndSearchWords() {
        //https://leetcode.com/problems/design-add-and-search-words-data-structure/
        //based on TRIE DATA STRUCTURE
        class TrieNode {

            Map<Character, TrieNode> map;
            boolean isEnd;

            public TrieNode() {
                map = new HashMap<>();
                isEnd = false;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
                currNode.isEnd = true;
            }

            boolean searchInTrieDFS(TrieNode root, int index, String str) {
                TrieNode currNode = root;
                for (int i = index; i < str.length(); i++) {
                    char ch = str.charAt(i);
                    if (ch == '.') {
                        //if we '.' then we need to try all the possible combination
                        //of char from the curr trie node and move forward to
                        //i + 1 char and next trie node
                        for (char fill : currNode.map.keySet()) {
                            if (searchInTrieDFS(currNode.map.get(fill), i + 1, str)) {
                                return true;
                            }
                        }
                        return false;
                    } else if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return false;
                    }
                }
                return currNode.isEnd;
            }

            boolean searchInTrie(String str) {
                return searchInTrieDFS(ROOT, 0, str);
            }

        }

        //input 1
        System.out.println("Input 1");
        List<String> commands = new ArrayList<>(Arrays
                .asList("addWord", "addWord", "addWord", "search", "search", "search", "search"));
        List<String> values = new ArrayList<>(Arrays
                .asList("bad", "dad", "mad", "pad", "bad", ".ad", "b.."));

        TrieNode ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (int i = 0; i < commands.size(); i++) {
            if (commands.get(i).equals("addWord")) {
                trieUtil.addToTrie(values.get(i));
            } else if (commands.get(i).equals("search")) {
                System.out.println(values.get(i) + " found: " + trieUtil.searchInTrie(values.get(i)));
            }
        }

        //input 2
        System.out.println("Input 2");
        commands = new ArrayList<>(Arrays
                .asList("addWord", "addWord", "search", "search", "search", "search", "search", "search"));
        values = new ArrayList<>(Arrays
                .asList("a", "a", ".", "a", "aa", "a", ".a", "a."));

        ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        trieUtil = new TrieUtil(ROOT);

        for (int i = 0; i < commands.size(); i++) {
            if (commands.get(i).equals("addWord")) {
                trieUtil.addToTrie(values.get(i));
            } else if (commands.get(i).equals("search")) {
                System.out.println(values.get(i) + " found: " + trieUtil.searchInTrie(values.get(i)));
            }
        }
    }

    public void checkIfSearchWordExistAsPrefixInAnyWordOfSentence(String sentence, String searchWord) {
        //https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
        //https://leetcode.com/problems/counting-words-with-a-given-prefix/
        //based on TRIE DATA STRUCTURE
        class TrieNode {

            Map<Character, TrieNode> map;
            int minIndex;

            public TrieNode() {
                map = new HashMap<>();
                minIndex = Integer.MAX_VALUE;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String str, int index) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        //if two or more words of the sentence have the same prefix
                        //then we need to maintain the minIndex of word upto that
                        //prefix
                        currNode.minIndex = Math.min(currNode.minIndex, index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.minIndex = index;
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            int getIndex(String str) {
                TrieNode currNode = ROOT;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return -1;
                    }
                }
                return currNode.minIndex;
            }
        }

        TrieNode ROOT = new TrieNode();
        ROOT.map.put('*', new TrieNode());

        TrieUtil trieUtil = new TrieUtil(ROOT);

        String[] split = sentence.split(" ");
        int n = split.length;
        for (int i = 0; i < n; i++) {
            trieUtil.addToTrie(split[i], i + 1);
        }
        int wordIndex = trieUtil.getIndex(searchWord);
        //output
        System.out.println("Index of word where searchWord exists as prefix: " + wordIndex);
    }

    public String breakAPallindrome(String pallindrome) {
        //https://leetcode.com/problems/break-a-palindrome/
        int n = pallindrome.length();
        if (n == 1) {
            return "";
        }

        char[] arr = pallindrome.toCharArray();
        int firstNonACharIndex = -1;
        for (int i = 0; i < n; i++) {
            if (arr[i] != 'a') {

                firstNonACharIndex = i;
                char original = arr[i];
                //to make the pallindromic string break and also lexicographically
                //smaller, replace its first non 'a' char index to 'a'
                arr[i] = 'a';
                String check = String.valueOf(arr);
                if (check.equals(new StringBuilder(check).reverse().toString())) {
                    //if after attempting to replace first non 'a' char to 'a'
                    //it still remains pallindrome then try attempting other non
                    //'a' char indexes
                    //reset
                    firstNonACharIndex = -1;
                    arr[i] = original;
                    continue;
                }
                break;
            }
        }

        if (firstNonACharIndex != -1) {
            arr[firstNonACharIndex] = 'a';
        } else {
            arr[n - 1] = 'b';
        }
        return String.valueOf(arr);
    }

    public void countNumberOfHomogenousSubstring(String str) {
        //https://leetcode.com/problems/count-number-of-homogenous-substrings/
        //https://leetcode.com/problems/count-number-of-homogenous-substrings/discuss/1064530/JavaC%2B%2BPython-Straight-Forward
        //https://leetcode.com/problems/consecutive-characters/
        int n = str.length();
        int prevCharAscii = 0;
        int result = 0;
        int count = 0;
        int mod = 1000000007;
        for (int i = 0; i < n; i++) {
            count = str.charAt(i) == prevCharAscii ? count + 1 : 1;
            prevCharAscii = str.charAt(i);
            result = (result + count) % mod;
        }
        //output
        System.out.println("Count number of homogenous substrings: " + result);
    }

    public void numberOfSubstringWithOnlyOnes(String str) {
        //https://leetcode.com/problems/number-of-substrings-with-only-1s/
        //based on countNumberOfHomogenousSubstring()
        int n = str.length();
        int index = 0;
        int result = 0;
        int mod = 1000000007;
        while (index < n) {
            if (str.charAt(index) != '0') {
                int count = 0;
                while (index < n && str.charAt(index) == '1') {
                    count++;
                    result = (result + count) % mod;
                    index++;
                }
            }
            index++;
        }
        //output
        System.out.println("Number of substrings with only 1s: " + result);
    }

    public void increasingDecreasingString(String str) {
        //https://leetcode.com/problems/increasing-decreasing-string/
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : str.toCharArray()) {
            freq.put(ch, freq.getOrDefault(ch, 0) + 1);
        }

        StringBuilder sb = new StringBuilder();
        while (!freq.isEmpty()) {

            //1. Pick the smallest character from s and append it to the result.
            //2. Pick the smallest character from s which is greater than the
            //last appended character to the result and append it.
            //3. Repeat step 2 until you cannot pick more characters.
            for (char ch = 'a'; ch <= 'z'; ch++) {
                if (freq.containsKey(ch)) {
                    sb.append(ch);
                    freq.put(ch, freq.getOrDefault(ch, 0) - 1);
                    if (freq.get(ch) <= 0) {
                        freq.remove(ch);
                    }
                }
            }

            //1. Pick the largest character from s and append it to the result.
            //2. Pick the largest character from s which is smaller than the
            //last appended character to the result and append it.
            //3. Repeat step 5 until you cannot pick more characters.
            for (char ch = 'z'; ch >= 'a'; ch--) {
                if (freq.containsKey(ch)) {
                    sb.append(ch);
                    freq.put(ch, freq.getOrDefault(ch, 0) - 1);
                    if (freq.get(ch) <= 0) {
                        freq.remove(ch);
                    }
                }
            }
        }
        //output
        System.out.println("Arrange the string: " + str + " in increasing decreasing order: " + sb.toString());
    }

    public void optimalStringPartitions(String str) {
        //https://leetcode.com/problems/optimal-partition-of-string/
        /*
        approach is to greedily take the unique chars in curr partition,
        as soon as we hit a char again whose freq[char] we have previously 
        increased that means we know its the breaking point because all the
        char upto this point were unique and now we are seeing duplicate char
        so increase the partitions count and reset the freq[]
        ex: "abacaba", freq[26] = [0,0,0....]
        chr: a freq[a] = 1
        chr: b freq[b] = 1
        chr: a freq[a] > 0, means a break point do a partitions here and reset
        freq[] and continue again
        
         */
        int[] freq = new int[26];
        int partitions = 0;
        for (char ch : str.toCharArray()) {

            if (freq[ch - 'a'] > 0) {
                partitions++;
                Arrays.fill(freq, 0);
            }
            freq[ch - 'a']++;
        }
        //output
        System.out.println("optimal string partitions: " + (partitions + 1));
    }

    public void largestMergeOfTwoStrings(String str1, String str2) {
        //https://leetcode.com/problems/largest-merge-of-two-strings/
        StringBuilder word1 = new StringBuilder(str1);
        StringBuilder word2 = new StringBuilder(str2);
        StringBuilder merge = new StringBuilder();

        while (word1.length() != 0 && word2.length() != 0) {

            if (word1.charAt(0) > word2.charAt(0)) {
                merge.append(word1.charAt(0));
                word1.deleteCharAt(0);
            } else if (word1.charAt(0) < word2.charAt(0)) {
                merge.append(word2.charAt(0));
                word2.deleteCharAt(0);
            } else {
                int diff = word1.compareTo(word2);
                if (diff > 0) {
                    merge.append(word1.charAt(0));
                    word1.deleteCharAt(0);
                } else {
                    merge.append(word2.charAt(0));
                    word2.deleteCharAt(0);
                }
            }
        }

        while (word1.length() != 0) {
            merge.append(word1.charAt(0));
            word1.deleteCharAt(0);
        }

        while (word2.length() != 0) {
            merge.append(word2.charAt(0));
            word2.deleteCharAt(0);
        }
        //output
        System.out.println("Lexicographically largest merge of two string: " + merge);
    }

    public void repeatedDNASequences(String dna) {
        //https://leetcode.com/problems/repeated-dna-sequences/
        List<String> repeatedSeq = new ArrayList<>();
        int n = dna.length();
        Map<String, Integer> seqFreq = new HashMap<>();
        //required seq should be of length 10
        for (int i = 0; i <= n - 10; i++) {
            String seq = dna.substring(i, i + 10);
            seqFreq.put(seq, seqFreq.getOrDefault(seq, 0) + 1);
        }

        //any dna seq that is occuring more than once
        for (String seq : seqFreq.keySet()) {
            if (seqFreq.get(seq) > 1) {
                repeatedSeq.add(seq);
            }
        }
        //output
        System.out.println("Repeated DNA sequneces: " + repeatedSeq);
    }

    public void numberOfLaserBeamsInBank(String[] bank) {
        //https://leetcode.com/problems/number-of-laser-beams-in-a-bank/
        int bankRow = 0;
        int laserBeams = 0;
        Map<Integer, Integer> oneFreqInRows = new HashMap<>();
        for (String currRow : bank) {
            boolean hasAtleastSingleOneInCurrRow = false;
            for (char device : currRow.toCharArray()) {
                if (device == '1') {
                    //if there is atleast one security device in curr row, mark
                    //hasAtleastSingleOneInCurrRow as true
                    hasAtleastSingleOneInCurrRow = true;
                    //count the freq of 1(security device) in curr row
                    oneFreqInRows.put(bankRow, oneFreqInRows.getOrDefault(bankRow, 0) + 1);
                }
            }

            if (hasAtleastSingleOneInCurrRow) {
                //if there exists ones in curr row we can calculate the number of
                //beams forming between the curr Row and curr row - 1
                if (bankRow > 0) {
                    //number of laser beams forming for a curr row is
                    //freq of securiy device in (row - 1) * freq of securiy device in row
                    laserBeams += oneFreqInRows.get(bankRow - 1) * oneFreqInRows.get(bankRow);
                }

                //we will not increament the bankRow for a row where there
                //is no security device, so if there is atleast 1 security device
                //in curr row then only we will enter this if-block and we will increament
                bankRow++;
            }
        }
        //output
        System.out.println("Number of laser beams: " + laserBeams);
    }

    public boolean isPossibleToConstructKPallindromeString(String str, int k) {
        //https://leetcode.com/problems/construct-k-palindrome-strings/
        /*
        hints:
        1. If the s.length < k we cannot construct k strings from s and answer
        is false.
        2. If the number of characters that have odd counts is > k then the
        minimum number of palindrome strings we can construct is > k and answer
        is false.
        3. Otherwise you can construct exactly k palindrome strings and answer
        is true (why ?).
        
        ex: str = "leetcode", k = 3 result is false
        freq = {e = 3, l = 1, t = 1, c = 1, o = 1, d = 1}
        charWithOddFreq = [l, t, c, o, d, e] = 6 > k ==> 6 > 3
        
        false how? try to form k pallindrome strings using all its char
        1. "ele" | char-left: [e, t, c, o, d]
        now the char-left can not form any combined pallindrome string but 
        each char separately like,
        2. "e"
        3. "t"
        4. "c"
        5. "o"
        6. "d"
        
        6 pallindrome strings > k so false
        
        ex: str = "aafaaeaagaahaak", k = 3, result is false
        freq = {a = 10, f = 1, e = 1, g = 1, h = 1, k = 1}
        charWithOddFreq = [f, e, g, h, k] = 6 > k ==> 5 > 3
        
        false how? try to form k pallindrome strings using all its char
        1. "aafaa" | char-left: [e, a, a, g, a, a, h, a, a, k]
        2. "aagaa" | char-left: [e, h, a, a, k]
        3. "aka" | char-left: [e, h]
        now the char-left can not form any combined pallindrome string but 
        each char separately like,
        4. "e"
        5. "h"
        
        we form k == 3 pallindrome strings but we couldn't use all the chars of
        given string
        
         */
        int n = str.length();
        if (n < k) {
            return false;
        }
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : str.toCharArray()) {
            freq.put(ch, freq.getOrDefault(ch, 0) + 1);
        }

        int charWithOddFreq = 0;
        for (char ch : freq.keySet()) {
            if (freq.get(ch) % 2 == 1) {
                charWithOddFreq++;
            }
        }
        return charWithOddFreq <= k;
    }

    public void orderlyQueue(String str, int k) {
        //https://leetcode.com/problems/orderly-queue/
        //https://leetcode.com/problems/orderly-queue/solution/
        //explanation: https://www.youtube.com/watch?v=qr-_tEll_e4&t=3s
        int n = str.length();
        char[] charArr = str.toCharArray();
        String result = "";
        if (k > 1) {
            Arrays.sort(charArr);
            result = String.valueOf(charArr);
        } else {
            //if k == 1
            result = str;
            for (int i = 0; i < n; i++) {
                //rotate the string by appending first[0, i - 1] prefix string
                //to end of remaining[i, n] string
                String rotateStr = str.substring(i) + str.substring(0, i);
                if (rotateStr.compareTo(result) < 0) {
                    result = rotateStr;
                }
            }
        }
        //output
        System.out.println("Orderly queue and lexicographically smaller string: " + result);
    }

    public void makeTheStringGreat(String str) {
        //https://leetcode.com/problems/make-the-string-great/
        //here also using the string builder as stack, this saves the time for
        //generating the string back from the chars from the stack
        StringBuilder sb = new StringBuilder();
        for (char ch : str.toCharArray()) {
            //case like: eE where peek == e, chr == E, then remove both
            if (!sb.isEmpty()
                    && (Character.isUpperCase(ch)
                    && Character.toLowerCase(ch) == sb.charAt(sb.length() - 1))) {
                sb.deleteCharAt(sb.length() - 1);
            } else if (!sb.isEmpty()
                    && (Character.isLowerCase(ch)
                    && Character.toUpperCase(ch) == sb.charAt(sb.length() - 1))) {
                //case like: Ee where peek == E, chr == e, then remove both
                sb.deleteCharAt(sb.length() - 1);
            } else {
                sb.append(ch);
            }
        }

        //output
        System.out.println("Great string: " + sb.toString());
    }

    public void sumOfBeautyOfAllSubstring(String str) {
        //https://leetcode.com/problems/sum-of-beauty-of-all-substrings/
        //use of hashmap is giving TLE, I don't know!!! :(
        int n = str.length();
        int sum = 0;
        for (int i = 0; i < n; i++) {

            int[] charFreq = new int[26];

            for (int j = i; j < n; j++) {

                char chJ = str.charAt(j);
                charFreq[chJ - 'a']++;

                //calculate the min & max freq of chars for the substring[i, j]
                int maxFreq = 0;
                int minFreq = Integer.MAX_VALUE;

                for (int freq : charFreq) {
                    //curr freq == 0 means that char was never there in the substring
                    //but if we choose this freq then this 0 will be minFreq which is
                    //wrong if we consider it, thats why choose those chars that exist
                    //in curr substring[i, j] means char whose freq != 0 
                    if (freq != 0) {
                        minFreq = Math.min(minFreq, freq);
                    }
                    maxFreq = Math.max(maxFreq, freq);
                }
                //calculate beauty of substring forming between (i to j) th index
                sum += (maxFreq - minFreq);
            }
        }
        //output
        System.out.println("Sum of beauty of all substrings: " + sum);
    }

    public void shortEncodingOfWords(String[] words) {
        //https://leetcode.com/problems/short-encoding-of-words/
        /*
        words[] = [time, me, bell]
        trie ROOT..........[e],[l]
        ................../.......\
        ................[m].......[l]
        ................/...........\
        ..............[i]...........[e]
        ............../...............\
        ............[t]...............[b]
        
        here time & me are grouped as their suffix matches: [ti[me]] encoded
        [ti[me]]'#'
        [bell]'#'
        
        [ti[me]]'#'[bell]'#' == time#bell# == 10 length of encoding
        
         */
        class TrieNode {

            Map<Character, TrieNode> map;

            public TrieNode() {
                map = new HashMap<>();
            }
        }

        class TrieUtil {

            TrieNode ROOT;
            int addHASHChar = 1;
            int wordEncodingLength = 0;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                //running loop from end of the word, that way we will add word
                //in suffix form, all those words having same suffix will be
                //grouped in single string
                for (int i = word.length() - 1; i >= 0; i--) {
                    char ch = word.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            //level/ depth traversal of N-ary tree 
            //with below method, we are doing the level traversal.
            //means we go till end of word in trie and add level( == length of word)
            //and add '#' char ( == length of 1)
            void countEncodingLengthHelper(TrieNode root, int level) {

                if (root.map.isEmpty()) {
                    wordEncodingLength += (level + addHASHChar);
                    return;
                }

                for (char ch : root.map.keySet()) {
                    countEncodingLengthHelper(root.map.get(ch), level + 1);
                }
            }

            void countEncodingLength() {
                countEncodingLengthHelper(ROOT, 0);
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        trieUtil.countEncodingLength();
        //output
        System.out.println("Short encoding of word: " + trieUtil.wordEncodingLength);
    }

    public void makingFileNamesUnique(String[] names) {
        //https://leetcode.com/problems/making-file-names-unique/
        int n = names.length;
        List<String> uniqueNames = new ArrayList<>();
        Map<String, Integer> namesFreq = new HashMap<>();
        for (int i = 0; i < n; i++) {

            String name = names[i];

            if (namesFreq.containsKey(name)) {

                //get the count of the name that is already contained in map
                int similarNameCount = namesFreq.get(name);
                Set<String> alreadyUniqueFileInMap = namesFreq.keySet();
                //a default new name for the curr name that is already there
                //now we need to check this new name is already existing in map
                //or not, if this name exist then we have to try out another 
                //name combination
                String newName = name + "(" + similarNameCount + ")";
                while (alreadyUniqueFileInMap.contains(newName)) {
                    similarNameCount++;
                    newName = name + "(" + similarNameCount + ")";
                }

                //above loop will break when we have a newName unique in the map
                //and also this newName is a version of curr name
                uniqueNames.add(newName);
                //since we have used the count of 'name' that already existed
                //so for next time we see same 'name' it should have a updated count
                namesFreq.put(name, namesFreq.getOrDefault(name, 0) + 1);
                //our newName that is just formed is unique in alreadyUniqueFileInMap
                //that should also be added in the map
                namesFreq.put(newName, namesFreq.getOrDefault(newName, 0) + 1);
            } else {
                uniqueNames.add(name);
                namesFreq.put(name, namesFreq.getOrDefault(name, 0) + 1);
            }
        }
        //output
        System.out.println("Unique file names: " + uniqueNames);
    }

    public void maxOccurenceSubstringFollowingCondition(
            String str, int maxUniqueLetters, int minSize, int maxSize) {
        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/
        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/discuss/2841277/Python-Hash-Solution
        //based on SLIDING WINDOW
        /*
        return the maximum number of ocurrences of any substring under the following rules:
        1. The number of unique characters in the substring must be less than or equal to maxUniqueLetters.
        2. The substring size must be between minSize and maxSize inclusive.
         */
        int n = str.length();
        int start = 0;
        int end = 0;
        Map<String, Integer> substrFollowingCond = new HashMap<>();
        while (end < n) {

            //rule 2.
            int windowSize = (end - start + 1);
            while (windowSize >= minSize && windowSize <= maxSize) {

                //a substring in the range of minSize & maxSize
                String substr = str.substring(start, start + windowSize);

                //get the unique chars from this substring in the form of set
                Set<Character> uniqueCharInSubstr = substr.chars().mapToObj(c -> (char) c)
                        .collect(Collectors.toSet());

                //rule 1.
                //if the unique char is set is less than equal to maxUniqueLetter
                //we can consider this substring
                if (uniqueCharInSubstr.size() <= maxUniqueLetters) {
                    substrFollowingCond.put(substr, substrFollowingCond.getOrDefault(substr, 0) + 1);
                }
                start++;
                //update the windowSize
                windowSize = end - start + 1;
            }
            end++;
        }
        int maxOccuerenceSubstr = substrFollowingCond.isEmpty()
                ? 0
                : //getting max occr of substring from all those subtrings that
                //followed the condition
                substrFollowingCond.values()
                        .stream()
                        .sorted(Collections.reverseOrder())
                        .collect(Collectors.toList()).get(0);
        //output
        System.out.println("Max occuerence of subtring following cond: " + maxOccuerenceSubstr);
    }

    public void prefixAndSuffixSearch(String[] words, String[][] prefixAndSuffix) {
        //https://leetcode.com/problems/prefix-and-suffix-search/
        class TrieNode {

            Map<Character, TrieNode> map;
            Set<Integer> indexes;

            public TrieNode() {
                map = new HashMap<>();
                indexes = new HashSet<>();
            }
        }

        class TrieUtil {

            TrieNode ROOTPref;
            TrieNode ROOTSuff;
            Map<String, Integer> cache;

            public TrieUtil(TrieNode ROOTPref, TrieNode ROOTSuff) {
                this.ROOTPref = ROOTPref;
                this.ROOTSuff = ROOTSuff;
                cache = new HashMap<>();
            }

            void addToTrie(String word, int index) {

                TrieNode currNode = ROOTPref;
                for (char ch : word.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.indexes.add(index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.indexes.add(index);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }

                currNode = ROOTSuff;
                //running loop from end of the word, that way we will add word
                //in suffix form
                for (int i = word.length() - 1; i >= 0; i--) {
                    char ch = word.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                        currNode.indexes.add(index);
                    } else {
                        TrieNode node = new TrieNode();
                        node.indexes.add(index);
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
            }

            Set<Integer> searchPref(String str) {
                TrieNode currNode = ROOTPref;
                for (char ch : str.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return Collections.emptySet();
                    }
                }
                return currNode.indexes;
            }

            Set<Integer> searchSuff(String str) {
                TrieNode currNode = ROOTSuff;
                for (int i = str.length() - 1; i >= 0; i--) {
                    char ch = str.charAt(i);
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        return Collections.emptySet();
                    }
                }
                return currNode.indexes;
            }

            int prefSuffixMatchIndex(String pref, String suff) {

                String key = pref + "," + suff;
                if (cache.containsKey(key)) {
                    return cache.get(key);
                }

                Set<Integer> prefMatchIndex = searchPref(pref);
                Set<Integer> suffMatchIndex = searchSuff(suff);

                if (prefMatchIndex.isEmpty() || suffMatchIndex.isEmpty()) {
                    cache.put(key, -1);
                    return -1;
                }

                //common indexes are those index of words where the searched
                //pref and suff matches
                //(ex: "me", "moonchime", prefAndSuff["m", "e"])
                //here m and e matches with both "[m][e]" & "[m]oonchim[e]"
                //but if there is a tie with multiple words, choose the max index
                List<Integer> common = new ArrayList<>();
                for (int index : prefMatchIndex) {
                    if (suffMatchIndex.contains(index)) {
                        common.add(index);
                    }
                }

                if (common.isEmpty()) {
                    cache.put(key, -1);
                    return -1;
                }

                //for choosing the max index, if there are multiple matches of
                //the search
                Collections.sort(common);
                cache.put(key, common.get(common.size() - 1));
                return common.get(common.size() - 1);
            }

        }

        TrieNode ROOTPref = new TrieNode();
        TrieNode ROOTSuff = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOTPref, ROOTSuff);

        for (int i = 0; i < words.length; i++) {
            trieUtil.addToTrie(words[i], i);
        }

        System.out.println("Prefix And Suffix aearch: ");
        for (String[] prefSuff : prefixAndSuffix) {
            String pref = prefSuff[0];
            String suff = prefSuff[1];
            System.out.println(pref + " and " + suff + " search: " + trieUtil.prefSuffixMatchIndex(pref, suff));
        }
    }

    public void magicDictionary(String[] words, String[] searches) {
        //https://leetcode.com/problems/implement-magic-dictionary/
        Map<Integer, List<String>> wordsByLengths = new HashMap<>();

        //create a map where lengths as key and all the words having same lengths
        //will be grouped together
        for (String word : words) {
            wordsByLengths.putIfAbsent(word.length(), new ArrayList<>());
            wordsByLengths.get(word.length()).add(word);
        }

        for (String word : searches) {

            int len = word.length();
            //if curr search word's length doesn't exist in the map, then this
            //word can't be searched
            if (!wordsByLengths.containsKey(len)) {
                System.out.println("Search: " + word + " false");
                continue;
            }

            //if the curr search word's length exists in the map, we will move
            //through all the words of this len and check which candidate word
            //is valid (valid : search word can be changed with one char and it
            //matches with candidate word)
            for (String candidate : wordsByLengths.get(len)) {

                int changeOneChar = 0;

                for (int i = 0; i < len; i++) {
                    //count the char that doesn't match in these two words
                    if (word.charAt(i) != candidate.charAt(i)) {
                        changeOneChar++;
                    }
                    //if changeOneChar unmatched chars is greater than 1 that means
                    //this search word can't be searched because we can change
                    //only 1 char to match with candidate word
                    if (changeOneChar > 1) {
                        System.out.println("Search: " + word + " false");
                        break;
                    }
                }
                //if there is one char change required this word can be searched
                if (changeOneChar == 1) {
                    System.out.println("Search: " + word + " true");
                    continue;
                }
                //this point is reached here when changeOneChar == 0
                //like if search word and candidate word are same, "hello" == "hello"
                System.out.println("Search: " + word + " false");
            }
        }
    }

    private boolean peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
            Set<String> child, Set<String> parent) {
        if (child.size() > parent.size()) {
            return false;
        }
        return parent.containsAll(child);
    }

    public void peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(List<List<String>> favouriteCompanies) {
        //https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
        int n = favouriteCompanies.size();
        Map<Integer, Set<String>> companiesMap = new HashMap<>();
        Set<Integer> persons = new HashSet<>();
        for (int i = 0; i < n; i++) {
            companiesMap.put(i, new HashSet<>());
            companiesMap.get(i).addAll(favouriteCompanies.get(i));
            persons.add(i);
        }

        for (int person1 = 1; person1 < n; person1++) {
            if (!persons.contains(person1)) {
                continue;
            }
            for (int person2 = 0; person2 < person1; person2++) {
                if (!persons.contains(person2)) {
                    continue;
                }
                if (peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
                        companiesMap.get(person1), companiesMap.get(person2))) {
                    persons.remove(person1);
                }

                if (peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList_IsSubset(
                        companiesMap.get(person2), companiesMap.get(person1))) {
                    persons.remove(person2);
                }
            }
        }
        System.out.println("Persons whose favourite companies not subset of another list: "
                + persons.stream().sorted().collect(Collectors.toList()));
    }

    public void printWordsVertically(String text) {
        //https://leetcode.com/problems/print-words-vertically/description/
        /*
        text = "TO BE OR NOT TO BE"
        split[] = [TO, BE, OR, NOT, TO, BE]
        now each word will occupy a col, here col == 6
        "TBONTB"
        "OEROOE"
        "   T"
        now row is actually the word with max length(), here NOT with length == 3
        
        verticalWordsGrid[6][3] = [
        ['T', 'B', 'O', 'N', 'T', 'B'],
        ['O', 'E', 'R', 'O', 'O', 'E'],
        [' ', ' ', ' ', 'T', ' ', ' ']]
        
        for output we need to trim spaces from end if any, that why
        last row = [' ', ' ', ' ', 'T', ' ', ' ']
        is trimmed to [' ', ' ', ' ', 'T']
        
        AND each row be converted to string
        "TBONTB"
        "OEROOE"
        "   T"
         */
        List<String> verticalWords = new ArrayList<>();
        String[] split = text.split(" ");
        //ROW = max length of a word in text that can be expanded vertically
        //will become the number of rows
        int ROW = 0;
        for (String word : split) {
            ROW = Math.max(ROW, word.length());
        }
        //col = number of words in split[] because each word will occupy
        //vertically one col
        int COL = split.length;

        char[][] verticalWordsGrid = new char[ROW][COL];

        int currWordCol = 0;
        for (String word : split) {
            //each char from curr word will be put in each row but in specific wordInCol
            //since the below for loop is running for max length of words( == ROW)
            //this curr word may be less than the ROW so add spaces for such rows
            for (int row = 0; row < ROW; row++) {
                verticalWordsGrid[row][currWordCol] = row >= word.length()
                        ? ' ' : word.charAt(row);
            }
            //now the next word will be put in the next col
            currWordCol++;
        }

        for (char[] charsInRow : verticalWordsGrid) {
            //works as left trim, trims spaces from end
            int skipSpacesFromEnd = COL - 1;
            while (skipSpacesFromEnd >= 0 && charsInRow[skipSpacesFromEnd] == ' ') {
                skipSpacesFromEnd--;
            }
            verticalWords.add(String.valueOf(charsInRow, 0, skipSpacesFromEnd + 1));
        }
        //output
        System.out.println("vertical words: " + verticalWords);
    }

    public void bullsAndCows(String secret, String guess) {
        //https://leetcode.com/problems/bulls-and-cows/description/
        /*
        1. The number of "bulls", which are digits in the guess that are in the
        correct position.
        2. The number of "cows", which are digits in the guess that are in your
        secret number but are located in the wrong position. Specifically, the
        non-bull digits in the guess that could be rearranged such that they
        become bulls.
        Constraints given:
        1. secret.length == guess.length
        2. secret and guess consist of digits only.
         */
        int m = secret.length();
        int n = guess.length();

        char[] secretArr = secret.toCharArray();
        char[] guessArr = guess.toCharArray();

        Map<Character, Integer> secretMap = new HashMap<>();
        Map<Character, Integer> guessMap = new HashMap<>();

        int cows = 0;
        int bulls = 0;

        for (int i = 0; i < m; i++) {
            //bulls are those i-th guess values that are exactly same as
            //secret values and also at same i-th location
            if (secretArr[i] == guessArr[i]) {
                bulls++;
                //after processing the bull chars mark them with '.'
                secretArr[i] = guessArr[i] = '.';
            }

            //count the freq of all the other char in secret that are not bull chars
            if (secretArr[i] != '.') {
                secretMap.put(secretArr[i], secretMap.getOrDefault(secretArr[i], 0) + 1);
            }

            //count the freq of all the other char in guess that are not bull chars
            if (guessArr[i] != '.') {
                guessMap.put(guessArr[i], guessMap.getOrDefault(guessArr[i], 0) + 1);
            }
        }

        //here check which other chars of our guess matches with secret but are not
        //at the exact locations as that of secret chars, take the min of them
        //because the min of both are those chars that we can rearrange to match
        //with secret string
        for (char guessChar : guessMap.keySet()) {
            if (secretMap.containsKey(guessChar)) {
                cows += (Math.min(secretMap.get(guessChar), guessMap.get(guessChar)));
            }
        }
        //output
        String score = bulls + "A" + cows + "B";
        System.out.println("Bulls and cows score: " + score);
    }

    private boolean expressiveWords_IsWordStrechable(String strechy, String word) {
        int m = strechy.length();
        int n = word.length();

        int strechyIndex = 0;
        int wordIndex = 0;

        while (strechyIndex < m && wordIndex < n) {
            if (strechy.charAt(strechyIndex) != word.charAt(wordIndex)) {
                return false;
            }

            int originalChar = word.charAt(wordIndex);

            int sameCharCountStrechy = 0;
            while (strechyIndex < m && strechy.charAt(strechyIndex) == originalChar) {
                sameCharCountStrechy++;
                strechyIndex++;
            }

            int sameCharCountWord = 0;
            while (wordIndex < n && word.charAt(wordIndex) == originalChar) {
                sameCharCountWord++;
                wordIndex++;
            }

            //in the original word, the min char of 'originalChar' is req as
            //sameCharCountWord but in given strechy string we get the less
            //count sameCharCountStrechy for same 'originalChar' then this
            //strechy string can't be fromed from curr word as it lacks atleast
            //sameCharCountWord amount of char in strechy string 
            if (sameCharCountStrechy < sameCharCountWord) {
                return false;
            }

            //if the strechy string have the sameCharCountStrechy for the curr
            //'originalChar' which is more than what is req from curr word i.e,
            //sameCharCountWord then it is fine but this sameCharCountStrechy
            //should be equal or more than 3(as per question), in case it is less
            //than that return false;
            if (sameCharCountStrechy > sameCharCountWord && sameCharCountStrechy < 3) {
                return false;
            }
        }
        //checking if both the strings are processed till their last chars,
        //if any of the string is ended before the other string, the curr word
        //can't be streched to given strechy string
        return strechyIndex == m && wordIndex == n;
    }

    public void expressiveWords(String strechy, String[] words) {
        //https://leetcode.com/problems/expressive-words/description/
        int expressiveWords = 0;
        for (String word : words) {
            if (expressiveWords_IsWordStrechable(strechy, word)) {
                expressiveWords++;
            }
        }
        //output
        System.out.println("Words that can be expressed as strechy: " + expressiveWords);
    }

    public void customSortString(String order, String str) {
        //https://leetcode.com/problems/custom-sort-string/description/
        //somewhat similar to sortLinkedListInRelativeOrderOfArr()
        char[] strArr = str.toCharArray();
        //create the freq map for given string str
        Map<Character, Integer> freq = new HashMap<>();
        for (char ch : strArr) {
            freq.put(ch, freq.getOrDefault(ch, 0) + 1);
        }

        //first put those chars from string str that relatively in order with
        //string order in the same freq as they are in string str
        int index = 0;
        for (char chOrder : order.toCharArray()) {
            int chOrderFreq = 0;
            if (freq.containsKey(chOrder)) {
                chOrderFreq = freq.get(chOrder);
                freq.remove(chOrder);
            }
            while (chOrderFreq > 0) {
                strArr[index++] = chOrder;
                chOrderFreq--;
            }
        }
        //after putting all the chars that were in string order, put all those
        //chars that are left in string str from freq map
        for (char ch : freq.keySet()) {
            int chFreq = freq.get(ch);
            while (chFreq > 0) {
                strArr[index++] = ch;
                chFreq--;
            }
        }
        //output
        System.out.println("Custom sort string relative to given order: " + String.valueOf(strArr));
    }

    public boolean buddyStrings(String str, String goal) {
        //https://leetcode.com/problems/buddy-strings/description/
        int m = str.length();
        int n = goal.length();
        if (m != n) {
            return false;
        }

        if (str.equals(goal)) {
            int[] freq = new int[26];
            for (char ch : str.toCharArray()) {
                freq[ch - 'a']++;
            }

            //case for s = "aa" & goal = "aa"
            for (int count : freq) {
                if (count > 1) {
                    return true;
                }
            }

            //case for s = "ab" & goal = "ab"
            return false;
        }

        int firstSwap = -1;
        int secondSwap = -1;
        for (int i = 0; i < m; i++) {
            if (goal.charAt(i) != str.charAt(i)) {
                if (firstSwap == -1) {
                    firstSwap = i;
                } else if (secondSwap == -1) {
                    secondSwap = i;
                } else {
                    return false;
                }
            }
        }

        return secondSwap != -1
                && str.charAt(firstSwap) == goal.charAt(secondSwap)
                && str.charAt(secondSwap) == goal.charAt(firstSwap);
    }

    public void maxNumberOfBalloonsFromText(String text) {
        //https://leetcode.com/problems/maximum-number-of-balloons/description/
        //freq of chars in word balloon
        int b = 1, a = 1, l = 2, o = 2, n = 1;

        int[] freq = new int[26];
        for (char ch : text.toCharArray()) {
            freq[ch - 'a']++;
        }

        int minBalloonsInText = Integer.MAX_VALUE;
        //find the min picks of char in 'balloon', each time the char picks get minimized
        //that much of balloon word can be formed out of chars present in text
        minBalloonsInText = Math.min(minBalloonsInText, freq['b' - 'a'] / b);
        minBalloonsInText = Math.min(minBalloonsInText, freq['a' - 'a'] / a);
        minBalloonsInText = Math.min(minBalloonsInText, freq['l' - 'a'] / l);
        minBalloonsInText = Math.min(minBalloonsInText, freq['o' - 'a'] / o);
        minBalloonsInText = Math.min(minBalloonsInText, freq['n' - 'a'] / n);
        //output
        System.out.println("Min balloon word formed from text: " + minBalloonsInText);
    }

    public void findLongestString(String[] words) {
        //https://practice.geeksforgeeks.org/problems/8d157f11af5416087251513cfc38ffc4d23be308/1
        //based on TRIE
        class TrieNode {

            Map<Character, TrieNode> map;
            boolean isEnd;

            public TrieNode() {
                map = new HashMap<>();
                isEnd = false;
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currRoot = ROOT;
                for (char ch : word.toCharArray()) {
                    if (currRoot.map.containsKey(ch)) {
                        currRoot = currRoot.map.get(ch);
                    } else {
                        TrieNode nextRoot = new TrieNode();
                        currRoot.map.put(ch, nextRoot);
                        currRoot = nextRoot;
                    }
                }
                //marks the end of a word
                currRoot.isEnd = true;
            }

            boolean isLongestWord(String word) {
                TrieNode currRoot = ROOT;
                for (char ch : word.toCharArray()) {
                    if (currRoot.map.containsKey(ch)) {
                        currRoot = currRoot.map.get(ch);
                        //if curr prefix string is not a word in itself in the
                        //given words[] then we must return false because each
                        //prefix part of the curr word should be a word existing
                        //in the words[]
                        if (!currRoot.isEnd) {
                            return false;
                        }
                    } else {
                        return false;
                    }
                }
                //if the complete word is actaully a word from the given array
                return currRoot.isEnd;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        //sort the words[] by longest length first if two words have same length
        //then sort them in their lexicographical order
        Arrays.sort(words, (a, b) -> a.length() == b.length()
                ? a.compareTo(b)
                : b.length() - a.length());

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        String longestWord = "";
        for (String word : words) {
            if (trieUtil.isLongestWord(word)) {
                longestWord = word;
                break;
            }
        }
        //output
        System.out.println("Longest word : " + longestWord);
    }

    public void applyDiscountToPrices(String sentence, int discount) {
        //https://leetcode.com/problems/apply-discount-to-prices/description/
        sentence = sentence.trim();
        String[] words = sentence.split(" ");
        StringBuilder reform = new StringBuilder();

        for (String word : words) {
            //if a word is not empty string(== "") or it start with '$' sign
            //then get the amount value of this '$amount'
            if (!word.isEmpty() && word.charAt(0) == '$') {

                long amount = 0;
                int n = word.length();
                //index = 1 because 0-th char at curr word is '$'
                int index = 1;
                //assuming that all the $amount words are valid, but they can be
                //invalid as well then we dont given discount to them but keep
                //them as it is in reform string
                boolean isValid = true;

                while (index < n) {
                    //if the curr index-char in word is not a digit, it becomes
                    //a invalid word ex: "$", "$1e5", "$10$" 
                    if (!Character.isDigit(word.charAt(index))) {
                        isValid = false;
                        break;
                    }

                    amount = (amount * 10l) + (word.charAt(index) - '0');
                    index++;
                }

                //if word is invalid or amount is 0 then keep them as it is
                if (!isValid || amount == 0) {
                    reform.append(word).append(" ");
                    continue;
                }

                double discountReduction = (double) amount * ((double) discount / 100.0);
                double discountedAmount = (double) amount - discountReduction;
                //format("%.2f") here will round off our discountedAmount to upto
                //2 decimal places
                String discountedAmountString = String.format("%.2f", discountedAmount);
                reform.append('$').append(discountedAmountString).append(" ");

            } else {
                reform.append(word).append(" ");
            }
        }
        //output
        System.out.println("Apply discount to valid prices in sentence: " + reform.toString().trim());
    }

    public void removeAllOccurencesOfSubstring(String main, String pattern) {
        //....................T: O((M - N) * (M + N))
        //time complexity for KMP pattern matching is O(M + N),
        //M = length of main string, N = length of pattern string
        //in worst case if main string is built only from pattern
        //ex: main = "abcabcabcabc", pattern = "abc", let lengths be M & N respec.
        //first time KMP = O(M + N)
        //we will loop untill there is no pattern in main string OR main string is empty(== "")
        //here in this example our main string will be empty
        //since pattern is there in main string,
        //our main string will be reduced by N chars ==> "abcabcabc" ==> M - N
        //second time KMP = O((M - N) + N)
        //our main string will be reduced again by N chars ==> "abcabc" ==> M - N - N ==> M - 2N
        //third time KMP = O((M - 2N) + N)
        //our main string will be reduced again by N chars ==> "abc" ==> M - N - N - N ==> M - 3N
        //fourth time KMP = O((M - 3N) + N)
        //our main string will be reduced again by N chars ==> "" ==> M - N - N - N - N ==> M - 4N
        //fourth time KMP = O((M - 4N) + N)
        //https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
        //based on KMP pattern matching also
        //KMP pattern matching algo helper
        class Helper {

            int[] createLPS(String pattern) {
                int n = pattern.length();
                int[] lps = new int[n];
                int prefIndex = 0;
                int suffIndex = 1;

                while (suffIndex < n) {
                    if (pattern.charAt(prefIndex) == pattern.charAt(suffIndex)) {
                        prefIndex++;
                        lps[suffIndex] = prefIndex;
                        suffIndex++;
                    } else if (prefIndex == 0) {
                        lps[suffIndex] = prefIndex;
                        suffIndex++;
                    } else {
                        prefIndex = lps[prefIndex - 1];
                    }
                }
                return lps;
            }

            int matchPattern(String main, String pattern) {
                int m = main.length();
                int n = pattern.length();

                int[] lps = createLPS(pattern);

                int mainIndex = 0;
                int patternIndex = 0;

                while (mainIndex < m) {
                    if (main.charAt(mainIndex) == pattern.charAt(patternIndex)) {
                        mainIndex++;
                        patternIndex++;
                    } else if (patternIndex == 0) {
                        mainIndex++;
                    } else {
                        patternIndex = lps[patternIndex - 1];
                    }

                    if (patternIndex == n) {
                        return mainIndex - n;
                    }
                }
                //incase pattern is not found in main string
                return -1;
            }

        }

        //actual:
        System.out.println("actual main string: " + main);

        int n = pattern.length();
        Helper helper = new Helper();

        //first pattern matchedIndex
        int matchedIndex = helper.matchPattern(main, pattern);

        //with this loop we find the pattern in main string
        //remove the found pattern to make a new main string
        //do this untill there are no pattern left in the main string
        while (matchedIndex >= 0) {
            //entering this while() loop when matchedIndex is some valid index
            //(i.e, >= 0, meaning starting index of the pattern is found in main string)
            //now with this matchedIndex, we must remove this pattern and create a
            //new main string
            //new main string = main[0, matcheIndex - 1] + main[matchedIndex + n]
            //meaning all the chars in main string from 0-th char to char before
            //the pattern(== matchedIdex) and all the chars after the last
            //index of pattern(== matchedIndex + n)
            //string substring() takes (0, n - 1) so (0, matchedIndex) == (0, matchedIndex - 1)
            //ex: main = "daabcbaabcbc", pattern = "abc"
            //now first pattern will be found at index == matchedIndex == 2
            //main = da{abc}baabcbc
            //new main string will be = da + baabcbc = "dabaabcbc"
            main = main.substring(0, matchedIndex) + "" + main.substring(matchedIndex + n);
            //now find the pattern again with the new main string
            matchedIndex = helper.matchPattern(main, pattern);
        }
        //output
        System.out.println("Main string after removing all occurences of " + pattern + " is: " + main);
    }

    public String decodeStringAtIndex(String str, int k) {
        //https://leetcode.com/problems/decoded-string-at-index/description/
        //https://leetcode.com/problems/decoded-string-at-index/solutions/156733/decoded-string-at-index/
        int n = str.length();
        long size = 0;
        //first calculate the size of the string whenever the repeatition occur 
        //by number in string as per the quest
        for (char ch : str.toCharArray()) {

            if (Character.isDigit(ch)) {
                size *= (ch - '0');
            } else {
                size++;
            }
        }

        //secondly, do a backward check
        for (int i = n - 1; i >= 0; i--) {
            char ch = str.charAt(i);
            k %= size;

            if (k == 0 && Character.isLetter(ch)) {
                return String.valueOf(ch);
            }

            if (Character.isDigit(ch)) {
                size /= (ch - '0');
            } else {
                size--;
            }
        }
        return "";
    }

    public void namingACompany(String[] ideas) {
        //https://leetcode.com/problems/naming-a-company/description/
        //https://leetcode.com/problems/naming-a-company/solutions/3081799/naming-a-company/
        long totalIdeas = 0;
        Map<Character, Set<String>> initials = new HashMap<>();
        for (String idea : ideas) {
            char firstChar = idea.charAt(0);
            initials.putIfAbsent(firstChar, new HashSet<>());
            //substring(1) means saving the suffix part where first char is not
            //included
            initials.get(firstChar).add(idea.substring(1));
        }

        for (char i = 'a'; i <= 'y'; i++) {
            for (char j = (char) (i + 1); j <= 'z'; j++) {

                //if both first chars don't exist at same time
                if (!initials.containsKey(i) || !initials.containsKey(j)) {
                    continue;
                }

                long commonSubstr = 0;
                //count all the common substring parts from string set having
                //firstChar as i in string set having firstChar as j
                for (String substr : initials.get(i)) {
                    if (initials.get(j).contains(substr)) {
                        commonSubstr++;
                    }
                }

                totalIdeas += (2
                        * (initials.get(i).size() - commonSubstr)
                        * (initials.get(j).size() - commonSubstr));
            }
        }
        //output
        System.out.println("Total names for company: " + totalIdeas);
    }

    private int greatestCommonDivisorOfStrings_GCD(int x, int y) {
        if (y == 0) {
            return x;
        }
        return greatestCommonDivisorOfStrings_GCD(y, x % y);
    }

    public String greatestCommonDivisorOfStrings(String str1, String str2) {
        //https://leetcode.com/problems/greatest-common-divisor-of-strings/description/
        if (!(str1 + str2).equals(str2 + str1)) {
            return "";
        }
        int gcdlength = greatestCommonDivisorOfStrings_GCD(str1.length(), str2.length());
        return str1.substring(0, gcdlength);
    }

    public void numberOfGoodWaysToSplitString(String str) {
        //https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/
        /*
        str = "aacaba"
        left = {}, right = {}
        
        right = {a = 4, b = 1, c = 1}
        
        for(i = 0 to i < n - 1)
        --- i = 0, chr = a
        --- left = {a = 1}, right = {a = 3, b = 1, c = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) FALSE
        
        --- i = 1, chr = a
        --- left = {a = 2}, right = {a = 2, b = 1, c = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) FALSE
        
        --- i = 2, chr = c
        --- left = {a = 2, c = 1}, right = {a = 2, b = 1, c = 0}
        --- right[c] <= 0 == right = {a = 2, b = 1}
        --- if(left.size == right.size) == (2 == 2) TRUE
        ----- ways++ == 1
        
        --- i = 3, chr = a
        --- left = {a = 3, c = 1}, right = {a = 1, b = 1}
        --- right[a] <= 0 FALSE
        --- if(left.size == right.size) == (2 == 2) TRUE
        ----- ways++ == 2
        
        --- i = 4, chr = b
        --- left = {a = 3, c = 1, b = 1}, right = {a = 1, b = 0}
        --- right[a] <= 0 == right = {a = 1}
        --- if(left.size == right.size) FALSE
        
         */
        int n = str.length();
        //left will hold the char freq for left part of string
        Map<Character, Integer> left = new HashMap<>();
        //right will hold the char freq for right part of string
        Map<Character, Integer> right = new HashMap<>();

        int ways = 0;

        //initailly the right will have the char freq for complete string, this
        //right freq map will help in a ways where each time a char chr is moved
        //from right to left, we don't have to run a separate loop from [i, n] to
        //calculate distinct char in right part every time, this optimize here
        for (char ch : str.toCharArray()) {
            right.put(ch, right.getOrDefault(ch, 0) + 1);
        }

        //here in this loop, we will try to split the string in left and right
        //parts. At each index i left will incr the count of char in left part
        //string (i.e str[0, i]) and right will decr the count of char in right
        //and move it to left. Now after moving a char from right to left, if its
        //freq reduced to 0 (means not char 'chr' exist in right part anymore) then
        //remove that char from right
        //running loop from i = 0 to i < n - 1 means it will run for [0, n - 2]
        //the last (n - 1)-th char will still be considered for right string part
        //as both left & right string part should be non-empty
        for (int i = 0; i < n - 1; i++) {
            char ch = str.charAt(i);
            //update the left by adding a char chr to it
            left.put(ch, left.getOrDefault(ch, 0) + 1);
            //the char chr added in left must have taken from right part
            right.put(ch, right.getOrDefault(ch, 0) - 1);
            //now after the char chr moved to left part, if no occuerence of chr
            //exist anymore in right part(== (right.get(chr) <= 0)) then remove it
            if (right.get(ch) <= 0) {
                right.remove(ch);
            }

            //after simulating two string parts left & right respect check if we
            //got same number of distinct chars in both parts the incr ways
            if (left.size() == right.size()) {
                ways++;
            }
        }
        //output
        System.out.println("Number of good ways to split string: " + ways);
    }

    public int repeatedStringMatch(String mainStr, String checkStr) {
        //https://leetcode.com/problems/repeated-string-match/description/
        int mainStrLen = mainStr.length();
        int checkStrLen = checkStr.length();
        int repeat = checkStrLen / mainStrLen;
        //since we are taking our first main string in repeatition
        //so its count should start from 1
        StringBuilder strRepeat = new StringBuilder(mainStr);
        int repeatCount = 1;

        for (int i = 0; i < repeat + 2; i++) {
            if (strRepeat.toString().contains(checkStr)) {
                return repeatCount;
            }

            strRepeat.append(mainStr);
            repeatCount++;
        }
        return -1;
    }

    public void rewardTopKStudents(
            String[] positiveFeedbacks, String[] negativeFeedbacks,
            String[] reports, int[] studentId, int k) {
        //based on HEAP
        //https://leetcode.com/problems/reward-top-k-students/description/

        List<Integer> topKStudents = new ArrayList<>();

        int n = studentId.length;

        Set<String> positiveSet = new HashSet<>(Arrays.asList(positiveFeedbacks));
        Set<String> negativeSet = new HashSet<>(Arrays.asList(negativeFeedbacks));

        Map<Integer, Integer> idAndScores = new HashMap<>();

        for (int i = 0; i < n; i++) {
            //id of curr i-th student
            int id = studentId[i];
            //report prepared by curr student with id at i-th index
            String report = reports[i];
            //if the curr student with id was prevously processes then there must
            //be some prev scores else default is 0
            int currScore = idAndScores.getOrDefault(id, 0);

            //for each word in reoprt prepared by curr student,
            //if word in positive feedback gain +3 score
            //if word in negative feedback loose -1 score 
            for (String word : report.split(" ")) {
                if (positiveSet.contains(word)) {
                    currScore += 3;
                }
                if (negativeSet.contains(word)) {
                    currScore -= 3;
                }
            }

            //put the curr total score achieved by student with id
            idAndScores.put(id, idAndScores.getOrDefault(id, 0) + currScore);
        }

        //find the top k student which students with higher scores
        //but if scores are same then pick the student with lower id
        //below priority queue will keep data having higher scores or lower id
        //in end and keep lower scores or higher id at top to keep only K students
        PriorityQueue<Integer> minHeapIdAndScores = new PriorityQueue<>(
                (a, b) -> idAndScores.get(a) == idAndScores.get(b)
                ? b - a : idAndScores.get(a) - idAndScores.get(b));

        for (int id : idAndScores.keySet()) {
            minHeapIdAndScores.add(id);
            if (minHeapIdAndScores.size() > k) {
                minHeapIdAndScores.poll();
            }
        }

        while (!minHeapIdAndScores.isEmpty()) {
            topKStudents.add(0, minHeapIdAndScores.poll());
        }

        //output
        System.out.println("Reward top k student: " + topKStudents);
    }

    public void alphabetBoardPath(String target) {
        //https://leetcode.com/problems/alphabet-board-path/description/
        //https://leetcode.com/problems/alphabet-board-path/solutions/3120261/easy-faster-efficient-java-soln/
        /*
        alphabet board:
        [a  b  c  d  e]
        [f  g  h  i  j]
        [k  l  m  n  o]
        [p  q  r  s  t]
        [u  v  w  row  col]
        [z            ]
         */
        //initial position
        int x = 0;
        int y = 0;
        StringBuilder path = new StringBuilder();
        for (char ch : target.toCharArray()) {
            //dest row & col location for curr char so that we can move initial row & col
            //to dest row & col
            //to keep the curr char chr in the alphabet board / & % by 5
            //divide / bound row into 6 rows
            //mod % bound col into 5 cols
            int destX = (ch - 'a') / 5;
            int destY = (ch - 'a') % 5;

            while (destX > x) {
                x++;
                path.append("D");
            }

            while (destX < x) {
                x--;
                path.append("U");
            }

            while (destY > y) {
                y++;
                path.append("R");
            }

            while (destY < y) {
                y--;
                path.append("L");
            }

            //"!" means picking the target char chr
            path.append("!");
        }
        //output
        System.out.println("Alphabet board path : " + path);
    }

    public int takeKOfEachCharFromLeftRight(String str, int k) {
        //https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/
        //based on SLIDING WINDOW
        /*
        str = "aabaaaacaabc", k = 2
        acc to quest, we need to pick atleast k chars of each a, b, c from left
        & right
        
        intuition:
        First we will calculate the freq of each chars of the string
        freq[] = int[3]
        
        we will remove few chars and check that after removing these chars we
        must have remaining chars equal or more than k
        i.e == freq[0] < k || freq[1] < k || freq[2] < k
        if we have freq of each chars(a, b, c) atleast k then inner while loop
        will not work
        
        after that we will calculate the chars we are actually considering
        min = Math.min(min, start + n - 1 - end);
        
        freq[] = {a = 8, b = 2, c = 2}
        
        end = 0, start = 0
        str = "aabaaaacaabc"
        
        #1
        end = 0, start = 0
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 7, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k) 
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 11
        end++ ==> 1
        means: remove[a] remaining[abaaaacaabc] is a valid pick
        
        #2
        end = 1, start = 0
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k) 
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 10
        end++ ==> 2
        means: remove[aa] remaining[baaaacaabc] is a valid pick
        
        #3
        end = 2, start = 0
        chEnd = str[end] = b
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 1, c = 2}
        //now freq[b] < k == true, while() will work and try fetch chars from start
        //untill freq[b] > k
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        ===> 1.
        chStart = start[start] = a;
        freq[a]++ == freq[a]++ == {a = 7, b = 1, c = 2}
        start++ ==> 1
        ===> 2.
        chStart = start[start] = a;
        freq[a]++ == freq[a]++ == {a = 8, b = 1, c = 2}
        start++ ==> 2
        ===> 3.
        chStart = start[start] = b;
        freq[a]++ == freq[a]++ == {a = 8, b = 2, c = 2}
        start++ ==> 3
        //now each freq[] > k, while() END 
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 2 ==> 12
        end++ ==> 3
        means: remove[] remaining[aabaaaacaabc] is a valid pick
        
        #4
        end = 3, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 7, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 3 ==> 11
        end++ ==> 4
        means: remaining[aab] remove[a] remaining[aaacaabc] is a valid pick
        
        #5
        end = 4, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 6, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 4 ==> 10
        end++ ==> 5
        means: remaining[aab] remove[aa] remaining[aacaabc] is a valid pick
        
        #6
        end = 5, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 5, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 5 ==> 9
        end++ ==> 6
        means: remaining[aab] remove[aaa] remaining[acaabc] is a valid pick
        
        #7
        end = 6, start = 3
        chEnd = str[end] = a
        freq[chEnd]-- == freq[a]-- == {a = 4, b = 2, c = 2}
        //we have freq of chars > k, so below while() won't work
        while (freq[0] < k || freq[1] < k || freq[2] < k)
        min = Math.min(min, start + n - 1 - end);
        ==> start + n - 1 + end ==> 3 + 12 - 1 - 6 ==> 8 ***ANSWER***
        end++ ==> 7
        means: remaining[aab] remove[aaaa] remaining[caabc] is a valid pick
        
        
        .....REST ITERATIONS.....
        
         */
        int n = str.length();
        //freq[0] = 'a', freq[1] = 'b', freq[2] = 'c'
        int[] freq = new int[3];

        //count the freq of all the a, b, c char in str
        for (char ch : str.toCharArray()) {
            freq[ch - 'a']++;
        }

        //if freq of any of char is less than k then it is not possible
        if (freq[0] < k || freq[1] < k || freq[2] < k) {
            return -1;
        }

        int end = 0;
        int start = 0;
        int min = n;

        while (end < n) {

            //try to remove chars
            char chEnd = str.charAt(end);
            freq[chEnd - 'a']--;

            //after removing chars from our freq[], if freq of all the remainig
            //chars are enough(i.e, atleast k means >= k) then we need not to
            //run this while()
            //only if any freq is less than k then we need to fetch chars from
            //start ptr untill freq of chars again > k
            while (freq[0] < k || freq[1] < k || freq[2] < k) {
                char chStart = str.charAt(start);
                freq[chStart - 'a']++;
                start++;
            }

            //here we will calculate the size of string left after removing chars
            //the remaining chars will basically tell you min size of string which
            //contains a, b, c atleast k times
            min = Math.min(min, start + n - 1 - end);
            end++;
        }
        return min;
    }

    public boolean swapAdjacentLRString(String start, String end) {
        //https://leetcode.com/problems/swap-adjacent-in-lr-string/description/
        //Explanation: https://leetcode.com/problems/swap-adjacent-in-lr-string/solutions/873004/easy-to-understand-explanation-with-picture/
        if (start.length() != end.length()) {
            return false;
        }

        String strStart = start.replace("X", "");
        String strEnd = end.replace("X", "");

        if (!strStart.equals(strEnd)) {
            return false;
        }

        List<Integer> startL = new ArrayList<>();
        List<Integer> startR = new ArrayList<>();
        List<Integer> endL = new ArrayList<>();
        List<Integer> endR = new ArrayList<>();

        for (int i = 0; i < start.length(); i++) {
            if (start.charAt(i) == 'L') {
                startL.add(i);
            } else if (start.charAt(i) == 'R') {
                startR.add(i);
            }
        }

        for (int i = 0; i < end.length(); i++) {
            if (end.charAt(i) == 'L') {
                endL.add(i);
            } else if (end.charAt(i) == 'R') {
                endR.add(i);
            }
        }

        for (int i = 0; i < startL.size(); i++) {
            if (startL.get(i) < endL.get(i)) {
                return false;
            }
        }

        for (int i = 0; i < startR.size(); i++) {
            if (startR.get(i) > endR.get(i)) {
                return false;
            }
        }

        return true;
    }

    public void removeOutermostParenthesis(String str) {
        //https://leetcode.com/problems/remove-outermost-parentheses/description/
        int n = str.length();
        int balanced = 0;
        int outerMostStart = 0;
        StringBuilder sb = new StringBuilder();
        for (int outerMostEnd = 0; outerMostEnd < n; outerMostEnd++) {
            char bracket = str.charAt(outerMostEnd);
            if (bracket == '(') {
                balanced++;
            } else {
                //if bracket is closing, remove the count of opening brackets
                //until it again balanced(== 0)
                balanced--;
                //when the outermost opening bracket is balanced by outermost
                //closing bracket then this balanced will be 0. Now to remove
                //these outermost bracket we will pick the substring in between
                //these outermost start & end that is
                //(== substring(outerMostStart + 1, outerMostEnd))
                //ex: str = "(()())" str.substring(start + 1, end) == "()()" 
                if (balanced == 0) {
                    sb.append(str.substring(outerMostStart + 1, outerMostEnd));
                    //update outermost start to start from next opening bracket
                    //where the balanced counter will again calculate
                    outerMostStart = outerMostEnd + 1;
                }
            }
        }
        //output
        System.out.println("Remove Outermost parenthesis : " + sb);
    }

    public void minAdditionToMakeValidString(String word) {
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/description/
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/solutions/3421831/java-c-python-easy-and-concise-with-explanation/
        int n = word.length();
        int count = 0;
        char prevChar = 'z';
        for (char ch : word.toCharArray()) {
            //with this cond: chr <= prevChar we are basically checking the valid
            //"abc", "ab", "ac", "bc" sequences
            //if the chr <= prevChar is true means we need to fulfil the "abc"
            //pattern that char
            //ex: "cba" now 'c' needs its own a,b before c so thats 2 char
            //'b' needs its own a,c before and after this 'b' so thats 2 char
            //'a' needs its own b,c after this 'a' so thats 2 char
            //so total becomes 6 chars required.
            //now each of this 'c', 'b', 'a' is breaking the "abc" pattern so
            //count will be 3 once loop ends
            //now with count 3 we are basically saying that to balance
            //this "cba" we need 3 "abc" pattern appened at end (for that we have
            //count * 3) that maked this string as "cbaabcabcabc"
            //but also we already have 3 chars as "cba" which will be common in
            //this so we also adjust this as (count * 3) - n = 3 * 3 - 3 = 6 chars
            count += ch <= prevChar ? 1 : 0;
            prevChar = ch;
        }
        //output
        int required = count * 3 - n;
        System.out.println("Min addition to make valid string : " + required);
    }

    public boolean stringsDifferByOneChar(String[] words) {
        //.....................T: O(N * M), N length of words[], M length of each word
        //.....................T: O(M * N), for each index [0 to M - 1], it will remove
        //a char and eventually will try to remove all M chars one by one from a single
        //word, hence in this process we will make M diff words and there are N words in
        //words[] so in worst case it might generate M * N words in seen set
        //https://leetcode.com/problems/strings-differ-by-one-character/
        //https://leetcode.ca/2020-03-02-1554-Strings-Differ-by-One-Character/
        Set<String> seen = new HashSet<>();
        for (String word : words) {
            //for every curr word, we will create possible words with 1 char removed
            //for every char index i, each removed char is marked as '*'
            for (int i = 0; i < word.length(); i++) {
                String wordWithoutOneChar = word.substring(0, i) + "*" + word.substring(i + 1);
                //if the word formed by removing 1 char at every i-th index is already
                //seen previously that means we have 2 strings to satisfy our req
                if (seen.contains(wordWithoutOneChar)) {
                    return true;
                }
                seen.add(wordWithoutOneChar);
            }
        }
        return false;
    }

    public void stringMirror(String str) {
        //https://practice.geeksforgeeks.org/problems/d385b9d635b7b10eef6bf365b84922aaeec9eb98/1
        int n = str.length();
        StringBuilder prev = new StringBuilder();
        prev.append(str.charAt(0));

        for (int i = 1; i < n; i++) {
            if (prev.charAt(i - 1) > str.charAt(i)) {
                prev.append(str.charAt(i));
            } else if (i > 1 && prev.charAt(i - 1) == str.charAt(i)) {
                prev.append(str.charAt(i));
            } else {
                break;
            }
        }

        String currStr = prev.toString();
        prev.reverse();
        String lexicographicallySmallerMirrorString = currStr + prev.toString();
        //output
        System.out.println("Lexicographically smaller mirror string : " + lexicographicallySmallerMirrorString);
    }

    public void maxNestedDepthOfParenthesis(String expression) {
        //https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/
        /*
        intuition here is, we need to only consider brackets ('(' or ')') in the
        given string expression
        
        opening brackets increases its depth when there are some nested brackets
        are inside it so if we see an opening bracket depth++
        and 
        closing brackets decreses its depth when there are some nested brackets
        are inside it so if we see an closing bracket depth--
        
        but in between we need to calculate the depth it went inside because of
        the nested structure of parenthesis
        
        ex: "((()))", its maxDepth is 3
        depth == 1 ==> (........)
        depth == 2 ==>   (....)
        depth == 3 ==>    (..)
        
        another ex: "()()()", its maxDepth is 1
        depth == 1 ==> ()...()..()
        how? initially depth == 0,
        first opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0
        
        second opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0
        
        third opening bracket depth++ ==> 1
        maxDepth ==> 1
        its closing bracket depth-- ==> 0
        
        hence on nesting depth increases(just like a tree)
        
         */
        int n = expression.length();
        int depth = 0;
        int maxDepth = 0;

        for (char ch : expression.toCharArray()) {
            if (ch == '(' || ch == ')') {

                boolean open = (ch == '(');

                if (open) {
                    depth++;
                }

                maxDepth = Math.max(maxDepth, depth);

                if (!open) {
                    depth--;
                }
            }
        }
        //output
        System.out.println("Max nested depth of parenthesis : " + maxDepth);
    }

    public void maxNestedDepthOfTwoValidParenthesisString(String seq) {
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/
        //based on maxNestedDepthOfParenthesis()
        //question statement is very bad to understand
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/solutions/358419/confused-by-this-problem-i-was-too-here-is-how-it-became-crystal-clear/
        int n = seq.length();
        int[] result = new int[n];
        int depth = 0;
        for (int i = 0; i < n; i++) {
            char bracket = seq.charAt(i);
            boolean open = (bracket == '(');

            if (open) {
                depth++;
            }

            result[i] = depth % 2;

            if (!open) {
                depth--;
            }
        }
        //output
        System.out.println("Max nested depth of two valid parenthesis strings : " + Arrays.toString(result));
    }

    public void replaceWords(List<String> dictionary, String sentence) {
        //https://leetcode.com/problems/replace-words/description/
        //based on TRIE
        class TrieNode {

            Map<Character, TrieNode> map;
            String word;
            boolean isEndOfWord;

            public TrieNode() {
                map = new HashMap<>();
                word = "";
                isEndOfWord = false;
            }
        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {

                        currRoot = currRoot.map.get(ch);

                    } else {

                        TrieNode node = new TrieNode();
                        currRoot.map.put(ch, node);
                        currRoot = node;
                    }
                }

                currRoot.word = word;
                currRoot.isEndOfWord = true;
            }

            String getSmallerPrefixOrSame(String word) {

                TrieNode currRoot = ROOT;

                for (char ch : word.toCharArray()) {

                    if (currRoot.map.containsKey(ch)) {

                        currRoot = currRoot.map.get(ch);
                        //if given 'word' has a prefix that is also marked as
                        //a word in trie return that word as soon we meet this
                        if (currRoot.isEndOfWord) {
                            return currRoot.word;
                        }

                    } else {
                        //prefix mismatch, hence return same given 'word' as it is
                        return word;
                    }
                }

                //case when the given 'word' is a full prefix match and also marked
                //as a word then return the prefix word(==> currRoot.word) but if
                //still this prefix is not marked as a word in trie then return
                //given 'word' 
                return currRoot.isEndOfWord ? currRoot.word : word;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        for (String word : dictionary) {
            trieUtil.addToTrie(word);
        }

        StringBuilder replacedSentence = new StringBuilder();

        for (String word : sentence.split(" ")) {
            replacedSentence.append(trieUtil.getSmallerPrefixOrSame(word));
            replacedSentence.append(" ");
        }
        //output
        System.out.println("Replace word (Trie) : " + replacedSentence.toString().trim());
    }

    public void sentenceScreenFitting(String[] words, int rows, int cols) {
        //https://leetcode.com/problems/sentence-screen-fitting/
        //explanation: https://www.youtube.com/watch?v=1ChX4Cpz0bU
        String sentence = String.join(" ", words) + " ";
        int len = sentence.length();
        int cursor = 0;

        for (int row = 0; row < rows; row++) {

            cursor += cols;

            if (sentence.charAt(cursor % len) == ' ') {
                cursor++;
            } else {
                while (cursor >= 0 && sentence.charAt(cursor % len) != ' ') {
                    cursor--;
                }
                //for 1 space to be added in the end
                cursor++;
            }
        }
        //output
        int sentenceFitted = cursor / len;
        System.out.println("Sentence screen fitting : " + sentenceFitted);
    }

    public void addingSpacesToString(String str, int[] spaces) {
        //https://leetcode.com/problems/adding-spaces-to-a-string/description/
        /*
        this question seems to be easy but requires time optimization as the
        constraint given is large
        
        constraints: 
        1 <= s.length <= 3 * 10^5
        s consists only of lowercase and uppercase English letters.
        1 <= spaces.length <= 3 * 10^5
        0 <= spaces[i] <= s.length - 1
        All the values of spaces are strictly increasing.
         */

        int startIndex = 0;
        StringBuilder updatedString = new StringBuilder();

        for (int spaceIndex : spaces) {
            String substr = str.substring(startIndex, startIndex + (spaceIndex - startIndex));
            updatedString.append(substr).append(" ");
            startIndex = spaceIndex;
        }

        //adding the last substring segemnt till str.length
        updatedString.append(str.substring(startIndex));

        //output
        System.out.println("Adding spaces to string : " + updatedString);
    }

    public void wordsWithinTwoEditsOfDictionary(String[] queries, String[] dictionary) {
        //https://leetcode.com/problems/words-within-two-edits-of-dictionary/description/
        //based on BRUTE FORCE approach as the given constraints are small
        List<String> validQueryWords = new ArrayList<>();
        int MAX_EDIT_LIMIT = 2;

        for (String query : queries) {
            for (String word : dictionary) {

                //given: both words in queries[] and dictionary[] have same length 'n'
                int n = word.length();
                //initial edits made on 'query' word to make it equal to 'word'
                //from dictionary[]
                //max edits can be made is just MAX_EDIT_LIMIT = 2
                //0 == means both 'query' & 'word' were already equal
                //1 == means made 1 edit in 'query' and it will be equal to 'word'
                //2 == means made 2 edit in 'query' and it will be equal to 'word'
                int edits = 0;

                for (int i = 0; i < n; i++) {

                    //if a char is mismatching in 'query' with that of 'word' means
                    //we must make an edit here, hence edits++
                    if (query.charAt(i) != word.charAt(i)) {
                        edits++;
                    }

                    //each time we see a char mismatch in 'query' we made some edit
                    //in above if(), now if those edits are more than our max
                    //limit(==> MAX_EDIT_LIMIT) break here, as this 'query' word
                    //is not a valid word
                    if (edits > MAX_EDIT_LIMIT) {
                        break;
                    }
                }

                //edits made above are under max limit(==> MAX_EDIT_LIMIT) hence
                //this 'query' word is a valid so add it in our valid list and
                //break here as we know 'query' is valid and there is no need
                //to check any other 'word' further from dictionary[]
                if (edits <= MAX_EDIT_LIMIT) {
                    validQueryWords.add(query);
                    break;
                }
            }
        }
        //output
        System.out.println("Words within two edits of dictionary : " + validQueryWords);
    }

    public void findDivisibiltyArrayOfString(String word, int m) {
        //https://leetcode.com/problems/find-the-divisibility-array-of-a-string/description/
        //based on REMAINDERS
        /*
        word = "998244353", m = 3
        
        numberRemainder = 0
        
        ##1
        i = 0, digit = 9
        ==> numberRemaider = 0 * 10 + (9) ==> 9
        ==> numberRemainder % m = 9 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1
        
        ##2
        i = 1, digit = 9
        ==> numberRemaider = 0 * 10 + (9) ==> 9
        ==> numberRemainder % m = 9 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1
        
        ##3
        i = 2, digit = 8
        ==> numberRemaider = 0 * 10 + (8) ==> 8
        ==> numberRemainder % m = 8 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0
        
        ##4
        i = 3, digit = 2
        ==> numberRemaider = 2 * 10 + (2) ==> 22
        ==> numberRemainder % m = 22 % 3 = 1
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0
        
        ##5
        i = 4, digit = 4
        ==> numberRemaider = 1 * 10 + (4) ==> 14
        ==> numberRemainder % m = 14 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0
        
        ##6
        i = 5, digit = 4
        ==> numberRemaider = 2 * 10 + (4) ==> 24
        ==> numberRemainder % m = 24 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1
        
        ##7
        i = 6, digit = 3
        ==> numberRemaider = 0 * 10 + (3) ==> 3
        ==> numberRemainder % m = 3 % 3 = 0
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 1
        
        ##8
        i = 7, digit = 5
        ==> numberRemaider = 0 * 10 + (5) ==> 5
        ==> numberRemainder % m = 5 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0
        
        ##9
        i = 8, digit = 3
        ==> numberRemaider = 2 * 10 + (3) ==> 23
        ==> numberRemainder % m = 23 % 3 = 2
        ==> divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0 ==> 0
        
         */
        int n = word.length();
        //if any number so formed from word[0 to i] % m == 0 then put 1 else 0
        int[] divisibiltyArray = new int[n];

        long numberRemainder = 0;

        for (int i = 0; i < n; i++) {

            char digit = word.charAt(i);
            //we only care about the previous number's remainder with given m
            numberRemainder = (numberRemainder * 10 + (digit - '0'));
            numberRemainder %= m;

            //if number formed within word[0 to i] and divisible by given m
            //then put 1 else 0
            divisibiltyArray[i] = numberRemainder == 0 ? 1 : 0;
        }
        //output
        System.out.print("Divisibilty array of string : " + Arrays.toString(divisibiltyArray));
    }

    public Node<Integer> reverseLinkedList_Iterative(Node<Integer> node) {
        System.out.println("Reverse linked list iterative");
        //actual
        new LinkedListUtil<>(node).print();

        Node<Integer> curr = node;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        while (curr != null) {

            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        //output
        new LinkedListUtil<>(prev).print();

        //to use by other methods when req 
        return prev;
    }

    Node<Integer> reverseLinkedList_Recursive_NewHead;

    private Node<Integer> reverseLinkedList_Recursive_Helper(Node<Integer> node) {

        if (node.getNext() == null) {
            reverseLinkedList_Recursive_NewHead = node;
            return node;
        }

        Node<Integer> revNode = reverseLinkedList_Recursive_Helper(node.getNext());
        revNode.setNext(node);
        node.setNext(null);

        return node;
    }

    public void reverseLinkedList_Recursive(Node<Integer> node) {
        System.out.println("Reverse linked list recursive");
        //actual
        LinkedListUtil<Integer> ll = new LinkedListUtil<>(node);
        ll.print();

        reverseLinkedList_Recursive_Helper(node);

        //output
        LinkedListUtil<Integer> output = new LinkedListUtil<>(reverseLinkedList_Recursive_NewHead);
        output.print();

    }

    private Stack<Integer> sumOfNumbersAsLinkedList_ByStack_ToStack(Node<Integer> node) {

        Stack<Integer> s = new Stack<>();
        Node<Integer> temp = node;
        while (temp != null) {

            s.push(temp.getData());
            temp = temp.getNext();

        }

        return s;

    }

    public void sumOfNumbersAsLinkedList_ByStack(Node<Integer> n1, Node<Integer> n2) {

        //..................................T: O(N1 + N2) where N1 = n1.length, N2 = n2.length
        //..................................S: O(N1 + N2) because of 2 stacks used
        Stack<Integer> nS1 = sumOfNumbersAsLinkedList_ByStack_ToStack(n1);
        Stack<Integer> nS2 = sumOfNumbersAsLinkedList_ByStack_ToStack(n2);

        int carry = 0;
        LinkedListUtil<Integer> ll = new LinkedListUtil<>();
        while (!nS1.isEmpty() || !nS2.isEmpty()) {

            int sum = carry;

            if (!nS1.isEmpty()) {
                sum += nS1.pop();
            }

            if (!nS2.isEmpty()) {
                sum += nS2.pop();
            }

            carry = sum / 10;
            ll.addAtHead(sum % 10);

        }

        if (carry > 0) {
            ll.addAtHead(carry);
        }

        //output
        ll.print();

    }

    public void sumOfNumbersAsLinkedList_ByReversingList(Node<Integer> n1, Node<Integer> n2) {

        //OPTIMISED
        //..................................T: O(N1 + N2) where N1 = n1.length, N2 = n2.length
        //..................................S: O(1)
        Node<Integer> n1Rev = reverseLinkedList_Iterative(n1);
        Node<Integer> n2Rev = reverseLinkedList_Iterative(n2);

        Node<Integer> head = null;

        int carry = 0;
        while (n1Rev != null || n2Rev != null) {

            int sum = carry;

            if (n1Rev != null) {
                sum += n1Rev.getData();
                n1Rev = n1Rev.getNext();
            }

            if (n2Rev != null) {
                sum += n2Rev.getData();
                n2Rev = n2Rev.getNext();
            }

            //adding start ptr as head
            Node<Integer> start = new Node<>(sum % 10);
            start.setNext(head);
            head = start;
            carry = sum / 10;
        }

        if (carry > 0) {
            Node<Integer> start = new Node<>(carry);
            start.setNext(head);
            head = start;
        }

        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void removeDuplicateFromSortedLinkedList(Node<Integer> head) {

        //actual
        new LinkedListUtil<>(head).print();

        Node<Integer> curr = head;
        Node<Integer> temp = head.getNext();

        while (temp != null) {
            if (curr.getData() != temp.getData()) {
                curr.setNext(temp);
                curr = temp;
            }
            temp = temp.getNext();
        }

        curr.setNext(temp);

        //output
        new LinkedListUtil<>(head).print();
    }

    public void mergeKSortedLinkedList(Node<Integer>[] nodes) {

        //............................T: O(N*K*LogK)
        //............................S: O(K)
        //https://www.geeksforgeeks.org/merge-k-sorted-linked-lists-set-2-using-min-heap/
        //HEAP based method
        PriorityQueue<Node<Integer>> minHeap = new PriorityQueue<>(
                (o1, o2) -> o1.getData().compareTo(o2.getData())
        );

        //at this point we have added K node heads in minHeap
        //so the minheap size after this loop will K
        for (Node<Integer> node : nodes) {
            if (node != null) {
                minHeap.add(node);
            }
        }

        //head to point arbitary infinite value to start with
        Node<Integer> head = new Node<>(Integer.MIN_VALUE);
        //saving the actual head's ref
        Node<Integer> copyHead = head;
        while (!minHeap.isEmpty()) {

            //we poll out one node from heap
            Node<Integer> curr = minHeap.poll();
            //and add in one node 
            //if its next node is not null
            //so the size of the min heap remains atmost K
            if (curr.getNext() != null) {
                minHeap.add(curr.getNext());
            }
            //isolate the current node by saying curr.next=NULL,
            //also curr.next node value is already preserved in
            //minHeap(above if block), if not null already
            curr.setNext(null);
            copyHead.setNext(curr);
            copyHead = copyHead.getNext();
        }

        //actual merged list starts with next of arbitary head pointer
        new LinkedListUtil<>(head.getNext()).print();
    }

    public void kThNodeFromEndOfLinkedList_1(Node node, int K) {
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //1. Approach
        //using additional space (Stack)
        //................O(N)+O(K)
        //time O(N) creating stack of N nodes from linked list + O(K) reaching out to Kth node
        //in the stack.
        //.......................space complexity O(N)
        Stack<Node> stack = new Stack<>();
        Node temp = node;
        //T: O(N)
        //S: O{N}
        while (temp != null) {
            stack.push(temp);
            temp = temp.getNext();
        }

        //T: O(K)
        while (!stack.isEmpty()) {

            K--;
            Object element = stack.pop().getData();
            if (K == 0) {
                System.out.println("Kth node from end is: " + element);
            }
        }
    }

    public void kThNodeFromEndOfLinkedList_2(Node node, int K) {
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //2. Approach
        //using Len - K + 1 formula
        //calculate the full length of the linked list frst 
        //then move the head pointer upto (Len - K + 1) limit which
        // is Kth node from the end
        //.................T: O(N) + O(Len - K + 1)
        //1. calculating Len O(N)
        //2. moving to Len - k + 1 pointer is O(Len - K + 1)
        int len = 0;
        Node temp = node;
        while (temp != null) {
            temp = temp.getNext();
            len++;
        }

        //Kth node from end = len - K + 1
        temp = node;
        //i=1 as we consider the first node from 1 onwards
        for (int i = 1; i < (len - K + 1); i++) {
            temp = temp.getNext();
        }

        //output
        System.out.println("Kth node from end is: " + temp.getData());

    }

    public void kThNodeFromEndOfLinkedList_3(Node head, int K) {
        //https://leetcode.com/problems/remove-nth-node-from-end-of-list/
        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
        //https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
        //3. Approach (OPTIMISED)
        //Two pointer method
        //Theory: 
        //maintain ref pointer, main pointer
        //both start from the head ref
        //move ref pointer to K dist. Once ref pointer reaches the K dist from main pointer
        //start moving the ref and main pointer one by one.
        //at the time ref pointer reaches the end of linked list
        //main pointer will be K dist behind the ref pointer(already at end now)
        //print the main pointer that will be answer
        //............T: O(N) S: O(1)
        Node front = head;
        Node back = head;

        while (front != null && K-- != 0) {
            front = front.getNext();
            if (front == null) {
                front = head;
            }
        }

        if (front == head) {
            //output
            System.out.println("Kth node from end is: " + back.getData());
            return;
        }

        //now ref is K dist ahead of main pointer
        //now move both pointer one by one
        //until ref reaches end of linked list
        //bt the time main pointer will be K dist behind the ref pointer
        while (front != null) {
            back = back.getNext();
            front = front.getNext();
        }

        //output
        System.out.println("Kth node from end is: " + back.getData());
    }

    public Node<Integer> swapLinkedListNodesInPair(Node<Integer> node) {

        //https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
        //https://leetcode.com/problems/swap-nodes-in-pairs/
        int K = 2; //because swap in pairs;
        Node current = node;
        Node next = null;
        Node prev = null;

        int count = 0;

        /* Reverse first k nodes of linked list */
        while (count < K && current != null) {
            next = current.getNext();
            current.setNext(prev);
            prev = current;
            current = next;
            count++;
        }

        /* next is now a pointer to (k+1)th node  
         Recursively call for the list starting from current. 
         And make rest of the list as next of first node */
        if (next != null) {
            node.setNext(swapLinkedListNodesInPair(next));
        }

        // prev is now head of input list 
        return prev;
    }

    public Node<Integer> reverseLinkedListInKGroups(Node<Integer> head, int K) {
        //https://www.geeksforgeeks.org/reverse-a-list-in-groups-of-given-size/
        //https://leetcode.com/problems/reverse-nodes-in-k-group/
        Node current = head;
        int count = 0;
        //in case the passed LinkedList length is less than k
        while (count < K && current != null) {
            current = current.getNext();
            count++;
        }

        if (count < K) {
            return head;
        }

        current = head;
        Node next = null;
        Node prev = null;

        count = 0;

        /* Reverse first k nodes of linked list */
        while (count < K && current != null) {
            next = current.getNext();
            current.setNext(prev);
            prev = current;
            current = next;
            count++;
        }

        /* next is now a pointer to (k+1)th node  
         Recursively call for the list starting from current. 
         And make rest of the list as next of first node */
        if (next != null) {
            head.setNext(reverseLinkedListInKGroups(next, K));
        }

        // prev is now head of input list 
        return prev;
    }

    public Node<Integer> reverseLinkedListInKGroupsAlternatively(Node<Integer> head, int K) {

        //Adaptation of reverseLinkedListInKGroups method
        //reverse first K groups
        Node<Integer> curr = head;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        int count = 0;

        while (count < K && curr != null) {

            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;

            count++;
        }

        //move straight K nodes without reversing
        count = 0;
        while (count < K && next != null) {

            head.setNext(next);
            head = head.getNext();
            next = next.getNext();
            count++;
        }

        //pass the alternate K group recursively
        if (next != null) {
            head.setNext(reverseLinkedListInKGroupsAlternatively(next, K));
        }

        return prev;
    }

    public boolean detectLoopCycleInLinkedList_HashBased(Node node) {

        //......................T: O(N)
        //......................S: O(N)
        Set<Node> set = new HashSet<>();
        Node temp = node;
        while (temp != null) {

            if (set.contains(temp)) {
                System.out.println("Hash Based Cycle at: " + temp.getData());
                return true;
            }
            set.add(temp);
            temp = temp.getNext();
        }

        System.out.println("Hash Based No cycle found");
        return false;
    }

    public boolean detectLoopCycleInLinkedList_Iterative(Node head) {

        //......................T: O(N)
        //......................S: O(1)
        Node slow = head;
        Node fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            if (slow == fast) {
                break;
            }
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        if (slow == fast) {
            slow = head;
            while (slow != fast.getNext()) {
                slow = slow.getNext();
                fast = fast.getNext();
            }

            //fast.next is where the loop starts...
            System.out.println("Iterative approach Cycle at: " + fast.getNext().getData());
            return true;
        }

        System.out.println("Iterative approach No cycle found");
        return false;
    }

    public void detectAndRemoveLoopCycleInLinkedList_HashBased(Node node) {

        //......................T: O(N)
        //......................S: O(N)
        Set<Node> set = new HashSet<>();
        Node loopEnd = null;
        Node temp = node;
        while (temp != null) {

            if (set.contains(temp)) {
                loopEnd.setNext(null);
                break;
            }

            set.add(temp);
            loopEnd = temp;
            temp = temp.getNext();
        }

        //output;
        System.out.println("Hash Based approach detect and remove a loop cycle in linked list output:");
        new LinkedListUtil(node).print();
    }

    public void detectAndRemoveLoopCycleInLinkedList_Iterative(Node head) {

        //......................T: O(N)
        //......................S: O(1)
        Node slow = head;
        Node fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            if (slow == fast) {
                break;
            }
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //if there is a loop in linked list
        if (slow == fast) {
            slow = head;
            while (slow != fast.getNext()) {
                slow = slow.getNext();
                fast = fast.getNext();
            }

            //fast is the node where it should end the loop
            fast.setNext(null);
        }

        //output
        System.out.println("Iterative approach detect and remove a loop cycle in linked list output:");
        new LinkedListUtil(head).print();
    }

    public void removeDuplicatesFromUnSortedLinkedListOnlyConsecutive(Node<Integer> node) {

        //...............................T: O(N)
        //...............................S: O(1)
        Node<Integer> curr = node;
        Node<Integer> temp = node.getNext();
        while (temp != null) {

            if (curr.getData() != temp.getData()) {
                curr.setNext(temp);
                curr = temp;
            }

            temp = temp.getNext();

        }

        curr.setNext(temp);

        //output
        System.out.println("Remove duplicates that are consecutive in lisnked list output:");
        new LinkedListUtil<>(node).print();

    }

    public void removeDuplicatesFromUnSortedLinkedListAllExtraOccuernce(Node<Integer> head) {

        //...............................T: O(N)
        //...............................S: O(N)
        Set<Integer> visited = new HashSet<>();
        Node<Integer> curr = head;
        Node<Integer> temp = head.getNext();
        visited.add(curr.getData());
        while (temp != null) {

            if (curr.getData() != temp.getData() && !visited.contains(temp.getData())) {
                curr.setNext(temp);
                curr = temp;
            }
            visited.add(temp.getData());
            temp = temp.getNext();
        }

        curr.setNext(temp);

        //output
        System.out.println("Remove duplicates all extra occuernce in lisnked list output:");
        new LinkedListUtil<>(head).print();
    }

    public Node<Integer> findMiddleNodeOfLinkedList(Node<Integer> head) {

        if (head == null || head.getNext() == null) {
            return head;
        }

        Node<Integer> slow = head;
        Node<Integer> fast = head.getNext();
        while (fast != null && fast.getNext() != null) {

            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //middle node = slow
        return slow;
    }

    public Node<Integer> mergeSortInLinkedList_Asc_Recursion(Node<Integer> n1, Node<Integer> n2) {

        if (n1 == null) {
            return n2;
        }

        if (n2 == null) {
            return n1;
        }

        if (n1.getData() <= n2.getData()) {
            Node<Integer> a = mergeSortInLinkedList_Asc_Recursion(n1.getNext(), n2);
            n1.setNext(a);
            return n1;
        } else {
            Node<Integer> b = mergeSortInLinkedList_Asc_Recursion(n1, n2.getNext());
            n2.setNext(b);
            return n2;
        }
    }

    public Node<Integer> mergeSortDivideAndMerge(Node<Integer> node) {

        if (node == null || node.getNext() == null) {
            return node;
        }

        Node<Integer> middle = findMiddleNodeOfLinkedList(node);
        Node<Integer> secondHalf = middle.getNext();
        //from node to middle is first half, so middle.next = null 
        //splites as 1. node -> middle.next->NULL 2. middle.next -> tail.next->NULL
        middle.setNext(null);

        return mergeSortInLinkedList_Asc_Recursion(mergeSortDivideAndMerge(node),
                mergeSortDivideAndMerge(secondHalf));
    }

    public boolean checkIfLinkedListIsCircularLinkedList(Node node) {

        if (node == null || node.getNext() == node) {
            return true;
        }

        Node headRef = node;
        Node temp = node;
        while (temp.getNext() != headRef && temp.getNext() != null) {
            temp = temp.getNext();
        }
        return temp.getNext() == headRef;
    }

    private int quickSortInLinkedList_Partition(List<Integer> arr, int low, int high) {

        int pivot = arr.get(high);
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr.get(j) < pivot) {

                i++;
                //swap
                int temp = arr.get(i);
                arr.set(i, arr.get(j));
                arr.set(j, temp);
            }
        }

        int temp = arr.get(i + 1);
        arr.set(i + 1, arr.get(high));
        arr.set(high, temp);

        return i + 1;
    }

    private void quickSortInLinkedList_Helper(List<Integer> arr, int low, int high) {

        if (high >= low) {

            int pivotIndex = quickSortInLinkedList_Partition(arr, low, high);
            quickSortInLinkedList_Helper(arr, low, pivotIndex - 1);
            quickSortInLinkedList_Helper(arr, pivotIndex + 1, high);
        }
    }

    public void quickSortInLinkedList(Node<Integer> node) {

        if (node == null || node.getNext() == null) {
            new LinkedListUtil<Integer>(node).print();
            return;
        }

        List<Integer> intArr = new ArrayList<>();
        Node<Integer> temp = node;
        while (temp != null) {
            intArr.add(temp.getData());
            temp = temp.getNext();
        }

        quickSortInLinkedList_Helper(intArr, 0, intArr.size() - 1);

        // System.out.println(intArr);
        temp = node;
        for (int x : intArr) {

            temp.setData(x);
            temp = temp.getNext();
        }

        //output
        new LinkedListUtil<Integer>(node).print();
    }

    public void moveLastNodeToFrontOfLinkedList(Node<Integer> node) {

        Node curr = node;
        Node prev = null;

        while (curr.getNext() != null) {
            prev = curr;
            curr = curr.getNext();
        }

        prev.setNext(curr.getNext());
        curr.setNext(node);
        node = curr;

        //output:
        new LinkedListUtil<Integer>(node).print();
    }

    private int addOneToLinkedList_Helper(Node<Integer> node) {

        if (node.getNext() == null) {
            //adding 1 to very last node(or last digit of number in linkedlist form)
            int sum = node.getData() + 1;
            node.setData(sum % 10);
            return sum / 10;
        }

        int carry = addOneToLinkedList_Helper(node.getNext());
        int sum = carry + node.getData();
        node.setData(sum % 10);
        return sum / 10;
    }

    public void addOneToLinkedList(Node<Integer> head) {

        if (head == null) {
            return;
        }

        int carry = addOneToLinkedList_Helper(head);
        //edge case for L [9 -> 9 -> 9 -> NULL] + 1 = [1 -> 0 -> 0 -> 0 -> NULL]
        //extra 1 is the newHead in this case...
        if (carry > 0) {
            Node<Integer> newHead = new Node<>(carry);
            newHead.setNext(head);
            head = newHead;
        }

        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void sortLinkedListOf012_2(Node<Integer> node) {

        //approach 1 is just using merger sort on linked list. 
        //merge sort method is already been implemented
        //approach 2 will be similar to my approach of solving
        //sortArrayOf012_1()
        int[] count = new int[3]; //we just have 3 digits (0, 1, 2)
        Node<Integer> curr = node;
        while (curr != null) {
            count[curr.getData()]++;
            curr = curr.getNext();
        }

        //manipulate the linked list 
        curr = node;
        for (int i = 0; i < 3; i++) { //O(3)

            while (count[i]-- != 0) {
                //O(N) as N = count[0]+count[1]+cout[2] == total no of node already in the linked list
                curr.setData(i);
                curr = curr.getNext();
            }
        }

        //output:
        new LinkedListUtil<Integer>(node).print();
    }

    public void reverseDoublyLinkedList(Node node) {

        //actual
        new LinkedListUtil(node).print();

        Node curr = node;
        Node nextToCurr = null;
        Node prevToCurr = null;
        while (curr != null) {

            nextToCurr = curr.getNext();
            curr.setNext(prevToCurr);
            curr.setPrevious(nextToCurr);
            prevToCurr = curr;
            curr = nextToCurr;
        }

        //output:
        //new head will pre prevToCurr
        new LinkedListUtil(prevToCurr).print();
    }

    public void intersectionOfTwoSortedLinkedList(Node<Integer> node1, Node<Integer> node2) {

        //....................T: O(M+N)
        //....................S: O(M+N)
        Set<Integer> node1Set = new HashSet<>();
        while (node1 != null) {
            node1Set.add(node1.getData());
            node1 = node1.getNext();
        }

        Set<Integer> node2Set = new HashSet<>();
        Node<Integer> newHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> copy = newHead;
        while (node2 != null) {

            //all the in node2 that is present in node1 set but same node2 should not be repested in node2 set
            if (node1Set.contains(node2.getData()) && !node2Set.contains(node2.getData())) {
                copy.setNext(node2);
                copy = copy.getNext();
            }
            node2Set.add(node2.getData());
            node2 = node2.getNext();
        }
        copy.setNext(null);
        //output:
        new LinkedListUtil<Integer>(newHead.getNext()).print();
    }

    private int lengthOfLinkedList(Node<Integer> node) {
        int len = 0;
        Node<Integer> curr = node;
        while (curr != null) {
            len++;
            curr = curr.getNext();
        }

        return len;
    }

    private Node<Integer> moveLinkedListNodeByDiff(Node<Integer> node, int diff) {

        int index = 0;
        Node<Integer> curr = node;
        while (index++ < diff) { //evaluates as index++ -> 0+1 -> 1 then 1 < diff
            curr = curr.getNext();
        }
        return curr;
    }

    private int intersectionPointOfTwoLinkedListByRef_Helper(Node<Integer> n1, Node<Integer> n2) {

        Node<Integer> currN1 = n1;
        Node<Integer> currN2 = n2;
        while (currN1 != null && currN2 != null) {

            //nodes get common by ref
            if (currN1 == currN2) {
                return currN1.getData();
            }

            currN1 = currN1.getNext();
            currN2 = currN2.getNext();
        }

        return -1;
    }

    public void intersectionPointOfTwoLinkedListByRef(Node<Integer> node1, Node<Integer> node2) {
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        //find length of node1 T: O(M)
        int M = lengthOfLinkedList(node1);
        //find length of node2 T: O(N)
        int N = lengthOfLinkedList(node2);

        //find the absolute diff in both the length
        //diff = abs(M - N)
        int diff = Math.abs(M - N);

        //if M > N move ptr in node1 by diff forward else move ptr in node2
        //once ptr is available move ptr and node1 or node2 till null and find the intersection point
        //by ref
        int intersectedData = -1;
        Node<Integer> curr = null;
        if (M > N) {
            curr = moveLinkedListNodeByDiff(node1, diff);
            intersectedData = intersectionPointOfTwoLinkedListByRef_Helper(curr, node2);
        } else {
            curr = moveLinkedListNodeByDiff(node2, diff);
            intersectedData = intersectionPointOfTwoLinkedListByRef_Helper(curr, node1);
        }

        //output:
        System.out.println("Two linked list are intersected at: " + intersectedData);
    }

    public void intersectionPointOfTwoLinkedListByRef_HashBased(Node<Integer> node1, Node<Integer> node2) {

        //................................T: O(N + M)
        //................................S: O(N)
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        Set<Node<Integer>> set1 = new HashSet<>();
        Node<Integer> curr = node1;
        while (curr != null) {
            set1.add(curr);
            curr = curr.getNext();
        }

        int intersectedData = -1;
        curr = node2;
        while (curr != null) {

            if (set1.contains(curr)) {
                intersectedData = curr.getData();
                break;
            }
            curr = curr.getNext();
        }

        //output:
        System.out.println("Two linked list are intersected at (hashbased): " + intersectedData);
    }

    public void intersectionPointOfTwoLinkedListByRef_Iterative(Node<Integer> headA, Node<Integer> headB) {
        //................................T: O(N + M)
        //................................S: O(1)
        //https://leetcode.com/problems/intersection-of-two-linked-lists
        //explanation: https://youtu.be/D0X0BONOQhI
        Node<Integer> currA = headA;
        Node<Integer> currB = headB;

        while (currA != currB) {
            currA = currA == null ? headB : currA.getNext();
            currB = currB == null ? headA : currB.getNext();
        }

        //output:
        System.out.println("Two linked list are intersected at (iterative): " + currA.getData());
    }

    public boolean checkIfLinkedListPallindrome_1(Node<Integer> node) {

        //.........................T: O(N)
        //.........................S: O(N)
        //https://leetcode.com/problems/palindrome-linked-list
        //empty list or 1 node list is by default true
        if (node == null || node.getNext() == null) {
            return true;
        }

        Node<Integer> curr = node;
        Stack<Node<Integer>> stack = new Stack<>();
        while (curr != null) {
            stack.push(curr);
            curr = curr.getNext();
        }

        //pop stack and start checking from the head of list
        curr = node;
        while (!stack.isEmpty()) {

            Node<Integer> popped = stack.pop();
            if (curr.getData() != popped.getData()) {
                return false;
            }
            curr = curr.getNext();
        }

        //if while loop doesn't prove false
        return true;
    }

    public boolean checkIfLinkedListPallindrome_2(Node<Integer> node) {

        //.........................T: O(N)
        //.........................S: O(1)
        //https://leetcode.com/problems/palindrome-linked-list/
        //empty list or 1 node list is by default true
        if (node == null || node.getNext() == null) {
            return true;
        }

        //ex LL = 1->2->2->1->N
        //find the mid of the linked list
        Node<Integer> slow = node;
        Node<Integer> fast = node;
        while (fast != null && fast.getNext() != null) {
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        //LL head = 1->2->2->1->N
        //LL slow = 2->1->N
        //from slow ptr reverse it
        Node<Integer> curr = slow;
        Node<Integer> prev = null;
        Node<Integer> next = null;
        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }
        //after reversing slow ptr
        //LL new Head(prev) = 1->2->N

        //now prev is the new head for the reversed-slow ptr
        curr = node; //actual head
        //now comparing
        //LL head = 1->2->2->1->N
        //prev = 1->2->N
        //if reversed-half of the linked list(prev) is equal to first-half-part of the actual linked list (head)
        //its pallindrme otherwise ret false
        while (prev != null) {
            if (curr.getData() != prev.getData()) {
                return false;
            }

            prev = prev.getNext();
            curr = curr.getNext();
        }

        //if while loop doesn't prove false
        return true;
    }

    public void reorderLinkedList(Node<Integer> head) {

        //First 2 approaches are in SomePracticeQuestion reorderList_1/reorderList_2
        //actual
        new LinkedListUtil<>(head).print();

        //explanantion: https://youtu.be/xRYPjDMSUFw
        //ex: 1-> 2-> 3-> 4-> 5-> NULL
        //slow = 3->..
        //break it into 2 list (2 half)
        //l1 = 1-> 2-> NULL
        //l2 = 3-> 4-> 5-> NULL
        //reverse(l2) = 5-> 4-> 3-> NULL
        //reorderMerger(l1, l2) = 1-> 5-> 2-> 4-> 3-> NULL
        if (head == null || head.getNext() == null) {
            return;
        }

        //find mid of the linked list
        Node<Integer> slow = head;
        Node<Integer> fast = head.getNext();
        while (fast != null && fast.getNext() != null) {
            slow = slow.getNext();
            fast = fast.getNext().getNext();
        }

        Node<Integer> mid = slow;

        Node<Integer> tempSecond = mid.getNext();
        mid.setNext(null);

        //reversing the second half of the list
        Node<Integer> curr = tempSecond;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        Node<Integer> second = prev;
        Node<Integer> first = head;

        while (second != null) {

            Node<Integer> firstNext = first.getNext();
            Node<Integer> secondNext = second.getNext();

            first.setNext(second);

            if (firstNext == null) {
                break;
            }

            second.setNext(firstNext);

            first = firstNext;
            second = secondNext;
        }
        //output
        new LinkedListUtil<>(head).print();
    }

    public void rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(Node<Integer> head) {

        //rearrange all node in linked list in such a way that nodes at odd index comes first and nodes at even index 
        //comes last and nodex should maintain the order of their occurence in actual list
        //nodes data is not to be consider for even and odd but their INDEX ONLY
        //https://leetcode.com/problems/odd-even-linked-list/
        //explanation: https://youtu.be/C_LA6SOwVTM
        //actual
        Node<Integer> forPrinting = head;
        int index = 0;
        while (forPrinting != null) {
            System.out.print((++index) + ") " + forPrinting.getData() + "\t");
            forPrinting = forPrinting.getNext();
        }
        System.out.println();

        Node<Integer> odd = head; //at index 1)
        Node<Integer> even = head.getNext(); //at index 2)
        Node<Integer> evenHead = even; //saving the starting ref of even pointr i.e, index 2) in evenHead

        while (even != null && even.getNext() != null) {
            odd.setNext(even.getNext()); //next odd index we will get after even index i.e, 3) after 2)
            odd = odd.getNext(); //index 1) now pointing to the update i.e, index 3) and so on...
            even.setNext(odd.getNext()); //similarly next even index we will get after odd index i.e, 4) after 3)
            even = even.getNext(); //index 2) now pointing to the update i.e, index 4) and so on...
        }

        //odd last ref will be having even starting index ref (last nth odd index -> index 2)
        odd.setNext(evenHead);

        //output:
        new LinkedListUtil<Integer>(head).print();
    }

    public void linkedListComponent(Node<Integer> head, int[] subset) {

        //https://leetcode.com/problems/linked-list-components/
        //ex L = 0-> 1-> 2-> 3-> 4
        //subset[] = [0,3,1,4]
        //first consecutive segment = 0-> 1
        //second consecutive segment = 3-> 4
        //also 0, 1, 3, 4 are in subset, so total segment = 2
        //this logic updates count when consecutivity breaks like 0->1->2 (b/w 1 & 2) count++
        //--->curr = 1 if(set(1) == true && (1.next == null => false || !set(1.next.data(=> 2)) == true)) == TRUE
        //and 3->4->Null (b/w 4 & Null) count++
        //--->curr = 4 if(set(4) == true && (4.next == null => true || !set(4.next.data(=> 2)) == false)) == TRUE
        Set<Integer> set = IntStream.of(subset).boxed().collect(Collectors.toSet());

        Node<Integer> curr = head;
        int count = 0;

        while (curr != null) {
            if (set.contains(curr.getData())
                    && (curr.getNext() == null || !set.contains(curr.getNext().getData()))) {
                count++;
            }
            curr = curr.getNext();
        }

        //output
        System.out.println("Total consecutive segment of linkedlist that are also in subset: " + count);
    }

    public void partitionList(Node<Integer> head, int x) {

        //https://leetcode.com/problems/partition-list
        //explanation: https://youtu.be/K5AVJVjdmL0
        //SIMILAR to odd-even linked list rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd()
        //ex: 1-> 4-> 3-> 2-> 5-> 2-> Null, row = 3
        //all values less than row should come in first segment and in same 
        //order of oocurence and values greater than row should come in 
        //second segment and in same order of oocurence
        //value less than row and order oocurence 1, 2, 2
        //after loop:
        //---> beforeHead = Int.MIN, before = 1-> 2-> 2-> so beforeHead becomes Int.MIN-> 1-> 2-> 2->
        //---> afterHead = Int.MIN, after = 4-> 3-> 5-> so afterHead becomes Int.MIN-> 4-> 3-> 5->
        //after to be last segment so after.next = Null afterHead = Int.MIN-> 4-> 3-> 5-> Null
        //next of before to have head of second segment i.e 4, before.next = afterhead.next
        //now beforeHead = Int.MIN-> 1-> 2-> 2-> 4-> 3-> 5-> Null, now beforehead.next is our output
        //print: beforeHead.next = 1-> 2-> 2-> 4-> 3-> 5-> Null
        //actual
        new LinkedListUtil<>(head).print();
        System.out.println();

        if (head == null || head.getNext() == null) {
            return;
        }

        Node<Integer> curr = head;
        Node<Integer> beforeHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> before = beforeHead;
        Node<Integer> afterHead = new Node<>(Integer.MIN_VALUE);
        Node<Integer> after = afterHead;

        while (curr != null) {

            if (curr.getData() < x) {
                before.setNext(curr);
                before = before.getNext();
            } else {
                after.setNext(curr);
                after = after.getNext();
            }
            curr = curr.getNext();
        }

        after.setNext(null);
        before.setNext(afterHead.getNext());

        //output
        new LinkedListUtil<>(beforeHead.getNext()).print();
        System.out.println();
    }

    public void rotateLinkedListKTimes(Node<Integer> head, int K) {

        //https://leetcode.com/problems/rotate-list/
        //Actual
        new LinkedListUtil<>(head).print();

        Node<Integer> dummy = new Node<>(Integer.MIN_VALUE);
        dummy.setNext(head);
        Node<Integer> fast = dummy;
        Node<Integer> slow = dummy;

        int len = 0;

        while (fast.getNext() != null) {
            len++;
            fast = fast.getNext();
        }

        for (int j = len - K % len; j > 0; j--) {
            slow = slow.getNext();
        }

        fast.setNext(dummy.getNext());
        dummy.setNext(slow.getNext());
        slow.setNext(null);

        //output
        System.out.println("Rotate linked list " + K + " times output approach1: ");
        new LinkedListUtil<>(dummy.getNext()).print();
    }

    public void rotateLinkedListKTimes2(Node<Integer> head, int K) {

        //https://leetcode.com/problems/rotate-list/
        //explanation: https://youtu.be/BHr381Guz3Y
        //approach similar to rotateArrayByK
        //Actual
        new LinkedListUtil<>(head).print();

        //find len of the the linked list
        int len = 0;
        Node<Integer> curr = head;
        while (curr != null) {
            len++;
            curr = curr.getNext();
        }

        //K > len, mod it by len so that K remains under len range
        K = K % len;

        curr = head;
        Node<Integer> prev = null;
        Node<Integer> next = null;

        //reverse linked list normally
        while (curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
        }

        //this is the node where we will append the second part of reversed list
        //ex: LL [1,2,3,4,5]
        //above reverse LL: [5,4,3,2,1]
        //lastNodeInFirstKReverse == prev = 5
        //let say if k = 2, so first k nodes reverse will be [4, 5]
        //second part reversal = [1,2,3] now the 1 should be linked to 5 above
        //lastNodeInFirstKReverse.next = 1
        Node<Integer> lastNodeInFirstKReverse = prev;

        //reverse first K nodes
        int firstK = K;
        curr = prev; // prev is new head after reversing above
        prev = null;
        next = null;
        while (firstK > 0 && curr != null) {
            next = curr.getNext();
            curr.setNext(prev);
            prev = curr;
            curr = next;
            firstK--;
        }

        //after reversing first K nodes its prev will be new head
        Node<Integer> rotatedListHead = prev;

        //reverse remaining nodes of list
        if (next != null) {
            curr = next;
            prev = null;
            next = null;
            while (curr != null) {
                next = curr.getNext();
                curr.setNext(prev);
                prev = curr;
                curr = next;
            }
            //join two parts of the linked list
            lastNodeInFirstKReverse.setNext(prev);
        }

        //output
        System.out.println("Rotate linked list " + K + " times output approach2: ");
        new LinkedListUtil<>(rotatedListHead).print();
    }

    public void sortLinkedListInRelativeOrderOfArr(Node<Integer> head, int[] arr) {

        //https://leetcode.com/problems/relative-sort-array/
        //https://www.geeksforgeeks.org/sort-linked-list-order-elements-appearing-array/
        //get the freq of all the elements in linkedlist
        Map<Integer, Integer> map = new TreeMap<>();
        Node<Integer> curr = head;

        while (curr != null) {
            map.put(curr.getData(), map.getOrDefault(curr.getData(), 0) + 1);
            curr = curr.getNext();
        }

        //regenerate linked list as relative order of arr
        curr = head;
        for (int a : arr) {
            int count = map.get(a);
            while (count-- != 0) {
                curr.setData(a);
                curr = curr.getNext();
            }
            map.remove(a);
        }

        //keep the values which are not in the arr[]
        for (int key : map.keySet()) {
            int count = map.get(key);
            while (count-- != 0) {
                curr.setData(key);
                curr = curr.getNext();
            }
        }

        //output
        new LinkedListUtil<>(head).print();
    }

    public void splitLinkedListInKParts(Node<Integer> head, int k) {

        //https://leetcode.com/problems/split-linked-list-in-parts/
        int len = 0;
        Node<Integer> curr = head;
        while (curr != null) {
            len++;
            curr = curr.getNext();
        }

        int width = len / k;
        int rem = len % k;

        Node<Integer>[] splits = new Node[k];
        int i = 0;
        curr = head;
        while (i < k) {

            Node<Integer> l = curr;
            for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; j++) {
                if (curr != null) {
                    curr = curr.getNext();
                }
            }

            if (curr != null) {
                Node<Integer> prev = curr;
                curr = curr.getNext();
                prev.setNext(null);
            }
            splits[i++] = l;
        }

        //output
        for (int j = 0; j < splits.length; j++) {
            System.out.print((j + 1) + ": ");
            Node<Integer> h = splits[j];
            if (h == null) {
                System.out.println("null");
                continue;
            }

            while (h != null) {
                System.out.print(h.getData() + " ");
                h = h.getNext();
            }
            System.out.println();
        }
    }

    public void trimLinkedListAndRemoveAllOccurencesOfGivenVal(Node<Integer> head, int val) {
        //............................T: O(N)
        //............................S: O(1)
        //https://leetcode.com/problems/remove-linked-list-elements
        //actual
        System.out.println("Actual");
        new LinkedListUtil<>(head).print();

        Node<Integer> prev = head;
        Node<Integer> curr = head.getNext();

        while (curr != null) {

            //we are moving all the val-to-remove curr ptr only once so T: remains O(N)
            //move curr ptr till curr.data value is same as val,
            //it will break when they don't match curr.data != val
            while (curr != null && curr.getData() == val) {
                curr = curr.getNext();
            }
            //since prev ptr was not moving, append this curr next to prev
            //this will break all links between prev and the val that needs to be removed
            prev.setNext(curr);
            //update the prev ptr to its next value
            prev = prev.getNext();
            //if curr is not already null, update curr as well
            if (curr != null) {
                curr = curr.getNext();
            }
        }

        //output
        //this cond will occur when val to remove occur at the starting of linked list
        head = head.getData() == val
                ? head.getNext()
                : head;
        new LinkedListUtil<>(head).print();
    }

    public void removeZeroSumConsecutiveNodesFromLinkedList(Node<Integer> head) {
        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/2079419/Java-two-pass-solution-using-prefix-sum
        int prefixSum = 0;
        Node<Integer> dummy = new Node<>(0);
        dummy.setNext(head);

        Map<Integer, Node<Integer>> prefixSumWithNode = new HashMap<>();
        Node<Integer> curr = dummy;
        while (curr != null) {
            prefixSum += curr.getData();
            prefixSumWithNode.put(prefixSum, curr);
            curr = curr.getNext();
        }

        prefixSum = 0;
        curr = dummy;
        while (curr != null) {
            prefixSum += curr.getData();
            curr.setNext(prefixSumWithNode.get(prefixSum).getNext());
            curr = curr.getNext();
        }
        //output
        new LinkedListUtil<>(dummy.getNext()).print();
    }

    public void mergeNodesInBetweenZeros(Node<Integer> head) {
        //https://leetcode.com/problems/merge-nodes-in-between-zeros/ 
        //actual
        new LinkedListUtil<Integer>(head).print();

        Node<Integer> curr = head;
        Node<Integer> next = head.getNext();

        while (next != null) {

            if (next.getData() == 0) {
                curr.setNext(next.getNext());
                curr = curr.getNext();
                next = next.getNext();
            } else {
                curr.setData(curr.getData() + next.getData());
            }
            if (next == null) {
                break;
            }
            next = next.getNext();
        }
        //output
        new LinkedListUtil<Integer>(head).print();
    }

    public void removeEveryNodeWhichHasStrictlyGreaterNodeToRight(Node<Integer> head) {
        //https://leetcode.com/problems/remove-nodes-from-linked-list/description/
        /*
        head: [5, 2, 13, 3, 8]
        remove 5, 2 as 13 is strictly greater value in right of [5, 2]
        ==> head: [13, 3, 8]
        remove 3 as 8 is strictly greater value in right of [3]
        ==> head: [13, 8]
        
        ##removing nodes
        stack = []
        curr = [5]...
        
        iterations
        #1.
        curr != null ==> 5 != null
        ___!stack.isEmpty ==> []  ==> FALSE
        ___stack.push(curr) ==> [5]
        ___curr = curr.next ==> 5.next ==> 2
        
        #2.
        curr != null ==> 2 != null
        ___!stack.isEmpty && stack.peek < curr ==> [5] && peek[5] < 2 ==> FALSE
        ___stack.push(curr) ==> [5, 2]
        ___curr = curr.next ==> 2.next ==> 13
        
        #3.
        curr != null ==> 13 != null
        ___!stack.isEmpty && stack.peek < curr ==> [5, 2] && peek[2] < 13 ==> TRUE
        ______stack.pop() ==> remove 2 as 2 < 13, remove 5 as 5 < 13 ==> []
        ___stack.push(curr) ==> [13]
        ___curr = curr.next ==> 13.next ==> 3
        
        #4.
        curr != null ==> 3 != null
        ___!stack.isEmpty && stack.peek < curr ==> [13] && peek[13] < 3 ==> FALSE
        ___stack.push(curr) ==> [13, 3]
        ___curr = curr.next ==> 3.next ==> 8
        
        #4.
        curr != null ==> 8 != null
        ___!stack.isEmpty && stack.peek < curr ==> [13, 3] && peek[3] < 8 ==> TRUE
        ______stack.pop() ==> remove 3 as 3 < 8 ==> [13]
        ___stack.push(curr) ==> [13, 8]
        ___curr = curr.next ==> 8.next ==> null
        
        ...curr != null ==> null != null..
        
        ##creating list again
        prev = null
        curr = null
        
        iterations
        #1.
        curr = stack.pop() ==> 8
        8.next = prev = null
        ==> 8 -> null
        prev = curr = 8
        ==> prev = 8 -> null
        head = curr = 8
        ==> head = 8 -> null
        
        #2.
        curr = stack.pop() ==> 13
        13.next = prev = 8
        ==> 13 -> 8 -> null
        prev = curr = 13
        ==> prev = 13 -> 8 -> null
        head = curr = 13
        ==> head = 13 -> 8 -> null
        
        ...stack empty...
        
        //list formed without reverse logic
        head = 13 -> 8 -> null
        
         */
        //actual:
        new LinkedListUtil<>(head).print();
        System.out.println();

        Node<Integer> curr = head;
        Stack<Node<Integer>> stack = new Stack<>();

        while (curr != null) {
            //each curr node is a value in the right and nodes in stack are those
            //nodes which are left of this curr node. if curr node(in right) is strictly
            //greater than the nodes in stack(to left of curr node) remove them
            while (!stack.isEmpty() && stack.peek().getData() < curr.getData()) {
                stack.pop();
            }
            //push the curr node in stack
            stack.push(curr);
            //update the curr node
            curr = curr.getNext();
        }

        //after above loop we have removed all the nodes that has strictly greater
        //value in their right so stack will have [13, 8] <-- PEEK
        //if we pop out values from stack it will be in reverse order
        //that means 8 -> 13
        //either create a linked list as this: 8 -> 13 -> NULL and then reverse it
        //OR
        //do below logic based on reversing linked list
        Node<Integer> prev = null;
        curr = null;
        while (!stack.isEmpty()) {
            curr = stack.pop();
            curr.setNext(prev);
            prev = curr;
        }
        //output
        //new head == prev
        new LinkedListUtil<>(prev).print();
        System.out.println();
    }

    public void levelOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        Queue<TreeNode> childQueue = new LinkedList<>();

        List<List> levels = new ArrayList<>();
        List nodes = new ArrayList<>();

        while (!queue.isEmpty()) {

            TreeNode curr = queue.poll();
            nodes.add(curr.getData());

            if (curr.getLeft() != null) {
                childQueue.add(curr.getLeft());
            }
            if (curr.getRight() != null) {
                childQueue.add(curr.getRight());
            }

            if (queue.isEmpty()) {
                levels.add(nodes);
                nodes = new ArrayList<>();
                queue.addAll(childQueue);
                childQueue.clear();
            }
        }

        //output
        System.out.println("Level order iterative (childQueue based approach): ");
        for (List level : levels) {
            System.out.println(level);
        }
    }

    public void levelOrderTraversal_Iterative2(TreeNode root) {

        if (root == null) {
            return;
        }

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        List<List> levels = new ArrayList<>();
        List currLevelNodes;

        while (!queue.isEmpty()) {

            int size = queue.size();
            currLevelNodes = new ArrayList<>();

            for (int index = 0; index < size; index++) {
                TreeNode curr = queue.poll();

                currLevelNodes.add(curr.getData());

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }
                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }
            levels.add(currLevelNodes);
        }

        //output
        System.out.println("Level order iterative (size based approach): ");
        for (List level : levels) {
            System.out.println(level);
        }
    }

    public void levelOrderTraversal_Recursive_Helper(TreeNode<Integer> root, int level,
            Map<Integer, List<Integer>> levelOrder) {

        if (root == null) {
            return;
        }

        levelOrder.putIfAbsent(level, new ArrayList<>());
        levelOrder.get(level).add(root.getData());

        levelOrderTraversal_Recursive_Helper(root.getLeft(), level + 1, levelOrder);
        levelOrderTraversal_Recursive_Helper(root.getRight(), level + 1, levelOrder);
    }

    public void levelOrderTraversal_Recursive(TreeNode<Integer> root) {
        Map<Integer, List<Integer>> levelOrder = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root, 0, levelOrder);

        //output:
        System.out.println("Level order recursive: ");
        for (List l : levelOrder.values()) {
            System.out.println(l);
        }
    }

    public void reverseLevelOrderTraversal(TreeNode<Integer> root) {

        //actuals
        BinaryTree bt = new BinaryTree(root);
        bt.treeBFS();

        List<Integer> singleListReverseLevelOrder = new ArrayList<>();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);
        Queue<TreeNode<Integer>> intQ = new LinkedList<>();

        List<List<Integer>> level = new ArrayList<>();
        List<Integer> nodes = new ArrayList<>();

        while (!q.isEmpty()) {

            TreeNode<Integer> temp = q.poll();
            nodes.add(temp.getData());

            if (temp.getLeft() != null) {
                intQ.add(temp.getLeft());
            }

            if (temp.getRight() != null) {
                intQ.add(temp.getRight());
            }

            if (q.isEmpty()) {
                level.add(nodes);
                nodes = new ArrayList<>();
                q.addAll(intQ);
                intQ.clear();
            }

        }

        //output
        System.out.println();
        Collections.reverse(level);
        System.out.println("Level wise: " + level);

        for (List l : level) {
            singleListReverseLevelOrder.addAll(l);
        }
        System.out.println("Single node list: " + singleListReverseLevelOrder);
    }

    public void inOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 1) {
                System.out.print(currNode.getData() + " ");
            }

            if (status == 2) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }
        }

        System.out.println();
    }

    public void inOrderTraversal_Recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        inOrderTraversal_Recursive(root.getLeft());
        System.out.print(root.getData() + " ");
        inOrderTraversal_Recursive(root.getRight());
    }

    public void preOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                System.out.print(currNode.getData() + " ");
            }

            if (status == 1) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 2) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }
        }

        System.out.println();
    }

    public void preOrderTraversal_Iterative2(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<TreeNode> stack = new Stack<>();
        TreeNode currRoot = root;

        while (!stack.isEmpty() || currRoot != null) {

            while (currRoot != null) {

                System.out.print(currRoot.getData() + " ");

                if (currRoot.getRight() != null) {
                    stack.push(currRoot.getRight());
                }

                currRoot = currRoot.getLeft();
            }

            if (!stack.isEmpty()) {
                currRoot = stack.pop();
            }
        }

        System.out.println();
    }

    public void preOrderTraversal_Recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        System.out.print(root.getData() + " ");
        preOrderTraversal_Recursive(root.getLeft());
        preOrderTraversal_Recursive(root.getRight());

    }

    public void postOrderTraversal_Iterative(TreeNode root) {

        if (root == null) {
            return;
        }

        Stack<Pair<TreeNode, Integer>> stack = new Stack<>();
        stack.push(new Pair<>(root, 0));

        while (!stack.isEmpty()) {

            Pair<TreeNode, Integer> currPair = stack.pop();
            TreeNode currNode = currPair.getKey();
            int status = currPair.getValue();

            if (currNode == null || status == 3) {
                continue;
            }

            stack.push(new Pair<>(currNode, status + 1));

            if (status == 0) {
                stack.push(new Pair<>(currNode.getLeft(), 0));
            }

            if (status == 1) {
                stack.push(new Pair<>(currNode.getRight(), 0));
            }

            if (status == 2) {
                System.out.print(currNode.getData() + " ");
            }
        }

        System.out.println();
    }

    public void postOrderTraversal_recursive(TreeNode root) {

        if (root == null) {
            return;
        }

        postOrderTraversal_recursive(root.getLeft());
        postOrderTraversal_recursive(root.getRight());
        System.out.print(root.getData() + " ");

    }

    public int heightOfTree(TreeNode root) {

        if (root == null) {
            return -1;
        }

        return Math.max(heightOfTree(root.getLeft()),
                heightOfTree(root.getRight())) + 1;
    }

    public TreeNode mirrorOfTree(TreeNode root) {

        if (root == null) {
            return null;
        }

        TreeNode left = mirrorOfTree(root.getLeft());
        TreeNode right = mirrorOfTree(root.getRight());
        root.setLeft(right);
        root.setRight(left);

        return root;
    }

    private void leftViewOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, Integer> result) {
        if (root == null) {
            return;
        }

        if (!result.containsKey(level)) {
            result.put(level, root.getData());
        }

        //for left view
        leftViewOfTree_Helper(root.getLeft(), level + 1, result);
        leftViewOfTree_Helper(root.getRight(), level + 1, result);
    }

    public void leftViewOfTree(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(N), worst case of left-skewed tree
        Map<Integer, Integer> result = new TreeMap<>();
        leftViewOfTree_Helper(root, 0, result);

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public int leftViewOfTreeWithoutExtraSpace_MaxLevel;

    private void leftViewOfTreeWithoutExtraSpace_Helper(TreeNode<Integer> root,
            int level, List<Integer> result) {
        if (root == null) {
            return;
        }

        if (level > leftViewOfTreeWithoutExtraSpace_MaxLevel) {
            leftViewOfTreeWithoutExtraSpace_MaxLevel = level;
            result.add(root.getData());
        }

        //for left view
        leftViewOfTreeWithoutExtraSpace_Helper(root.getLeft(), level + 1, result);
        leftViewOfTreeWithoutExtraSpace_Helper(root.getRight(), level + 1, result);
    }

    public void leftViewOfTreeWithoutExtraSpace(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(1)
        leftViewOfTreeWithoutExtraSpace_MaxLevel = -1;
        List<Integer> result = new ArrayList<>();
        leftViewOfTreeWithoutExtraSpace_Helper(root, 0, result);

        result.stream().forEach(e -> {
            System.out.print(e + " ");
        });

        System.out.println();
    }

    private void rightViewOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, Integer> result) {

        if (root == null) {
            return;
        }

        if (!result.containsKey(level)) {
            result.put(level, root.getData());
        }

        //for right view
        rightViewOfTree_Helper(root.getRight(), level + 1, result);
        rightViewOfTree_Helper(root.getLeft(), level + 1, result);
    }

    public void rightViewOfTree(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(N), worst case of right-skewed tree
        Map<Integer, Integer> result = new TreeMap<>();
        rightViewOfTree_Helper(root, 0, result);

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public int rightViewOfTreeWithoutExtraSpace_MaxLevel;

    private void rightViewOfTreeWithoutExtraSpace_Helper(TreeNode<Integer> root,
            int level, List<Integer> result) {

        if (root == null) {
            return;
        }

        if (level > rightViewOfTreeWithoutExtraSpace_MaxLevel) {
            rightViewOfTreeWithoutExtraSpace_MaxLevel = level;
            result.add(root.getData());
        }

        //for right view
        rightViewOfTreeWithoutExtraSpace_Helper(root.getRight(), level + 1, result);
        rightViewOfTreeWithoutExtraSpace_Helper(root.getLeft(), level + 1, result);
    }

    public void rightViewOfTreeWithoutExtraSpace(TreeNode<Integer> root) {
        //...................T: O(N)
        //...................S: O(1)
        rightViewOfTreeWithoutExtraSpace_MaxLevel = -1;
        List<Integer> result = new ArrayList<>();
        rightViewOfTreeWithoutExtraSpace_Helper(root, 0, result);

        result.stream().forEach(e -> {
            System.out.print(e + " ");
        });

        System.out.println();
    }

    public void topViewOfTree(TreeNode<Integer> root) {

        Queue<Pair<TreeNode<Integer>, Integer>> queue = new LinkedList<>();
        queue.add(new Pair<>(root, 0));

        Map<Integer, Integer> result = new TreeMap<>();

        while (!queue.isEmpty()) {

            Pair<TreeNode<Integer>, Integer> currPair = queue.poll();
            TreeNode<Integer> currNode = currPair.getKey();
            int vLevel = currPair.getValue();

            if (!result.containsKey(vLevel)) {
                result.put(vLevel, currNode.getData());
            }

            if (currNode.getLeft() != null) {
                queue.add(new Pair<>(currNode.getLeft(), vLevel - 1));
            }
            if (currNode.getRight() != null) {
                queue.add(new Pair<>(currNode.getRight(), vLevel + 1));
            }
        }

        result.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public void verticalOrderTraversalOfBinaryTree(TreeNode root) {
        //https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
        //based on topViewOfTree()
        class Pair {

            TreeNode<Integer> node;
            int verticalLevel;

            public Pair(TreeNode node, int verticalLevel) {
                this.node = node;
                this.verticalLevel = verticalLevel;
            }
        }

        List<List<Integer>> verticalOrderLevels;
        Map<Integer, List<Integer>> treeMap;
        verticalOrderLevels = new ArrayList<>();

        treeMap = new TreeMap<>();

        int verticalLevel = 0;

        Queue<Pair> queue = new LinkedList<>();
        queue.add(new Pair(root, verticalLevel));

        while (!queue.isEmpty()) {

            List<Pair> currLevel = new ArrayList<>();

            int size = queue.size();
            for (int i = 0; i < size; i++) {

                Pair pair = queue.poll();

                currLevel.add(pair);

                if (pair.node.getLeft() != null) {
                    queue.add(new Pair(pair.node.getLeft(), pair.verticalLevel - 1));
                }

                if (pair.node.getRight() != null) {
                    queue.add(new Pair(pair.node.getRight(), pair.verticalLevel + 1));
                }
            }

            //sort the curr level nodes as asked in questions, a slight diff from above
            //top view method
            Collections.sort(currLevel, (a, b) -> a.node.getData() - b.node.getData());
            for (Pair levelPair : currLevel) {
                treeMap.putIfAbsent(levelPair.verticalLevel, new ArrayList<>());
                treeMap.get(levelPair.verticalLevel).add(levelPair.node.getData());
            }

        }
        verticalOrderLevels.addAll(treeMap.values());
        //output
        System.out.println("Vertical order traversal of binary tree: " + verticalOrderLevels);
    }

    public void bottomViewOfTree(TreeNode<Integer> root) {

        //pair: node,vlevels
        Queue<Pair<TreeNode<Integer>, Integer>> q = new LinkedList<>();
        q.add(new Pair<>(root, 0));

        Map<Integer, Integer> bottomView = new TreeMap<>();

        while (!q.isEmpty()) {

            Pair<TreeNode<Integer>, Integer> p = q.poll();
            TreeNode<Integer> n = p.getKey();
            int vLevel = p.getValue();

            //updates the vlevel with new node data, as we go down the tree in level order wise
            bottomView.put(vLevel, n.getData());

            if (n.getLeft() != null) {
                q.add(new Pair<>(n.getLeft(), vLevel - 1));
            }

            if (n.getRight() != null) {
                q.add(new Pair<>(n.getRight(), vLevel + 1));
            }

        }

        bottomView.entrySet().stream().forEach(e -> {
            System.out.print(e.getValue() + " ");
        });

        System.out.println();
    }

    public void zigZagTreeTraversal(TreeNode<Integer> root, boolean isLeftToRight) {

        Stack<TreeNode<Integer>> stack = new Stack<>();
        stack.push(root);
        Stack<TreeNode<Integer>> childStack = new Stack<>();

        List<List<Integer>> level = new ArrayList<>();
        List<Integer> zigZagNodes = new ArrayList<>();

        while (!stack.isEmpty()) {

            TreeNode<Integer> curr = stack.pop();
            zigZagNodes.add(curr.getData());

            if (isLeftToRight) {

                if (curr.getRight() != null) {
                    childStack.push(curr.getRight());
                }

                if (curr.getLeft() != null) {
                    childStack.push(curr.getLeft());
                }
            } else {

                if (curr.getLeft() != null) {
                    childStack.push(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    childStack.push(curr.getRight());
                }
            }

            if (stack.isEmpty()) {

                isLeftToRight = !isLeftToRight;
                level.add(zigZagNodes);
                zigZagNodes = new ArrayList<>();
                stack.addAll(childStack);
                childStack.clear();
            }
        }

        //output
        System.out.println("Output: " + level);
    }

    private void minAndMaxInBST_Helper(TreeNode<Integer> root, List<Integer> l) {

        if (root == null) {
            return;
        }

        //inorder traversal
        minAndMaxInBST_Helper(root.getLeft(), l);
        if (root != null) {
            l.add(root.getData());
        }
        minAndMaxInBST_Helper(root.getRight(), l);
    }

    public void minAndMaxInBST(TreeNode<Integer> root) {
        List<Integer> inOrder = new ArrayList<>();
        minAndMaxInBST_Helper(root, inOrder);

        System.out.println("Min & Max in BST: " + inOrder.get(0) + " " + inOrder.get(inOrder.size() - 1));

    }

    TreeNode treeToDoublyLinkedList_Prev;
    TreeNode treeToDoublyLinkedList_HeadOfDLL;

    private void treeToDoublyLinkedList_Helper(TreeNode root) {
        if (root == null) {
            return;
        }

        treeToDoublyLinkedList_Helper(root.getLeft());

        if (treeToDoublyLinkedList_HeadOfDLL == null) {
            treeToDoublyLinkedList_HeadOfDLL = root;
        }

        if (treeToDoublyLinkedList_Prev != null) {
            root.setLeft(treeToDoublyLinkedList_Prev);
            treeToDoublyLinkedList_Prev.setRight(root);
        }

        treeToDoublyLinkedList_Prev = root;

        treeToDoublyLinkedList_Helper(root.getRight());
    }

    private void treeToDoublyLinkedList_Print(TreeNode head) {

        while (head != null) {

            System.out.print(head.getData() + " ");
            head = head.getRight();
        }
        System.out.println();
    }

    public void treeToDoublyLinkedList(TreeNode root) {

        //just resetting
        treeToDoublyLinkedList_Prev = null;
        treeToDoublyLinkedList_HeadOfDLL = null;

        treeToDoublyLinkedList_Helper(root);
        treeToDoublyLinkedList_Print(treeToDoublyLinkedList_HeadOfDLL);
    }

    private void checkIfAllLeafNodeOfTreeAtSameLevel_Helper(TreeNode root, int level, Set<Integer> levels) {

        if (root == null) {
            return;
        }

        //leaf
        if (root.getLeft() == null && root.getRight() == null) {
            levels.add(level);
        }

        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root.getLeft(), level + 1, levels);
        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root.getRight(), level + 1, levels);

    }

    public void checkIfAllLeafNodeOfTreeAtSameLevel(TreeNode root) {
        //..........................T: O(N), traversing all the nodes
        //..........................S: O(Leaf Nodes(M)), in worst case if all lead nodes are at different levels
        Set<Integer> levels = new HashSet<>();
        checkIfAllLeafNodeOfTreeAtSameLevel_Helper(root, 0, levels);

        System.out.println("Leaf at same level: " + (levels.size() == 1));
    }

    TreeNode<Integer> isTreeBST_Prev;

    private boolean isTreeBST_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return true;
        }

        boolean leftBst = isTreeBST_Helper(root.getLeft());

        if (isTreeBST_Prev != null && isTreeBST_Prev.getData() > root.getData()) {
            return false;
        }

        isTreeBST_Prev = root;

        boolean rightBst = isTreeBST_Helper(root.getRight());

        return leftBst && rightBst;
    }

    public void isTreeBST(TreeNode<Integer> root) {

        //just resetting
        isTreeBST_Prev = null;

        System.out.println("Tree is BST: " + isTreeBST_Helper(root));
    }

    private void kThLargestNodeInBST_Helper(TreeNode<Integer> root, int K, PriorityQueue<Integer> minHeap) {

        if (root == null) {
            return;
        }

        minHeap.add(root.getData());
        if (minHeap.size() > K) {
            minHeap.poll();
        }

        kThLargestNodeInBST_Helper(root.getLeft(), K, minHeap);
        kThLargestNodeInBST_Helper(root.getRight(), K, minHeap);
    }

    public void kTHLargestNodeInBST(TreeNode<Integer> root, int K) {
        //actual
        //inorder of BST is sorted nodes list
        inOrderTraversal_Iterative(root);

        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        kThLargestNodeInBST_Helper(root, K, minHeap);

        System.out.println(K + " largest node from BST: " + minHeap.poll());
    }

    private int kTHLargestNodeInBSTWithoutHeap_Value;
    private int kTHLargestNodeInBSTWithoutHeap_CurrK;

    public void kTHLargestNodeInBSTWithoutHeap_Helper(TreeNode<Integer> root, int K) {
        if (root == null) {
            return;
        }
        //since it a BST the larger nodes are in right sub tree so 
        //traversing the right subtree first to find the kth node
        kTHLargestNodeInBSTWithoutHeap_Helper(root.getRight(), K);

        kTHLargestNodeInBSTWithoutHeap_CurrK++;

        if (kTHLargestNodeInBSTWithoutHeap_CurrK == K) {
            kTHLargestNodeInBSTWithoutHeap_Value = root.getData();
            return;
        }
        kTHLargestNodeInBSTWithoutHeap_Helper(root.getLeft(), K);
    }

    public void kTHLargestNodeInBSTWithoutHeap(TreeNode<Integer> root, int K) {

        kTHLargestNodeInBSTWithoutHeap_CurrK = 0;
        kTHLargestNodeInBSTWithoutHeap_Value = Integer.MIN_VALUE;
        kTHLargestNodeInBSTWithoutHeap_Helper(root, K);
        System.out.println(K + " largest node from BST without heap: " + kTHLargestNodeInBSTWithoutHeap_Value);
    }

    private void kThSmallestNodeInBST_Helper(TreeNode<Integer> root, int K, PriorityQueue<Integer> maxHeap) {

        if (root == null) {
            return;
        }

        maxHeap.add(root.getData());
        if (maxHeap.size() > K) {
            maxHeap.poll();
        }

        kThSmallestNodeInBST_Helper(root.getLeft(), K, maxHeap);
        kThSmallestNodeInBST_Helper(root.getRight(), K, maxHeap);
    }

    public void kTHSmallestNodeInBST(TreeNode<Integer> root, int K) {
        //actual
        //inorder of BST is sorted nodes list
        inOrderTraversal_Iterative(root);

        //maxHeap
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(
                (o1, o2) -> o2.compareTo(o1)
        );
        kThSmallestNodeInBST_Helper(root, K, maxHeap);

        System.out.println(K + " smallest node from BST: " + maxHeap.poll());
    }

    class Height {

        int height = 0;
    }

    private boolean isTreeHeightBalanced_Helper(TreeNode root, Height currHeight) {

        //this approach calculates height and check height balanced at the same time
        if (root == null) {
            currHeight.height = -1;
            return true;
        }

        Height leftTreeHeight = new Height();
        Height rightTreeHeight = new Height();

        boolean isLeftBal = isTreeHeightBalanced_Helper(root.getLeft(), leftTreeHeight);
        boolean isRightBal = isTreeHeightBalanced_Helper(root.getRight(), rightTreeHeight);

        //calculate the height for the current node
        currHeight.height = Math.max(leftTreeHeight.height, rightTreeHeight.height) + 1;

        //checking the cond if height balanced
        //if diff b/w left subtree or right sub tree is greater than 1 it's
        //not balanced
        if (Math.abs(leftTreeHeight.height - rightTreeHeight.height) > 1) {
            return false;
        }

        //if the above cond doesn't fulfil
        //it should check if both of the left or right sub tree are balanced or not
        return isLeftBal && isRightBal;
    }

    public void isTreeHeightBalanced(TreeNode root) {
        Height h = new Height();
        System.out.println("Is tree heght  balanced: " + isTreeHeightBalanced_Helper(root, h));
    }

    public boolean checkTwoTreeAreMirror(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        return root1.getData() == root2.getData()
                && checkTwoTreeAreMirror(root1.getLeft(), root2.getRight())
                && checkTwoTreeAreMirror(root1.getRight(), root2.getLeft());
    }

    private int convertTreeToSumTree_Sum(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int lSum = convertTreeToSumTree_Sum(root.getLeft());
        int rSum = convertTreeToSumTree_Sum(root.getRight());

        return lSum + rSum + root.getData();

    }

    public void convertTreeToSumTree(TreeNode<Integer> root) {

        //actual
        BinaryTree<Integer> bt = new BinaryTree<>(root);
        bt.treeBFS();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            TreeNode<Integer> t = q.poll();

            if (t.getLeft() != null) {
                q.add(t.getLeft());
            }

            if (t.getRight() != null) {
                q.add(t.getRight());
            }

            //leaf
            if (t.getLeft() == null && t.getRight() == null) {
                t.setData(0);
                continue;
            }

            // - t.getData() just don't include the value of that node itself
            t.setData(convertTreeToSumTree_Sum(t) - t.getData());

        }

        //output
        System.out.println();
        bt = new BinaryTree<>(root);
        bt.treeBFS();
        System.out.println();

    }

    private int convertTreeToSumTree_Recursion_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int data = root.getData();

        int lSum = convertTreeToSumTree_Recursion_Helper(root.getLeft());
        int rSum = convertTreeToSumTree_Recursion_Helper(root.getRight());

        //leaf
        if (root.getLeft() == null && root.getRight() == null) {
            root.setData(0);
            return data;
        } else {
            root.setData(lSum + rSum);
            return lSum + rSum + data;
        }
    }

    public void convertTreeToSumTree_Recursion(TreeNode<Integer> root) {

        //OPTIMISED
        //actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        convertTreeToSumTree_Recursion_Helper(root);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();

    }

    List<Integer> printKSumPathAnyNodeTopToDown_PathList;

    private void printKSumPathAnyNodeTopToDown_Helper(TreeNode<Integer> root, int K) {

        if (root == null) {
            return;
        }

        printKSumPathAnyNodeTopToDown_PathList.add(root.getData());

        printKSumPathAnyNodeTopToDown_Helper(root.getLeft(), K);
        printKSumPathAnyNodeTopToDown_Helper(root.getRight(), K);

        int pathSum = 0;
        for (int i = printKSumPathAnyNodeTopToDown_PathList.size() - 1; i >= 0; i--) {

            pathSum += printKSumPathAnyNodeTopToDown_PathList.get(i);
            if (pathSum == K) {
                //print actual nodes data
                for (int j = i; j < printKSumPathAnyNodeTopToDown_PathList.size(); j++) {
                    System.out.print(printKSumPathAnyNodeTopToDown_PathList.get(j) + " ");
                }
                System.out.println();
            }
        }
        //remove current node
        printKSumPathAnyNodeTopToDown_PathList.remove(printKSumPathAnyNodeTopToDown_PathList.size() - 1);
    }

    public void printKSumPathAnyNodeTopToDown(TreeNode<Integer> root, int K) {
        printKSumPathAnyNodeTopToDown_PathList = new ArrayList<>();
        printKSumPathAnyNodeTopToDown_Helper(root, K);
    }

    private TreeNode<Integer> lowestCommonAncestorOfTree_Helper(TreeNode<Integer> root, int N1, int N2) {

        if (root == null) {
            return null;
        }

        if (N1 == root.getData() || N2 == root.getData()) {
            return root;
        }

        TreeNode<Integer> leftNode = lowestCommonAncestorOfTree_Helper(root.getLeft(), N1, N2);
        TreeNode<Integer> rightNode = lowestCommonAncestorOfTree_Helper(root.getRight(), N1, N2);

        if (leftNode != null && rightNode != null) {
            return root;
        }

        return leftNode == null ? rightNode : leftNode;

    }

    public void lowestCommonAncestorOfTree(TreeNode<Integer> root, int N1, int N2) {
        System.out.println("Lowest common ancestor of " + N1 + " " + N2 + ": " + lowestCommonAncestorOfTree_Helper(root, N1, N2));
    }

    class CheckTreeIsSumTree {

        /*Helper class for checkTreeIsSumTree_Helper method*/ int data = 0;
    }

    public boolean checkTreeIsSumTree_Helper(TreeNode<Integer> root, CheckTreeIsSumTree obj) {

        if (root == null) {
            obj.data = 0;
            return true;
        }

        CheckTreeIsSumTree leftSubTreeSum = new CheckTreeIsSumTree();
        CheckTreeIsSumTree rightSubTreeSum = new CheckTreeIsSumTree();

        boolean isLeftSubTreeSumTree = checkTreeIsSumTree_Helper(root.getLeft(), leftSubTreeSum);
        boolean isRightSubTreeSumTree = checkTreeIsSumTree_Helper(root.getRight(), rightSubTreeSum);

        //calculating data for the current root node itself
        obj.data = root.getData() + leftSubTreeSum.data + rightSubTreeSum.data;

        //current root node should not be be leaf
        if (!(root.getLeft() == null && root.getRight() == null)
                && //current root is not equal to the sum of left and rigth sub tree 
                (root.getData() != leftSubTreeSum.data + rightSubTreeSum.data)) {
            return false;
        }

        return isLeftSubTreeSumTree && isRightSubTreeSumTree;
    }

    public void checkTreeIsSumTree(TreeNode<Integer> root) {
        System.out.println("Check if a tree is sum tree: " + checkTreeIsSumTree_Helper(root, new CheckTreeIsSumTree()));
    }

    class TreeLongestPathNodeSum {

        /*Helper class for longestPathNodeSum method*/
        List<Integer> path = new ArrayList<>();
        List<Integer> nodeInLongestPath = new ArrayList<>();
        int maxLevel = 0;
        int longestPathSum = 0;
        int maxSumOfAnyPath = 0;
    }

    private void longestPathNodeSum_Helper(TreeNode<Integer> root,
            TreeLongestPathNodeSum obj, int level) {

        if (root == null) {
            return;
        }
        obj.path.add(root.getData());
        longestPathNodeSum_Helper(root.getLeft(), obj, level + 1);
        longestPathNodeSum_Helper(root.getRight(), obj, level + 1);

        int currPathSum = 0;
        //to find the max sum of any path this for() is outside of below if() block
        //otherwise only to find sum of longest path move this for() inside the if()
        //it will be optimised then
        for (int nodes : obj.path) {
            currPathSum += nodes;
        }

        if (level > obj.maxLevel) {
            obj.maxLevel = level;
            obj.longestPathSum = currPathSum;
            obj.nodeInLongestPath.clear();
            obj.nodeInLongestPath.addAll(obj.path);
        }

        obj.maxSumOfAnyPath = Math.max(obj.maxSumOfAnyPath, currPathSum);

        //remove the last added node
        obj.path.remove(obj.path.size() - 1);
    }

    public void longestPathNodeSum(TreeNode<Integer> root) {
        TreeLongestPathNodeSum obj = new TreeLongestPathNodeSum();
        longestPathNodeSum_Helper(root, obj, 0);
        System.out.println("The sum of nodes of longest path of tree: " + obj.longestPathSum);
        System.out.println("The length of longest path in the tree: " + obj.maxLevel);
        System.out.println("The nodes of longest path of tree: " + obj.nodeInLongestPath);
        System.out.println("The max sum of nodes that may occur on any path of tree: " + obj.maxSumOfAnyPath);
    }

    private void findPredecessorAndSuccessorInBST_Helper(TreeNode<Integer> root, int key, TreeNode<Integer>[] result) {

        if (root == null) {
            return;
        }

        if (root.getData() == key) {

            if (root.getLeft() != null) {
                //predecessor : rightmost node in the left subtree
                TreeNode<Integer> pred = root.getLeft();
                while (pred.getRight() != null) {
                    pred = pred.getRight();
                }
                result[0] = pred;
            }

            if (root.getRight() != null) {
                //successor : leftmost node in the right subtree
                TreeNode<Integer> succ = root.getRight();
                while (succ.getLeft() != null) {
                    succ = succ.getLeft();
                }
                result[1] = succ;
            }
            return;
        }

        //key is less than root data so move to whole left sub tree
        //ex: root = 2, key = 4
        //2 > 4 -> else
        if (key < root.getData()) {
            result[1] = root; //succ
            findPredecessorAndSuccessorInBST_Helper(root.getLeft(), key, result);
        } else {
            //else move to whole right sub tree
            //in else because 2 is not greater 4 
            //inorder of bst is sorted list [2, 4] and 2 will be pred of 4
            result[0] = root; //pred
            findPredecessorAndSuccessorInBST_Helper(root.getRight(), key, result);
        }
    }

    public void findPredecessorAndSuccessorInBST(TreeNode<Integer> root, int key) {
        //..................................T: O(H), worst case: key can be the leaf node, H = height of BST
        //..................................S: O(H), function call stack 
        //can use list also
        //[0] : predecessor, [1] : successor
        TreeNode<Integer>[] result = new TreeNode[2];
        findPredecessorAndSuccessorInBST_Helper(root, key, result);
        System.out.println("Predecessor and successor of BST: "
                + (result[0] != null ? result[0].getData() : "null") + " "
                + (result[1] != null ? result[1].getData() : "null"));

    }

    private int countNodesThatLieInGivenRange_Count = 0;

    private void countNodesThatLieInGivenRange_Helper(TreeNode<Integer> root, int low, int high) {

        if (root == null) {
            return;
        }

        if (root.getData() >= low && root.getData() <= high) {
            countNodesThatLieInGivenRange_Count++;
        }

        countNodesThatLieInGivenRange_Helper(root.getLeft(), low, high);
        countNodesThatLieInGivenRange_Helper(root.getRight(), low, high);
    }

    public void countNodesThatLieInGivenRange(TreeNode<Integer> root, int low, int high) {
        countNodesThatLieInGivenRange_Count = 0;
        countNodesThatLieInGivenRange_Helper(root, low, high);
        System.out.println("No. of nodes that lie in given range: " + countNodesThatLieInGivenRange_Count);
    }

    public void flattenBSTToLinkedList(TreeNode root) {

        //...........................T: O(N)
        //...........................S: O(N)
        if (root == null) {
            return;
        }

        /*Deque<TreeNode> dQueue = new ArrayDeque<>();
         dQueue.add(root);

         while (!dQueue.isEmpty()) {

         TreeNode curr = dQueue.removeFirst();

         if (curr.getRight() != null) {
         dQueue.addFirst(curr.getRight());
         }

         if (curr.getLeft() != null) {
         dQueue.addFirst(curr.getLeft());
         }

         if (!dQueue.isEmpty()) {
         curr.setRight(dQueue.peek());
         curr.setLeft(null);
         }

         }*/
 /*List<TreeNode> q = new ArrayList<>();
         q.add(root);
         while (!q.isEmpty()) {

         TreeNode curr = q.remove(0);

         if (curr.getRight() != null) {
         q.add(0, curr.getRight());
         }

         if (curr.getLeft() != null) {
         q.add(0, curr.getLeft());
         }

         if (!q.isEmpty()) {
         curr.setRight(q.get(0));
         curr.setLeft(null);
         }

         }*/
        //using LIFO stack
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {

            TreeNode curr = stack.pop();

            //we need left at peek of stack so pushing right first
            //and then left so that left can be at peek
            if (curr.getRight() != null) {
                stack.push(curr.getRight());
            }

            if (curr.getLeft() != null) {
                stack.push(curr.getLeft());
            }

            if (!stack.isEmpty()) {

                curr.setRight(stack.peek());
                curr.setLeft(null);
            }
        }

        //output:
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    private TreeNode flattenBSTToLinkedList_Recursion_Current;

    public void flattenBSTToLinkedList_Recursion_Helper(TreeNode root) {
        if (root == null) {
            return;
        }

        TreeNode left = root.getLeft();
        TreeNode right = root.getRight();

        if (flattenBSTToLinkedList_Recursion_Current != null) {
            flattenBSTToLinkedList_Recursion_Current.setLeft(null);
            flattenBSTToLinkedList_Recursion_Current.setRight(root);
        }

        flattenBSTToLinkedList_Recursion_Current = root;

        flattenBSTToLinkedList_Recursion_Helper(left);
        flattenBSTToLinkedList_Recursion_Helper(right);
    }

    public void flattenBSTToLinkedList_Recursion(TreeNode root) {
        //...........................T: O(N)
        //...........................S: O(1), As we are not taking extra stack other than function call stack
        flattenBSTToLinkedList_Recursion_Current = null;
        flattenBSTToLinkedList_Recursion_Helper(root);
        //output:
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    private void diagonalTraversalOfTree_Helper(TreeNode<Integer> root, int level, Map<Integer, List<Integer>> result) {

        if (root == null) {
            return;
        }

        result.putIfAbsent(level, new ArrayList<>());
        result.get(level).add(root.getData());

        diagonalTraversalOfTree_Helper(root.getLeft(), level + 1, result);
        diagonalTraversalOfTree_Helper(root.getRight(), level, result);
    }

    public void diagonalTraversalOfTree(TreeNode<Integer> root) {

        Map<Integer, List<Integer>> result = new TreeMap<>();
        diagonalTraversalOfTree_Helper(root, 0, result);
        System.out.println("Diagonal traversal of tree");
        for (Map.Entry<Integer, List<Integer>> e : result.entrySet()) {
            System.out.println(e.getValue());
        }
    }

    private int diameterOfTree_Helper(TreeNode<Integer> root, Height height) {

        if (root == null) {
            height.height = 0;
            return 0;
        }

        Height leftSubTreeHeight = new Height();
        Height rightSubTreeHeight = new Height();

        int leftTreeDiameter = diameterOfTree_Helper(root.getLeft(), leftSubTreeHeight);
        int rightTreeDiameter = diameterOfTree_Helper(root.getRight(), rightSubTreeHeight);

        //current node height
        height.height = Math.max(leftSubTreeHeight.height, rightSubTreeHeight.height) + 1;

        return Math.max(
                Math.max(leftTreeDiameter, rightTreeDiameter),
                leftSubTreeHeight.height + rightSubTreeHeight.height + 1
        );
    }

    public void diameterOfTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/diameter-of-binary-tree/
        //https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/
        //gives the total no of nodes forming that diameter
        System.out.println("Diameter of tree: " + diameterOfTree_Helper(root, new Height()));
        //gives the no. of edges between these nodes
        System.out.println("Diameter of tree: " + (diameterOfTree_Helper(root, new Height()) - 1));
    }

    class CheckIfBinaryTreeIsMaxHeapClass {

        /*Helper class for checkIfBinaryTreeIsMaxHeap method*/
        int data;
    }

    private boolean checkIfBinaryTreeIsMaxHeap_Helper(TreeNode<Integer> root, CheckIfBinaryTreeIsMaxHeapClass obj) {

        if (root == null) {
            obj.data = Integer.MIN_VALUE;
            return true;
        }

        CheckIfBinaryTreeIsMaxHeapClass leftSubTree = new CheckIfBinaryTreeIsMaxHeapClass();
        CheckIfBinaryTreeIsMaxHeapClass rightSubTree = new CheckIfBinaryTreeIsMaxHeapClass();

        boolean isLeftMaxHeap = checkIfBinaryTreeIsMaxHeap_Helper(root.getLeft(), leftSubTree);
        boolean isRightMaxHeap = checkIfBinaryTreeIsMaxHeap_Helper(root.getRight(), rightSubTree);

        //calculating current node's object
        obj.data = root.getData();

        //if root's data is less than its immediate left OR right child return false
        if (root.getData() < leftSubTree.data || root.getData() < rightSubTree.data) {
            return false;
        }

        return isLeftMaxHeap && isRightMaxHeap;
    }

    public void checkIfBinaryTreeIsMaxHeap(TreeNode<Integer> root) {
        System.out.println("Given binary tree is max heap: "
                + checkIfBinaryTreeIsMaxHeap_Helper(root, new CheckIfBinaryTreeIsMaxHeapClass()));
    }

    public boolean checkIfAllLevelsOfTwoTreesAreAnagrams_1(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        //this approach performs level order traversal first and then anagrams checking
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        Map<Integer, List<Integer>> levelOrder1 = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root1, 0, levelOrder1); //T: O(N)

        Map<Integer, List<Integer>> levelOrder2 = new TreeMap<>();
        levelOrderTraversal_Recursive_Helper(root2, 0, levelOrder2); //T: O(N)

        //if both tree are of different levels then two trees acn't be anagrams
        if (levelOrder1.size() != levelOrder2.size()) {
            return false;
        }

        //T: O(H) H = height of tree
        for (int level = 0; level < levelOrder1.size(); level++) {

            List<Integer> l1 = levelOrder1.get(level);
            List<Integer> l2 = levelOrder2.get(level);

            //sort: T: O(Logl1) + O(Logl2)
            Collections.sort(l1);
            Collections.sort(l2);

            //if levels of two trees after sorting are not equal then they are not anagram
            //ex l1.sort: [2,3], l2.sort: [3,4] then l1 != l2
            if (!l1.equals(l2)) {
                return false;
            }
        }

        return true;
    }

    public boolean checkIfAllLevelsOfTwoTreesAreAnagrams_2(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        //this approach performs level order traversal and anagrams checking at the same time
        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        Queue<TreeNode<Integer>> q1 = new LinkedList<>();
        Queue<TreeNode<Integer>> q2 = new LinkedList<>();
        q1.add(root1);
        q2.add(root2);

        Queue<TreeNode<Integer>> intQ1 = new LinkedList<>();
        Queue<TreeNode<Integer>> intQ2 = new LinkedList<>();

        List<Integer> l1 = new ArrayList<>();
        List<Integer> l2 = new ArrayList<>();

        while (!q1.isEmpty() && !q2.isEmpty()) {

            TreeNode<Integer> curr1 = q1.poll();
            TreeNode<Integer> curr2 = q2.poll();

            l1.add(curr1.getData());
            l2.add(curr2.getData());

            if (curr1.getLeft() != null) {
                intQ1.add(curr1.getLeft());
            }

            if (curr1.getRight() != null) {
                intQ1.add(curr1.getRight());
            }

            if (curr2.getLeft() != null) {
                intQ2.add(curr2.getLeft());
            }

            if (curr2.getRight() != null) {
                intQ2.add(curr2.getRight());
            }

            if (q1.isEmpty() && q2.isEmpty()) {

                Collections.sort(l1);
                Collections.sort(l2);

                //if after sorting the nodes at a paticular level from both
                //the tree are not equal
                //ex l1.sort: [2,3], l2.sort: [3,4] then l1 != l2
                if (!l1.equals(l2)) {
                    return false;
                }

                l1.clear();
                l2.clear();

                //intQ holds the immediate child nodes of a parent node
                //if the no. of immediate child nodes are different then further 
                //checking for anagrams are not req.
                //ex T1: 1.left = 2, 1.right = 3
                //T2: 1.left = 2
                //at parent node = 1 intQ will hold immediate childs
                //intQ1 = [2,3], intQ2 = [2] here intQ1.size != intQ2.size
                if (intQ1.size() != intQ2.size()) {
                    return false;
                }

                q1.addAll(intQ1);
                q2.addAll(intQ2);

                intQ1.clear();
                intQ2.clear();
            }
        }

        //if none of the cond in while is false then all the levels in both tree are anagrams
        return true;
    }

    private boolean areTwoTreeIsoMorphic_Helper(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        if (root1 == null && root2 == null) {
            return true;
        }

        if (root1 == null || root2 == null) {
            return false;
        }

        return root1.getData() == root2.getData()
                && ((areTwoTreeIsoMorphic_Helper(root1.getLeft(), root2.getRight()) && areTwoTreeIsoMorphic_Helper(root1.getRight(), root2.getLeft()))
                || (areTwoTreeIsoMorphic_Helper(root1.getLeft(), root2.getLeft()) && areTwoTreeIsoMorphic_Helper(root1.getRight(), root2.getRight())));
    }

    public boolean areTwoTreeIsoMorphic(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        return areTwoTreeIsoMorphic_Helper(root1, root2);
    }

    private String findDuplicateSubtreeInAGivenTree_Inorder(TreeNode<Integer> root,
            Map<String, Integer> map, List<TreeNode<Integer>> subtrees) {

        if (root == null) {
            return "";
        }

        String str = "(";
        str += findDuplicateSubtreeInAGivenTree_Inorder(root.getLeft(), map, subtrees);
        str += String.valueOf(root.getData());
        str += findDuplicateSubtreeInAGivenTree_Inorder(root.getRight(), map, subtrees);
        str += ")";

//        System.out.println(str);
        if (map.containsKey(str) && map.get(str) == 1) {
            //System.out.println(root.getData()+ " "); //print the starting node of suplicate subtree
            subtrees.add(root);
        }

        map.put(str, map.getOrDefault(str, 0) + 1);

        return str;
    }

    public void findDuplicateSubtreeInAGivenTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/construct-string-from-binary-tree/
        Map<String, Integer> map = new HashMap<>();
        List<TreeNode<Integer>> subtrees = new ArrayList<>();
        findDuplicateSubtreeInAGivenTree_Inorder(root, map, subtrees);

        //output:
        //print level order of found subtrees
        for (TreeNode<Integer> tree : subtrees) {
            levelOrderTraversal_Recursive(tree);
        }
    }

    private void allNodesAtKDistanceFromRoot(TreeNode<Integer> root, int level,
            int K, List<Integer> result) {

        if (root == null) {
            return;
        }

        if (level == K) {
            result.add(root.getData());
        }

        allNodesAtKDistanceFromRoot(root.getLeft(), level + 1, K, result);
        allNodesAtKDistanceFromRoot(root.getRight(), level + 1, K, result);
    }

    private int printAllTheNodesAtKDistanceFromTargetNode_DFS(TreeNode<Integer> root, int target,
            int K, List<Integer> result) {

        if (root == null) {
            return -1;
        }

        if (root.getData() == target) {
            //search all the nodes at K dist below the target node
            allNodesAtKDistanceFromRoot(root, 0, K, result);
            return 1;
        }

        int left = printAllTheNodesAtKDistanceFromTargetNode_DFS(root.getLeft(), target, K, result);

        if (left != -1) {
            if (left == K) {
                result.add(root.getData());
                return -1;
            }
            allNodesAtKDistanceFromRoot(root.getRight(), left + 1, K, result);
            return left + 1;
        }

        int right = printAllTheNodesAtKDistanceFromTargetNode_DFS(root.getRight(), target, K, result);

        if (right != -1) {
            if (right == K) {
                result.add(root.getData());
                return -1;
            }
            allNodesAtKDistanceFromRoot(root.getLeft(), right + 1, K, result);
            return right + 1;
        }

        return -1;
    }

    public void printAllTheNodesAtKDistanceFromTargetNode(TreeNode<Integer> root, int target, int K) {

        List<Integer> result = new ArrayList<>();
        printAllTheNodesAtKDistanceFromTargetNode_DFS(root, target, K, result);
        //output:
        System.out.println("All nodes at K distance from target node: " + result);
    }

    private boolean deleteTreeNodesAndReturnForest_Helper(TreeNode<Integer> root,
            Set<Integer> deleteSet, List<TreeNode<Integer>> result) {

        if (root == null) {
            return false;
        }

        boolean deleteLeft = deleteTreeNodesAndReturnForest_Helper(root.getLeft(), deleteSet, result);
        boolean deleteRight = deleteTreeNodesAndReturnForest_Helper(root.getRight(), deleteSet, result);

        if (deleteLeft) {
            root.setLeft(null);
        }

        if (deleteRight) {
            root.setRight(null);
        }

        if (deleteSet.contains(root.getData())) {

            if (root.getLeft() != null) {
                result.add(root.getLeft());
            }

            if (root.getRight() != null) {
                result.add(root.getRight());
            }
            return true;
        }

        return deleteLeft && deleteRight && deleteSet.contains(root.getData());

    }

    private TreeNode<Integer> deleteTreeNodesAndReturnForest_Helper2(TreeNode<Integer> root,
            Set<Integer> deleteSet, List<TreeNode<Integer>> result) {

        //Easier explanation
        if (root == null) {
            return null;
        }

        root.setLeft(deleteTreeNodesAndReturnForest_Helper2(root.getLeft(), deleteSet, result));
        root.setRight(deleteTreeNodesAndReturnForest_Helper2(root.getRight(), deleteSet, result));

        if (deleteSet.contains(root.getData())) {

            if (root.getLeft() != null) {
                result.add(root.getLeft());
            }

            if (root.getRight() != null) {
                result.add(root.getRight());
            }

            return null;
        }

        return root;
    }

    public void deleteTreeNodesAndReturnForest(TreeNode<Integer> root, int[] toDelete) {

        List<TreeNode<Integer>> result = new ArrayList<>();

        if (root == null) {
            return;
        }

        Set<Integer> deleteSet = new HashSet<>();
        for (int x : toDelete) {
            deleteSet.add(x);
        }

//        boolean res = deleteTreeNodesAndReturnForest_Helper(root, deleteSet, result);
//
//        if (res == false || (res && !deleteSet.contains(root.getData()))) {
//            result.add(root);
//        }
        //Easier explanation
        //if curr root is not in delete set then root node is also a forest
        if (!deleteSet.contains(root.getData())) {
            result.add(root);
        }
        root = deleteTreeNodesAndReturnForest_Helper2(root, deleteSet, result);

        //output:
        for (TreeNode<Integer> curr : result) {
            levelOrderTraversal_Iterative(curr);
            System.out.println();
        }
    }

    private TreeNode<Integer> constructBinaryTreeFromInorderPreorderArray_Helper(
            int preIndex, int inStart, int inEnd, Map<Integer, Integer> inorderMap, int[] preorder) {

        if (preIndex >= preorder.length || inStart > inEnd) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(preorder[preIndex]);

        int index = inorderMap.get(preorder[preIndex]);

        root.setLeft(constructBinaryTreeFromInorderPreorderArray_Helper(
                preIndex + 1, inStart, index - 1, inorderMap, preorder));
        root.setRight(constructBinaryTreeFromInorderPreorderArray_Helper(
                preIndex + 1 + (index - inStart), index + 1, inEnd, inorderMap, preorder));

        return root;
    }

    public void constructBinaryTreeFromInorderPreorderArray(int[] inorder, int[] preorder) {

        System.out.println("Inorder & Preorder");
        if (inorder.length != preorder.length) {
            return;
        }

        int n = inorder.length;

        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            inorderMap.put(inorder[i], i);
        }

        TreeNode<Integer> root = constructBinaryTreeFromInorderPreorderArray_Helper(
                0, 0, n - 1, inorderMap, preorder);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> constructBinaryTreeFromInorderPostorderArray_Helper(
            int[] postorder, int postIndex, int inStart, int inEnd,
            Map<Integer, Integer> inorderMap) {
        if (inStart > inEnd || postIndex < 0 || postIndex > postorder.length) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(postorder[postIndex]);
        int index = inorderMap.get(postorder[postIndex]);

        root.setLeft(constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder,
                // current root minus what's on the right side on the inorder array minus 1
                postIndex - (inEnd - index) - 1,
                inStart,
                index - 1,
                inorderMap
        ));

        root.setRight(constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder,
                // the next right side node will be the next one (backwards) on the postorder list
                postIndex - 1,
                index + 1,
                inEnd,
                inorderMap
        ));

        return root;
    }

    public void constructBinaryTreeFromInorderPostorderArray(int[] inorder, int[] postorder) {
        //https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
        System.out.println("Inorder & Postorder");
        if (inorder.length != postorder.length) {
            return;
        }

        int n = inorder.length;
        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < n; i++) {
            inorderMap.put(inorder[i], i);
        }

        TreeNode<Integer> root = constructBinaryTreeFromInorderPostorderArray_Helper(
                postorder, n - 1, 0, n - 1, inorderMap);

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> constructBinarySearchTreeFromPreorderArray_Helper(int[] preorder, int preStart, int preEnd) {

        if (preStart > preEnd) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(preorder[preStart]);

        int index = preStart + 1;
        while (index <= preEnd && preorder[index] < preorder[preStart]) {
            index++;
        }

        root.setLeft(constructBinarySearchTreeFromPreorderArray_Helper(preorder, preStart + 1, index - 1));
        root.setRight(constructBinarySearchTreeFromPreorderArray_Helper(preorder, index, preEnd));

        return root;
    }

    public void constructBinarySearchTreeFromPreorderArray(int[] preorder) {

        int n = preorder.length;
        TreeNode<Integer> root = constructBinarySearchTreeFromPreorderArray_Helper(preorder, 0, n - 1);

        //output:
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> constructBinarySearchTreeFromPostorderArray_Helper(
            int[] postorder, int postStart, int postEnd) {

        if (postEnd > postStart) {
            return null;
        }

        TreeNode<Integer> root = new TreeNode<>(postorder[postStart]);

        int index = postStart - 1;
        while (index >= postEnd && postorder[index] > postorder[postStart]) {
            index--;
        }

        root.setLeft(constructBinarySearchTreeFromPostorderArray_Helper(postorder, index, postEnd));
        root.setRight(constructBinarySearchTreeFromPostorderArray_Helper(postorder, postStart - 1, index + 1));

        return root;
    }

    public void constructBinarySearchTreeFromPostorderArray(int[] postorder) {

        int n = postorder.length;
        TreeNode<Integer> root = constructBinarySearchTreeFromPostorderArray_Helper(postorder, n - 1, 0);

        //output:
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL;
    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev;

    private TreeNode<Integer> leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return null;
        }

        TreeNode<Integer> leftChild = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root.getLeft());
        TreeNode<Integer> rightChild = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root.getRight());

        //isLeaf condition
        if (root.getLeft() == null && root.getRight() == null) {

            //left most leaf node
            if (leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL == null) {
                leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL = root;
            }

            if (leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev != null) {
                leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev.setRight(root);
                root.setLeft(leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev);
            }

            leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev = root;

            return null; //to delete leaf, return null to its parent
        }

        //setting current root's left and right child below the isLeaf condition
        //because if we add these child before that condition, current root can become
        //a leaf node itself just before the isLeaf check and in that condition
        //that root will be considered as leaf
        /*
         treeBFS = 2,3,4; 
         3 & 4 are leaf; 
         inside isLeaf cond it will return null to its parent (i.e, 2);
         now if 2.left = null & 2.right = null is before isLeaf the 2 will be
         a leaf itself, which should never be the checked;
         thats why root.left = leftChild & root.right = rightChild should be below
         isLeaf cond to save the parent/intermediate node;
         */
        root.setLeft(leftChild);
        root.setRight(rightChild);

        return root;
    }

    public void leavesOfTreeToDoublyLinkedListAndRemoveLeaves(TreeNode<Integer> root) {

        //actual
        System.out.println("Actual tree");
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();

        leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL = null;
        leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Prev = null;

        //in case if root node is single node,that must be head of DLL and should be deleted(set to null)
        //otherwise it will just return root itselt
        root = leavesOfTreeToDoublyLinkedListAndRemoveLeaves_Helper(root);

        //output;
        System.out.println("Leaf of tree are now DLL");
        treeToDoublyLinkedList_Print(leavesOfTreeToDoublyLinkedListAndRemoveLeaves_DLL);
        System.out.println("Tree after deleting leaf");
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private void checkIfTwoNAryTreeAreMirror_PushStack(List<List<Integer>> tree1, Stack<Integer> stack, int root) {

        if (tree1.size() == 0) {
            return;
        }

        stack.push(root);
        List<Integer> childs = tree1.get(root);
        for (int childNodes : childs) {
            checkIfTwoNAryTreeAreMirror_PushStack(tree1, stack, childNodes);
        }
    }

    private void checkIfTwoNAryTreeAreMirror_PushQueue(List<List<Integer>> tree2, Queue<Integer> queue, int root) {

        if (tree2.size() == 0) {
            return;
        }

        List<Integer> childs = tree2.get(root);
        for (int childNodes : childs) {
            checkIfTwoNAryTreeAreMirror_PushQueue(tree2, queue, childNodes);
        }
        queue.add(root);
    }

    public boolean checkIfTwoNAryTreeAreMirror(List<List<Integer>> tree1, List<List<Integer>> tree2) {

        //Explanation: https://youtu.be/UGzXSDZv-SY
        Stack<Integer> stack = new Stack<>();
        checkIfTwoNAryTreeAreMirror_PushStack(tree1, stack, 0);

        Queue<Integer> queue = new LinkedList<>();
        checkIfTwoNAryTreeAreMirror_PushQueue(tree2, queue, 0);

//        System.out.println(stack+"---"+queue);
        if (stack.size() != queue.size()) {
            System.out.println("Not a mirror images");
            return false;
        }

        while (!stack.isEmpty() && !queue.isEmpty()) {
            if (stack.pop() != queue.poll()) {
                return false;
            }
        }
        return true;
    }

    public void deepestLeavesSumOfTree_Iterative(TreeNode<Integer> root) {

//        base edge case
//        if(root == null){
//            return 0;
//        }
        //do level order traversal
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        int sum = 0;
        while (!q.isEmpty()) {

            sum = 0;

            //size of queue at a particular level is required beforehand
            //because we putting the child of curr node in the queue
            //we don't want those nodes to be consumed in the for() loop
            int size = q.size();
            for (int i = 0; i < size; i++) {

                //add up all the nodes at a particular level in the sum variable
                //and at the same time add the chiild nodes of curr node into queue
                TreeNode<Integer> curr = q.poll();

                sum += curr.getData();
                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
        }

        //output:
        System.out.println("Deepest leaves sum: " + sum);
    }

    private void smallestStringInTreeFromLeafToRoot_Helper(TreeNode<Integer> root, StringBuilder sb,
            PriorityQueue<String> strs) {

        if (root == null) {
            return;
        }

        sb.insert(0, (char) (root.getData() + 'a'));

        smallestStringInTreeFromLeafToRoot_Helper(root.getLeft(), sb, strs);
        smallestStringInTreeFromLeafToRoot_Helper(root.getRight(), sb, strs);

        if (root.getLeft() == null && root.getRight() == null) {
            strs.add(sb.toString());
            //we only need 1 string as answer
            if (strs.size() > 1) {
                strs.poll();
            }
        }

        sb.deleteCharAt(0);
    }

    public void smallestStringInTreeFromLeafToRoot(TreeNode<Integer> root) {

        //each nodes contains value 0 - 25 representing alphabets a - z
        //find the lexicographically smallest string (leaf to root) in the tree
        StringBuilder sb = new StringBuilder();
        //making maxHeap to store smallest string in the last of heap
        PriorityQueue<String> strs = new PriorityQueue<>((a, b) -> b.compareTo(a));
        smallestStringInTreeFromLeafToRoot_Helper(root, sb, strs);

        //output
        System.out.println("Smallest string: " + strs.peek());
    }

    private void printSumWhereRootToLeafPathIsANumber_createNumberHelper(TreeNode<Integer> root, int num, List<Integer> nums) {

        if (root == null) {
            return;
        }

        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root.getLeft(), num * 10 + root.getData(), nums);
        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root.getRight(), num * 10 + root.getData(), nums);

        if (root.getLeft() == null && root.getRight() == null) {
            nums.add(num * 10 + root.getData());
        }
    }

    public void printSumWhereRootToLeafPathIsANumber(TreeNode<Integer> root) {

        //ex: 
        /* root:
         1
         2       3
         */
        //num1 = 12 (as 1->2 is a path)
        //num2 = 13 (as 1->3 is a path)
        //each path from root to leaf is a separate num
        //print sum of all such number
        List<Integer> nums = new ArrayList<>();
        printSumWhereRootToLeafPathIsANumber_createNumberHelper(root, 0, nums);

        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        //output:
        System.out.println("Sum of path of tree representing as a number: " + sum);
    }

    private void fixTwoSwappedNodesInBST_Helper_IsBST(TreeNode<Integer> root) {
        if (root == null) {
            return;
        }

        fixTwoSwappedNodesInBST_Helper_IsBST(root.getLeft());

        if (fixTwoSwappedNodesInBST_Prev != null && fixTwoSwappedNodesInBST_Prev.getData() > root.getData()) {

            if (fixTwoSwappedNodesInBST_First == null) {
                fixTwoSwappedNodesInBST_First = fixTwoSwappedNodesInBST_Prev;
                fixTwoSwappedNodesInBST_Middle = root;
            } else {
                fixTwoSwappedNodesInBST_Last = root;
            }
        }

        fixTwoSwappedNodesInBST_Prev = root;

        fixTwoSwappedNodesInBST_Helper_IsBST(root.getRight());
    }

    private void fixTwoSwappedNodesInBST_Helper(TreeNode<Integer> root) {

        fixTwoSwappedNodesInBST_First = null;
        fixTwoSwappedNodesInBST_Middle = null;
        fixTwoSwappedNodesInBST_Last = null;
        fixTwoSwappedNodesInBST_Prev = null;

        fixTwoSwappedNodesInBST_Helper_IsBST(root);

        if (fixTwoSwappedNodesInBST_First != null && fixTwoSwappedNodesInBST_Last != null) {
            int temp = fixTwoSwappedNodesInBST_First.getData();
            fixTwoSwappedNodesInBST_First.setData(fixTwoSwappedNodesInBST_Last.getData());
            fixTwoSwappedNodesInBST_Last.setData(temp);
        } else if (fixTwoSwappedNodesInBST_First != null && fixTwoSwappedNodesInBST_Middle != null) {
            int temp = fixTwoSwappedNodesInBST_First.getData();
            fixTwoSwappedNodesInBST_First.setData(fixTwoSwappedNodesInBST_Middle.getData());
            fixTwoSwappedNodesInBST_Middle.setData(temp);
        }
    }

    TreeNode<Integer> fixTwoSwappedNodesInBST_First;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Middle;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Last;
    TreeNode<Integer> fixTwoSwappedNodesInBST_Prev;

    public void fixTwoSwappedNodesInBST(TreeNode<Integer> root) {

        //https://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/
        //actual
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();

        fixTwoSwappedNodesInBST_Helper(root);

        //output
        new BinaryTree<Integer>(root).treeInorder();
        System.out.println();
    }

    private TreeNode<Integer> mergeTwoBinaryTree_Heleper(TreeNode<Integer> root1, TreeNode<Integer> root2) {

        if (root1 == null) {
            return root2;
        }

        if (root2 == null) {
            return root1;
        }

        root1.setData(root1.getData() + root2.getData());

        root1.setLeft(mergeTwoBinaryTree_Heleper(root1.getLeft(), root2.getLeft()));
        root1.setRight(mergeTwoBinaryTree_Heleper(root1.getRight(), root2.getRight()));

        return root1;
    }

    public void mergeTwoBinaryTree(TreeNode<Integer> root1, TreeNode<Integer> root2) {
        //actual
        System.out.println("Actual trees");
        new BinaryTree<Integer>(root1).treeBFS();
        System.out.println();
        new BinaryTree<Integer>(root2).treeBFS();
        System.out.println();

        mergeTwoBinaryTree_Heleper(root1, root2);

        //output
        System.out.println("Merged both trees in tree1");
        new BinaryTree<Integer>(root1).treeBFS();
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_Factorial(long N) {
        long result = 1;
        for (long i = 1; i <= N; i++) {
            result *= i;
        }

        return result;
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_BinomialCoeff(long N, long K) {
        long result = 1;

        if (K > N - K) {
            K = N - K;
        }

        for (long i = 0; i < K; i++) {
            result *= (N - i);
            result /= (i + 1);
        }

        return result;
    }

    private long numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(long N) {

        //Catalan number series:
        //https://www.youtube.com/watch?v=CMaZ69P1bAc
        //https://www.geeksforgeeks.org/program-nth-catalan-number/
        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
        long cat = numberOfWaysToCreateBSTAndBTWithGivenN_BinomialCoeff(2 * N, N);
        return cat / (N + 1);
    }

    public void numberOfWaysToCreateBSTAndBTWithGivenN(long N) {

        //problem: https://leetcode.com/problems/unique-binary-search-trees
        //Explanation :
        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
        //ways to create BST
        //find the catalan number of given Nth number 
        System.out.println("Number of ways to create a binary search tree with given N nodes: "
                + numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(N));

        //ways to create BT
        //find the catalan number of given Nth number * factorial(N)
        System.out.println("Number of ways to create a binary tree with given N nodes: "
                + (numberOfWaysToCreateBSTAndBTWithGivenN_CatalanNumberOfGivenNthNumber(N)
                * numberOfWaysToCreateBSTAndBTWithGivenN_Factorial(N)));
    }

    public boolean checkIfBinaryTreeIsCompleteOrNot(TreeNode<Integer> root) {

        //explanation: https://youtu.be/j16cwbLEf9w
        //complete binary tree:
        /*
         In a complete binary tree, every level, except possibly the last, 
         is completely filled, and all nodes in the last level are as far left 
         as possible. It can have between 1 and 2^h nodes inclusive at the 
         last level h.
         */
        //all the nodes at last level should be left-most alinged
        //if any null is present before the very last node at the level
        //that means tree is not complete binary tree
        boolean isNullBeforeLastNode = false;

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            TreeNode<Integer> curr = q.poll();

            if (curr == null) {
                isNullBeforeLastNode = true;
            } else {
                if (isNullBeforeLastNode) {
                    return false;
                }
                //put all the left and right child nodes as it is
                //without checking for null
                q.add(curr.getLeft());
                q.add(curr.getRight());
            }
        }
        return true;
    }

    private void maximumWidthOfBinaryTree_Helper(TreeNode<Integer> root, int level,
            int position, Map<Integer, Integer> map) {
        if (root == null) {
            return;
        }

        map.putIfAbsent(level, position);
        maximumWidthOfBinaryTree_MaxWidth = Math.max(maximumWidthOfBinaryTree_MaxWidth,
                position - map.get(level) + 1);

        maximumWidthOfBinaryTree_Helper(root.getLeft(), level + 1, 2 * position, map);
        maximumWidthOfBinaryTree_Helper(root.getRight(), level + 1, 2 * position + 1, map);
    }

    int maximumWidthOfBinaryTree_MaxWidth;

    public void maximumWidthOfBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-width-of-binary-tree/description/
        //explanation: https://youtu.be/FPzLE2L7uHs | https://youtu.be/sm4UdCO2868
        maximumWidthOfBinaryTree_MaxWidth = 0;
        Map<Integer, Integer> map = new HashMap<>();
        maximumWidthOfBinaryTree_Helper(root, 0, 1, map);

        //output
        System.out.println("Max Width of binary tree: " + maximumWidthOfBinaryTree_MaxWidth);
    }

    private int distributeCoinsInBinaryTree_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return 0;
        }

        int leftDistributionMove = distributeCoinsInBinaryTree_Helper(root.getLeft());
        int rightDistributionMove = distributeCoinsInBinaryTree_Helper(root.getRight());

        distributeCoinsInBinaryTree_Moves += (Math.abs(leftDistributionMove) + Math.abs(rightDistributionMove));

        return root.getData() + leftDistributionMove + rightDistributionMove - 1;
    }

    int distributeCoinsInBinaryTree_Moves;

    public void distributeCoinsInBinaryTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/distribute-coins-in-binary-tree/
        //explanation: https://youtu.be/MfXxic8IhkI
        //coins = root.data, distribution rule: parent to child OR child to parent
        distributeCoinsInBinaryTree_Moves = 0;
        distributeCoinsInBinaryTree_Helper(root);

        //output:
        System.out.println("Number of moves to distribute coins equally in whole tree: " + distributeCoinsInBinaryTree_Moves);
    }

    public boolean checkIfBinaryTreeIsOddEvenTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/even-odd-tree
        int level = 0;
        TreeNode<Integer> prev = null;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            prev = null; //reset
            int size = q.size();

            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();
                if (level % 2 == 0) {
                    //level = EVEN then nodes at this level should have 
                    //all odd data and nodes at this level should be in strictly incr order
                    if (curr.getData() % 2 == 0 || (prev != null && prev.getData() >= curr.getData())) {
                        return false;
                    }
                } else {
                    //level = ODD then nodes at this level should have 
                    //all even data and nodes at this level should be in strictly decr order
                    if (curr.getData() % 2 == 1 || (prev != null && prev.getData() <= curr.getData())) {
                        return false;
                    }
                }

                prev = curr;

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }

            level++;
        }
        return true;
    }

    private int maxSumInAnyPathOfTree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int leftSum = Math.max(0, maxSumInAnyPathOfTree_Helper(root.getLeft()));
        int rightSum = Math.max(0, maxSumInAnyPathOfTree_Helper(root.getRight()));

        maxSumInAnyPathOfTree_MaxPathSum = Math.max(maxSumInAnyPathOfTree_MaxPathSum,
                leftSum + rightSum + root.getData());

        return Math.max(leftSum, rightSum) + root.getData();
    }

    int maxSumInAnyPathOfTree_MaxPathSum;

    public void maxSumInAnyPathOfTree(TreeNode<Integer> root) {

        //SIMILAR to diameter of tree approach
        //https://leetcode.com/problems/binary-tree-maximum-path-sum/
        //explanation: https://youtu.be/mOdetMWwtoI
        maxSumInAnyPathOfTree_MaxPathSum = Integer.MIN_VALUE;
        maxSumInAnyPathOfTree_Helper(root);

        //output
        System.out.println("Max path sum in any path of tree: " + maxSumInAnyPathOfTree_MaxPathSum);
    }

    private int longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return 0;
        }

        int left = longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root.getLeft());
        int right = longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root.getRight());

        int leftEdge = 0;
        if (root.getLeft() != null && root.getLeft().getData() == root.getData()) {
            leftEdge += left + 1;
        }

        int rightEdge = 0;
        if (root.getRight() != null && root.getRight().getData() == root.getData()) {
            rightEdge += right + 1;
        }

        longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge = Math.max(longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge,
                leftEdge + rightEdge);

        return Math.max(leftEdge, rightEdge);
    }

    int longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge;

    public void longestEdgeLengthBetweenTreeNodesWithSameValue(TreeNode<Integer> root) {

        //https://leetcode.com/problems/longest-univalue-path/
        longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge = 0;
        longestEdgeLengthBetweenTreeNodesWithSameValue_Helper(root);

        //output
        System.out.println("Longest edge between the nodes having same values: " + longestEdgeLengthBetweenTreeNodesWithSameValue_LongestEdge);
    }

    private int countNodesInCompleteBinaryTree_LeftTreeHeight(TreeNode<Integer> root) {
        int height = 0;
        while (root != null) {
            height++;
            root = root.getLeft();
        }
        return height;
    }

    private int countNodesInCompleteBinaryTree_RightTreeHeight(TreeNode<Integer> root) {
        int height = 0;
        while (root != null) {
            height++;
            root = root.getRight();
        }
        return height;
    }

    public int countNodesInCompleteBinaryTree(TreeNode<Integer> root) {

        //brute force do levelorder and count++ for all the nodes T: O(N)
        //OPTIMISED
        //https://leetcode.com/problems/count-complete-tree-nodes/
        if (root == null) {
            return 0;
        }

        int leftSubtreeHeight = countNodesInCompleteBinaryTree_LeftTreeHeight(root);
        int rightSubtreeHeight = countNodesInCompleteBinaryTree_RightTreeHeight(root);

        if (leftSubtreeHeight == rightSubtreeHeight) {
            //number of node in complete binary tree = (2^H) - 1
            return (int) Math.pow(2, leftSubtreeHeight) - 1;
        }

        return countNodesInCompleteBinaryTree(root.getLeft())
                + countNodesInCompleteBinaryTree(root.getRight()) + 1;
    }

    public int countGoodNodesInBinaryTree_1(TreeNode<Integer> root, int max) {

        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
        /*
         Given a binary tree root, a node X in the tree is named good if in the 
         path from root to X there are no nodes with a value greater than X.
         */
        if (root == null) {
            return 0;
        }

        int left = countGoodNodesInBinaryTree_1(root.getLeft(), Math.max(max, root.getData()));
        int right = countGoodNodesInBinaryTree_1(root.getRight(), Math.max(max, root.getData()));

        if (root.getData() < max) {
            //curr node is not a goodNode but it can have 
            //max (curr goodNode(i.e 0), left sub tree gootNodes + right sub tree gooNodes)
            return Math.max(0, left + right);
        }

        //left sub tree goodNodes + right sub tree goodNodes + curr root goodNode(i.e 1) 
        return left + right + 1;
    }

    private void countGoodNodesInBinaryTree_2_Helper(TreeNode<Integer> root, int max) {

        if (root == null) {
            return;
        }

        countGoodNodesInBinaryTree_2_Helper(root.getLeft(), Math.max(max, root.getData()));
        countGoodNodesInBinaryTree_2_Helper(root.getRight(), Math.max(max, root.getData()));

        if (root.getData() >= max) {
            countGoodNodesInBinaryTree_2_GoodNodes++;
        }
    }

    int countGoodNodesInBinaryTree_2_GoodNodes = 0;

    public void countGoodNodesInBinaryTree_2(TreeNode<Integer> root) {

        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
        /*
         Given a binary tree root, a node X in the tree is named good if in the 
         path from root to X there are no nodes with a value greater than X.
         */
        //EASIER APPROACH
        countGoodNodesInBinaryTree_2_GoodNodes = 0;
        countGoodNodesInBinaryTree_2_Helper(root, Integer.MIN_VALUE);

        //output
        System.out.println("Good nodes counts in tree approach 2: " + countGoodNodesInBinaryTree_2_GoodNodes);
    }

    private int minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(TreeNode<Integer> root, int N, int level) {

        if (root == null) {
            return -1;
        }

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();

                if (curr.getData() == N) {
                    return level;
                }

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
            level++;
        }
        return -1;
    }

    public void minDistanceBetweenGivenTwoNodesInBinaryTree(TreeNode<Integer> root, int N1, int N2) {

        //https://www.geeksforgeeks.org/find-distance-between-two-nodes-of-a-binary-tree/
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, N1, N2);

        int levelN1 = minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(lca, N1, 0);
        int levelN2 = minDistanceBetweenGivenTwoNodesInBinaryTree_FindLevelFromLCA(lca, N2, 0);

        System.out.println("Min dstance between two given nodes: " + (levelN1 + levelN2));
    }

    private void maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(TreeNode<Integer> root) {
        if (root == null) {
            return;
        }

        maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum += root.getData();

        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root.getLeft());
        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root.getRight());
    }

    private int maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(TreeNode<Integer> root) {

        if (root == null) {
            return 0;
        }

        int leftSubTreeSum = maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root.getLeft());
        int rightSubTreeSum = maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root.getRight());

        int leftSplitProduct = (maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum - leftSubTreeSum) * leftSubTreeSum;
        int rightSplitProduct = (maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum - rightSubTreeSum) * rightSubTreeSum;

        maxProductIfBinaryTreeIsSplitIntoTwo_Product = Math.max(maxProductIfBinaryTreeIsSplitIntoTwo_Product,
                Math.max(leftSplitProduct, rightSplitProduct));

        return leftSubTreeSum + rightSubTreeSum + root.getData(); //sub-tree sum from bottom
    }

    int maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum = 0;
    int maxProductIfBinaryTreeIsSplitIntoTwo_Product = 0;

    public void maxProductIfBinaryTreeIsSplitIntoTwo(TreeNode<Integer> root) {

        //https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
        /*
        
         treeBFS = [1,2,3,4,5,6,NULL]
         split tree as t1 = [2,4,5], t2 = [1,3,6] link-break-between 1.left = 2 break this
         product = sum{t1} * sum(t2) should be maximum
         trace all such break-point where, product of two subtrees max (prod1, prod2)
         */
        maxProductIfBinaryTreeIsSplitIntoTwo_TotalTreeSum = 0;
        maxProductIfBinaryTreeIsSplitIntoTwo_Product = 0;

        //find the total sum of all tree nodes
        maxProductIfBinaryTreeIsSplitIntoTwo_FindTreeSum(root);

        //find max product by imitating splits
        maxProductIfBinaryTreeIsSplitIntoTwo_FindMaxProduct(root);

        //output
        System.out.println("Max product of sum of trees by splitting into two: "
                + maxProductIfBinaryTreeIsSplitIntoTwo_Product);

    }

    private List<TreeNode<Integer>> deleteTreeNodeFromBinarySearchTree_FindInorderSuccessor(
            TreeNode<Integer> root) {

        if (root == null) {
            return Collections.emptyList();
        }

        TreeNode<Integer> succ = null;
        TreeNode<Integer> succPrev = null;
        if (root.getRight() != null) {
            succPrev = root;
            succ = root.getRight(); //succ is left most node in the right sub tree
            while (succ.getLeft() != null) {
                succPrev = succ;
                succ = succ.getLeft();
            }
        }
        return Arrays.asList(succPrev, succ);
    }

    private TreeNode<Integer> deleteTreeNodeFromBinarySearchTree_Delete(TreeNode<Integer> rootToDelete) {

        //https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
        if (rootToDelete == null) {
            return null;
        }

        if (rootToDelete.getLeft() == null && rootToDelete.getRight() == null) { // node is leaf
            return null;
        } else if (rootToDelete.getLeft() == null) { //node has one child
            return rootToDelete.getRight();
        } else if (rootToDelete.getRight() == null) { //node has one child
            return rootToDelete.getLeft();
        } else { //node has two child
            List<TreeNode<Integer>> succList = deleteTreeNodeFromBinarySearchTree_FindInorderSuccessor(rootToDelete);

            if (!succList.isEmpty()) {
                TreeNode<Integer> succPrev = succList.get(0);
                TreeNode<Integer> succ = succList.get(1);
                //replace root's data with inorder successor (succ)
                rootToDelete.setData(succ.getData());
                //delete the inorder successor node from its actual place
                if (succPrev != rootToDelete) {
                    succPrev.setLeft(deleteTreeNodeFromBinarySearchTree_Delete(succ));
                } else {
                    succPrev.setRight(deleteTreeNodeFromBinarySearchTree_Delete(succ));
                }
            }

            return rootToDelete;
        }
    }

    public TreeNode<Integer> deleteTreeNodeFromBinarySearchTree(TreeNode<Integer> root, int findToDelete) {

        //https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
        if (root == null) {
            return null;
        }

        if (root.getData() == findToDelete) {
            return deleteTreeNodeFromBinarySearchTree_Delete(root);
        } else if (findToDelete < root.getData()) {
            root.setLeft(deleteTreeNodeFromBinarySearchTree(root.getLeft(), findToDelete));
        } else {
            root.setRight(deleteTreeNodeFromBinarySearchTree(root.getRight(), findToDelete));
        }
        return root;
    }

    private TreeNode<Integer> deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(TreeNode<Integer> root,
            int low, int high) {

        if (root == null) {
            return null;
        }

        root.setLeft(deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root.getLeft(),
                low, high));
        root.setRight(deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root.getRight(),
                low, high));

        //not in range
        if (!(root.getData() >= low && root.getData() <= high)) {
            return deleteTreeNodeFromBinarySearchTree_Delete(root);
        }

        return root;
    }

    public void deleteTreeNodeFromBinarySearchTreeNotInRange(TreeNode<Integer> root,
            int low, int high) {
        TreeNode<Integer> node = deleteTreeNodeFromBinarySearchTreeNotInRange_Helper(root, low, high);
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    public void checkIfTwoTreeNodesAreCousin(TreeNode<Integer> root, int x, int y) {

        //https://leetcode.com/problems/cousins-in-binary-tree/
        /*
         Two nodes are cousins when they both lie on same level (levelX == levelY) but also 
         their parent should not be same (parentX != parentY)
         */
        int levelX = -1;
        int levelY = -1;

        TreeNode<Integer> parentX = null;
        TreeNode<Integer> parentY = null;

        int level = 0;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = q.poll();

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());

                    //x or col can be in left sub tree
                    if ((int) curr.getLeft().getData() == x) {
                        levelX = level;
                        parentX = curr;
                    }

                    if ((int) curr.getLeft().getData() == y) {
                        levelY = level;
                        parentY = curr;
                    }
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());

                    //x or col can be in right sub tree
                    if ((int) curr.getRight().getData() == x) {
                        levelX = level;
                        parentX = curr;
                    }

                    if ((int) curr.getRight().getData() == y) {
                        levelY = level;
                        parentY = curr;
                    }
                }
            }

            //if both nodes are found, their parents will not be null
            //and we will not be required to traverse further
            if (parentX != null && parentY != null) {
                break;
            }
            level++;
        }

        if (levelX == levelY && parentX != parentY) {
            System.out.println("Cousins");
        } else {
            System.out.println("Not cousins");
        }
    }

    public void cousinsInBinaryTreeTwo(TreeNode<Integer> root) {
        //https://leetcode.com/problems/cousins-in-binary-tree-ii/description/

        //actual
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();

        Map<Integer, Set<TreeNode<Integer>>> levelToParents = new HashMap<>();
        Map<Integer, Integer> levelWiseNodeSum = new HashMap<>();

        int maxLevel = 0;

        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> currRoot = queue.poll();

                //curr level == maxLevel, child level below is maxLevel + 1
                //so the parent of nodes in child level is 'currRoot'
                levelToParents.putIfAbsent(maxLevel + 1, new HashSet<>());
                levelToParents.get(maxLevel + 1).add(currRoot);

                //curr level == maxLevel, in this map we will store the sum of nodes
                //in the curr level only
                levelWiseNodeSum.put(maxLevel, levelWiseNodeSum.getOrDefault(maxLevel, 0) + currRoot.getData());

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }
            maxLevel++;
        }

        //process tree now
        for (int level = 0; level < maxLevel; level++) {
            if (level == 0) {
                root.setData(0);
            } else {

                //total sum of nodes per level
                int levelWiseTotalSum = levelWiseNodeSum.get(level);

                //iterate over the all the parent nodes above this 'level'
                for (TreeNode<Integer> parent : levelToParents.get(level)) {

                    //curr parent can have atmost 2 childs, find the possible sum
                    //from these 2 childs of curr 'parent'
                    int childSum = 0;
                    childSum += parent.getLeft() == null ? 0 : parent.getLeft().getData();
                    childSum += parent.getRight() == null ? 0 : parent.getRight().getData();

                    //possible child value to be updated with
                    //total_level_wise_sum - sum_of_childs_of_curr_parent
                    int updateChildNodes = levelWiseTotalSum - childSum;

                    //update both the child of curr 'parent'
                    if (parent.getLeft() != null) {
                        parent.getLeft().setData(updateChildNodes);
                    }

                    if (parent.getRight() != null) {
                        parent.getRight().setData(updateChildNodes);
                    }
                }
            }
        }
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private void printConnectedNodesAtSameLevelByRandomPointer(TreeNode<Integer> root) {

        int level = 0;
        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {

            int size = q.size();
            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = q.poll();
                TreeNode<Integer> ptrRandom = curr;
                System.out.print(level + ": ");
                while (ptrRandom != null) {
                    //print the nodes connected by random pointers
                    System.out.print(ptrRandom.getData() + " ");
                    ptrRandom = ptrRandom.getRandom();
                }

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }

                System.out.println();
            }
            level++;
        }
    }

    private void connectTreeNodesAtSameLevel_Recursive_Helper(TreeNode<Integer> root,
            int level, Map<Integer, TreeNode<Integer>> map) {

        if (root == null) {
            return;
        }

        if (map.containsKey(level)) {
            //this will have a previous node to current root
            map.get(level).setRandom(root);
        }

        //update previous node with current root in that level
        map.put(level, root);
        root.setRandom(null); //default random value if there is no next node in that level

        connectTreeNodesAtSameLevel_Recursive_Helper(root.getLeft(), level + 1, map);
        connectTreeNodesAtSameLevel_Recursive_Helper(root.getRight(), level + 1, map);
    }

    public void connectTreeNodesAtSameLevel_Recursive(TreeNode<Integer> root) {
        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
        Map<Integer, TreeNode<Integer>> map = new HashMap<>();
        connectTreeNodesAtSameLevel_Recursive_Helper(root, 0, map);

        //output
        printConnectedNodesAtSameLevelByRandomPointer(root);
    }

    public void connectTreeNodesAtSameLevel_Iterative(TreeNode<Integer> root) {
        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);
        TreeNode<Integer> prev;
        while (!queue.isEmpty()) {

            int size = queue.size();
            prev = null;

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = queue.poll();
                if (i > 0) {
                    prev.setRandom(curr);
                }
                curr.setRandom(null);
                prev = curr;

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }
        }

        //output
        printConnectedNodesAtSameLevelByRandomPointer(root);
    }

    private void binarySearchTreeToGreaterSumTree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return;
        }

        //go to right most leaf node in right sub tree
        //output starts from there only (otherwise you could choose as per the output demands)
        binarySearchTreeToGreaterSumTree_Helper(root.getRight());

        binarySearchTreeToGreaterSumTree_Sum += root.getData();

        root.setData(binarySearchTreeToGreaterSumTree_Sum);

        //now go to left sub tree as per output
        binarySearchTreeToGreaterSumTree_Helper(root.getLeft());
    }

    int binarySearchTreeToGreaterSumTree_Sum;

    public void binarySearchTreeToGreaterSumTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/convert-bst-to-greater-tree/
        //actual
        new BinarySearchTree<Integer>(root).treeBFS();
        System.out.println();

        binarySearchTreeToGreaterSumTree_Sum = 0;
        binarySearchTreeToGreaterSumTree_Helper(root);

        //output
        new BinarySearchTree<Integer>(root).treeBFS();
        System.out.println();
    }

    public void subtreeWithAllDeepestNodes(TreeNode<Integer> root) {

        //https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
        //https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
        //Actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //levelorder to find the deepest leaf nodes
        List<Integer> deepLeaf = new ArrayList<>();

        Queue<TreeNode<Integer>> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            //clear all previous levels, in the end, we will have last level, 
            //which will never be cleared
            deepLeaf.clear();
            int size = q.size();
            for (int i = 0; i < size; i++) {

                TreeNode<Integer> curr = q.poll();
                deepLeaf.add(curr.getData());

                if (curr.getLeft() != null) {
                    q.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    q.add(curr.getRight());
                }
            }
        }

        //get leftMost & rightMost leaf nodes in the deepLeaf level
        int n1 = -1;
        int n2 = -1;
        if (!deepLeaf.isEmpty()) {
            n1 = deepLeaf.get(0);
            n2 = deepLeaf.get(deepLeaf.size() - 1);
        }

        //find lca for n1 & n2
        //lca for two deepest leaf nodes will hold subtree, that conatins the deepest leaf nodes
        TreeNode<Integer> lcaForDeepLeafNodes = null;
        if (n1 != -1 && n2 != -1) {
            lcaForDeepLeafNodes = lowestCommonAncestorOfTree_Helper(root, n1, n2);
        }

        //output
        new BinaryTree<>(lcaForDeepLeafNodes).treeBFS();
        System.out.println();
    }

    private void pseudoPallindromicPathInBinaryTree_Helper(TreeNode<Integer> root,
            Map<Integer, Integer> map) {

        if (root == null) {
            return;
        }

        //freq of nodes in the path 
        map.put(root.getData(), map.getOrDefault(root.getData(), 0) + 1);

        pseudoPallindromicPathInBinaryTree_Helper(root.getLeft(), map);
        pseudoPallindromicPathInBinaryTree_Helper(root.getRight(), map);

        if (root.getLeft() == null && root.getRight() == null) {
            //for a path to be pseudo pallindromic, the freq of nodes in the paths can have 
            //either even freq(nodeHasOddFreq == 0) OR atmost 1 node can have odd freq(nodeHasOddFreq == 1)
            int nodeHasOddFreq = 0;
            for (int key : map.keySet()) {
                if (map.get(key) % 2 == 1) {
                    nodeHasOddFreq++;
                }
            }

            //atmost 1 node should have odd freq
            if (nodeHasOddFreq <= 1) {
                pseudoPallindromicPathInBinaryTree_Count++;
            }
        }

        //remove the freq of the last node added once they are processed
        map.put(root.getData(), map.get(root.getData()) - 1);
        if (map.get(root.getData()) <= 0) {
            map.remove(root.getData());
        }
    }

    int pseudoPallindromicPathInBinaryTree_Count;

    public void pseudoPallindromicPathInBinaryTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
        /*paths are [2,3,3] & [2,1,1] these paths are 
         pseudo pallindromic as they can be represented as pallindrome [3,2,3] & [1,2,1]*/
        pseudoPallindromicPathInBinaryTree_Count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        pseudoPallindromicPathInBinaryTree_Helper(root, map);

        //output
        System.out.println("Pseudo pallindromic paths count: " + pseudoPallindromicPathInBinaryTree_Count);
    }

    int countNumberOfTurnsBetweenRootToGivenKey_CountTurns = 0;

    public boolean countNumberOfTurnsBetweenRootToGivenKey(TreeNode<Integer> root,
            int key, boolean goingLeft) {

        if (root == null) {
            return false;
        }

        if (root.getData() == key) {
            return true;
        }

        if (goingLeft) {
            //as we are goingLeft == true so turn will not be counted 
            //going deeper to left subtrees
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getLeft(),
                    key, goingLeft)) {
                return true;
            }
            //each time we make a move to right subtree that means we are making
            //a turn to find the key
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getRight(), key, !goingLeft)) {
                countNumberOfTurnsBetweenRootToGivenKey_CountTurns += 1;
                return true;
            }
        } else { //goingLeft == false
            //as we are goingLeft == false(going to right) so turn will not be counted 
            //going deeper to right subtrees
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getRight(), key, goingLeft)) {
                return true;
            }
            //each time we make a move to left subtree that means we are making
            //a turn to find the key
            if (countNumberOfTurnsBetweenRootToGivenKey(root.getLeft(), key, !goingLeft)) {
                countNumberOfTurnsBetweenRootToGivenKey_CountTurns += 1;
                return true;
            }
        }
        return false;
    }

    public int countNumberOfTurnsBetweenTwoNodesOfTree(TreeNode<Integer> root, int n1, int n2) {

        //https://www.geeksforgeeks.org/number-turns-reach-one-node-binary-tree/
        //find lca of two nodes
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, n1, n2);

        if (lca == null) {
            return -1;
        }

        countNumberOfTurnsBetweenRootToGivenKey_CountTurns = 0;

        boolean n1FoundInLeftSubtree = false;
        boolean n2FoundInLeftSubtree = false;

        //if lca is not any of the nodes, neither n1 AND n2
        if (lca.getData() != n1 && lca.getData() != n2) {

            //count turns  in finding n1 in both left OR right sub tree of lca 
            n1FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n1, true); //goingLeft == true
            if (!n1FoundInLeftSubtree) {
                //if n1 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n1, false); //goingLeft == false
            }

            //count turns  in finding n2 in both left OR right sub tree of lca 
            n2FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n2, true); //goingLeft == true
            if (!n2FoundInLeftSubtree) {
                //if n2 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n2, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns + 1; //1 turn also made at lca node
        } else if (lca.getData() == n1) { //lca node is one of the given node

            //count turns of the other node from the lca
            n2FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n2, true); //goingLeft == true
            if (!n2FoundInLeftSubtree) {
                //if n2 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n2, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns;
        } else { //lca.getData() == n2
            //count turns of the other node from the lca
            n1FoundInLeftSubtree = countNumberOfTurnsBetweenRootToGivenKey(lca.getLeft(), n1, true); //goingLeft == true
            if (!n1FoundInLeftSubtree) {
                //if n1 is not found in left subtree then only go to search in right sub tree
                countNumberOfTurnsBetweenRootToGivenKey(lca.getRight(), n1, false); //goingLeft == false
            }
            return countNumberOfTurnsBetweenRootToGivenKey_CountTurns;
        }
    }

    class LongestZigZagPathInTreePair {

        int leftZigZagPath;
        int rightZigZagPath;

        public LongestZigZagPathInTreePair(int leftZigZagPath, int rightZigZagPath) {
            this.leftZigZagPath = leftZigZagPath;
            this.rightZigZagPath = rightZigZagPath;
        }
    }

    private void longestZigZagPathInTree_Helper(TreeNode<Integer> root,
            Map<TreeNode<Integer>, LongestZigZagPathInTreePair> map) {

        if (root == null) {
            return;
        }

        map.putIfAbsent(root, new LongestZigZagPathInTreePair(0, 0));

        longestZigZagPathInTree_Helper(root.getLeft(), map);
        longestZigZagPathInTree_Helper(root.getRight(), map);

        //calculate zig zag path for curr root for its both
        //leftZigZagPath i.e, path from root.left and its rightZigZagPath
        //rightZigZagPath i.e, path from root.right and its leftZigZagPath
        map.get(root).leftZigZagPath = 1 + map.get(root.getLeft()).rightZigZagPath;
        map.get(root).rightZigZagPath = 1 + map.get(root.getRight()).leftZigZagPath;

        longestZigZagPathInTree_Length = Math.max(
                longestZigZagPathInTree_Length,
                Math.max(map.get(root).leftZigZagPath,
                        map.get(root).rightZigZagPath));
    }

    int longestZigZagPathInTree_Length;

    public void longestZigZagPathInTree(TreeNode<Integer> root) {

        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
        longestZigZagPathInTree_Length = 0;
        Map<TreeNode<Integer>, LongestZigZagPathInTreePair> map = new HashMap<>();
        map.put(null, new LongestZigZagPathInTreePair(0, 0));
        longestZigZagPathInTree_Helper(root, map);

        //output
        System.out.println("Longest zig zag path in tree approach1: " + (longestZigZagPathInTree_Length - 1));
    }

    private int longestZigZagPathInTree2_Helper(
            TreeNode<Integer> root, boolean isComingFromLeft, boolean isComingFromRight, int pathLength) {
        if (root == null) {
            return pathLength;
        }
        int leftPathLength = longestZigZagPathInTree2_Helper(root.getLeft(),
                true, //from curr root going to its left
                false,
                //if previously coming from right
                //and now going to left that means its a zig zag path
                //so pathLen + 1
                //otherwise not coming from right and going to left 
                //consider it starting of some new zig zag path
                isComingFromRight ? pathLength + 1 : 1);
        int rightPathLength = longestZigZagPathInTree2_Helper(root.getRight(),
                false,
                true, //from curr root going to its right
                //if previously coming from left
                //and now going to right that means its a zig zag path
                //so pathLen + 1
                //otherwise not coming from left and going to right 
                //consider it starting of some new zig zag path
                isComingFromLeft ? pathLength + 1 : 1);
        return Math.max(leftPathLength, rightPathLength);
    }

    public void longestZigZagPathInTree2(TreeNode<Integer> root) {
        //FASTER than above approach 1
        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/discuss/2225080/Java-Solution
        int longestZigZagPath = longestZigZagPathInTree2_Helper(root, false, false, 1) - 1;
        //output
        System.out.println("Longest zig zag path in tree approach2: " + longestZigZagPath);
    }

    private int longestPathArithemeticProgressionInBinaryTree_MaxLength;

    private void longestPathArithemeticProgressionInBinaryTree_DFS(
            TreeNode<Integer> root, int difference, int currMaxLengthAP) {

        if (root.getLeft() != null) {
            int currDifference = root.getLeft().getData() - root.getData();
            if (currDifference == difference) {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getLeft(), currDifference, currMaxLengthAP + 1);

                longestPathArithemeticProgressionInBinaryTree_MaxLength = Math.max(
                        longestPathArithemeticProgressionInBinaryTree_MaxLength,
                        currMaxLengthAP + 1);
            } else {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getLeft(), currDifference, currMaxLengthAP);
            }
        }

        if (root.getRight() != null) {
            int currDifference = root.getRight().getData() - root.getData();
            if (currDifference == difference) {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getRight(), currDifference, currMaxLengthAP + 1);

                longestPathArithemeticProgressionInBinaryTree_MaxLength = Math.max(
                        longestPathArithemeticProgressionInBinaryTree_MaxLength,
                        currMaxLengthAP + 1);
            } else {
                longestPathArithemeticProgressionInBinaryTree_DFS(
                        root.getRight(), currDifference, currMaxLengthAP);
            }
        }
    }

    public void longestPathArithemeticProgressionInBinaryTree(TreeNode<Integer> root) {

        //https://www.geeksforgeeks.org/arithmetic-progression/
        //https://www.geeksforgeeks.org/longest-path-to-the-bottom-of-a-binary-tree-forming-an-arithmetic-progression/
        longestPathArithemeticProgressionInBinaryTree_MaxLength = 2;

        if (root == null) {
            longestPathArithemeticProgressionInBinaryTree_MaxLength = 0;
        }

        if (root.getLeft() == null && root.getRight() == null) {
            longestPathArithemeticProgressionInBinaryTree_MaxLength = 1;
        }

        //root & root.left OR root & root.right
        int currMaxLengthAP = 2;
        if (root.getLeft() != null) {
            int difference = root.getLeft().getData() - root.getData();
            longestPathArithemeticProgressionInBinaryTree_DFS(root.getLeft(), difference, currMaxLengthAP);
        }

        if (root.getRight() != null) {
            int difference = root.getRight().getData() - root.getData();
            longestPathArithemeticProgressionInBinaryTree_DFS(root.getRight(), difference, currMaxLengthAP);
        }
        //output
        System.out.println("Max length AP in binary tree: "
                + longestPathArithemeticProgressionInBinaryTree_MaxLength);
    }

    public void timeNeededToInformAllEmployee_NAryTreeDFS(int managerNode,
            Map<Integer, List<Integer>> managerToEmployees,
            int[] informTime,
            PriorityQueue<Integer> minHeap,
            int currTime) {

        if (!managerToEmployees.containsKey(managerNode)) {
            minHeap.add(currTime);
            if (minHeap.size() > 1) {
                minHeap.poll();
            }
        }

        List<Integer> directReportee = managerToEmployees.getOrDefault(managerNode, new ArrayList<>());
        for (int employee : directReportee) {
            timeNeededToInformAllEmployee_NAryTreeDFS(employee,
                    managerToEmployees,
                    informTime,
                    minHeap,
                    currTime + informTime[managerNode]);
        }
    }

    public void timeNeededToInformAllEmployee_NAryTree(int employees, int headManagerID,
            int[] manager, int[] informTime) {
        //Working but little time taking
        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
        //minHeap to store max time taken from headManager to last subordinate 
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        //manager[i] => [i]
        Map<Integer, List<Integer>> managerToEmployees = new HashMap<>();
        for (int i = 0; i < employees; i++) {
            managerToEmployees.putIfAbsent(manager[i], new ArrayList<>());
            managerToEmployees.get(manager[i]).add(i);
        }
        timeNeededToInformAllEmployee_NAryTreeDFS(headManagerID, managerToEmployees, informTime, minHeap, 0);
        System.out.println("Max time required to inform all employee from head manager to subordinate(N-Ary tree DFS): "
                + (minHeap.isEmpty() ? 0 : minHeap.peek()));
    }

    private int timeNeededToInformAllEmployee_DFS_Helper(int employeeNode, int[] manager, int[] informTime) {
        if (manager[employeeNode] == -1) {
            return informTime[employeeNode];
        }

        informTime[employeeNode] += timeNeededToInformAllEmployee_DFS_Helper(
                manager[employeeNode], manager, informTime);

        manager[employeeNode] = -1;

        return informTime[employeeNode];
    }

    public void timeNeededToInformAllEmployee_DFS(int employees, int headManagerID,
            int[] manager, int[] informTime) {
        //Little more optimized than above solution
        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
        //https://www.geeksforgeeks.org/google-interview-experience-sde-1-off-campus-2022/ 
        int maxTime = 0;
        //Loop trying to check the max time taken from any node, headMaangerID is not directly used here
        for (int employee = 0; employee < employees; employee++) {
            maxTime = Math.max(maxTime, timeNeededToInformAllEmployee_DFS_Helper(employee, manager, informTime));
        }
        System.out.println("Max time required to inform all employee from head manager to subordinate(Direct DFS): "
                + maxTime);
    }

    private enum BinaryTreeCameraState {

        hasCamera, needCamera, covered
    }
    int binaryTreeCameras_ReqCamera;

    private BinaryTreeCameraState binaryTreeCameras_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return BinaryTreeCameraState.covered;
        }

        BinaryTreeCameraState leftState = binaryTreeCameras_Helper(root.getLeft());
        BinaryTreeCameraState rightState = binaryTreeCameras_Helper(root.getRight());

        if (leftState == BinaryTreeCameraState.needCamera
                || rightState == BinaryTreeCameraState.needCamera) {
            binaryTreeCameras_ReqCamera++;
            return BinaryTreeCameraState.hasCamera;
        }

        if (leftState == BinaryTreeCameraState.hasCamera
                || rightState == BinaryTreeCameraState.hasCamera) {
            return BinaryTreeCameraState.covered;
        }
        return BinaryTreeCameraState.needCamera;
    }

    public void binaryTreeCameras(TreeNode<Integer> root) {
        //https://leetcode.com/problems/binary-tree-cameras/
        //https://leetcode.com/problems/binary-tree-cameras/solution/
        binaryTreeCameras_ReqCamera = 0;
        int output = binaryTreeCameras_Helper(root) == BinaryTreeCameraState.needCamera
                ? binaryTreeCameras_ReqCamera++
                : binaryTreeCameras_ReqCamera;
        System.out.println("Binary tree cameras : " + output);
    }

    private TreeNode<Integer> convertSortedArrayToHeightBalancedBinarySearchTree_Helper(
            int[] arr, int start, int end) {
        if (start > end) {
            return null;
        }

        int mid = start + (end - start) / 2;
        TreeNode<Integer> root = new TreeNode<>(arr[mid]);
        root.setLeft(
                convertSortedArrayToHeightBalancedBinarySearchTree_Helper(arr, start, mid - 1)
        );
        root.setRight(
                convertSortedArrayToHeightBalancedBinarySearchTree_Helper(arr, mid + 1, end)
        );

        return root;
    }

    public void convertSortedArrayToHeightBalancedBinarySearchTree(int[] arr) {
        //https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
        //explanation: https://youtu.be/0K0uCMYq5ng
        TreeNode<Integer> root = convertSortedArrayToHeightBalancedBinarySearchTree_Helper(
                arr, 0, arr.length - 1);
        //output
        new BinarySearchTree<>(root).treeInorder();
        System.out.println();
    }

    public void binarySearchTreeIterator(TreeNode<Integer> root) {
        //..............T: O(H), at most using addNodes() we are just travelling
        //tree upto the height of tree and not the complete N nodes of tree
        //https://leetcode.com/problems/binary-search-tree-iterator
        BinarySearchTreeIterator<Integer> iterator = new BinarySearchTreeIterator<>(root);
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    private boolean linkedListInBinaryTree_MatchCheck(Node<Integer> head, TreeNode<Integer> root) {
        if (head == null) {
            return true;
        }

        if (root == null) {
            return false;
        }

        return (root.getData() == head.getData())
                && (linkedListInBinaryTree_MatchCheck(head.getNext(), root.getLeft())
                || linkedListInBinaryTree_MatchCheck(head.getNext(), root.getRight()));

    }

    private boolean linkedListInBinaryTree_DFS(Node<Integer> head, TreeNode<Integer> root) {

        if (root == null) {
            return false;
        }

        if (linkedListInBinaryTree_MatchCheck(head, root)) {
            return true;
        }

        return linkedListInBinaryTree_DFS(head, root.getLeft())
                || linkedListInBinaryTree_DFS(head, root.getRight());

    }

    public void linkedListInBinaryTree(Node<Integer> head, TreeNode<Integer> root) {
        //https://leetcode.com/problems/linked-list-in-binary-tree/
        boolean output = linkedListInBinaryTree_DFS(head, root);
        //output
        System.out.println("Is linked list present in binary tree: " + output);
    }

    private void printBinaryTreeInStringMatrixFormat_Helper(
            TreeNode<Integer> root, int currRow, int currCol, int height, List<List<String>> treeMatrix) {

        if (root == null) {
            return;
        }

        treeMatrix.get(currRow).set(currCol, root.getData() + "");

        printBinaryTreeInStringMatrixFormat_Helper(root.getLeft(),
                currRow + 1,
                currCol - (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);

        printBinaryTreeInStringMatrixFormat_Helper(root.getRight(),
                currRow + 1,
                currCol + (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);
    }

    public void printBinaryTreeInStringMatrixFormat(TreeNode<Integer> root) {
        //https://leetcode.com/problems/print-binary-tree/
        /*
            1. The height of the tree is height and the number of rows m should be equal to height + 1.
            2. The number of columns n should be equal to 2height+1 - 1.
            3. Place the root node in the middle of the top row (more formally, at location res[0][(n-1)/2]).
            4. For each node that has been placed in the matrix at position res[r][c],
                place its left child at res[r+1][c-2height-r-1] and its right child at res[r+1][c+2height-r-1].
            5. Continue this process until all the nodes in the tree have been placed.
            6. Any empty cells should contain the empty string "".
         */
        int height = heightOfTree(root);
        int m = height + 1;
        int n = (int) Math.pow(2, height + 1) - 1;

        //preparing empty matrix
        String EMPTY_SPOT = ".";
        List<List<String>> treeMatrix = new ArrayList<>();
        for (int r = 0; r < m; r++) {
            treeMatrix.add(new ArrayList<>());
            for (int c = 0; c < n; c++) {
                treeMatrix.get(r).add(EMPTY_SPOT);
            }
        }

        int currRow = 0;
        int currCol = (n - 1) / 2;

        treeMatrix.get(currRow).set(currCol, root.getData() + "");

        printBinaryTreeInStringMatrixFormat_Helper(root.getLeft(),
                currRow + 1,
                currCol - (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);

        printBinaryTreeInStringMatrixFormat_Helper(root.getRight(),
                currRow + 1,
                currCol + (int) Math.pow(2, height - currRow - 1),
                height,
                treeMatrix);
        //output
        System.out.println("Print binary tree in string matrix format: ");
        for (List<String> level : treeMatrix) {
            System.out.println(level);
        }
    }

    private TreeNode<Integer> insufficientNodesInRootToLeafPath_Helper(
            TreeNode<Integer> root, int limit, int currPathSum) {

        if (root == null) {
            return null;
        }

        if (root.getLeft() == null && root.getRight() == null) {
            if (currPathSum + root.getData() < limit) {
                return null;
            }
            return root;
        }

        TreeNode<Integer> leftNode = insufficientNodesInRootToLeafPath_Helper(
                root.getLeft(), limit, currPathSum + root.getData());

        TreeNode<Integer> rightNode = insufficientNodesInRootToLeafPath_Helper(
                root.getRight(), limit, currPathSum + root.getData());

        if (leftNode == null) {
            root.setLeft(null);
        }

        if (rightNode == null) {
            root.setRight(null);
        }

        if (leftNode == null && rightNode == null) {
            return null;
        }
        return root;
    }

    public void insufficientNodesInRootToLeafPath(TreeNode<Integer> root, int limit) {
        //https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
        //actual:
        new BinaryTree(root).treeBFS();
        System.out.println();

        TreeNode<Integer> output = insufficientNodesInRootToLeafPath_Helper(root, limit, 0);
        //output
        System.out.println("Tree after removing insufficient sum path: ");
        new BinaryTree(output).treeBFS();
        System.out.println();
    }

    private int sticklerThiefThree_DP_Memoization_DFSHelper(
            TreeNode<Integer> root, Map<TreeNode<Integer>, Integer> memo) {
        if (root == null) {
            return 0;
        }

        if (memo.containsKey(root)) {
            return memo.get(root);
        }

        int currPick = 0;

        //1. decide to pick the curr root house
        currPick += root.getData();
        //since we have picked the curr root house, we can't pick its direct
        //childrens(left or right) but we can surely pick its grand children
        //i.e, left & right grand child of curr root.left
        if (root.getLeft() != null) {
            int maxPickGrandLeftChildOfLeft = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getLeft().getLeft(), memo);

            int maxPickGrandRightChildOfLeft = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getLeft().getRight(), memo);

            currPick += maxPickGrandLeftChildOfLeft + maxPickGrandRightChildOfLeft;

        }
        //i.e, left & right grand child of curr root.right
        if (root.getRight() != null) {
            int maxPickGrandLeftChildOfRight = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getRight().getLeft(), memo);

            int maxPickGrandRightChildOfRight = sticklerThiefThree_DP_Memoization_DFSHelper(
                    root.getRight().getRight(), memo);

            currPick += maxPickGrandLeftChildOfRight + maxPickGrandRightChildOfRight;
        }

        //2. decide to not pick curr root, in that case we can directly move to
        //its direct children i.e, root.left & root.right
        int maxPickDirectLeftChild = sticklerThiefThree_DP_Memoization_DFSHelper(
                root.getLeft(), memo);

        int maxPickDirectRightChild = sticklerThiefThree_DP_Memoization_DFSHelper(
                root.getRight(), memo);

        //choosing which option has get us the max currPick for the curr root house
        currPick = Math.max(currPick, maxPickDirectLeftChild + maxPickDirectRightChild);

        memo.put(root, currPick);
        return currPick;
    }

    public void sticklerThiefThree_DP_Memoization(TreeNode<Integer> rootHouse) {
        //https://leetcode.com/problems/house-robber-iii/
        Map<TreeNode<Integer>, Integer> memo = new HashMap<>();
        int maxRob = sticklerThiefThree_DP_Memoization_DFSHelper(rootHouse, memo);
        System.out.println("The maximum amount stickler thief can pick from alternate binary tree house: " + maxRob);
    }

    private void stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(
            TreeNode<Integer> root, int startNode, StringBuilder curr) {
        if (root == null) {
            return;
        }

        if (root.getData() == startNode) {
            stepByStepDirection_Path += curr;
            return;
        }
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(root.getLeft(), startNode, curr.append("U"));
        //remove the last added direction before moving to right subtree
        curr.deleteCharAt(curr.length() - 1);

        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(root.getRight(), startNode, curr.append("U"));
        //remove the last added direction before moving to prev call stack
        curr.deleteCharAt(curr.length() - 1);
    }

    private void stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(
            TreeNode<Integer> root, int destNode, StringBuilder curr) {
        if (root == null) {
            return;
        }

        if (root.getData() == destNode) {
            stepByStepDirection_Path += curr;
            return;
        }
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(root.getLeft(), destNode, curr.append("L"));
        //remove the last added direction before moving to right subtree
        curr.deleteCharAt(curr.length() - 1);

        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(root.getRight(), destNode, curr.append("R"));
        //remove the last added direction before moving to prev call stack
        curr.deleteCharAt(curr.length() - 1);
    }

    private String stepByStepDirection_Path;

    public void stepByStepDirectionsBetweenTwoNodesInBinaryTree(TreeNode<Integer> root, int startNode, int destNode) {
        //https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
        stepByStepDirection_Path = "";
        TreeNode<Integer> lca = lowestCommonAncestorOfTree_Helper(root, startNode, destNode);
        //using StringBuilder here for below DFS is trivial, otherwise it may cause memory limit exceed
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindStartFromLCA(lca, startNode, new StringBuilder());
        stepByStepDirectionsBetweenTwoNodesInBinaryTree_FindDestFromLCA(lca, destNode, new StringBuilder());
        //output
        System.out.println("Step by step direction between two nodes in binary tree: " + stepByStepDirection_Path);
    }

    private void addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(
            TreeNode<Integer> root, int level, int maxLevel, Map<Integer, List<TreeNode<Integer>>> levelOrder) {
        //level > maxLevel this cond is added because we only need the nodes at
        //depth - 1 parent level to perform our logic, we don't really need to
        //traverse each and every node falling below the given depth, this might
        //save some extra time on traversing the whole tree
        if (root == null || level > maxLevel) {
            return;
        }

        levelOrder.putIfAbsent(level, new ArrayList<>());
        levelOrder.get(level).add(root);

        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root.getLeft(), level + 1, maxLevel, levelOrder);
        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root.getRight(), level + 1, maxLevel, levelOrder);
    }

    public void addExtraRowWithGivenValueAtGivenDepth(TreeNode<Integer> root, int val, int depth) {
        //https://leetcode.com/problems/add-one-row-to-tree/
        System.out.println("Add row in tree with given value at given depth using BFS recursive approach");
        //actual
        System.out.println("Actual tree:");
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //simple level order traversal using recursion and hashmap
        Map<Integer, List<TreeNode<Integer>>> levelOrder = new HashMap<>();
        addExtraRowWithGivenValueAtGivenDepth_PreorderTraversal(root, 1, depth, levelOrder);
        //update functionality
        //edge condition when we want to add the new row at the root level( == 1)
        //simply create a newRoot with given val and add the actual tree(root) as
        //left child of it
        if (depth == 1) {
            //depth == 1 is root level
            TreeNode<Integer> newRoot = new TreeNode<>(val);
            newRoot.setLeft(root);
            new BinaryTree<>(newRoot).treeBFS();
            System.out.println();
            return;
        }

        List<TreeNode<Integer>> nodesAboveCurrDepth = levelOrder.getOrDefault(depth - 1, new ArrayList<>());
        //since we want to create the new row at given depth that means if we have
        //all the nodes at the level above, we can do our logic
        //1. save actual left & right subtree of curr parent
        //2. create a new row with given value and make it a child of curr parent
        //3. then adjust the actual left subtree to left part of new row node and
        //actual right subtree to right part of new row node
        for (TreeNode<Integer> parent : nodesAboveCurrDepth) {

            TreeNode<Integer> actualLeftSubtree = parent.getLeft();
            TreeNode<Integer> actualRightSubtree = parent.getRight();

            //adding the new row right below the parent level as its child
            parent.setLeft(new TreeNode<>(val));
            parent.setRight(new TreeNode<>(val));

            //putting parents left subtree & right substree in
            //exactly left & right part of the newly created row
            parent.getLeft().setLeft(actualLeftSubtree);
            parent.getRight().setRight(actualRightSubtree);
        }
        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    public void addExtraRowWithGivenValueAtGivenDepth_BFSIterative(TreeNode<Integer> root, int val, int depth) {
        //https://leetcode.com/problems/add-one-row-to-tree/
        //same approach as addExtraRowWithGivenValueAtGivenDepth(), but little
        //OPTIMIZED as no extra hashmap used and in single BFS pass we are targetting
        //the row above curr depth
        System.out.println("Add row in tree with given value at given depth using BFS iterative approach");
        //actual
        System.out.println("Actual tree:");
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        //update functionality
        //edge condition when we want to add the new row at the root level( == 1)
        //simply create a newRoot with given val and add the actual tree(root) as
        //left child of it
        if (depth == 1) {
            //depth == 1 is root level
            TreeNode<Integer> newRoot = new TreeNode<>(val);
            newRoot.setLeft(root);
            new BinaryTree<>(newRoot).treeBFS();
            System.out.println();
            return;
        }

        int level = 1;
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                TreeNode<Integer> parent = queue.poll();

                //since we want to create the new row at given depth that means if we have
                //all the nodes at the level above given depth, we can do our logic
                //1. save actual left & right subtree of curr parent
                //2. create a new row with given value and make it a child of curr parent
                //3. then adjust the actual left subtree to left part of new row node and
                //actual right subtree to right part of new row node
                if (level == depth - 1) {
                    TreeNode<Integer> actualLeftSubtree = parent.getLeft();
                    TreeNode<Integer> actualRightSubtree = parent.getRight();

                    //adding the new row right below the parent level as its child
                    parent.setLeft(new TreeNode<>(val));
                    parent.setRight(new TreeNode<>(val));

                    //putting parents left subtree & right substree in
                    //exactly left & right part of the newly created row
                    parent.getLeft().setLeft(actualLeftSubtree);
                    parent.getRight().setRight(actualRightSubtree);
                } else {
                    if (parent.getLeft() != null) {
                        queue.add(parent.getLeft());
                    }

                    if (parent.getRight() != null) {
                        queue.add(parent.getRight());
                    }
                }
            }
            level++;
            if (level == depth) {
                break;
            }
        }

        //output
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    public void findElementsInContaminatedBinaryTree(TreeNode<Integer> contaminatedRoot, List<Integer> find) {
        //https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
        class FindElements {

            Set<Integer> nodes;

            public FindElements(TreeNode<Integer> root) {
                nodes = new HashSet<>();
                nodes.add(0);
                root.setData(0);
                fixTree(root);
            }

            private void fixTree(TreeNode<Integer> root) {
                //pre-order traversal
                if (root == null) {
                    return;
                }

                //if root.left is valid
                if (root.getLeft() != null) {
                    //root.left.val = 2 * root.val + 1
                    root.getLeft().setData(2 * root.getData() + 1);
                    nodes.add(root.getLeft().getData());
                }

                //if root.right is valid
                if (root.getRight() != null) {
                    //root.right.val = 2 * root.val + 2
                    root.getRight().setData(2 * root.getData() + 2);
                    nodes.add(root.getRight().getData());
                }

                fixTree(root.getLeft());
                fixTree(root.getRight());
            }

            public boolean find(int val) {
                return nodes.contains(val);
            }
        }

        FindElements findElements = new FindElements(contaminatedRoot);
        for (int val : find) {
            System.out.println(val + " is present in contaminated tree : " + findElements.find(val));
        }
    }

    public void reverseOddLevelsOfPerfectBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
        /*
        A binary tree is perfect if all parent nodes have two children and all
        leaves are on the same level.
         */
        //actual:
        new BinaryTree(root).treeBFS();
        System.out.println();

        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        int level = 0;
        //with stack for parent level nodes we can access the last node in parent
        Stack<TreeNode> parents = new Stack<>();
        //with queue for child level nodes we can process starting nodes and
        //put them in prev parent node
        Queue<Integer> childs = new LinkedList<>();

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {
                TreeNode<Integer> currNode = queue.poll();

                if (currNode.getLeft() != null) {
                    queue.add(currNode.getLeft());
                }

                if (currNode.getRight() != null) {
                    queue.add(currNode.getRight());
                }

                if (level % 2 == 0) {
                    parents.push(currNode);
                } else {
                    childs.add(currNode.getData());
                }

            }

            //reversing the odd levels
            if (level % 2 == 1) {
                while (!parents.isEmpty()) {
                    TreeNode currParent = parents.pop();
                    currParent.getRight().setData(childs.poll());
                    currParent.getLeft().setData(childs.poll());
                }
                parents.clear();
                childs.clear();
            }

            level++;
        }

        //output
        new BinaryTree(root).treeBFS();
        System.out.println();
    }

    public void closestNodesQueriesInBinarySearchTree(TreeNode<Integer> root, List<Integer> queries) {
        //https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/
        List<List<Integer>> closestNodesForQueries = new ArrayList<>();
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);

        TreeSet<Integer> treeSet = new TreeSet<>();
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode<Integer> currRoot = queue.poll();

                treeSet.add(currRoot.getData());

                if (currRoot.getLeft() != null) {
                    queue.add(currRoot.getLeft());
                }

                if (currRoot.getRight() != null) {
                    queue.add(currRoot.getRight());
                }
            }
        }

        for (int query : queries) {
            if (treeSet.contains(query)) {
                closestNodesForQueries.add(Arrays.asList(query, query));
            } else {
                Integer min = treeSet.lower(query);
                Integer max = treeSet.higher(query);
                closestNodesForQueries.add(Arrays.asList(min == null ? -1 : min,
                        max == null ? -1 : max));
            }
        }
        //output
        System.out.println("Closest nodes queries: " + closestNodesForQueries);
    }

    private TreeNode<Integer> deleteLeavesWithGiveValue_Helper(TreeNode<Integer> root, int target) {
        if (root == null) {
            return null;
        }

        root.setLeft(deleteLeavesWithGiveValue_Helper(root.getLeft(), target));
        root.setRight(deleteLeavesWithGiveValue_Helper(root.getRight(), target));

        //if curr root is leaf and root's value is target, return null to its
        //parent root node
        if (root.getLeft() == null && root.getRight() == null && root.getData() == target) {
            return null;
        }
        //if above condition is not matching return curr root back to its parent root
        return root;
    }

    public void deleteLeavesWithGiveValue(TreeNode<Integer> root, int target) {
        //https://leetcode.com/problems/delete-leaves-with-a-given-value/description/
        //actual
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        root = deleteLeavesWithGiveValue_Helper(root, target);
        //outout
        new BinaryTree<>(root).treeBFS();
        System.out.println();
    }

    private int maxDiffBetweenNodesAndAncestor_Helper(TreeNode<Integer> root, int currMax, int currMin) {
        if (root == null) {
            return currMax - currMin;
        }
        int leftDiff = maxDiffBetweenNodesAndAncestor_Helper(root.getLeft(),
                Math.max(currMax, root.getData()),
                Math.min(currMin, root.getData()));

        int rightDiff = maxDiffBetweenNodesAndAncestor_Helper(root.getRight(),
                Math.max(currMax, root.getData()),
                Math.min(currMin, root.getData()));

        return Math.max(leftDiff, rightDiff);
    }

    public void maxDiffBetweenNodesAndAncestor(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/
        if (root == null) {
            System.out.println("Max diff between node and ancestor is: 0");
            return;
        }

        int maxDiffBetweenNodeAndAncestor = maxDiffBetweenNodesAndAncestor_Helper(root, root.getData(), root.getData());
        //output
        System.out.println("Max diff between node and ancestor is: " + maxDiffBetweenNodeAndAncestor);
    }

    private void timeRequiredToInfectBinaryTree_TreeToGraph(
            TreeNode<Integer> root, TreeNode<Integer> parent, Map<Integer, List<Integer>> graph) {
        if (root == null) {
            return;
        }

        graph.putIfAbsent(root.getData(), new ArrayList<>());

        if (parent != null) {
            graph.get(root.getData()).add(parent.getData());
        }

        if (root.getLeft() != null) {
            graph.get(root.getData()).add(root.getLeft().getData());
        }

        if (root.getRight() != null) {
            graph.get(root.getData()).add(root.getRight().getData());
        }

        timeRequiredToInfectBinaryTree_TreeToGraph(root.getLeft(), root, graph);
        timeRequiredToInfectBinaryTree_TreeToGraph(root.getRight(), root, graph);
    }

    public void timeRequiredToInfectBinaryTree(TreeNode<Integer> root, int startNode) {
        //https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/
        //based on BFS, Graph
        Map<Integer, List<Integer>> graph = new HashMap<>();
        //this creates an adjlist map for curr tree in graph form
        //where a curr root will have connections to atmost 3 nodes
        //curr root's parent & curr root's child(left & right child)
        /*
        Tree: 
        ...............parent
        .................\
        ...............currRoot
        ............../........\
        .......leftChild.....rightChild
        Graph: 
        {currRoot = [parent, leftChild, rightChild]}
         */
        timeRequiredToInfectBinaryTree_TreeToGraph(root, null, graph);

        //perform BFS on graph
        int infect = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.add(startNode);

        Set<Integer> visited = new HashSet<>();
        visited.add(startNode);

        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int currRoot = queue.poll();
                for (int childRoot : graph.getOrDefault(currRoot, new ArrayList<>())) {
                    if (visited.contains(childRoot)) {
                        continue;
                    }
                    visited.add(childRoot);
                    queue.add(childRoot);
                }
            }
            infect++;
        }
        //output
        System.out.println("Amount of time required to infect the binary tree: " + (infect - 1));
    }

    private TreeNode<Integer> maxBinaryTree_Helper(int[] nums, int start, int end) {
        if (start > end) {
            return null;
        }

        int maxVal = Integer.MIN_VALUE;
        int maxValIndex = -1;
        int index = start;
        for (; index <= end; index++) {
            if (nums[index] > maxVal) {
                maxVal = nums[index];
                maxValIndex = index;
            }
        }

        TreeNode<Integer> root = new TreeNode<>(nums[maxValIndex]);
        root.setLeft(maxBinaryTree_Helper(nums, start, maxValIndex - 1));
        root.setRight(maxBinaryTree_Helper(nums, maxValIndex + 1, end));

        return root;
    }

    public void maxBinaryTree(int[] nums) {
        //https://leetcode.com/problems/maximum-binary-tree/description/
        TreeNode<Integer> root = maxBinaryTree_Helper(nums, 0, nums.length - 1);
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    private TreeNode<Integer> maxBinaryTreeTwo_Helper(TreeNode<Integer> root, int val) {
        //if the 'val' is the smallest of all the nodes present in tree
        if (root == null) {
            return new TreeNode<>(val);
        }
        //if the curr 'root' is smaller than the 'val', means the subtree starting
        //from this 'root' be below this 'val', so create newNode of 'val'
        //fill the left node of this newNode curr 'root', return newNode to its
        //parent node
        if (root.getData() < val) {
            TreeNode<Integer> newNode = new TreeNode<>(val);
            newNode.setLeft(root);
            return newNode;
        }

        root.setRight(maxBinaryTreeTwo_Helper(root.getRight(), val));
        return root;
    }

    public void maxBinaryTreeTwo(TreeNode<Integer> root, int val) {
        //https://leetcode.com/problems/maximum-binary-tree-ii/description/
        //actual:
        new BinaryTree<>(root).treeBFS();
        System.out.println();

        TreeNode<Integer> result = maxBinaryTreeTwo_Helper(root, val);

        //output
        new BinaryTree<>(result).treeBFS();
        System.out.println();
    }

    private boolean univaluedBinaryTree_Helper(TreeNode<Integer> root) {
        if (root == null) {
            return true;
        }

        boolean isLeftSubtreeUnivalued = univaluedBinaryTree_Helper(root.getLeft());

        if (univaluedBinaryTree_Prev != null && univaluedBinaryTree_Prev.getData() != root.getData()) {
            return false;
        }

        univaluedBinaryTree_Prev = root;

        boolean isRightSubtreeUnivalued = univaluedBinaryTree_Helper(root.getRight());

        return isLeftSubtreeUnivalued && isRightSubtreeUnivalued;
    }

    private TreeNode<Integer> univaluedBinaryTree_Prev;

    public void univaluedBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/univalued-binary-tree/description/
        univaluedBinaryTree_Prev = null;
        boolean isTreeUnivalued = univaluedBinaryTree_Helper(root);
        //output
        System.out.println("Is tree univalued: " + isTreeUnivalued);
    }

    private boolean countSingleValuedSubtreeInATree_Helper(TreeNode<Integer> root) {

        if (root == null) {
            return true;
        }

        boolean isLeftTreeSingleValues = countSingleValuedSubtreeInATree_Helper(root.getLeft());
        boolean isRightTreeSingleValues = countSingleValuedSubtreeInATree_Helper(root.getRight());

        //if both the child subtrees (left & right) of this curr root are also
        //single valued subtrees then check if this curr root node value is also
        //same as its both subtree's node values.
        //in case of the cond to fail, root.left should not be null & root.val != root.left.val
        //also root.right should not be null & root.val != root.right.val
        //if both these conds are OK then we have a subtree with single value so count++
        //and return true because this curr root node also forms a single value subtree
        //with its left & right substree
        if (isLeftTreeSingleValues && isRightTreeSingleValues) {

            //curr root left node is valid but its value is not same as curr root's value
            if (root.getLeft() != null && root.getLeft().getData() != root.getData()) {
                return false;
            }

            //curr root right node is valid but its value is not same as curr root's value
            if (root.getRight() != null && root.getRight().getData() != root.getData()) {
                return false;
            }

            countSingleValuedSubtreeInATree_CountSubtree++;

            return true;
        }

        //if in above cond, any of the subtrees is not a single value subtree
        //then this curr root node will never make itself a single value sutree
        //either isLeftTreeSingleValues == false OR isRightTreeSingleValues == false
        //so return false;
        return false;
    }

    private int countSingleValuedSubtreeInATree_CountSubtree;

    public void countSingleValuedSubtreeInATree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/univalued-binary-tree/description/
        //https://practice.geeksforgeeks.org/problems/single-valued-subtree/1
        //actual:
        new BinaryTree<>(root).treeBFS();
        System.out.println();
        countSingleValuedSubtreeInATree_CountSubtree = 0;
        countSingleValuedSubtreeInATree_Helper(root);
        //output
        System.out.println("Single values subtrees: " + countSingleValuedSubtreeInATree_CountSubtree);
    }

    public void sumOfNodesWithEvenValuedGrandparent(TreeNode<Integer> root) {
        //https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description/
        class Relation {

            TreeNode<Integer> grandparent;
            TreeNode<Integer> parent;
            TreeNode<Integer> root;

            public Relation(TreeNode<Integer> grandparent, TreeNode<Integer> parent, TreeNode<Integer> root) {
                this.grandparent = grandparent;
                this.parent = parent;
                this.root = root;
            }

        }

        int nodeSumWithEvenValuedGrandparent = 0;

        if (root == null) {
            System.out.println("Nodes sum have even valued grandparent: " + nodeSumWithEvenValuedGrandparent);
            return;
        }

        Queue<Relation> queue = new LinkedList<>();
        //root's grandparent is null, root's parent is null, root itself
        queue.add(new Relation(null, null, root));

        while (!queue.isEmpty()) {

            Relation currRelation = queue.poll();

            //if the curr root's grandparent is not null and also this grandparent
            //is even-valued then we must add the curr root's value to our sum
            if (currRelation.grandparent != null && currRelation.grandparent.getData() % 2 == 0) {
                nodeSumWithEvenValuedGrandparent += currRelation.root.getData();
            }

            //for next left child from the curr root node
            //curr root's parent will become grandparent of root's left child
            //curr root itself become parent of root's left child
            if (currRelation.root.getLeft() != null) {
                queue.add(new Relation(
                        currRelation.parent,
                        currRelation.root,
                        currRelation.root.getLeft()
                ));
            }

            //for next right child from the curr root node
            //curr root's parent will become grandparent of root's right child
            //curr root itself become parent of root's right child
            if (currRelation.root.getRight() != null) {
                queue.add(new Relation(
                        currRelation.parent,
                        currRelation.root,
                        currRelation.root.getRight()
                ));
            }

        }
        //output
        System.out.println("Nodes sum have even valued grandparent: " + nodeSumWithEvenValuedGrandparent);
    }

    private boolean printAllAncestorOfTagetNodeInBinaryTree_Helper(
            TreeNode<Integer> root, int target, List<Integer> ancestors) {
        if (root == null) {
            return false;
        }

        if (root.getData() == target) {
            return true;
        }

        //first try to find the target node in left subtree
        boolean isTragetInLeft = printAllAncestorOfTagetNodeInBinaryTree_Helper(root.getLeft(), target, ancestors);
        boolean isTragetInRight = false;

        //if the target node is not found in the left sub tree then only go searching
        //in the right sub tree. This will help in reducing the time complexity of
        //searching a node. Because if we have already found our target ndoe in left
        //sub tree then there is no sense to go search the same in right sub tree
        if (!isTragetInLeft) {
            isTragetInRight = printAllAncestorOfTagetNodeInBinaryTree_Helper(root.getRight(), target, ancestors);
        }

        //if the target node is found in either of its left or right sub trees
        //then that means the curr root node is its ancestor (target node lies
        //in the either child sub trees(left or right))
        if (isTragetInLeft || isTragetInRight) {
            ancestors.add(root.getData());
        }

        //return true only if the target node is there in any of the subtrees
        //of this curr root node
        return isTragetInLeft || isTragetInRight;
    }

    public void printAllAncestorOfTagetNodeInBinaryTree(TreeNode<Integer> root, int target) {
        //https://youtu.be/2VZHLtHM_6w
        List<Integer> ancestors = new ArrayList<>();
        printAllAncestorOfTagetNodeInBinaryTree_Helper(root, target, ancestors);
        //output
        System.out.println("Print all the ancestors of the given target node: " + ancestors);
    }

    public void kthLargestLevelSumInBinaryTree(TreeNode<Integer> root, int k) {
        //https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description/
        //based on BFS
        PriorityQueue<Long> minHeap = new PriorityQueue<>((a, b) -> a.compareTo(b));
        Queue<TreeNode<Integer>> queue = new LinkedList<>();
        queue.add(root);
        long levelSum = 0;
        int level = 0;

        while (!queue.isEmpty()) {
            int size = queue.size();
            levelSum = 0;

            for (int i = 0; i < size; i++) {
                TreeNode<Integer> curr = queue.poll();
                levelSum += curr.getData();

                if (curr.getLeft() != null) {
                    queue.add(curr.getLeft());
                }

                if (curr.getRight() != null) {
                    queue.add(curr.getRight());
                }
            }

            level++;
            minHeap.add(levelSum);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }
        long kThLargestLevelSum = level < k ? -1 : minHeap.peek();
        //output
        System.out.println("Kth largest level sum in binary tree: " + kThLargestLevelSum);
    }

    public int numberOfGoodLeafNodesPairsOFBinaryTree(TreeNode<Integer> root, int distance) {
        //https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/
        /*
        Intuition behind this is 
        convert the tree into graph representation and while converting save all
        the leaf nodes in a list
        
        now that we have all leaf ndoes and a tree-as-graph we will be able to
        directly start a DFS call from leaf nodes via this graph
        
        using this DFS from a leaf node on this graph calculate distance with
        currDist. any currDist above the given distance should be discarded.
        in order to calculate pair, currDist <= distance and this path should
        start and end with a leaf node. 
        starting leaf node is via the loop on leafNodes and ending leaf node is
        checked in DFS calls
        
         */
        //saving graph as TreeNodes beacuses tree node's values may be duplicate
        //here we will convert the given tree to a graph representation
        //this will helps us do dfs from leaf nodes directly
        Map<TreeNode<Integer>, List<TreeNode<Integer>>> graph = new HashMap<>();
        //to hold only leaf nodes of tree
        List<TreeNode<Integer>> leafNodes = new ArrayList<>();

        Set<TreeNode<Integer>> visited = new HashSet<>();

        class Helper {

            int pairs = 0;

            void convertTreeToGraph(TreeNode<Integer> root, TreeNode<Integer> parent) {
                if (root == null) {
                    return;
                }

                //leaf nodes here, so save all the leaf nodes in a list
                if (root.getLeft() == null && root.getRight() == null) {
                    leafNodes.add(root);
                }

                //create a graph
                if (root != null && parent != null) {

                    graph.putIfAbsent(root, new ArrayList<>());
                    graph.get(root).add(parent);

                    graph.putIfAbsent(parent, new ArrayList<>());
                    graph.get(parent).add(root);
                }

                convertTreeToGraph(root.getLeft(), root);
                convertTreeToGraph(root.getRight(), root);
            }

            void calculatePairsWithinDistance(TreeNode<Integer> node, int distance, int currDist) {

                //the shortest path from starting leaf node to any other leaf node
                //should not be more than given distance
                if (currDist > distance) {
                    return;
                }

                //currDist > 0 ensures that we dont update pairs for the same leaf node
                //we started the DFS call with
                if (currDist > 0
                        //shortest dist limit from one leaf node to another
                        && currDist <= distance
                        //shortest path should end with another leaf node 
                        && node.getLeft() == null && node.getRight() == null) {
                    pairs++;
                }

                visited.add(node);

                for (TreeNode<Integer> childNode : graph.getOrDefault(node, new ArrayList<>())) {
                    if (childNode == null || visited.contains(childNode)) {
                        continue;
                    }
                    calculatePairsWithinDistance(childNode, distance, currDist + 1);
                }

                visited.remove(node);

            }
        }

        Helper helper = new Helper();

        helper.convertTreeToGraph(root, null);

        //in case of skewed trees there will be only one leaf node, then no pairs
        //can be possible hence return 0
        if (leafNodes.size() == 1) {
            return 0;
        }

        for (TreeNode<Integer> leaf : leafNodes) {
            helper.calculatePairsWithinDistance(leaf, distance, 0);
        }
        //since we are looping over leafNodes then we are calculating pairs twice
        //that why we need to divide 2
        //ex: leafNodes: [4, 5, 6, 7] then shortest path is calculated with all
        //leaf nodes. So if 4 has shortest path with 5 == pair == 1
        //then in the loop itself 5 will be calculated again with 4 == pair == 2
        //we checked 4 and 5 pairs twice that why divide by 2
        return helper.pairs / 2;
    }

    public void maxSumBSTInBinaryTree(TreeNode<Integer> root) {
        //https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/
        class NodeInfo {

            boolean isBST;
            int maxInLeftSubtree;
            int minInRightSubtree;
            int sum;

            public NodeInfo() {
                isBST = false;
                maxInLeftSubtree = Integer.MIN_VALUE;
                minInRightSubtree = Integer.MAX_VALUE;
                sum = 0;
            }
        }

        class Helper {

            int maxBSTSubtreeSum = Integer.MIN_VALUE;

            void helperDFS(TreeNode<Integer> root, NodeInfo currRootInfo) {

                if (root == null) {
                    currRootInfo.isBST = true;
                    return;
                }

                //curr root's left subtree info will be collected in this in DFS calls
                NodeInfo leftTreeInfo = new NodeInfo();
                //curr root's right subtree info will be collected in this in DFS calls
                NodeInfo rightTreeInfo = new NodeInfo();

                helperDFS(root.getLeft(), leftTreeInfo);
                helperDFS(root.getRight(), rightTreeInfo);

                //node sum i.e,
                //sum of nodes in left subtree
                //+ curr root value
                //+ sum of nodes in right subtree
                currRootInfo.sum = leftTreeInfo.sum + root.getData() + rightTreeInfo.sum;

                //Here we will calculate the max node value among all the nodes
                //from curr root's left subtree and right subtree and including
                //curr root node value as well, this info will also be propagated
                //back to curr root's parent
                currRootInfo.maxInLeftSubtree = Math.max(root.getData(),
                        Math.max(leftTreeInfo.maxInLeftSubtree, rightTreeInfo.maxInLeftSubtree));

                //Here we will calculate the min node value among all the nodes
                //from curr root's left subtree and right subtree and including
                //curr root node value as well, this info will also be propagated
                //back to curr root's parent
                currRootInfo.minInRightSubtree = Math.min(root.getData(),
                        Math.min(leftTreeInfo.minInRightSubtree, rightTreeInfo.minInRightSubtree));

                //a subtree having this curr root node as 'root' is BST only if
                //1. this root's left subtree is also a BST 
                //2. this root's right subtree is also a BST
                //3. this root's value is greater than the max value in its left
                //subtree AND less than the min value in its right subtree
                //i.e property of BST:
                //root node's left tree will have all nodes lesser than curr root node
                //AND
                //root node's right tree will have all nodes greater than curr root node
                currRootInfo.isBST
                        = //left subtree should be BST in itself
                        leftTreeInfo.isBST
                        && //right subtree should be BST in itself
                        rightTreeInfo.isBST
                        && //curr root node should be greater than the max node
                        //value in its left subtree i.e leftTreeInfo.maxInLeftSubtree
                        //also
                        //curr root node should be less than the min node
                        //value in its right subtree i.e rightTreeInfo.minInRightSubtree
                        (root.getData() > leftTreeInfo.maxInLeftSubtree
                        && root.getData() < rightTreeInfo.minInRightSubtree);

                //now, that if the curr subtree rooted at this curr root node
                //is a BST then we will compare the max BST subtree sum
                if (currRootInfo.isBST) {
                    maxBSTSubtreeSum = Math.max(maxBSTSubtreeSum, currRootInfo.sum);
                }
            }
        }

        Helper helper = new Helper();

        helper.helperDFS(root, new NodeInfo());
        //output
        //-ve max value are default to 0, acc to quest
        System.out.println("Max BST sum in binary tree : "
                + (helper.maxBSTSubtreeSum < 0 ? 0 : helper.maxBSTSubtreeSum));
    }

    // STACK
    int middleElementInStack_Element = Integer.MIN_VALUE;

    private void middleElementInStack_Helper(Stack<Integer> s, int n, int index) {

        if (n == index || s.isEmpty()) {
            return;
        }

        int ele = s.pop();
        middleElementInStack_Helper(s, n, index + 1);
        if (index == n / 2) {
            middleElementInStack_Element = ele;
        }
        s.push(ele);
    }

    public void middleElementInStack(Stack<Integer> stack) {
        int n = stack.size();
        int index = 0;
        //just reseting
        middleElementInStack_Element = Integer.MIN_VALUE;
        middleElementInStack_Helper(stack, n, index);
        //outputs
        System.out.println("Middle eleement of the stack: " + middleElementInStack_Element);
    }

    public void nextSmallerElementToRightInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() > val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next smaller element to the right in array: " + Arrays.toString(result));
    }

    public void nextSmallerElementToLeftInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() > val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next smaller element to the left in array: " + Arrays.toString(result));
    }

    public void nextGreaterElementToRightInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = n - 1; i >= 0; i--) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() < val) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next greater element to the right in the array: " + Arrays.toString(result));
    }

    public void nextGreaterElementToLeftInArray(int[] arr) {
        int n = arr.length;
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[n];
        for (int i = 0; i < n; i++) {
            int val = arr[i];
            while (!stack.isEmpty() && stack.peek() < arr[i]) {
                stack.pop();
            }

            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(val);
        }
        //output
        System.out.println("Next greater element to the left in the array: " + Arrays.toString(result));
    }

    private void reserveStack_Recursion_Insert(Stack<Integer> stack, int element) {

        if (stack.isEmpty()) {
            stack.push(element);
            return;
        }

        int popped = stack.pop();
        reserveStack_Recursion_Insert(stack, element);
        stack.push(popped);
    }

    private void reserveStack_Recursion(Stack<Integer> stack) {

        if (stack.isEmpty()) {
            return;
        }

        int popped = stack.pop();
        reserveStack_Recursion(stack);
        reserveStack_Recursion_Insert(stack, popped);
    }

    public void reverseStack(Stack<Integer> stack) {
        System.out.println("actual: " + stack);
        reserveStack_Recursion(stack);
        System.out.println("output: " + stack);
    }

    public void largestAreaInHistogram(int[] heights) {
        //https://leetcode.com/problems/largest-rectangle-in-histogram/
        // Create an empty stack. The stack holds indexes of hist[] array 
        // The bars stored in stack are always in increasing order of their 
        // heights. 
        Stack<Integer> stack = new Stack<>();
        int n = heights.length;
        int maxArea = 0; // Initialize max area 
        int top;  // To store top of stack 
        int areaWithTop; // To store area with top bar as the smallest bar 

        // Run through all bars of given histogram 
        int index = 0;
        while (index < n) {
            // If this bar is higher than the bar on top stack, push it to stack 
            if (stack.isEmpty() || heights[stack.peek()] <= heights[index]) {
                stack.push(index++);

                // If this bar is lower than top of stack, then calculate area of rectangle  
                // with stack top as the smallest (or minimum height) bar. 'i' is  
                // 'right index' for the top and element before top in stack is 'left index' 
            } else {

                top = stack.pop();  // store the top index 
                // Calculate the area with hist[tp] stack as smallest bar 
                areaWithTop = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
                // update max area, if needed 
                maxArea = Math.max(maxArea, areaWithTop);
            }
        }

        // Now pop the remaining bars from stack and calculate area with every 
        // popped bar as the smallest bar 
        while (!stack.isEmpty()) {
            top = stack.pop();
            areaWithTop = heights[top] * (stack.isEmpty() ? index : index - stack.peek() - 1);
            maxArea = Math.max(maxArea, areaWithTop);
        }

        //output:
        System.out.println("Max area of histogram: " + maxArea);
    }

    public void postfixExpressionEvaluation_SingleDigit(String expr) {
        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < expr.length(); i++) {

            char ch = expr.charAt(i);
            if (Character.isDigit(ch)) {
                stack.push(ch - '0');
            } else {
                int num1 = stack.pop();
                int num2 = stack.pop();

                switch (ch) {
                    case '+':
                        stack.push(num2 + num1);
                        break;
                    case '-':
                        stack.push(num2 - num1);
                        break;
                    case '*':
                        stack.push(num2 * num1);
                        break;
                    case '/':
                        stack.push(num2 / num1);
                        break;
                }
            }
        }

        //output:
        System.out.println("Evaluation single digit expression: " + stack.pop());
    }

    public void postfixExpressionEvaluation_MultipleDigit(String expr) {
        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < expr.length(); i++) {

            char ch = expr.charAt(i);

            //space is needed in expr to distinguish b/w 2 different multiple digit
            if (ch == ' ') {
                continue;
            }

            //if we found atleat one digit
            //try to iterate i until we found a char chr which is not a digit
            if (Character.isDigit(ch)) {
                int createNum = 0;
                while (Character.isDigit(expr.charAt(i))) {
                    createNum = createNum * 10 + (expr.charAt(i) - '0');
                    i++; //this to further iterate i and find digit char 
                }
//                i--; //just to balance to one iter back
                stack.push(createNum);
            } else {
                int num1 = stack.pop();
                int num2 = stack.pop();

                switch (ch) {
                    case '+':
                        stack.push(num2 + num1);
                        break;
                    case '-':
                        stack.push(num2 - num1);
                        break;
                    case '*':
                        stack.push(num2 * num1);
                        break;
                    case '/':
                        stack.push(num2 / num1);
                        break;
                }
            }
        }

        //output:
        System.out.println("Evaluation multiple digit expression: " + stack.pop());
    }

    public void removeKDigitsToCreateSmallestNumber(String num, int K) {

        //explanation: https://youtu.be/vbM41Zql228
        if (K == num.length()) {
            System.out.println("Number formed: 0");
            return;
        }

        StringBuilder sb = new StringBuilder();
        Stack<Integer> stack = new Stack<>();

        for (char ch : num.toCharArray()) {
            int digit = ch - '0';
            //Greedily take the smaller digit than stack's peek digit
            //ex: "1432219"
            //stack [1]
            //stack [1, 4] as not 1 > 4
            //stack [1, 3] as 4 > 3 
            //becasue if number has to be formed in that case 14 > 13 smaller num req 13 and so on.
            while (!stack.isEmpty() && stack.peek() > digit && K != 0) {
                stack.pop();
                K--;
            }
            stack.push(digit);
        }

        //case when all the digits in the stack are same
        //ex: 1111
        while (!stack.isEmpty() && K != 0) {
            stack.pop();
            K--;
        }

        //form the number
        //ex: "1432219"
        //stack would be having [1, 2, 1, 9] <- peek
        //pop element and add then at 0th index so sb = "1219"
        while (!stack.isEmpty()) {
            sb.insert(0, stack.pop());
        }

        //case when there are leading zeros in num 
        //ex: 000234 => 234
        while (sb.length() > 1 && sb.charAt(0) == '0') {
            sb.deleteCharAt(0);
        }

        //output
        System.out.println("Number formed: " + sb.toString());
    }

    public void findTheMostCompetetiveSubsequenceOfSizeKFromArray(int[] nums, int K) {

        //problem: https://leetcode.com/problems/find-the-most-competitive-subsequence/
        //explanation: https://leetcode.com/problems/find-the-most-competitive-subsequence/discuss/1113429/Java-Brute-Force-Stack
        int n = nums.length;
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            int val = nums[i];

            while (stack.size() > 0 && stack.size() + n - (i + 1) >= K
                    && stack.peek() > val) {
                stack.pop();
            }
            stack.push(val);
        }

        while (!stack.isEmpty() && stack.size() > K) {
            stack.pop();
        }
        //output
        int[] result = stack.stream().mapToInt(val -> val).toArray();
        for (int x : result) {
            System.out.print(x + " ");
        }

        System.out.println();
    }

    public void nextWarmerDayInTheGivenWeatherRecordings(int[] recordings) {

        //SIMILAR TO NEXT GREATER ELEMENT TO RIGHT
        //problem statement: https://youtu.be/0mcAy91rPzE
        //https://leetcode.com/problems/daily-temperatures/
        int n = recordings.length;
        List<Integer> daysAfter = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        for (int i = n - 1; i >= 0; i--) {

            while (!stack.isEmpty() && recordings[stack.peek()] < recordings[i]) {
                stack.pop();
            }

            if (stack.isEmpty()) {
                daysAfter.add(0);
            } else {
                daysAfter.add(stack.peek() - i);
            }

            stack.push(i);
        }

        //output:
        Collections.reverse(daysAfter);
        System.out.println("For each recording next warm day occur after:");
        for (int i = 0; i < n; i++) {
            if (daysAfter.get(i) == 0) {
                System.out.println(recordings[i] + ": after " + daysAfter.get(i) + " day, there is no warm day after this recrding");
                continue;
            }
            System.out.println(recordings[i] + ": after " + daysAfter.get(i) + " day, there is a warm day i,e: " + recordings[i + daysAfter.get(i)]);
        }
    }

    private void rotAllAdjacent(int[][] basket,
            int x, int y,
            boolean[][] visited,
            int row, int col) {

        //all aadjacent coordinate
        //check new coordinates are in bounds
        //check new coordinates are not previously visited
        //maake the adjacent rot and mark them visited
        int x1 = -1;
        int y1 = -1;

        //left coordinate to row,col = row, col-1
        x1 = x;
        y1 = y - 1;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //right coordinate to row,col = row, col+1
        x1 = x;
        y1 = y + 1;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //top coordinate to row,col = row-1, col
        x1 = x - 1;
        y1 = y;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

        //bottom coordinate to row,col = row+1, col
        x1 = x + 1;
        y1 = y;
        if ((x1 >= 0 && x1 < row) && (y1 >= 0 && y1 < col) && visited[x1][y1] != true && basket[x1][y1] != 0) {
            visited[x1][y1] = true; //maark them visited
            basket[x1][y1] = 2; //make them rot
            rotAllAdjacent(basket, x1, y1, visited, row, col);
        }

    }

    public void rottenOranges_DFS(int[][] basket) {

        int rottenTime = 0;
        int row = basket.length;
        int col = basket[0].length;

        boolean[][] visited = new boolean[row][col];

        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (visited[x][y] != true && basket[x][y] == 2) {
                    //rotten oranges == 2
                    visited[x][y] = true;
                    rottenTime++;
                    rotAllAdjacent(basket, x, y, visited, row, col);
                }
            }
        }

        //check if any one is left unrotten(1)
        for (int x = 0; x < row; x++) {
            for (int y = 0; y < col; y++) {
                if (basket[x][y] == 1) {
                    //rotten oranges == 2
                    rottenTime = -1;
                }
            }
        }

        System.out.println("rotten time " + rottenTime);

    }

    public int rottenOranges_HashBased(int[][] grid) {
        //https://leetcode.com/problems/rotting-oranges/
        Set<String> fresh = new HashSet<>();
        Set<String> rotten = new HashSet<>();
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {

                if (grid[i][j] == 1) {
                    fresh.add(i + "" + j);
                }

                if (grid[i][j] == 2) {
                    rotten.add(i + "" + j);
                }
            }
        }

        int minTime = 0;
        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };
        Set<String> infected = new HashSet<>();
        while (fresh.size() > 0) {
            //loop over all the rotten oranges
            for (String rottenPoint : rotten) {
                //get coord of all the curr rotten orange
                int x = rottenPoint.charAt(0) - '0';
                int y = rottenPoint.charAt(1) - '0';
                //find all the adjacent 4-directions from the 
                //curr rotten orange
                for (int[] dir : dirs) {
                    int newX = x + dir[0];
                    int newY = y + dir[1];
                    //if any adjacent 4-directions contains a fresh orange
                    //that means the curr rotten orange has infected it(in 1 unit time)
                    if (fresh.contains(newX + "" + newY)) {
                        //fresh is now infected by curr rotten orange
                        //so remove from fresh coords
                        fresh.remove(newX + "" + newY);
                        //move this newly infected orange into infected coord
                        infected.add(newX + "" + newY);
                    }
                }
            }

            //if at any point, we are unable to infect any fresh oranges
            //out infected coord will remain empty, so return -1
            if (infected.isEmpty()) {
                return -1;
            }

            //put all the infected oranges into rotten coords and clear infected
            //for next time
            rotten.addAll(infected);
            infected.clear();
            minTime++;
        }

        return minTime;
    }

    public void validSudoku(String[][] grid) {
        //https://leetcode.com/problems/valid-sudoku/
        //https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/
        //Explanantion: https://youtu.be/Pl7mMcBm2b8
        HashSet<String> vis = new HashSet<>();

        for (int x = 0; x < grid.length; x++) {
            for (int y = 0; y < grid[x].length; y++) {

                String curr = grid[x][y];
                if (!curr.equals(".")) {

                    if (!vis.add(curr + " at row: " + x)
                            || !vis.add(curr + " at col: " + y)
                            || !vis.add(curr + " in cell: " + (x / 3) + "-" + (y / 3))) {
                        System.out.println("Invalid sudoku grid");
                        return;
                    }
                }
            }
        }

        System.out.println("Valid sudoku grid");
    }

    public void minCostOfRope(int[] ropes) {

        //GREEDY ALGO
        //HEAP based approach
        PriorityQueue<Integer> minHeapRopes = new PriorityQueue<>();
        for (int rope : ropes) {
            minHeapRopes.add(rope);
        }

        //calculations
        int cost = 0;
        while (minHeapRopes.size() >= 2) {

            int rope1 = minHeapRopes.poll();
            int rope2 = minHeapRopes.poll();

            cost += rope1 + rope2;
            int newRope = rope1 + rope2;
            minHeapRopes.add(newRope);
        }
        //output
        System.out.println("Min cost to combine all rpes into one rope: " + cost);
    }

    public void kLargestElementInArray(int[] arr, int K) {

        PriorityQueue<Integer> minHeap = new PriorityQueue<>((o1, o2) -> o1.compareTo(o2));
        for (int x : arr) {
            minHeap.add(x);
            if (minHeap.size() > K) {
                minHeap.poll();
            }
        }

        int[] result = new int[minHeap.size()];
        int index = minHeap.size() - 1;
        while (!minHeap.isEmpty()) {

            result[index--] = minHeap.poll();
        }

        //output
        System.out.println("K largest elements: " + Arrays.toString(result));
    }

    public void kLargestElementInStringNumsArray(String[] nums, int k) {
        //https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/description/

        PriorityQueue<String> minHeapStringNums = new PriorityQueue<>((a, b) -> {
            //**custom comparator as min heap**
            //if "80" length < "3000" length put "80" first
            //despite having a comparision on chars '8' & '3'
            if (a.length() < b.length()) {
                return -1;
            } else if (b.length() < a.length()) {
                return 1;
            }
            //here we are having same length for both a and b string nums
            //so decide which numeric char is smaller out of the two
            return a.compareTo(b) <= 0 ? -1 : 1;
        });

        for (String num : nums) {
            minHeapStringNums.add(num);
            if (minHeapStringNums.size() > k) {
                minHeapStringNums.poll();
            }
        }

        //output
        System.out.println("K-th largest element in string nums array: " + minHeapStringNums.peek());
    }

    public void mergeKSortedArrays_1(int[][] arr) {
        //......................T: O(M*N*Log(M*N)), where M = row & N = col
        //......................S: O(M*N)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int[] row : arr) {
            for (int cell : row) {
                minHeap.add(cell);
            }
        }

        List<Integer> sortedList = new ArrayList<>();
        while (!minHeap.isEmpty()) {
            sortedList.add(minHeap.poll());
        }

        //output:
        System.out.println("K sorted array into a list: " + sortedList);
    }

    public void mergeKSortedArrays_2(int[][] arr) {

        class Input {

            final int row;
            int col;
            final int colLength;

            public Input(int row, int col, int colLength) {
                this.row = row;
                this.col = col;
                this.colLength = colLength;
            }
        }

        //OPTIMISED
        //........................T: O(N*K*LogK)
        //........................S: O(K)
        PriorityQueue<Input> minHeap = new PriorityQueue<>((a, b) -> arr[a.row][a.col] - arr[b.row][b.col]);
        //minHeap will hold start coordinate(row, col) for all the elements in each row not the total R*C elements directly
        for (int r = 0; r < arr.length; r++) {
            if (arr[r].length > 0) {
                minHeap.add(new Input(r, 0, arr[r].length));
            }
        }
        //after this loop minHeap will have K instance of Input() holding (row, col)  for each row
        //minHeap.size() == K

        List<Integer> sortedList = new ArrayList<>();
        while (!minHeap.isEmpty()) {

            //At any point of time we poll Input from minHeap
            Input in = minHeap.poll();
            //we put the element at that row, col
            sortedList.add(arr[in.row][in.col]);
            //if new col is less than its col length
            //we update col and put that updated input(in) in minHeap back
            if (in.col + 1 < in.colLength) {
                in.col++;
                minHeap.add(in);
            }
        }

        //output:
        System.out.println("K sorted array into a list: " + sortedList);
    }

    public void kThLargestSumFromContigousSubarray(int[] arr, int K) {
        //................................T: O(N^2 * LogK)
        //................................S: O(K), only K elements are stored at a time in heap
        //https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/
        //arr[]: [20, -5, -1]
        //contSumSubarry: [20, 15, 14, -5, -6, -1]
        //20, 20+(-5), 20+(-5)+(-1), -5, -5+(-1), -1 
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        //generating subarrays
        for (int i = 0; i < arr.length; i++) {
            int contSum = 0;
            for (int j = i; j < arr.length; j++) {
                contSum += arr[j];
                minHeap.add(contSum);
                if (minHeap.size() > K) {
                    minHeap.poll();
                }
            }
        }
        System.out.println("kth largest sum from contigous subarray: " + minHeap.peek());
    }

    public void majorityElement_1(int[] a) {
        //.............T: O(N)
        //.............S: O(Unique ele in a)
        //https://leetcode.com/problems/majority-element/
        //https://leetcode.com/problems/majority-element-ii/
        int maj = a.length / 2;

        Map<Integer, Integer> map = new HashMap<>();
        for (int x : a) {
            map.put(x, map.getOrDefault(x, 0) + 1);
        }

        for (Map.Entry<Integer, Integer> e : map.entrySet()) {
            if (e.getValue() > maj) {
                System.out.println("Majority element: " + e.getKey());
                return;
            }
        }

        System.out.println("Majority element: -1");
    }

    public void majorityElement_2(int[] a) {
        //Moore’s Voting Algorithm
        //https://leetcode.com/problems/majority-element/
        //https://www.geeksforgeeks.org/majority-element/
        //..........T: O(N)
        //..........S: O(1)
        //finding candidate
        int majorIndex = 0;
        int count = 1;
        int i;
        for (i = 1; i < a.length; i++) {
            if (a[majorIndex] == a[i]) {
                count++;
            } else {
                count--;
            }
            if (count == 0) {
                majorIndex = i;
                count = 1;
            }
        }
        int cand = a[majorIndex];

        //validating the cand 
        count = 0;
        for (i = 0; i < a.length; i++) {
            if (a[i] == cand) {
                count++;
            }
        }
        if (count > a.length / 2) {
            System.out.println("Majority element: " + cand);
        } else {
            System.out.println("Majority element: -1");
        }

    }

    public void mergeTwoSortedArraysWithoutExtraSpace(int[] arr1, int[] arr2, int m, int n) {

        //https://www.geeksforgeeks.org/merge-two-sorted-arrays-o1-extra-space/
        // Iterate through all elements of ar2[] starting from 
        // the last element 
        for (int i = n - 1; i >= 0; i--) {
            /* Find the smallest element greater than ar2[i]. Move all 
             elements one position ahead till the smallest greater 
             element is not found */
            int j, last = arr1[m - 1];
            for (j = m - 2; j >= 0 && arr1[j] > arr2[i]; j--) {
                arr1[j + 1] = arr1[j];
            }

            // If there was a greater element 
            if (j != m - 2 || last > arr2[i]) {
                arr1[j + 1] = arr2[i];
                arr2[i] = last;
            }
        }

        //output
        for (int x : arr1) {
            System.out.print(x + " ");
        }
        System.out.println();
        for (int x : arr2) {
            System.out.print(x + " ");
        }

        System.out.println();
    }

    private int findFirstOccurenceKInSortedArray(int[] arr, int K, int start, int end, int N) {
        if (end >= start) {
            int mid = start + (end - start) / 2;
            if ((mid == 0 || K > arr[mid - 1]) && arr[mid] == K) {
                return mid;
            } else if (K > arr[mid]) {
                return findFirstOccurenceKInSortedArray(arr, K, (mid + 1), end, N);
            } else {
                return findFirstOccurenceKInSortedArray(arr, K, start, (mid - 1), N);
            }
        }
        return -1;
    }

    private int findLastOccurenceKInSortedArray(int[] arr, int K, int start, int end, int N) {
        if (end >= start) {
            int mid = start + (end - start) / 2;
            if ((mid == N - 1 || K < arr[mid + 1]) && arr[mid] == K) {
                return mid;
            } else if (K < arr[mid]) {
                return findLastOccurenceKInSortedArray(arr, K, start, (mid - 1), N);
            } else {
                return findLastOccurenceKInSortedArray(arr, K, (mid + 1), end, N);
            }
        }
        return -1;
    }

    public void findFirstAndLastOccurenceOfKInSortedArray(int[] arr, int K) {
        //https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
        //https://leetcode.com/problems/find-target-indices-after-sorting-array/
        //https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/
        int N = arr.length;
        int first = findFirstOccurenceKInSortedArray(arr, K, 0, N - 1, N);
        int last = findLastOccurenceKInSortedArray(arr, K, 0, N - 1, N);

        System.out.println(K + " first and last occurence: " + first + " " + last);
    }

    public int searchInRotatedSortedArray(int[] nums, int K) {
        //https://leetcode.com/problems/search-in-rotated-sorted-array
        //explanation: https://youtu.be/oTfPJKGEHcc
        /*
        normal sorted nums[]: [0, 1, 2, 3, 4, 5, 6, 7, 8]
        rotated sorted nums[]: [5, 6, 7, 8, 0, 1, 2, 3, 4]
        left sorted sec = [5, 6, 7, 8] strictly increasing
        right sorted sec = [0, 1, 2, 3, 4] strictly increasing
         */
        int start = 0;
        int end = nums.length - 1;
        int N = nums.length;

        while (end >= start) {

            int mid = start + (end - start) / 2;
            if (nums[mid] == K) {
                return mid;
            }
            //left sorted section
            //if nums[mid] lies in left sorted sec then it is obvious that
            //nums[start] will be nums[start] <= nums[mid]
            //else if nums[mid] lies in right sorted sec then each values of
            //left sorted sec is greater than each values of right sorted sec
            //means this if cond (nums[start] <= nums[mid]) will fail
            if (nums[start] <= nums[mid]) {
                //we are in left sorted sec and also if target lies in
                //left sorted sec range then move end to left sorted sec
                //(reducing search window to left sorted sec only)
                //otherwise move start to right sorted sec
                if (K >= nums[start] && K < nums[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }

            } else {
                //right sorted section
                //we are in right sorted sec and also if target lies in
                //right sorted sec range then mode start to right sorted sec
                //(reducing search window to right sorted sec only)
                //otherwise move end to left-sec
                if (K > nums[mid] && K <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        return -1;
    }

    public int searchInRotatedSortedArrayWithDuplicateArrayElement(int[] arr, int K) {

        int start = 0;
        int end = arr.length - 1;
        int N = arr.length;
        int mid = -1;

        while (end >= start) {

            //shift front till arr[f] is same as arr[f+1]
            //when f and f+1 elements are diff loop will end
            while (start < end && arr[start] == arr[start + 1]) {
                start++;
            }
            //shift last till arr[l] is same as arr[l-1]
            //when l and l-1 elements are diff loop will end
            while (start < end && arr[end] == arr[end - 1]) {
                end--;
            }

            mid = start + (end - start) / 2;
            if (arr[mid] == K) {
                return mid;
            }

            if (arr[start] <= arr[mid]) {

                if (K >= arr[start] && K < arr[mid]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }

            } else {
                if (K > arr[mid] && K <= arr[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }

        return -1;
    }

    public void findRepeatingAndMissingInUnsortedArray_1(int[] arr) {
        //https://leetcode.com/problems/set-mismatch/
        //problem statement: https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
        //arr: will be of size N and elements in arr[] will be [1..N]
        //.......................T: O(N)
        //.......................S: O(N)
        System.out.println("Approach 1");
        int[] count = new int[arr.length + 1];
        //get the occurence of arr element in count[] where count[i] i: elements in arr
        for (int i = 0; i < arr.length; i++) {
            count[arr[i]]++;
        }

        for (int i = 1; i < count.length; i++) {
            //first ith index that has count[i] = 0 is the element in arr which is supposed to be missing
            //count[i] == 0 => i = element in arr is supposed to be missing
            if (count[i] == 0) {
                System.out.println("Missing: " + i);
                break;
            }
        }

        for (int i = 1; i < count.length; i++) {
            //first ith index which has count[i] > 1 (occuring more that 1)
            //is the element which is repeating
            //count[i] > 1 => i = element in arr which is repeating
            if (count[i] > 1) {
                System.out.println("Repeating: " + i);
                break;
            }
        }
    }

    public void findRepeatingAndMissingInUnsortedArray_2(int[] arr) {
        //https://leetcode.com/problems/set-mismatch/
        //problem statement: https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
        //explanation: https://youtu.be/aMsSF1Il3IY
        //OPTIMISED
        //.......................T: O(N)
        //.......................S: O(1)
        System.out.println("Approach 2");
        System.out.println("Repeating element: ");
        for (int val : arr) {
            int absVal = Math.abs(val);
            if (arr[absVal - 1] > 0) {
                arr[absVal - 1] = -arr[absVal - 1];
            } else {
                System.out.println(absVal);
            }
        }

        System.out.println("Missing element: ");
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0) {
                System.out.println(i + 1);
            }
        }
    }

    public boolean checkIfPairPossibleInArrayHavingGivenDiff(int[] arr, int diff) {

        //..................T; O(N)
        //..................S: O(N)
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < arr.length; i++) {
            //arr[row] - arr[col] = diff
            //arr[row] = diff + arr[col]
            //if set.contains(arr[col]) then pair is possible
            if (set.contains(arr[i])) {
                return true;
            }

            //arr[row] = arr[col] +diff
            set.add(arr[i] + diff);
        }

        return false;
    }

    private double squareRootOfANumber_PreciseDoubleValue_BinarySearch(double n, double start, double end) {

        if (end >= start) {

            double mid = start + (end - start) / 2.0;
            double sqr = mid * mid;

            if (sqr == n || Math.abs(n - sqr) < 0.00001) {
                return mid;
            } else if (sqr < n) {
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, mid, end);
            } else {
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, start, mid);
            }
        }

        return 1.0;
    }

    public double squareRootOfANumber_PreciseDoubleValue(double n) {

        //https://leetcode.com/problems/sqrtx/
        if (n == 0.0 || n == 1.0) {
            return n;
        }

        double i = 1;
        while (true) {
            double sqr = i * i;
            if (sqr == n) {
                return i;
            } else if (sqr > n) {
                //at this point where sqr of i is > n then that means sqr root for n lies b/w 
                // i-1 and i
                //ex sqrt(3) == 1.73 (lie b/w 1 and 2)
                // i = 1 sqr = 1*1 = 1
                //i = 2 sqr = 2*2 = 4
                //4 > n i.e 4 > 3 that means sqrt(3) lie in b/w 1 and 2
                //so we will do binary search i-1, i (1, 2)
                return squareRootOfANumber_PreciseDoubleValue_BinarySearch(n, i - 1, i);
            }
            i++;
        }
    }

    public int squareRootOfANumber_RoundedIntValue(int x) {

        //https://leetcode.com/problems/sqrtx/
        long start = 0;
        long end = (x / 2) + 1;

        while (end > start) {

            long mid = start + (end - start) / 2 + 1;
            long sqr = mid * mid;
            if (sqr == x) {
                return (int) mid;
            } else if (x < sqr) {
                end = mid - 1;
            } else {
                start = mid;
            }
        }
        return (int) start;
    }

    public void kThElementInTwoSortedArrays_1(int[] a, int[] b, int K) {

        //HEAP SORTING AND MERGING
        //...........................T: O((N+M).Log(N+M))
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        for (int a_ : a) {
            minHeap.add(a_);
        }

        for (int b_ : b) {
            minHeap.add(b_);
        }

        //pop out K element from heap
        int kthElement = -1;
        while (K-- != 0 && !minHeap.isEmpty()) {
            kthElement = minHeap.poll();
        }

        //output:
        System.out.println("Kth element in two sorted arrays: " + kthElement);
    }

    public void kThElementInTwoSortedArrays_2(int[] a, int[] b, int K) {

        //Two arrays are already sorted
        //...........................T: O(K)
        int iK = 0;
        int m = a.length;
        int n = b.length;
        int i = 0;
        int j = 0;
        int kthElement = -1;

        while (i < m && j < n) {

            if (a[i] < b[j]) {
                iK++;
                if (iK == K) {
                    kthElement = a[i];
                    break;
                }
                i++;
            } else {
                iK++;
                if (iK == K) {
                    kthElement = b[j];
                    break;
                }
                j++;
            }
        }

        //if loop ends beacuse we run out of one array element
        while (i < m) {
            iK++;
            if (iK == K) {
                kthElement = a[i];
            }
            i++;
        }

        while (j < n) {
            iK++;
            if (iK == K) {
                kthElement = b[j];
            }
            j++;
        }

        //output:
        System.out.println("Kth element in two sorted arrays: " + kthElement);
    }

    public int findMinimumInRotatedSortedArray(int[] nums) {
        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/
        //explanation: https://youtu.be/IzHR_U8Ly6c
        /*
        lets take an expample of sorted array[]
        nums[] = [1,2,3,4,5]
        
        in sorted incr array(non rotated), there is always a single upward slope
        
        ..................................5
        ................................./
        ................................4
        .............................../
        ..............................3
        ............................./
        ............................2
        .........................../
        ..........................1
        
        
        now rotate this nums[] = [3,4,5,1,2]
        
        ...................................5...2
        ................................./..\./
        ................................4....1
        .............................../
        ..............................3
        
        now after the rotation, we can see there are two upward slope(3 -> 5) & (1 -> 2)
        and one dip/falling slope (5 -> 1) 
        
        in our binary search, we need to find a 'mid' which is the bottom point
        of the falling slope and our min-in-rotated-rotated-array here that bottom
        point is '1' on mid == 3 since its falling slope, just before this point
        there will be peek value that is '5' always on (mid - 1)
        
        hence this cond is there ==> (mid > 0 && nums[mid - 1] > nums[mid]), since
        we are considering (mid - 1) so it can go out of bounds so check for (mid > 0)
        
        now in order to move the start or end ptr, we need to keep track of this
        peek point
        ==>
        ..................nums[mid]
        ................../.......\
        ................./.........\
        .........nums[start].......nums[end]
        
        some movement for example
        
        ==>
        start = 0, mid == 0, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ................3............2
        ==>
        start = 0, mid == 1, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ......................4
        ................../.......\
        ................./.........\
        ................3............2
        ==>
        start = 0, mid == 2, end = 4
        nums[start] <= nums[mid] && nums[mid] > nums[end]
        start = mid + 1
        ......................5
        ................../.......\
        ................./.........\
        ................3............2
        
        as long as we are seeing (nums[start] <= nums[mid] && nums[mid] > nums[end]) 
        we are following a peek value and we continue to find a peek value by moving
        start = mid + 1 why? as we said, right after a top peek, there will be a fall.
        our mid should point to this fall point
        
         */
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {
            int mid = start + (end - start) / 2;

            if (mid > 0 && nums[mid - 1] > nums[mid]) {
                return nums[mid];
            } else if (nums[start] <= nums[mid] && nums[mid] > nums[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return nums[start];
    }

    public int findMinimumInRotatedSortedArrayTwo(int[] nums) {
        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/
        //based exactly on findMinimumInRotatedSortedArray()
        //handle duplicated values
        int n = nums.length;
        int start = 0;
        int end = n - 1;

        while (end >= start) {

            //keep lopp on start ptr, until we skip all the duplicates of nums[start]
            while (start + 1 < n && nums[start] == nums[start + 1]) {
                start++;
            }

            //keep lopp on end ptr, until we skip all the duplicates of nums[end]
            while (end - 1 >= 0 && nums[end - 1] == nums[end]) {
                end--;
            }

            //if from above loops, we ever reach an invalid start & end ptr, break
            if (start > end) {
                break;
            }

            int mid = start + (end - start) / 2;
            if (mid > 0 && nums[mid - 1] > nums[mid]) {
                return nums[mid];
            } else if (nums[start] <= nums[mid] && nums[mid] > nums[end]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        return nums[start];
    }

    public void findLocalMinima(int[] arr) {

        int start = 0;
        int end = arr.length - 1;
        int mid = 0;
        while (end >= start) {

            mid = start + (end - start) / 2;

            if ((mid == 0 || arr[mid - 1] > arr[mid])
                    && (mid == arr.length - 1 || arr[mid + 1] > arr[mid])) {
                break;
            } else if (mid > 0 && arr[mid - 1] < arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        //output
        System.out.println("Local minima at index: " + mid + " element: " + arr[mid]);
    }

    public void findLocalMaxima(int[] arr) {

        //LOCAL MAXIMA OR PEAK ELEMENT
        //https://leetcode.com/problems/find-peak-element/
        //explanation: https://youtu.be/kMzJy9es7Hc
        int start = 0;
        int end = arr.length - 1;
        int mid = 0;
        while (end >= start) {

            mid = start + (end - start) / 2;

            if ((mid == 0 || arr[mid - 1] < arr[mid])
                    && (mid == arr.length - 1 || arr[mid + 1] < arr[mid])) {
                break;
            } else if (mid > 0 && arr[mid - 1] > arr[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }

        //output
        System.out.println("Local maxima at index: " + mid + " element: " + arr[mid]);
    }

    private int countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(int[] arr,
            int x, int start, int end) {

        //MODIFIED BINARY SERACH FOR THIS QUESTION
        //SIMILAR TO findLastOccurenecOfKInSortedArray()
        if (end >= start) {

            int mid = start + (end - start) / 2;

            if ((mid == arr.length - 1 || x < arr[mid + 1]) && arr[mid] == x) {
                return mid;
            } else if (x < arr[mid]) {
                return countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                        arr, x, start, mid - 1);
            } else {
                return countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                        arr, x, mid + 1, end);
            }
        }
        return end;
    }

    public void countElementsFromSecondArrayLessOrEqualToElementInFirstArray(int[] first, int[] second) {

        /*
         Brute force : T: O(N^2)
         `1. Use 2 for loop: 
         -> i for first[] 
         ---> count = 0
         ---> j for second[]
         ------> if second[j] <= first[i]: count++
         ---> print: count
         */
        //............................T: O((M + N) * LogN) where M = first.length, N = second.length
        //............................S: O(1)
        //https://www.geeksforgeeks.org/element-1st-array-count-elements-less-equal-2nd-array/
        Arrays.sort(second);
        List<Integer> result = new ArrayList<>();
        for (int x : first) {
            int index = countElementsFromSecondArrayLessOrEqualToElementInFirstArray_FindLastOccurenceOfX(
                    second, x, 0, second.length - 1);
            result.add(index + 1);
        }

        //output
        System.out.println("Count: " + result);
    }

    private int[] KMP_PatternMatching_Algorithm_LPSArray(String pattern, int size) {

        int[] lps = new int[size];
        lps[0] = 0; //always 0th index is 0
        int suffixIndex = 1;
        int prefixIndex = 0;
        while (suffixIndex < size) {

            if (pattern.charAt(prefixIndex) == pattern.charAt(suffixIndex)) {
                prefixIndex++;
                lps[suffixIndex] = prefixIndex;
                suffixIndex++;
            } else if (prefixIndex == 0) {
                lps[suffixIndex] = prefixIndex; // prefixIndex == 0
                suffixIndex++;
            } else {
                prefixIndex = lps[prefixIndex - 1];
            }
        }

        return lps;
    }

    public void KMP_PatternMatching_Algorithm(String text, String pattern) {
        //https://leetcode.com/problems/implement-strstr/
        //explanation: https://youtu.be/JoF0Z7nVSrA
        //explanation: https://youtu.be/ziteu2FpYsA
        int textLen = text.length();
        int patternLen = pattern.length();

        //create LPS array for pattern
        int[] lps = KMP_PatternMatching_Algorithm_LPSArray(pattern, patternLen);

        boolean atleastOneMatchFound = false;
        //text and pattern matching
        int textIndex = 0; // index for text
        int patternIndex = 0; // index for pattern
        while (textIndex < textLen) {

            if (textIndex < textLen && patternIndex < patternLen
                    && text.charAt(textIndex) == pattern.charAt(patternIndex)) {
                textIndex++;
                patternIndex++;
            } else if (patternIndex == 0) {
                textIndex++;
            } else {
                patternIndex = lps[patternIndex - 1];
            }

            if (patternIndex == patternLen) {
                //if atleast one match is found and want to stop matching further then simply do
                //return textIndex - patternLen;

                //this below logic will allow to find all matches in text
                System.out.println("Pattern matched at: " + (textIndex - patternLen));
                atleastOneMatchFound = true;
            }
        }
        if (!atleastOneMatchFound) {
            System.out.println("Pattern not matched");
        }
        //if pattern is not found
        //return -1;
    }

    public int editDistance_Recursion(String s1, String s2, int m, int n) {
        //https://leetcode.com/problems/edit-distance/description/
        //https://www.geeksforgeeks.org/edit-distance-dp-5/
        //explanation: https://youtu.be/XYi2-LPrwm4
        //https://youtu.be/MiqoA-yF-0M
        //if s1 is empty then whole s2 is to be inserted to convert s1 to s2
        if (m == 0) {
            return n;
        }

        //if s2 is empty then whole s1 is to be deleted to convert s1 to s2
        if (n == 0) {
            return m;
        }

        //if last char of two strings matches then just move ahead one char in both
        if (s1.charAt(m - 1) == s2.charAt(n - 1)) {
            return editDistance_Recursion(s1, s2, m - 1, n - 1);
        }

        //if the char doesn't matches then take the min of below 3
        int minOprn = Integer.MAX_VALUE;
        //insert
        //simulation, at m-th pos in s1 we have added a char from s2[n-th]
        //and move to next char in s2 by n - 1 but m-th char s1 is still need to
        //be matched with rest of chars in s2 so m remains on m-th char in s1
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m, n - 1));
        //delete
        //simulation, at m-th pos in s1 we have deleted a char from s1[m-th]
        //and move to next char in s1 by m - 1 but since we haven't matched n-th char
        //in s2 so n remains on n-th char in s2 to match with rest of chars in s1
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m - 1, n));
        //replace
        //simulation, char at n-th pos of s2 is put on m-th char of s1 that means
        //replacing m-th char of s1 with n-th char from s2. with this oprn we have
        //made m-th and n-th chars same as that of s2 so we can move to next indexes
        //m - 1 & n - 1 to check further
        minOprn = Math.min(minOprn, editDistance_Recursion(s1, s2, m - 1, n - 1));
        return minOprn + 1;
    }

    public int editDistance_DP_Memoization(String s1, String s2) {
        //https://leetcode.com/problems/edit-distance/description/
        //https://www.geeksforgeeks.org/edit-distance-dp-5/
        //explanation: https://youtu.be/XYi2-LPrwm4
        //https://youtu.be/MiqoA-yF-0M
        int m = s1.length();
        int n = s2.length();
        int[][] memo = new int[m + 1][n + 1];

        //base cond
        //in order to convert s1 to s2
        //if s1 is "" (row == 0) and s2 is valid then we need to INSERT char in s1 to be s2
        //if s1 is valid but s2 is "" (col == 0) then we need to DELETE char in s1 to be s2
        for (int x = 0; x < m + 1; x++) {
            for (int y = 0; y < n + 1; y++) {
                if (x == 0) {
                    memo[x][y] = y;
                } else if (y == 0) {
                    memo[x][y] = x;
                }
            }
        }

        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (s1.charAt(x - 1) == s2.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1];
                } else {
                    //if the char doesn't matches then take the min of below 3
                    int minOprn = Integer.MAX_VALUE;
                    //insert
                    //simulation, at m-th pos in s1 we have added a char from s2[n-th]
                    //and move to next char in s2 by n - 1 but m-th char s1 is still need to
                    //be matched with rest of chars in s2 so m remains on m-th char in s1
                    minOprn = Math.min(minOprn, memo[x][y - 1]);
                    //delete
                    //simulation, at m-th pos in s1 we have deleted a char from s1[m-th]
                    //and move to next char in s1 by m - 1 but since we haven't matched n-th char
                    //in s2 so n remains on n-th char in s2 to match with rest of chars in s1
                    minOprn = Math.min(minOprn, memo[x - 1][y]);
                    //replace
                    //simulation, char at n-th pos of s2 is put on m-th char of s1 that means
                    //replacing m-th char of s1 with n-th char from s2. with this oprn we have
                    //made m-th and n-th chars same as that of s2 so we can move to next indexes
                    //m - 1 & n - 1 to check further
                    minOprn = Math.min(minOprn, memo[x - 1][y - 1]);
                    memo[x][y] = minOprn + 1;
                }
            }
        }
        return memo[m][n];
    }

    public void minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(int[] coins, int change) {
        //Explanation ; SomePracticeQuestion.minNoOfCoinsUsedForChange()
        int N = coins.length;
        int[][] memo = new int[N + 1][change + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < change + 1; y++) {

                //if no coisn are available, we might need infinite-coins to make that change
                if (x == 0) {
                    memo[x][y] = Integer.MAX_VALUE - 1;
                }

                //if coins are available, but change we need to make is 0, wee need 0 coins
                if (y == 0) {
                    memo[x][y] = 0;
                }

                if (x == 1 && y >= 1) {
                    if (y % coins[x - 1] == 0) {
                        memo[x][y] = 1;
                    } else {
                        memo[x][y] = Integer.MAX_VALUE - 1;
                    }
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < change + 1; y++) {
                //if the amount of coins is greater than the change(col) we are making
                //then just leave that coin, and move from that without making any change in col
                if (coins[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    //two choices 
                    //1. take that coin and adjust the change col with the amount of that coin
                    //and add 1 as picking up 1 coins in min
                    //2. don't take that coins and move to next coin, without making any adjustment in change col
                    memo[x][y] = Math.min(memo[x][y - coins[x - 1]] + 1,
                            memo[x - 1][y]);
                }
            }
        }

        //output
        System.out.println("Minimum coins required to make change: " + memo[N][change]);
    }

    public void coinChange_DP_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change/description/
        //https://leetcode.com/problems/coin-change/editorial/
        //1-D memory optimization on minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization()
        int n = coins.length;
        int[] memo = new int[amount + 1];
        Arrays.fill(memo, amount + 1);
        memo[0] = 0;
        for (int coinIndex = 0; coinIndex < n; coinIndex++) {
            for (int currAmount = 1; currAmount < amount + 1; currAmount++) {
                if (coins[coinIndex] <= currAmount) {
                    memo[currAmount] = Math.min(memo[currAmount], 1 + memo[currAmount - coins[coinIndex]]);
                }
            }
        }
        //output
        System.out.println("Minimum number of coins to make change for amount: "
                + (memo[amount] > amount ? -1 : memo[amount]));
    }

    private int coinChange_Recursive_Memoization_Helper(int[] coins, int index, int amount, Integer[][] memo) {

        //if the amount for change is already 0 or it has reached 0(by makinh change),
        //then we had made change so there is 1 way we can make this change
        if (amount == 0) {
            return 1;
        }

        //if no coins available there, no way we can make any change
        //possibilities when amount for change is > 0 (thats why above if-block didn't work)
        //1. no coins are available to make change(== empty coins[])
        //so in the starting itself empty coins[] ==> index == coins.length == 0
        //2. we reached the index == coins.length meaning we ran out of coins to use
        //but amount is yet not 0 so we can't make any change further
        if (index == coins.length) {
            return 0;
        }

        if (memo[index][amount] != null) {
            return memo[index][amount];
        }

        //now we have two choices,
        //1. don't take the coin and don't adjust amount just move ahead for a new coin(== index + 1)
        int dontPick = coinChange_Recursive_Memoization_Helper(coins, index + 1, amount, memo);

        //2. take the coin (if coin value is less than or equal to amount we need to make change for)
        //and adjust the amount by this coin value but since coins are in infinte supply
        //then we can keep picking the same coins so keep index as it is
        int pick = 0;
        if (coins[index] <= amount) {
            pick = coinChange_Recursive_Memoization_Helper(coins, index, amount - coins[index], memo);
        }

        //total ways we can make change is ways if pick or dontPick the curr coin
        return memo[index][amount] = pick + dontPick;
    }

    public void coinChangeTwo_Recursive_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change-2/
        int n = coins.length;
        Integer[][] memo = new Integer[n + 1][amount + 1];
        int waysToMakeChange = coinChange_Recursive_Memoization_Helper(coins, 0, amount, memo);
        //output
        System.out.println("Ways to make change for given amount with infinite supply of coins: " + waysToMakeChange);
    }

    public void coinChangeTwo_DP_Memoization(int[] coins, int amount) {
        //https://leetcode.com/problems/coin-change-2/
        int N = coins.length;
        int[][] memo = new int[N + 1][amount + 1];

        //base
        //if(N == 0)
        for (int col = 0; col < amount + 1; col++) {
            memo[0][col] = 0;
        }
        //if(K == 0)
        for (int row = 0; row < N + 1; row++) {
            memo[row][0] = 1;
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < amount + 1; y++) {

                if (coins[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x][y - coins[x - 1]] + memo[x - 1][y];
                }
            }
        }

        System.out.println("Ways to make change for given amount with infinite supply of coins: " + memo[N][amount]);
    }

    public int knapSack01_Recursive_Memoization_Helper(
            int[] weight, int[] value, int W, int index, Integer[][] memo) {

        //if the knapsack capacity is already 0 or it has reached 0 or less
        //(by picking product of some weight[index])
        if (W <= 0) {
            return 0;
        }

        //if no products available there, no way we can pick anything in our knapsack
        //possibilities when knapsack has some capacity left > 0 (thats why above if-block didn't work)
        //1. no products are available to put in knapsack(== empty weight[] & value[])
        //so in the starting itself empty weight[] & value[] ==> index == value.length == 0
        //2. we reached the index == value.length meaning we ran out of products to pick
        if (index == value.length) {
            return 0;
        }

        if (memo[index][W] != null) {
            return memo[index][W];
        }

        //we have 2 choices to make if we want to get max value in given knapsack
        //of weight W
        //1. dont pick the curr value[index] of some weight[index] then its value
        //will not be considered and we move to next value(== index + 1)
        int dontPick = knapSack01_Recursive_Memoization_Helper(
                weight, value, W, index + 1, memo);

        //2. we choose to pick the curr value[index] of some weight[index] only
        //if the our curr knapsack have the capacity to hold this weight[index]
        //inside W(== weight[index] <= W, because if the weight of this product
        //is more than the knapSack capacity(W) then we must ignore it)
        //now we are picking this value[index] here means we have to consider its
        //value to be added and since we adding that means knapsack capacity must
        //be reduced by this weight[index](== W - weight[index])
        int pick = 0;
        if (weight[index] <= W) {
            pick = value[index] + knapSack01_Recursive_Memoization_Helper(
                    weight, value, W - weight[index], index + 1, memo);
        }

        //we now have to take max of these 2 descision
        return Math.max(dontPick, pick);
    }

    public void knapSack01_Recursive_Memoization(int[] weight, int[] value, int W) {
        int n = weight.length;
        Integer[][] memo = new Integer[n + 1][W + 1];
        int maxValueInKnapsack = knapSack01_Recursive_Memoization_Helper(weight, value, W, 0, memo);
        //output
        System.out.println("The maximum profit with given knap sack: " + maxValueInKnapsack);
    }

    public void knapSack01_DP_Memoization(int[] weight, int[] value, int W) {

        int N = value.length;
        int[][] memo = new int[N + 1][W + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < W + 1; y++) {
                //No product row == N == 0
                //No knapSack capacity col == W == 0
                if (x == 0 || y == 0) {
                    memo[x][y] = 0;
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < W + 1; y++) {
                if (weight[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = Math.max(
                            value[x - 1] + memo[x - 1][y - weight[x - 1]],
                            memo[x - 1][y]);
                }
            }
        }

        System.out.println("The maximum profit with given knap sack: " + memo[N][W]);
    }

    public boolean subsetSum_Recursive_Memoization_Helper(int[] arr, int sum, int index, Boolean[][] memo) {

        //if the sum given is already 0 then we always have a subset from arr[]
        //whoose sum will be 0 i.e, empty subset {} subset sum == sum == 0
        //OR our sum has reached 0 by picking some arr values from arr[]
        //return true in both cases
        if (sum == 0) {
            return true;
        }

        //if no arr values available there, no way we add any value to our subset
        //possibilities when given sum is > 0 (thats why above if-block didn't work)
        //1. no arr values are available to put in subset(== empty arr[])
        //so in the starting itself empty arr[] ==> index == arr.length == 0
        //2. we reached the index == arr.length meaning we ran out of arr values
        //to pick and further we can't pick any value so we have to return false
        //because our sum didn't reach 0 but index reached its limit
        if (index == arr.length) {
            return false;
        }

        if (memo[index][sum] != null) {
            return memo[index][sum];
        }

        //here we have 2 choices to make
        //1. dont pick the curr arr value at index and move to next index(== index + 1)
        //and hence the sum will also not change
        boolean dontPick = subsetSum_Recursive_Memoization_Helper(arr, sum, index + 1, memo);

        //2. we pick the curr arr value at index, only if the curr arr value is
        //less than equals to the 'sum' we want to make and then move to next
        //index(== index + 1) and since we taking this curr arr value we must
        //reduce our sum by this arr value
        boolean pick = false;
        if (arr[index] <= sum) {
            pick = subsetSum_Recursive_Memoization_Helper(arr, sum - arr[index], index + 1, memo);
        }

        //from our 2 choices, if it possible to have some subset from arr[] that
        //sum upto given 'sum', we return that (OR any of the choice gives true
        //then return true)
        return memo[index][sum] = dontPick || pick;

    }

    public void subsetSum_Recursive_Memoization(int[] arr, int sum) {
        int n = arr.length;
        Boolean[][] memo = new Boolean[n + 1][sum + 1];
        boolean subsetSumPossible = subsetSum_Recursive_Memoization_Helper(arr, sum, 0, memo);
        //output
        System.out.println("Subset of array equal to given sum is possible: " + subsetSumPossible);
    }

    public void subsetSum_DP_Memoization(int[] arr, int sum) {

        int N = arr.length;
        boolean[][] memo = new boolean[N + 1][sum + 1];

        //base cond
        for (int x = 0; x < N + 1; x++) {
            for (int y = 0; y < sum + 1; y++) {
                //if array is empty then any given sum is not possible (except sum == 0) 
                if (x == 0) {
                    memo[x][y] = false;
                }

                //if the given sum is just 0 then it can be prove even if the arrays is empty or full
                if (y == 0) {
                    memo[x][y] = true;
                }
            }
        }

        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < sum + 1; y++) {
                if (arr[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x - 1][y - arr[x - 1]] || memo[x - 1][y];
                }
            }
        }

        System.out.println("Subset of array equal to given sum is possible: " + memo[N][sum]);
    }

    public void equalsSumPartition_SubsetSum(int[] arr) {

        int arrSum = 0;
        for (int ele : arr) {
            arrSum += ele;
        }

        if (arrSum % 2 == 1) {
            //if odd no equal partition is possble for the given sum
            //arr = {1,5,5,11} arrSum = 22 == even can be divided into 2 half as {11}, {1,5,5}
            //if arrSum = 23 == odd no equal partition possible
            System.out.println("The equal sum partition for the given sum is not possible as sum of array is odd");
            return;
        }

        System.out.println("The equal sum partition for the given array is possible: ");
        //if arrSum == even the if we can prove the sum = arrSum/2 is possible
        //then other half of the sub set is by default will be eqaul to arrSum/2
        //arrSum = 22 == sum = arrSum/2 = 11 prove {11} then other half will be {1,5,5}
        subsetSum_DP_Memoization(arr, arrSum / 2);
    }

    public int longestCommonSubsequence_Recursion(String s1, String s2, int m, int n) {

        if (m == 0 || n == 0) {
            return 0;
        }

        if (s1.charAt(m - 1) == s2.charAt(n - 1)) {
            return longestCommonSubsequence_Recursion(s1, s2, m - 1, n - 1) + 1;
        }

        return Math.max(longestCommonSubsequence_Recursion(s1, s2, m, n - 1),
                longestCommonSubsequence_Recursion(s1, s2, m - 1, n));

    }

    public int longestCommonSubsequence_DP_Memoization(String s1, String s2, int m, int n) {
        //https://leetcode.com/problems/longest-common-subsequence
        int[][] memo = new int[m + 1][n + 1];

        //base cond
        //if s1 is empty and s2 is non-empty String no subseq length is possible
        //if s2 is empty and s1 is non-empty Strng no subseq length is possible
        for (int[] r : memo) {
            Arrays.fill(r, 0);
        }

        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (s1.charAt(x - 1) == s2.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x][y - 1], memo[x - 1][y]);
                }
            }
        }

        System.out.println("The longest common subsequence length for the given two string is: " + memo[m][n]);
        return memo[m][n];
    }

    public void uncrossedLines_DP_Memoization(int[] nums1, int[] nums2) {
        //https://leetcode.com/problems/uncrossed-lines/
        //this questions is also longestCommonSubsequence between two int arrays
        //completely based on longestCommonSubsequence_DP_Memoization
        int n = nums1.length;
        int m = nums2.length;

        int[][] memo = new int[n + 1][m + 1];
        //base cond is if there are no elements in nums1 then
        //there is no lines possible with nums2 similarly if there
        //no elements in nums2 there is no lines possible with nums1
        //so memo[r == 0][c] = 0 and memo[r][c == 0] = 0
        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < m + 1; y++) {
                if (nums1[x - 1] == nums2[y - 1]) {
                    //here adding 1 represents that one line between two arrays is made
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    //here we need to choose the max uncrossed lines possible
                    //out of all the combinations
                    memo[x][y] = Math.max(memo[x - 1][y], memo[x][y - 1]);
                }
            }
        }
        //output
        System.out.println("Max uncrossed lines possible with given two num arrays: " + memo[n][m]);
    }

    private int longestPallindromicSubsequence_Recursive_Memoization_Helper(
            String str, int startIndex, int endIndex, Integer[][] memo) {

        //if the both the ptrs startIndex & endIndex referreing to same char
        //for ex: 'a' then any single char is by default pallindrome, hence return 1
        if (startIndex == endIndex) {
            return 1;
        }

        //since both the ptrs, checks the char from start and end indexes and if
        //at any point in time endIndex goes below startIndex OR startIndex goes
        //ahead of endIndex return 0, as this is not a valid ptrs position
        if (endIndex < startIndex) {
            return 0;
        }

        if (memo[startIndex][endIndex] != null) {
            return memo[startIndex][endIndex];
        }

        //as with any basic pallindrome logic, we check if the starting char of string
        //matches with the ending char of the same str, then those 2 chars are considered 
        //to be pallindrome and we move both ptrs repectively to check further
        //here also, if the char at startIndex matches with endIndex then 2 char
        //matches hence adding '2' and move ahead to next chars from both the ptrs
        //means (startIndex + 1) & (endIndex - 1)
        if (str.charAt(startIndex) == str.charAt(endIndex)) {
            return memo[startIndex][endIndex]
                    = 2 + longestPallindromicSubsequence_Recursive_Memoization_Helper(
                            str, startIndex + 1, endIndex - 1, memo);
        }

        //if the chars at startIndex & endIndex don't match, then we have to check the
        //subeq if we ignore the startIndex-th char and move to next (startIndex + 1)
        //while keeping endIndex same
        //AND vice verse condition
        //any of the options give the max value will be considere in longest subseq
        return memo[startIndex][endIndex]
                = Math.max(
                        longestPallindromicSubsequence_Recursive_Memoization_Helper(str, startIndex + 1, endIndex, memo),
                        longestPallindromicSubsequence_Recursive_Memoization_Helper(str, startIndex, endIndex - 1, memo)
                );
    }

    public void longestPallindromicSubsequence_Recursive_Memoization(String s) {
        //https://leetcode.com/problems/longest-palindromic-subsequence/
        //explanation: https://youtu.be/M4pfB3G-YQc
        //based on recursive approach
        int n = s.length();
        Integer[][] memo = new Integer[n + 1][n + 1];
        int longestPallindromicSubseq = longestPallindromicSubsequence_Recursive_Memoization_Helper(
                s, 0, n - 1, memo);
        //output
        System.out.println("Longest pallindromic subsequence (recursive memoization) : "
                + longestPallindromicSubseq);
    }

    public void longestPallindromicSubsequence_DP_Memoization(String s) {
        //https://leetcode.com/problems/longest-palindromic-subsequence/
        //based on LONGEST COMMON SUBSEQUENCE, longestCommonSubsequence_DP_Memoization()
        int len = s.length();
        String rev = new StringBuilder(s).reverse().toString();
        int longestPallindromicSubseq = longestCommonSubsequence_DP_Memoization(s, rev, len, len);
        System.out.println("Longest pallindromic subsequences (based on LCS) : "
                + longestPallindromicSubseq);
    }

    public void maximizePallindromLengthFromSubsequence_DP_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/description/
        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/solutions/2193811/simple-java-dp-solution/
        //based on longestPallindromicSubsequence_DP_Memoization() & longestCommonSubsequence_DP_Memoization()
        int m = str1.length();
        int n = str2.length();

        int minStart = Integer.MAX_VALUE;
        int maxEnd = Integer.MIN_VALUE;

        //find the minStart index (==> starting index) of a char from str1
        //that also occurs in str2 as near as possible in i-th loop
        //find the maxEnd index (==> ending index) of a char from str1
        //that also occurs in str2 as far as possible in j-th loop
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (str1.charAt(i) == str2.charAt(j)) {
                    minStart = Math.min(minStart, i);
                    maxEnd = Math.max(maxEnd, j);
                }
            }
        }

        //when no char is common in str1 and str2
        if (minStart == Integer.MAX_VALUE) {
            System.out.println("Maximize pallindromic length from subsequences (based on LPS & LCS) : 0");
            return;
        }

        //from here it will same as LPS
        String word1 = str1.substring(minStart) + str2.substring(0, maxEnd + 1);
        String word2 = new StringBuilder(word1).reverse().toString();
        int len = word1.length();

        int longestPallindromicSubseq = longestCommonSubsequence_DP_Memoization(word1, word2, len, len);
        //output
        System.out.println("Maximize pallindromic length from subsequences (based on LPS & LCS) : "
                + longestPallindromicSubseq);
    }

    public void deleteOperationOfTwoStrings_DP_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/delete-operation-for-two-strings/
        /*
         how many char we need to delete or insert to make str1 transformed to str2
         //ex: str1 = "sea", str2 = "eat"
         longest common subseq = 2 ==> (ea)
         if both strings are combined = str1 + str2 = sea + eat ==> seaeat
         you can see in merged form of both strings the lcs come 2 times and if we
         remove these 2 occurences of lcs we will left with those chars
         that we either need to delete or insert
         seaeat - 2 * (ea) ==> st ==> delete(s) and insert(t)
         that's why len1 + len2 - 2 * lcs 
         */
        int len1 = str1.length();
        int len2 = str2.length();
        int longestCommonSubseq = longestCommonSubsequence_DP_Memoization(str1, str2, len1, len2);
        int deleteOprn = len1 + len2 - 2 * longestCommonSubseq;
        System.out.println("Delete operation of two strings: "
                + deleteOprn);
    }

    private int longestRepeatingSubsequence_Recursion_Helper(String a, String b, int m, int n) {

        if (m == 0 || n == 0) {
            return 0;
        } else if (a.charAt(m - 1) == b.charAt(n - 1) && m != n) {
            return longestRepeatingSubsequence_Recursion_Helper(a, b, m - 1, n - 1) + 1;
        }

        return Math.max(longestRepeatingSubsequence_Recursion_Helper(a, b, m, n - 1),
                longestRepeatingSubsequence_Recursion_Helper(a, b, m - 1, n));
    }

    public int longestRepeatingSubsequence_Recursion(String str, int N) {
        return longestRepeatingSubsequence_Recursion_Helper(str, str, N, N);
    }

    public void longestRepeatingSubsequence_DP_Memoization(String str) {

        int N = str.length();
        int[][] memo = new int[N + 1][N + 1];

        //base cond
        //if string length is 0 then no subseq is possible
        //here there is only one string so mem[row][col] where row == 0 OR col == 0 memo[row][col] = 0
        for (int x = 1; x < N + 1; x++) {
            for (int y = 1; y < N + 1; y++) {
                if (str.charAt(x - 1) == str.charAt(y - 1) && x != y) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                } else {
                    memo[x][y] = Math.max(memo[x][y - 1], memo[x - 1][y]);
                }
            }
        }

        //output:
        System.out.println("Longest repeating subsequence: " + memo[N][N]);
    }

    public void longestCommonSubstring_DP_Memoization(String a, String b) {
        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
        int m = a.length();
        int n = b.length();

        int[][] memo = new int[m + 1][n + 1];

        //base cond: if any of the string is empty then common subtring is not possible
        //x == 0 OR col == 0 : memo[0][0] = 0
        int maxLenSubstring = 0;
        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (a.charAt(x - 1) == b.charAt(y - 1)) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                    maxLenSubstring = Math.max(maxLenSubstring, memo[x][y]);
                } else {
                    memo[x][y] = 0;
                }
            }
        }

        //output:
        System.out.println("Longest common substring: " + maxLenSubstring);
    }

    public int maximumLengthOfPairChain_DP_Approach(int[][] pairs) {

        //https://leetcode.com/problems/maximum-length-of-pair-chain/solution/
        //.......................T: O(N^2)
        //.......................S: O(N)
        Arrays.sort(pairs, (a, b) -> a[0] - b[0]); //T: O(N.LogN)
        int N = pairs.length;
        int[] dp = new int[N];
        Arrays.fill(dp, 1);

        //T: O(N^2)
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[j][1] < pairs[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }

        int ans = 0;
        for (int x : dp) {
            ans = Math.max(ans, x);
        }

        //overall T: O(N^2) as, N^2 > N.LogN
        return ans;
    }

    public int maximumLengthOfPairChain_Greedy_Approach(int[][] pairs) {

        //OPTIMISED
        //https://leetcode.com/problems/maximum-length-of-pair-chain/solution/
        //........................T: O(N.LogN)
        //........................S: O(1)
        Arrays.sort(pairs, (a, b) -> a[1] - b[1]); //T: O(N.LogN)
        int prevEnd = Integer.MIN_VALUE;
        int chain = 0;
        for (int[] currPair : pairs) { //T: O(N)
            int currStart = currPair[0];
            int currEnd = currPair[1];
            if (prevEnd < currStart) {
                prevEnd = currEnd;
                chain++;
            }
        }

        //overall T: O(N.LogN) as, N.LogN > N
        return chain;
    }

    public int findBinomialCoefficient_Recursion(int n, int r) {

        //https://www.geeksforgeeks.org/binomial-coefficient-dp-9/
        //this approach have overlapping subproblems
        //Binomial coefficient : nCr formula = n!/r!(n - r)!
        //if r = 0 OR r = n, ans: 1 as, 
        //r == 0: n!/0!.(n - 0)! => n!/n! => 1
        //r == n: n!/n!.(n - n)! => n!/n! => 1
        //0! = 1
        if (r > n) {
            return 0;
        }

        if (r == 0 || r == n) {
            return 1;
        }

        return findBinomialCoefficient_Recursion(n - 1, r - 1) + findBinomialCoefficient_Recursion(n - 1, r);
    }

    public void findBinomialCoefficient_DP_Memoization(int n, int r) {

        int[][] memo = new int[n + 1][r + 1];
        //base cond
        for (int x = 0; x < n + 1; x++) {
            for (int y = 0; y < r + 1; y++) {

                if (y > x) {
                    memo[x][y] = 0;
                } else if (y == 0 || y == x) {
                    memo[x][y] = 1;
                }
            }
        }

        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < r + 1; y++) {
                memo[x][y] = memo[x - 1][y - 1] + memo[x - 1][y];
            }
        }

        //output:
        System.out.println("Binomial coefficient (nCr) DP way: " + memo[n][r]);
    }

    public int friendsPairingProblem_Recursion(int n) {

        //https://www.geeksforgeeks.org/friends-pairing-problem/
        //if no friend is there nothing is possible
        if (n == 0) {
            return 0;
        }

        //if 1 friend is avaialbe he can only remain single
        if (n == 1) {
            return 1;
        }

        //if 2 friends are available there can be two ways
        //friend can remain single: {2} Or can be be paired as {1,2}
        if (n == 2) {
            return 2;
        }

        //if above cond doesn't fulfil we have two choices
        //1. ether we can remain single fun(n-1)
        //2. Or we can keep ourself and check others for pair: (n-1)*fun(n-2)
        return friendsPairingProblem_Recursion(n - 1) + (n - 1) * friendsPairingProblem_Recursion(n - 2);

    }

    public void friendsPairingProblem_DP_Memoization(int n) {

        //.............................T: O(N)
        //.............................S: O(N)
        //https://www.geeksforgeeks.org/friends-pairing-problem/
        int[] memo = new int[n + 1];
        //base cond
        memo[0] = 0;
        memo[1] = 1;
        memo[2] = 2;

        for (int i = 3; i < n + 1; i++) {
            memo[i] = memo[i - 1] + (i - 1) * memo[i - 2];
        }

        //output
        System.out.println("No. ways freinds can be paired: " + memo[n]);
    }

    public void friendsPairingProblem(int n) {

        //.............................T: O(N)
        //.............................S: O(1)
        //OPTIMISED
        //https://www.geeksforgeeks.org/friends-pairing-problem/
        if (n <= 2) {
            System.out.println("No. ways freinds can be paired: " + n);
            return;
        }

        int a = 1;
        int b = 2;
        int c = 0;

        for (int i = 3; i <= n; i++) {

            c = b + (i - 1) * a;
            a = b;
            b = c;
        }

        //output
        System.out.println("No. ways freinds can be paired: " + c);
    }

    public int sticklerThief_Recursion(int[] houses, int n) {

        //if no houses is available
        if (n == 0) {
            return 0;
        }

        //if only one house is available
        if (n == 1) {
            return houses[n - 1];
        }

        //2 choices
        //1. we choose not to pick a house and we simply move to next house
        //2. we choose to pick that house then we have to add the amount 
        //in that house in our result and move to alternate house (which is not adjacent(n-2))
        //just choose the max of these choices
        return Math.max(sticklerThief_Recursion(houses, n - 1),
                houses[n - 1] + sticklerThief_Recursion(houses, n - 2));
    }

    public int sticklerThief_DP_Memoization(int[] houses) {
        //https://leetcode.com/problems/house-robber
        int n = houses.length;
        int[] memo = new int[n + 1];

        //base cond
        memo[0] = 0; //if no house is available
        memo[1] = houses[0]; //if only one house is available

        for (int i = 2; i < memo.length; i++) {
            memo[i] = Math.max(memo[i - 1], houses[i - 1] + memo[i - 2]);
        }

        //output;
        return memo[n];
    }

    public void sticklerThiefTwo_DP_Memoization(int[] houses) {
        //https://leetcode.com/problems/house-robber-ii/
        int n = houses.length;
        int result = Integer.MIN_VALUE;

        int[] currHouses = new int[n - 1];
        //house[0] to house[n - 2] in which last house (n - 1)-th will not be covered
        for (int i = 0; i < n - 1; i++) {
            currHouses[i] = houses[i];
        }

        result = Math.max(result, sticklerThief_DP_Memoization(currHouses));

        currHouses = new int[n];
        //house[1] to house[n - 1] in which first house(0-th) will not be covered
        for (int i = 1; i < n; i++) {
            currHouses[i] = houses[i];
        }

        result = Math.max(result, sticklerThief_DP_Memoization(currHouses));

        //output;
        System.out.println("The maximum amount stickler thief can pick from alternate but circular houses: "
                + result);
    }

    int longestIncreasingSubsequence_LongestSeqLength;

    private int longestIncreasingSubsequence_Recursion_Helper(int[] arr, int n) {

        //if there is one element in arr then the longest seq length is just one
        if (n == 1) {
            return 1;
        }

        int res = 0;
        int maxLengthHere = 1;

        for (int i = 1; i < n; i++) {

            res = longestIncreasingSubsequence_Recursion_Helper(arr, i);
            if (arr[i - 1] < arr[n - 1] && res + 1 > maxLengthHere) {
                maxLengthHere = res + 1;
            }
        }

        longestIncreasingSubsequence_LongestSeqLength = Math.max(
                longestIncreasingSubsequence_LongestSeqLength,
                maxLengthHere);

        return maxLengthHere;
    }

    public int longestIncreasingSubsequence_Recursion(int[] arr, int n) {
        //if array is empty no longest incr seq is possible hence -1,
        //otherwise atleast element will be considered as incr seq hence 1
        longestIncreasingSubsequence_LongestSeqLength = n == 0 ? -1 : 1;
        longestIncreasingSubsequence_Recursion_Helper(arr, n);
        return longestIncreasingSubsequence_LongestSeqLength;
    }

    public void longestIncreasingSubsequence_DP_Memoization(int[] arr, int n) {
        //https://leetcode.com/problems/longest-increasing-subsequence
        //https://leetcode.com/problems/number-of-longest-increasing-subsequence
        //if array is empty, no longest incr seq is possible hence -1,
        //otherwise atleast one element will be considered as incr seq hence 1
        int maxLengthLongestIncSubseq = n == 0 ? -1 : 1;
        //memo[i] will hold the longest incr subseq for ith arr[i] calculated
        int[] memo = new int[n];
        //base cond
        //a single num is also an increasing seq, that's why 1
        Arrays.fill(memo, 1);

        for (int i = 1; i < n; i++) {
            //we iterate over subarray [0 to i]
            for (int j = 0; j < i; j++) {
                //j loop will run over the above subarray
                //while looping in j will check what all 
                //arr[j] are lesser than arr[i] (i.e arr[i] > arr[j])
                //also need to have a check like, at any subarray if memo[i] 
                //already have a longest incr length memo[j] should not modify that
                //only when memo[i] <= memo[j]
                if (arr[i] > arr[j] && memo[i] <= memo[j]) {
                    memo[i] = memo[j] + 1;
                }
            }
            maxLengthLongestIncSubseq = Math.max(maxLengthLongestIncSubseq, memo[i]);
        }

        //output:
        System.out.println("DP Longest inc subseq of the given array is: " + maxLengthLongestIncSubseq);
    }

    public void maxSumIncreasingSubsequence_DP_Memoization(int[] arr) {
        //...............................T: O(N ^ 2), checking all subseq
        //...............................T: O(N), memo[] space
        //https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/
        //https://practice.geeksforgeeks.org/problems/maximum-sum-increasing-subsequence4749/1/
        //approach similar to longestIncreasingSubsequence_DP_Memoization()
        int n = arr.length;
        //if array is empty no longest incr seq is possible hence -1,
        //otherwise atleast one element will be considered as incr seq hence 1
        int maxSumIncSubseq = n == 0 ? -1 : 1;
        //memo[i] will hold the max sum incr subseq for ith arr[i] calculated
        int[] memoSum = new int[n];
        //base cond
        //a single num can be a max sum incr seq, that's why arr[i]
        for (int i = 0; i < n; i++) {
            memoSum[i] = arr[i];
        }

        for (int i = 1; i < n; i++) {
            //we iterate over subarray [0 to i]
            for (int j = 0; j < i; j++) {
                //j loop will run over the above subarray
                //while looping in j will check what all 
                //arr[j] are lesser than arr[i] (i.e arr[i] > arr[j])
                //also need to have a check like, at any subarray if memo[i] 
                //already have a max sum, memo[j] should not modify that
                //only when memo[i] <= memo[j] + arr[i] that means max sum till 
                //memo[j] plus value of arr[i] makes the max sum curr max sum at memo[i]
                if (arr[i] > arr[j] && memoSum[i] <= memoSum[j] + arr[i]) {
                    memoSum[i] = memoSum[j] + arr[i];
                }
            }
            maxSumIncSubseq = Math.max(maxSumIncSubseq, memoSum[i]);
        }

        //output:
        System.out.println("DP Max sum incr subseq of the given array is: " + maxSumIncSubseq);
    }

    public void maximumLengthOfRepeatedSubarray_DP_Memoization(int[] arr1, int[] arr2) {

        //Approach is similar to longest common substring
        int m = arr1.length;
        int n = arr2.length;
        int[][] memo = new int[m + 1][n + 1];

        //base cond:
        //arr1 is empty no repeated values can be checked arr2
        //similarly arr2 is empty no repeated values can be checked with arr1
        //x == 0, col == 0 will 0
        int maxLen = 0;
        for (int x = 1; x < m + 1; x++) {
            for (int y = 1; y < n + 1; y++) {
                if (arr1[x - 1] == arr2[y - 1]) {
                    memo[x][y] = memo[x - 1][y - 1] + 1;
                    maxLen = Math.max(maxLen, memo[x][y]);
                } else {
                    memo[x][y] = 0;
                }
            }
        }

        //output
        System.out.println("Maximum length of repeated subarray: " + maxLen);
    }

    public int minInsertsToMakeStringPallindrome_DP_Memoization(String str) {
        //https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome
        //ref: SomePracticeQuestion.minNoOfInsertionInStringToMakeItPallindrome()
        String revString = new StringBuilder(str).reverse().toString();
        int len = str.length();
        int longestCommonSubseq = longestCommonSubsequence_DP_Memoization(str, revString, len, len);
        int inserts = len - longestCommonSubseq;
        //output
        System.out.println("Min inserts to make the string pallindrome: " + inserts);
        return inserts;
    }

    public void minDeletesToMakeStringPallindrome_DP_Memoization(String str) {
        //ref: SomePracticeQuestion.minNoOfDeletionInStringToMakeItPallindrome_LPSBasedApproach()
        int deletes = minInsertsToMakeStringPallindrome_DP_Memoization(str);
        //output
        System.out.println("Min deletes to make the string pallindrome: " + deletes);
    }

    public void paintFence_DP_Memoization(int fence, int paints) {
        //https://www.geeksforgeeks.org/painting-fence-algorithm/
        //explanation: https://youtu.be/ju8vrEAsa3Q
        long ways = paints;
        int mod = 1000000007;

        int paintSame = 0;
        int paintDifferent = paints;

        for (int i = 2; i <= fence; i++) {
            paintSame = paintDifferent;

            paintDifferent = (int) ways * (paints - 1);
            paintDifferent %= mod;

            ways = (paintSame + paintDifferent) % mod;
        }
        //output
        System.out.println("No of ways to paint fences such that adjacent fence are painted with same color: "
                + ways);
    }

    private int decodeWays_Recursive_Memoization_Helper(
            int index, String str, Integer[] memo) {

        int n = str.length();
        //if we have successfully crossed the string
        if (index >= n) {
            return 1;
        }

        //if we already cached the values previously retunn that
        if (memo[index] != null) {
            return memo[index];
        }

        int ways = 0;

        //form a single-digit number mapped to [A == 1 to I == 9]
        int singleDigitNum = str.charAt(index) - '0';

        //form a two-digit number mapped to [J == 10 to Z == 26]
        int twoDigitNum = 0;
        //we can form two digit num only when we are allowed to take (index + 1)th char
        //it should be less than n
        if (index + 1 < n) {
            //this two digit num should be formed with the index-th char which is singleDigitNum
            twoDigitNum = singleDigitNum * 10 + (str.charAt(index + 1) - '0');
        }

        //we have two decision to make to decode our nums in str
        //1. we can take the first single digit that is mapped to char[A == 1 to I == 9]
        if (singleDigitNum > 0) {
            //if we are considering just a single digit, then we simply move to
            //next index val(index + 1)
            ways += decodeWays_Recursive_Memoization_Helper(index + 1, str, memo);
        }

        //2. we can take first two digit num that is mapped to char[J == 10 to Z == 26]
        //this will also handle cases like "06" because "06" as int is not two-digit
        //it will be number = 6
        if (twoDigitNum >= 10 && twoDigitNum <= 26) {
            //if we are considering first two digit, that means we took index-th
            //& (index + 1)-th char then we simply move to (index + 2)
            ways += decodeWays_Recursive_Memoization_Helper(index + 2, str, memo);
        }

        //cache the values
        return memo[index] = ways;
    }

    public void decodeWays_Recursive_Memoization(String str) {
        //https://leetcode.com/problems/decode-ways/
        //explanation: https://youtu.be/N5i7ySYQcgM
        //<index, ways>
        int n = str.length();
        Integer[] memo = new Integer[n];
        int ways = decodeWays_Recursive_Memoization_Helper(0, str, memo);
        //output
        System.out.println("Ways to decode string into alphabets(Recursive-Memoization): " + ways);
    }

    public void decodeWays_DP_Memoization(String str) {
        //https://leetcode.com/problems/decode-ways/
        //explanation: https://youtu.be/N5i7ySYQcgM
        int n = str.length();
        Map<Integer, Integer> cache = new HashMap<>();
        cache.put(n + 1, 1);
        cache.put(n, 1);
        for (int index = n - 1; index >= 0; index--) {
            int singleDigitNum = str.charAt(index) - '0';
            int twoDigitNum = 0;
            //we can form two digit num only when we are allowed to take (index + 1)th char
            //it should be less than n
            if (index + 1 < n) {
                //this two digit num should be formed with the index-th char which is singleDigitNum
                twoDigitNum = singleDigitNum * 10 + (str.charAt(index + 1) - '0');
            }

            if (singleDigitNum > 0) {
                int ways = cache.getOrDefault(index, 0) + cache.getOrDefault(index + 1, 0);
                cache.put(index, ways);
            }

            if (singleDigitNum > 0 && twoDigitNum > 0 && twoDigitNum <= 26) {
                int ways = cache.getOrDefault(index, 0) + cache.getOrDefault(index + 2, 0);
                cache.put(index, ways);
            }
        }
        //output
        System.out.println("Ways to decode string into alphabets(DP): " + cache.getOrDefault(0, 0));
    }

    private int fillingBooksInShelves_DP_Recusrive_Memoization_Helper(
            int[][] books, int shelfWidth, int index, Map<Integer, Integer> memo) {

        if (index >= books.length) {
            return 0;
        }

        if (memo.containsKey(index)) {
            return memo.get(index);
        }

        int currWidth = 0;
        int maxHeight = 0;
        int minHeight = Integer.MAX_VALUE;

        //this approach tries to put a single book in its own shelf. as the loop 
        //increases it tries to include more books in one shelf (as long as its
        //under shelfWidth) and while trying to put more books in some shelfs
        //we minimize the height
        //ex [[1,1],[3,1]], shelfWidth = 4
        //index  = 0 it will try to put book[1,1] in its own shelf
        //maxHeight = 1, currWidth = 1 since its under shelfWidth
        //we can move to i + 1 book to put it in another shelf
        //index = 1, it will try to put book[3,1] in its own shelf
        //maxHeight = 1, currWidth = 3 since its under shelfWidth
        //by going to another i + 1 index it will go to base cond(>= n) that will ret 0
        //maxHeight + 0 = 1 + 0 = 1 so minHeight for book[3,1] = 1 now this one
        //recurse back to previous shelf
        //back to book[1,1] maxHeight = 1 + minHeight[3,1] == 1 ==> 2
        //this states that if we try to put each book in its own shelf that would take
        //the max height of our book selves.
        //form here, we will try to add more books in curr shelf here we already have
        //in 1st shelf[1,1] now we put book[3,1] in this shelve
        //currWidth += [3,1] ==> 1 + 3 = 4 which is still equal to shelfWidth(OK!!)
        //maxHeight = max(book[1,1], book[3,1]) = 1 only. This states that
        //now single shelf has book [1,1][3,1] having width <= shelfWidth and maxHeight = 1
        for (int i = index; i < books.length; i++) {
            currWidth += books[i][0];
            maxHeight = Math.max(maxHeight, books[i][1]);

            if (currWidth > shelfWidth) {
                break;
            }

            minHeight = Math.min(minHeight,
                    maxHeight + fillingBooksInShelves_DP_Recusrive_Memoization_Helper(
                            books, shelfWidth, i + 1, memo));

            memo.put(index, minHeight);
        }
        return memo.get(index);
    }

    public void fillingBooksInShelves_DP_Recusrive_Memoization(int[][] books, int shelfWidth) {
        //https://leetcode.com/problems/filling-bookcase-shelves/
        //https://leetcode.com/problems/filling-bookcase-shelves/discuss/2278530/Split-and-CHILL
        Map<Integer, Integer> memo = new HashMap<>();
        int minHeight = fillingBooksInShelves_DP_Recusrive_Memoization_Helper(books, shelfWidth, 0, memo);
        //output
        System.out.println("Min possible height: " + minHeight);
    }

    private int perfectSquares_DP_Recursive_Memoization_Helper(int n, Map<Integer, Integer> cache) {
        //if n == 0, there are 0 perfect squares that sums upto 0
        if (n == 0) {
            return n; // n == 0
        }

        if (cache.containsKey(n)) {
            return cache.get(n);
        }

        //this is the branching factor.
        //let say n == 12, sqrt(n) = 3.4.. roundOff = 3
        //Now this 3 * 3 == 9 and if we go one more like for 4 ==> 4 * 4 = 16
        //that means this 16 > n, we can't use 4 as perfect sqaures sums because
        //it always be greater than n
        int sqrRootN = (int) Math.sqrt(n);
        int currPerfectSquaresWaysToN = Integer.MAX_VALUE;
        for (int branch = 1; branch <= sqrRootN; branch++) {
            int currPerfectSqr = branch * branch;
            currPerfectSquaresWaysToN = Math.min(currPerfectSquaresWaysToN,
                    1 + perfectSquares_DP_Recursive_Memoization_Helper(n - currPerfectSqr, cache));
        }
        cache.put(n, currPerfectSquaresWaysToN);
        return currPerfectSquaresWaysToN;
    }

    public void perfectSquares_DP_Recursive_Memoization(int n) {
        //........................T: O(n * sqrt(n)), sqrt(n) is the branching factor for
        //each n in the decision tree
        //https://leetcode.com/problems/perfect-squares/submissions/
        //explanation: https://youtu.be/HLZLwjzIVGo
        //<n, currPerfectSquaresWays>
        Map<Integer, Integer> cache = new HashMap<>();
        int perfectSquaresCount = perfectSquares_DP_Recursive_Memoization_Helper(n, cache);
        //output
        System.out.println("Count of perfect squares that will sum up to n: " + perfectSquaresCount);
    }

    public void perfectSquares_DP_Memoization(int n) {
        //........................T: O(n * sqrt(n)), sqrt(n) is the branching factor for
        //each n in the decision tree
        //https://leetcode.com/problems/perfect-squares/submissions/
        //explanation: https://youtu.be/HLZLwjzIVGo
        //<n, currPerfectSquaresWays>
        Map<Integer, Integer> cache = new HashMap<>();
        //if n == 0, 0 are the ways to have sum of perfect squares
        cache.put(0, 0);

        for (int nth = 1; nth <= n; nth++) {
            for (int i = 1; i <= nth; i++) {
                int currPerfectSqr = i * i;
                if (nth - currPerfectSqr < 0) {
                    break;
                }
                int currPerfectSquaresWaysToN = Math.min(
                        cache.getOrDefault(nth, Integer.MAX_VALUE),
                        1 + cache.getOrDefault(nth - currPerfectSqr, Integer.MAX_VALUE));
                cache.put(nth, currPerfectSquaresWaysToN);
            }
        }
        //output
        System.out.println("Count of perfect squares that will sum up to n: " + cache.get(n));
    }

    private int outOfBoundaryPaths_DP_Recursive_Memoization_Helper(
            int m, int n, int maxMoves, int row, int col, Integer[][][] memo) {

        int mod = 1000000007;

        //return 1, as we need to count out-of-boundary-paths and here our curr
        //row & col 'isOutOfBounds'
        if (row < 0 || row >= m || col < 0 || col >= n) {
            return 1;
        }

        //return 0, as above if() cond didn't meet, means we haven't gone out-of-boundary
        //yet but our 'maxMoves' to move in the grid is now 0 hence no movement
        if (maxMoves <= 0) {
            return 0;
        }

        if (memo[row][col][maxMoves] != null) {
            return memo[row][col][maxMoves];
        }

        int outOfBoundaryPathCount = 0;

        //UP
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row - 1, col, memo)) % mod;
        //DOWN
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row + 1, col, memo)) % mod;
        //LEFT
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row, col - 1, memo)) % mod;
        //RIGHT
        outOfBoundaryPathCount = (outOfBoundaryPathCount
                + outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves - 1, row, col + 1, memo)) % mod;

        return memo[row][col][maxMoves] = outOfBoundaryPathCount;
    }

    public void outOfBoundaryPaths_DP_Recursive_Memoization(int m, int n, int maxMoves, int startRow, int startCol) {
        //https://leetcode.com/problems/out-of-boundary-paths/
        Integer[][][] memo = new Integer[m][n][maxMoves + 1];
        int paths = outOfBoundaryPaths_DP_Recursive_Memoization_Helper(m, n, maxMoves, startRow, startCol, memo);
        //output:
        System.out.println("Out of boundary paths:  " + paths);
    }

    private int frogJump_Recursive_Helper(int[] heights, int index) {

        //if no heights is given the energy consumed for the frog
        //from jumping nth height to n-1th or n-2th height becomes 0
        //because there is no such heights
        //also we are coming back from nth step to 0th step
        if (index <= 0) {
            return 0;
        }

        //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
        int oneStepBack = Math.abs(heights[index] - heights[index - 1])
                + frogJump_Recursive_Helper(heights, index - 1);

        //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
        //default value is Int.MAX because this time frog has to jump 2 steps back
        //and possibly n - 2 steps doesn't exist
        int twoStepBack = Integer.MAX_VALUE;
        //if it is possible to go n - 2 steps back then only calculate the energy consumed
        if (index - 2 >= 0) {
            twoStepBack = Math.abs(heights[index] - heights[index - 2])
                    + frogJump_Recursive_Helper(heights, index - 2);
        }

        //return the min energy consumed from both the steps
        return Math.min(oneStepBack, twoStepBack);
    }

    private int frogJump_Recursive_Memoization(int[] heights, int index, Map<Integer, Integer> cache) {

        //if no heights is given the energy consumed for the frog
        //from jumping nth height to n-1th or n-2th height becomes 0
        //because there is no such heights
        //also we are coming back from nth step to 0th step
        if (index <= 0) {
            return 0;
        }

        if (cache.containsKey(index)) {
            return cache.get(index);
        }

        //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
        int oneStepBack = Math.abs(heights[index] - heights[index - 1])
                + frogJump_Recursive_Helper(heights, index - 1);

        //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
        //default value is Int.MAX because this time frog has to jump 2 steps back
        //and possibly n - 2 steps doesn't exist
        int twoStepBack = Integer.MAX_VALUE;
        //if it is possible to go n - 2 steps back then only calculate the energy consumed
        if (index - 2 >= 0) {
            twoStepBack = Math.abs(heights[index] - heights[index - 2])
                    + frogJump_Recursive_Helper(heights, index - 2);
        }

        cache.put(index, Math.min(oneStepBack, twoStepBack));
        //return the min energy consumed from both the steps
        return Math.min(oneStepBack, twoStepBack);
    }

    public void frogJump_Recursive_And_Memoization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int recursiveFrogJump = frogJump_Recursive_Helper(heights, n - 1);

        Map<Integer, Integer> cache = new HashMap<>();
        int recursiveMemoFrogJump = frogJump_Recursive_Memoization(heights, n - 1, cache);

        System.out.println("Frog jump min energy consumed(Recusrive): " + recursiveFrogJump);
        System.out.println("Frog jump min energy consumed(Recusrive Memoization): " + recursiveMemoFrogJump);
    }

    public void frogJump_DP_Memoization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int[] memo = new int[n];
        memo[0] = 0;
        for (int i = 1; i < n; i++) {
            //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
            int oneStepBack = Math.abs(heights[i] - heights[i - 1])
                    + memo[i - 1];

            //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
            //default value is Int.MAX because this time frog has to jump 2 steps back
            //and possibly n - 2 steps doesn't exist
            int twoStepBack = Integer.MAX_VALUE;
            //if it is possible to go n - 2 steps back then only calculate the energy consumed
            if (i - 2 >= 0) {
                twoStepBack = Math.abs(heights[i] - heights[i - 2])
                        + memo[i - 2];
            }

            //return the min energy consumed from both the steps
            memo[i] = Math.min(oneStepBack, twoStepBack);
        }
        //output
        System.out.println("Frog jump min energy consumed(DP Memoization): " + memo[n - 1]);
    }

    public void frogJump_DP_Memoization_SpaceOptimization(int[] heights) {
        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
        //explanation: https://youtu.be/EgG3jsGoPvQ
        int n = heights.length;
        int prevStep = 0;
        int secondPrevStep = 0;
        for (int i = 1; i < n; i++) {
            //energy consumed by frog if it is only going 1 step back (i.e, n - 1 steps)
            int oneStepBack = Math.abs(heights[i] - heights[i - 1])
                    + prevStep;

            //energy consumed by frog if it is only going 2 step back (i.e, n - 2 steps)
            //default value is Int.MAX because this time frog has to jump 2 steps back
            //and possibly n - 2 steps doesn't exist
            int twoStepBack = Integer.MAX_VALUE;
            //if it is possible to go n - 2 steps back then only calculate the energy consumed
            if (i - 2 >= 0) {
                twoStepBack = Math.abs(heights[i] - heights[i - 2])
                        + secondPrevStep;
            }
            secondPrevStep = prevStep;
            //return the min energy consumed from both the steps
            prevStep = Math.min(oneStepBack, twoStepBack);
        }
        //output
        System.out.println("Frog jump min energy consumed(DP Memoization Space Optimization): " + prevStep);
    }

    public int ninjaTraining_Recursive_Helper(int[][] points, int day, int skipTask) {

        //base condition
        //we have started from the last day to day 0, at day 0
        //we can only pick a point which is max on day 0 but we will skip
        //that task which was was performed on day0 + 1 == day1
        if (day == 0) {
            int maxPointsAtDay0 = 0;
            for (int task = 0; task < 3; task++) {
                //skiping the task performed before this curr day
                if (skipTask == task) {
                    continue;
                }
                maxPointsAtDay0 = Math.max(maxPointsAtDay0, points[day][task]);
            }
            return maxPointsAtDay0;
        }

        //out of all the given tasks we will try to maximize out points
        //by trying all the task trainings but skiping the task which
        //was performed on its previous day
        int maxPoints = 0;
        for (int task = 0; task < 3; task++) {
            if (skipTask == task) {
                continue;
            }
            //we are perfroming task 'task' on curr day 'day' now we will move to next day
            //day == 'day - 1' but we are also saying that on the next day we must skip this curr 'task'
            int currMax = points[day][task] + ninjaTraining_Recursive_Helper(points, day - 1, task);
            //from the possible attempts to maximizing our points, keep the maxPoints
            maxPoints = Math.max(maxPoints, currMax);
        }
        return maxPoints;
    }

    public int ninjaTraining_Recursive_Memoization_Helper(
            int[][] points, int day, int skipTask, Map<String, Integer> cache) {

        //base condition
        //we have started from the last day to day 0, at day 0
        //we can only pick a point which is max on day 0 but we will skip
        //that task which was was performed on day0 + 1 == day1
        if (day == 0) {
            int maxPointsAtDay0 = 0;
            for (int task = 0; task < 3; task++) {
                //skiping the task performed before this curr day
                if (skipTask == task) {
                    continue;
                }
                maxPointsAtDay0 = Math.max(maxPointsAtDay0, points[day][task]);
            }
            return maxPointsAtDay0;
        }

        String key = day + "," + skipTask;
        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        //out of all the given tasks we will try to maximize out points
        //by trying all the task trainings but skiping the task which
        //was performed on its previous day
        int maxPoints = 0;
        for (int task = 0; task < 3; task++) {
            if (skipTask == task) {
                continue;
            }
            //we are perfroming task 'task' on curr day 'day' now we will move to next day
            //day == 'day - 1' but we are also saying that on the next day we must skip this curr 'task'
            int currMax = points[day][task] + ninjaTraining_Recursive_Memoization_Helper(points, day - 1, task, cache);
            //from the possible attempts to maximizing our points, keep the maxPoints
            maxPoints = Math.max(maxPoints, currMax);
        }

        cache.put(key, maxPoints);
        return maxPoints;
    }

    public void ninjaTraining_Recursive_And_Memoization(int[][] points) {
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int skipTask = 3;

        //.............................T: O(~ 2 ^ N), because at each level of descion tree
        //we are left with 2 task to try because one is skipped from previous day, so branching factor is reduced 2
        //..............................S: O(N), function call stack
        int recursiveMaxPoints = ninjaTraining_Recursive_Helper(points, n - 1, skipTask);

        //.............................T: O(N), Overlapping subproblems handled by cache
        //..............................S: O(N + N), function call stack + cache
        //<day+","+skipTaks, maxPoints>
        Map<String, Integer> cache = new HashMap<>();
        int recursiveMemoMaxPoints = ninjaTraining_Recursive_Memoization_Helper(points, n - 1, skipTask, cache);
        //output:
        System.out.println("Ninja Training max points on trainings(Recusrive): " + recursiveMaxPoints);
        System.out.println("Ninja Training max points on trainings(Recusrive Memoization): " + recursiveMemoMaxPoints);
    }

    public void ninjaTraining_DP_Memoization(int[][] points) {
        //...............................T: O(N * 4 * 3), N for all the days,
        //4 = (skipTask (0 = skipTask 0, 1 = skipTask 1, 2 = skipTask 2, 3 = skipTask None means try all tasks))
        //3 = tasks to try per day
        //...............................S: O(N * 4), for all N days we are havings points as per skipTasks
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int[][] memo = new int[n][4];
        //base condition
        //on day [0] and by skipping i-th task[i] the max points we can get is
        //the points from other 2 tasks
        //ex skipping task 0 we can pick max points from task 1 or task 2, same for others
        memo[0][0] = Math.max(points[0][1], points[0][2]);
        memo[0][1] = Math.max(points[0][0], points[0][2]);
        memo[0][2] = Math.max(points[0][0], points[0][1]);
        //task 3 actually represents here we didn't skip any task
        //for nth starting day, we won't be haing any skipTask from previous day because
        //that is our starting day, so on that we will try all the task to get our max points
        //from that day to any next day after that, we will some skipTask
        memo[0][3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));

        for (int day = 1; day < n; day++) {
            for (int skipTask = 0; skipTask < 4; skipTask++) {

                memo[day][skipTask] = 0;
                for (int task = 0; task < 3; task++) {
                    if (skipTask == task) {
                        continue;
                    }
                    memo[day][skipTask] = Math.max(memo[day][skipTask],
                            points[day][task] + memo[day - 1][task]);
                }
            }
        }
        //output
        int dpMemoMaxPoints = memo[n - 1][3];
        System.out.println("Ninja Training max points on trainings(DP Memoization): " + dpMemoMaxPoints);
    }

    public void ninjaTraining_DP_Memoization_SpaceOptimization(int[][] points) {
        //...............................T: O(N * 4 * 3), N for all the days,
        //4 = (skipTask (0 = skipTask 0, 1 = skipTask 1, 2 = skipTask 2, 3 = skipTask None means try all tasks))
        //3 = tasks to try per day
        //...............................S: O(4), we will need just a prev day points to calculate our curr day points
        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
        //explanation: https://youtu.be/AE39gJYuRog
        int n = points.length;
        int[] prevDayPoints = new int[4];
        //base condition
        //on day [0] and by skipping i-th task[i] the max points we can get is
        //the points from other 2 tasks
        //ex skipping task 0 we can pick max points from task 1 or task 2, same for others
        prevDayPoints[0] = Math.max(points[0][1], points[0][2]);
        prevDayPoints[1] = Math.max(points[0][0], points[0][2]);
        prevDayPoints[2] = Math.max(points[0][0], points[0][1]);
        //task 3 actually represents here we didn't skip any task
        //for nth starting day, we won't be haing any skipTask from previous day because
        //that is our starting day, so on that we will try all the task to get our max points
        //from that day to any next day after that, we will some skipTask
        prevDayPoints[3] = Math.max(points[0][0], Math.max(points[0][1], points[0][2]));

        for (int day = 1; day < n; day++) {
            int[] currDayPoints = new int[4];
            for (int skipTask = 0; skipTask < 4; skipTask++) {
                currDayPoints[skipTask] = 0;
                for (int task = 0; task < 3; task++) {
                    if (skipTask == task) {
                        continue;
                    }
                    currDayPoints[skipTask] = Math.max(currDayPoints[skipTask],
                            points[day][task] + prevDayPoints[task]);
                }
            }
            prevDayPoints = currDayPoints;
        }
        //output
        int dpMemoSapceOptMaxPoints = prevDayPoints[3];
        System.out.println("Ninja Training max points on trainings(DP Memoization Space Optimization): " + dpMemoSapceOptMaxPoints);
    }

    public void minRemovalToMakeArrayMountain_DP_Memoization(int[] arr) {
        //https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/
        //completely based on Longest increasing subseq, longestIncreasingSubsequence_DP_Memoization()
        int n = arr.length;
        //find longest incr subseq from left to right
        int[] leftLIS = new int[n];
        Arrays.fill(leftLIS, 1);

        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (arr[i] > arr[j] && leftLIS[i] <= leftLIS[j]) {
                    leftLIS[i] = 1 + leftLIS[j];
                }
            }
        }

        //find longest incr subseq from right to left
        int[] rightLIS = new int[n];
        Arrays.fill(rightLIS, 1);

        for (int i = n - 2; i >= 0; i--) {
            for (int j = n - 1; j > i; j--) {
                if (arr[i] > arr[j] && rightLIS[i] <= rightLIS[j]) {
                    rightLIS[i] = 1 + rightLIS[j];
                }
            }
        }

        int maxRemoval = 0;
        //why choosing loop from 1 to n - 1?, because acc to question
        //[5,4,3,1] or [1,2,3,4,5] these are not valid mountains
        //for a mountain, mountain-peek should have lesses values in left and right of it
        //[1,3,1], so mountain-peek should start from 1 till n - 2
        for (int i = 1; i < n - 1; i++) {
            if (leftLIS[i] > 1 && rightLIS[i] > 1) {
                maxRemoval = Math.max(maxRemoval, leftLIS[i] + rightLIS[i] - 1);
            }
        }
        //output
        System.out.println("Min removal to make array mountain: " + (n - maxRemoval));
    }

    public void lastStoneWeightTwo_DP_Memoization(int[] stones) {
        //https://leetcode.com/problems/last-stone-weight-ii/
        //ref: SomePracticeQuestion.minDiffInEqualSubset()
        int n = stones.length;
        int totalStoneSum = 0;
        for (int stone : stones) {
            totalStoneSum += stone;
        }

        boolean[][] memo = new boolean[n + 1][totalStoneSum + 1];

        //if no stones given where n == 0, any sum of stones will not be possible
        for (int col = 0; col < totalStoneSum + 1; col++) {
            memo[0][col] = false;
        }

        //if stones are given but stone sum to prove == 0, then only stone with 0
        //value is possible
        for (int row = 0; row < n + 1; row++) {
            memo[row][0] = true;
        }

        for (int stoneIndex = 1; stoneIndex < n + 1; stoneIndex++) {
            for (int stoneSum = 1; stoneSum < totalStoneSum + 1; stoneSum++) {
                if (stones[stoneIndex - 1] > stoneSum) {
                    memo[stoneIndex][stoneSum] = memo[stoneIndex - 1][stoneSum];
                } else {
                    memo[stoneIndex][stoneSum] = memo[stoneIndex - 1][stoneSum]
                            || memo[stoneIndex - 1][stoneSum - stones[stoneIndex - 1]];
                }
            }
        }

        int minDiff = Integer.MAX_VALUE;
        for (int stoneSum = totalStoneSum / 2; stoneSum >= 0; stoneSum--) {
            if (memo[n][stoneSum]) {
                minDiff = Math.min(minDiff, totalStoneSum - 2 * stoneSum);
            }
        }
        //output
        System.out.println("Min stone diff: " + minDiff);
    }

    private int numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(
            int n, int k, int target, Integer[][] memo) {

        int mod = 1000000007;

        //atmost dice given is n == 1 so that is our base cond
        //now with this 1 dice, can we reduce our target to 0 by taking any 
        //face-value number on the dice, if yes return 1 for a possible way
        //otherwise return 0
        if (n == 1) {
            return target >= 1 && target <= k ? 1 : 0;
        }

        //if we have already cache the changing parameters before, get that to
        //save time complexity
        if (memo[n][target] != null) {
            return memo[n][target];
        }

        int currWays = 0;

        //the given k value are the max face-value number the n-th dice can have
        //but just like a knapsack or subset sum with target problem, there is no
        //point in considering a 'face' value that is already greater than our curr
        //target that why, Math.min(target, k) we will take the min of what is required
        //inside the loop we will just add up all the possible ways
        for (int face = 1; face <= Math.min(target, k); face++) {

            currWays = (currWays
                    + numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(
                            n - 1, k, target - face, memo)) % mod;
        }

        //since the changing parameters are n and target, they are causing the
        //subproblem in this DP question so just cache the ways against these
        //changing parameters
        return memo[n][target] = currWays;
    }

    public void numberOfDiceRollWithTargetSum_Recursive_Memoization(int n, int k, int target) {
        //https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
        //somewhat similar to subset sum with given target
        Integer[][] memo = new Integer[n + 1][target + 1];
        int ways = numberOfDiceRollWithTargetSum_Recursive_Memoization_Helper(n, k, target, memo);
        //output
        System.out.println("Number of ways to dice roll with target sum: " + ways);
    }

    private void maxNumberOfPointsWithCost_Recursive_Helper(
            int[][] points, int row, int prevCol, int currSum, int ROW, int COL) {

        if (row == ROW) {
            maxNumberOfPointsWithCost_Recursive_MaxCost = Math.max(
                    maxNumberOfPointsWithCost_Recursive_MaxCost,
                    currSum);
            return;
        }

        int currCost = 0;
        for (int col = 0; col < COL; col++) {
            currCost = points[row][col] - Math.abs(col - prevCol);
            maxNumberOfPointsWithCost_Recursive_Helper(points, row + 1, col, currSum + currCost, ROW, COL);
        }
    }

    private int maxNumberOfPointsWithCost_Recursive_MaxCost;

    public void maxNumberOfPointsWithCost_Recursive(int[][] points) {
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
        //this is giving TLE
        int ROW = points.length;
        int COL = points[0].length;
        maxNumberOfPointsWithCost_Recursive_MaxCost = 0;
        for (int col = 0; col < COL; col++) {
            maxNumberOfPointsWithCost_Recursive_Helper(points, 1, col, points[0][col], ROW, COL);
        }
        //output
        System.out.println("Max number of points with cost(Recursive): " + maxNumberOfPointsWithCost_Recursive_MaxCost);
    }

    public void maxNumberOfPointsWithCost_DP_Memoization(int[][] points) {
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
        //https://leetcode.com/problems/maximum-number-of-points-with-cost/discuss/1344870/Java-DP
        int ROW = points.length;
        int COL = points[0].length;
        long[] memo = new long[COL];

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                memo[col] += points[row][col];
            }

            for (int col = 1; col < COL; col++) {
                memo[col] = Math.max(memo[col], memo[col - 1] - 1);
            }

            for (int col = COL - 2; col >= 0; col--) {
                memo[col] = Math.max(memo[col], memo[col + 1] - 1);
            }
        }

        long maxCost = 0L;
        for (long cost : memo) {
            maxCost = Math.max(maxCost, cost);
        }
        //output
        System.out.println("Max number of points with cost(DP Memoization): " + maxCost);
    }

    private int minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
            int[][] grid, int target, int row, int currSum, Integer[][] memo) {

        if (row == grid.length) {
            int absDiff = Math.abs(target - currSum);
            return absDiff;
        }

        if (memo[row][currSum] != null) {
            return memo[row][currSum];
        }

        int minAbsDiff = Integer.MAX_VALUE;

        for (int c = 0; c < grid[0].length; c++) {
            int currMinAbsDiff = minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
                    grid, target, row + 1, currSum + grid[row][c], memo);

            minAbsDiff = Math.min(minAbsDiff, currMinAbsDiff);
            if (minAbsDiff == 0) {
                break;
            }
        }

        memo[row][currSum] = minAbsDiff;
        return minAbsDiff;
    }

    public void minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(int[][] grid, int target) {
        //https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
        int ROW = grid.length;
        int COL = grid[0].length;
        //for this question hashmap based cache/memo object was not working and giving TLE
        //using 2D memo matrix solved the problen, usiing Integer wrapper instead
        //of primitive int helps directly checking with null rather than providing
        //default values to memo[][] as -1
        Integer[][] memo = new Integer[ROW][5001];
        int minAbsDiff = 0;
        for (int col = 0; col < COL; col++) {
            minAbsDiff = minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization_Helper(
                    grid, target, 0, 0, memo);
        }
        //output
        System.out.println("Min abs diff between target and choosen elements: " + minAbsDiff);
    }

    private int minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
            int[] jobs, int days, int index, Integer[][] memo) {

        int n = jobs.length;

        //base case, if we have just 1 day then we have to finish all the jobs
        //in that single day 1, hence we will find the maxDiffJob on this days
        if (days == 1) {
            int maxDiffJob = Integer.MIN_VALUE;
            for (int i = index; i < n; i++) {
                maxDiffJob = Math.max(maxDiffJob, jobs[i]);
            }
            return maxDiffJob;
        }

        if (memo[index][days] != null) {
            return memo[index][days];
        }

        int currMaxDiffJob = Integer.MIN_VALUE;
        int minDiffJobSchedule = Integer.MAX_VALUE;

        //if we have more than 1 day to do jobs then n - days insures that we
        //don't do all the jobs in the same day itself and jobs are left for rest
        //other days as well because as per question we need to do some jobs on
        //each 'days' given
        for (int i = index; i <= n - days; i++) {

            currMaxDiffJob = Math.max(currMaxDiffJob, jobs[i]);

            minDiffJobSchedule = Math.min(minDiffJobSchedule,
                    currMaxDiffJob + minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
                            jobs, days - 1, i + 1, memo));
        }
        return memo[index][days] = minDiffJobSchedule;
    }

    public void minDifficultyOfAJobSchedule_Recursive_Memoization(int[] jobs, int days) {
        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/
        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/discuss/2708329/C%2B%2B-Memoized-Solution-oror-Runtime-130-ms-Beats-34.93-Memory-7.3-MB-Beats-93.10
        //explanation: https://youtu.be/smTnSl6UKi0
        /*
        for ex jobs[] = [6, 5, 4, 3, 2, 1], days = 2
        we need to create 'days' non-empty subarrays
        1. [6] | [5, 4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 5 = minDifficulty = 6 + 5 = 11
        2. [6, 5] | [4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 4 = minDifficulty = 6 + 4 = 10
        3. [6, 5, 4] | [4, 3, 2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 3 = minDifficulty = 6 + 3 = 9
        4. [6, 5, 4, 3] | [2, 1] = maxDay1 schedule = 6, maxDay2 schedule = 2 = minDifficulty = 6 + 2 = 8
        5. [6, 5, 4, 3, 2] | [1] = maxDay1 schedule = 6, maxDay2 schedule = 1 = minDifficulty = 6 + 1 = 7
        
        minDifficulty of all the possible 'days' wise schedule is 7
        where day1 schedule [6, 5, 4, 3, 2]
        and day2 schedule [1]
        
         */

        int n = jobs.length;

        if (n < days) {
            System.out.println("Min difficulty of a job schedule: -1");
            return;
        }

        Integer[][] memo = new Integer[n + 1][days + 1];
        int minDifficulty = minDifficultyOfAJobSchedule_Recursive_Memoization_Helper(
                jobs, days, 0, memo);
        //output
        System.out.println("Min difficulty of a job schedule: " + minDifficulty);
    }

    public void longestArithmeticSubseqOfGivenDiff_DP_Memoization(int[] arr, int diff) {
        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/
        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/discuss/2717595/C%2B%2B-Solution
        /*
        ex: arr[7,5,3,1], diff = -2
        length is 4 because 7 - 5 - 3 - 1 has arithmetic diff of -2
        here in the logic
        1. val = 7, map[7 - diff, 0] ==> 0 +1 = 1 because val - diff ==> 7 - -2 = 9 doesn't exists
        map[7=1]
        2. val = 5, map[5 - diff, 0] ==> 0 +1 = 2 because val - diff ==> 5 - -2 = 7 exists with length 1
        (so do +1 to prev seq(7))
        map[7=1, 5=2]
        3. val = 3, map[3 - diff, 0] ==> 0 +1 = 3 because val - diff ==> 3 - -2 = 5 exists with length 2
        (so do +1 to prev seq(5))
        map[7=1, 5=2, 3=3]
        4. val = 1, map[1 - diff, 0] ==> 0 +1 = 4 because val - diff ==> 1 - -2 = 3 exists with length 2
        (so do +1 to prev seq(5))
        map[7=1, 5=2, 3=3, 1=4]
         */
        //a approach similar to longest Increasing Subseq was giving TLE for this
        //tried a different approach based on hashmap
        int n = arr.length;
        //a single element will also be considered as of length 1 even if there
        //is no arithmetic seq with given diff
        int maxLen = 1;
        Map<Integer, Integer> memo = new HashMap<>();
        for (int val : arr) {
            //calculate the length for the curr val if there exists a subseq
            //val - diff, get the length if exists else 0 +1 to it because it is
            //forming subseq
            memo.put(val, memo.getOrDefault(val - diff, 0) + 1);
            maxLen = Math.max(maxLen, memo.get(val));
        }
        //output
        System.out.println("Longest arithmetic subseq with given diff: " + maxLen);
    }

    private int distinctSubsequences_Recursive_Memoization_Helper(
            String main, String curr, int mainIndex, int currIndex, Integer[][] memo) {
        //as we need to find all the distinct subseq of curr string that can be formed
        //from main string, but if the curr string is empty("") then it really
        //doesn't matter if the main string is empty("") or some valid long string
        //because there will exist one empty subseq in main string that will match
        //the given empty("") curr string, so return 1
        if (curr.length() == 0 || currIndex == curr.length()) {
            return 1;
        }

        //just opposite to above note, need to find all the distinct subseq of
        //curr string that can be formed from main string, but if the main string
        //is empty("") and curr string is some valid long string then it will not
        //be possible to form the subseq of curr string from main string because
        //there are no chars in main string to choose from to form curr string
        //so return 0
        if (main.length() == 0 || mainIndex >= main.length()) {
            return 0;
        }

        //if something is already cached
        if (memo[mainIndex][currIndex] != null) {
            return memo[mainIndex][currIndex];
        }

        //if two chars from main and curr string are matches, there will be two
        //possibilities to form the subseq from main string that have same chars
        //as curr string
        if (main.charAt(mainIndex) == curr.charAt(currIndex)) {
            return memo[mainIndex][currIndex]
                    //1. possibility, since two chars already matched, then move both indexes
                    //of main and curr string ahead (ex: main: rabbbit, curr: rabbit)
                    //r, a, b will match but you decide to move both index
                    //mainIndex + 1, currIndex + 1
                    //so next main: rab[b]bit, curr: rab[b]it
                    = distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex + 1, memo)
                    //2. possibility, since two chars already matched, then move only
                    //the index of main string ahead
                    //r, a, b will match but you decide to move only mainIndex + 1
                    //so next main: rab[b]bit, curr: ra[b]bit
                    + distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex, memo);
        }
        //if the two chars don't match, we can only move mainIndex because, we want to
        //form subseq that is exactly the curr string, so currIndex remains at that position
        //so that next the any (mainIndex + 1)-th char can match with currIndex
        return memo[mainIndex][currIndex]
                = distinctSubsequences_Recursive_Memoization_Helper(main, curr, mainIndex + 1, currIndex, memo);
    }

    public void distinctSubsequences_Recursive_Memoization(String main, String curr) {
        //https://leetcode.com/problems/distinct-subsequences/
        //explanation: https://youtu.be/-RDzMJ33nx8
        int n = main.length();
        int m = curr.length();
        Integer[][] memo = new Integer[n][m];
        int distinctSubseq = distinctSubsequences_Recursive_Memoization_Helper(main, curr, 0, 0, memo);
        //output
        System.out.println("Distinct subsequences: " + distinctSubseq);
    }

    private int arrayRemovals_Recursive_Memoization_Helper(
            int[] arr, int k, int minIndex, int maxIndex, int currRemovals, Integer[][] memo) {
        //if by trying for all the possible min & max elements, our
        //minIndex > maxIndex, we dont need to include this so return Int.MAX
        if (minIndex > maxIndex) {
            return Integer.MAX_VALUE;
        }

        //if we have our valid statement i.e, maxEle - minEle <= k
        //return the currRemoval we have made to reach this condition
        if (arr[maxIndex] - arr[minIndex] <= k) {
            return currRemovals;
        }

        //if already cached, return those removals
        if (memo[minIndex][maxIndex] != null) {
            return memo[minIndex][maxIndex];
        }

        int removals = Integer.MAX_VALUE;
        //if maxEle - minEle > k then we are left with two decisions to make
        //1. move to next minEle by keeping the maxEle same i.e minIndex + 1 & maxIndex
        //in this case we consider that we have removed the element at minIndex, so
        //for that currRemoval + 1
        //2. kepp the curr minEle same but move to next maxEle same i.e minIndex & maxIndex - 1
        //in this case we consider that we have removed the element at maxIndex, so
        //for that currRemoval + 1
        //choose the min currRemovals from the arra when they reach the valid statement cond
        removals = Math.min(
                arrayRemovals_Recursive_Memoization_Helper(arr, k, minIndex + 1, maxIndex, currRemovals + 1, memo),
                arrayRemovals_Recursive_Memoization_Helper(arr, k, minIndex, maxIndex - 1, currRemovals + 1, memo));

        return memo[minIndex][maxIndex] = removals;
    }

    public void arrayRemovals_Recursive_Memoization(int[] arr, int k) {
        //https://practice.geeksforgeeks.org/problems/array-removals/1
        Integer[][] memo = new Integer[101][101];
        int n = arr.length;
        //by sorting we will get minEle at minIndex(i.e, 0) and maxEle at maxIndex(i.e, n - 1)
        Arrays.sort(arr);
        int minRemovals = arrayRemovals_Recursive_Memoization_Helper(
                arr, k, 0, n - 1, 0, memo);
        //output
        System.out.println("Min array element removal: " + minRemovals);
    }

    private int deleteAndEarn_Recursive_Memoization_Helper(int val, int[] valFreq, Integer[] memo) {
        if (val >= valFreq.length) {
            return 0;
        }

        if (memo[val] != null) {
            return memo[val];
        }

        //1. don't pick the curr val so it will not be taken into earnings and move
        //to next val (val + 1)
        int dontPick = deleteAndEarn_Recursive_Memoization_Helper(
                val + 1, valFreq, memo);

        //2. pick the curr val so it will be taken into earnings
        //we will consider this val and its freq (val * freq[val])
        //and move to next val (val + 2)
        int pick = (val * valFreq[val]) + deleteAndEarn_Recursive_Memoization_Helper(
                val + 2, valFreq, memo);
        //pick the maxEarning
        return memo[val] = Math.max(dontPick, pick);
    }

    public void deleteAndEarn_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/delete-and-earn/
        //https://leetcode.com/problems/delete-and-earn/discuss/2767347/Javaoror1msoror-90-MEMOIZATIONDP
        //based on sticklerThief() 
        int n = nums.length;
        /*
        Pick any nums[i] and delete it to earn nums[i] points. Afterwards,
        you must delete every element equal to nums[i] - 1 and every element
        equal to nums[i] + 1.
        
        sorting the nums[] will help to skip nums[i] - 1 & nums[i] + 1
         */
        Arrays.sort(nums);
        //find the max value in nums[], upto that (maxVal + 1) all are values in
        //nums[] will be covered.
        int maxVal = nums[n - 1];
        //to calculate freq of each value including any val in nums[] till its
        //maxVal
        int[] valFreq = new int[maxVal + 1];
        for (int val : nums) {
            valFreq[val]++;
        }
        //why + 2? because in question if you pick any nums[i] then we must
        //not use nums[i] + 1 that why +2 is used so that we don't go out of bounds.
        Integer[] memo = new Integer[maxVal + 2];
        int maxEarnings = deleteAndEarn_Recursive_Memoization_Helper(1, valFreq, memo);
        //output
        System.out.println("Delete and earn: " + maxEarnings);
    }

    public void deleteAndEarn_DP_Memoization(int[] nums) {
        //https://leetcode.com/problems/delete-and-earn/
        //https://leetcode.com/problems/delete-and-earn/discuss/2767347/Javaoror1msoror-90-MEMOIZATIONDP
        //based on sticklerThief() 
        int n = nums.length;
        /*
        Pick any nums[i] and delete it to earn nums[i] points. Afterwards,
        you must delete every element equal to nums[i] - 1 and every element
        equal to nums[i] + 1.
        
        sorting the nums[] will help to skip nums[i] - 1 & nums[i] + 1
         */
        Arrays.sort(nums);
        //find the max value in nums[], upto that (maxVal + 1) all are values in
        //nums[] will be covered.
        int maxVal = nums[n - 1];
        //to calculate freq of each value including any val in nums[] till its
        //maxVal
        int[] valFreq = new int[maxVal + 1];
        for (int val : nums) {
            valFreq[val]++;
        }

        //why + 2? because in question if you pick any nums[i] then you we must
        //not use nums[i] + 1 that why +2 is used so that we don't out of bounds.
        Integer[] memo = new Integer[maxVal + 2];

        memo[0] = 0;
        memo[1] = 0;

        for (int val = 2; val < maxVal + 2; val++) {
            memo[val] = Math.max((valFreq[val - 1] * (val - 1)) + memo[val - 2], memo[val - 1]);
        }

        int maxEarnings = memo[maxVal + 1];
        //output
        System.out.println("Delete and earn: " + maxEarnings);
    }

    private void uniquePartitions_Recursive_Helper(int[] nums, int index, int target,
            List<Integer> currList, List<List<Integer>> partitions) {
        if (target == 0) {
            partitions.add(new ArrayList<>(currList));
            return;
        }
        if (index < 0) {
            return;
        }

        //PICK the nums[index], only if this nums[index] is reducing our target
        //not less than 0 (means upto >= 0)
        if (target - nums[index] >= 0) {
            currList.add(nums[index]);
            //if we pick curr nums[index] we can pick this num again and again
            //that why we are keeping index as index only (not index - 1)
            uniquePartitions_Recursive_Helper(nums, index, target - nums[index], currList, partitions);
            currList.remove(currList.size() - 1);
        }

        //DON'T PICK, we are not picking the curr nums[index], that means we have
        //to move to next index i.e, index - 1 and target will also remain as it is
        uniquePartitions_Recursive_Helper(nums, index - 1, target, currList, partitions);
    }

    public void uniquePartitions_Recursive(int n) {
        //https://practice.geeksforgeeks.org/problems/unique-partitions1041/1
        List<List<Integer>> partitions = new ArrayList<>();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = i + 1;
        }
        uniquePartitions_Recursive_Helper(nums, n - 1, n, new ArrayList<>(), partitions);
        //output
        System.out.println("Unique partitions: " + partitions);
    }

    public void largestOneBorderedSquare_DP_Memoization(int[][] grid) {
        //https://leetcode.com/problems/largest-1-bordered-square/
        //https://leetcode.com/problems/largest-1-bordered-square/discuss/2770491/Java-%3A-Easy-to-understand(with-explanation)
        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] verticalOneCount = new int[ROW][COL];
        int[][] horizontalOneCount = new int[ROW][COL];

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 0) {
                    continue;
                }
                verticalOneCount[r][c] = r == 0 ? 1 : verticalOneCount[r - 1][c] + 1;
                horizontalOneCount[r][c] = c == 0 ? 1 : horizontalOneCount[r][c - 1] + 1;
            }
        }

        int max = 0;
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                int min = Math.min(verticalOneCount[r][c], horizontalOneCount[r][c]);
                while (min > max) {
                    if (horizontalOneCount[r - min + 1][c] >= min
                            && verticalOneCount[r][c - min + 1] >= min) {
                        max = min;
                    }
                    min--;
                }
            }
        }

        System.out.println("Largest 1 bordered square: " + (max * max));
    }

    private void lexicographicalNumbers_Recursion_DFS(int n, int currNum, List<Integer> lexicographicalNumbers) {
        if (currNum > n) {
            return;
        }
        lexicographicalNumbers.add(currNum);
        for (int nextDigit = 0; nextDigit <= 9; nextDigit++) {
            lexicographicalNumbers_Recursion_DFS(n, currNum * 10 + nextDigit, lexicographicalNumbers);
        }
    }

    public void lexicographicalNumbers_Recursion(int n) {
        //https://leetcode.com/problems/lexicographical-numbers/
        //based on DFS RECURSION
        List<Integer> lexicographicalNumbers = new ArrayList<>();
        //because we want to generate nums in range of [1, n], thats why our curr
        //digit will start from 1
        for (int digit = 1; digit <= 9; digit++) {
            lexicographicalNumbers_Recursion_DFS(n, digit, lexicographicalNumbers);
        }
        //output
        System.out.println("Lexicographically sorted numbers from [1, " + n + "]: " + lexicographicalNumbers);
    }

    private int minFallingPathSum_Recursive_Memoization_Helper(
            int[][] grid, int row, int col, Integer[][] memo) {
        //if we have reached the row limit of the grid, that means we have covered
        //a path from row == 0 to row >= ROW
        if (row >= grid.length) {
            return 0;
        }
        //if already in cache
        if (memo[row][col] != null) {
            return memo[row][col];
        }

        int currMinFallingPathSum = Integer.MAX_VALUE;
        //from the curr col location we can make 3 moves in the next row from
        //this curr col, i.e, newCol will be diagonal-left(-1), down(0), diagonal-right(+1)
        //if this newCol is going out of bounds, skip that iteration
        for (int newCol = col - 1; newCol <= col + 1; newCol++) {
            //out of bounds
            if (newCol < 0 || newCol >= grid[0].length) {
                continue;
            }

            currMinFallingPathSum = Math.min(currMinFallingPathSum,
                    //picking the value at curr row & col and moving to next row
                    //with new col until we reach the path end we will add them
                    //find the currMinFallingPathSum of all the possible paths
                    grid[row][col] + minFallingPathSum_Recursive_Memoization_Helper(grid, row + 1, newCol, memo));
        }

        return memo[row][col] = currMinFallingPathSum;
    }

    public void minFallingPathSum_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/minimum-falling-path-sum/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        Integer[][] memo = new Integer[ROW][COL];
        int minFallingPathSum = Integer.MAX_VALUE;
        for (int col = 0; col < COL; col++) {
            minFallingPathSum = Math.min(minFallingPathSum,
                    minFallingPathSum_Recursive_Memoization_Helper(grid, 0, col, memo));
        }
        //output
        System.out.println("Min falling path sum: " + minFallingPathSum);
    }

    private int minFallingPathSumTwo_Recursive_Memoization_Helper(int[][] grid,
            int row, int skipCol, Integer[][] memo) {
        int ROW = grid.length;
        int COL = grid[0].length;

        if (row >= ROW) {
            return 0;
        }

        if (memo[row][skipCol] != null) {
            return memo[row][skipCol];
        }

        int currMinFallingPathSum = Integer.MAX_VALUE;

        for (int col = 0; col < COL; col++) {
            if (col == skipCol) {
                continue;
            }
            currMinFallingPathSum = Math.min(
                    currMinFallingPathSum,
                    grid[row][col] + minFallingPathSumTwo_Recursive_Memoization_Helper(grid, row + 1, col, memo));
        }
        return memo[row][skipCol] = currMinFallingPathSum;
    }

    public void minFallingPathSumTwo_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/minimum-falling-path-sum-ii/
        int ROW = grid.length;
        int COL = grid[0].length;
        int minFallingPathSum = Integer.MAX_VALUE;
        //edge case when there is just 1 row OR 1 col
        //for a single row, minFallingPathSum will be min of all the elements
        //in the row == 0
        if (ROW == 1) {
            for (int val : grid[0]) {
                minFallingPathSum = Math.min(minFallingPathSum, val);
            }
            System.out.println("Min falling path sum two: " + minFallingPathSum);
            return;
        }

        //for a single column, minFallingPathSum will be sum of all the elements
        //in the given grid[][]
        if (COL == 1) {
            minFallingPathSum = 0;
            for (int row = 0; row < ROW; row++) {
                minFallingPathSum += grid[row][0];
            }
            System.out.println("Min falling path sum two: " + minFallingPathSum);
            return;
        }

        Integer[][] memo = new Integer[ROW][COL];

        for (int col = 0; col < COL; col++) {
            minFallingPathSum = Math.min(
                    minFallingPathSum,
                    minFallingPathSumTwo_Recursive_Memoization_Helper(grid, 0, col, memo));
        }
        //output
        System.out.println("Min falling path sum two: " + minFallingPathSum);
    }

    private int cherryPickupTwo_Recursive_Memoization_Helper(
            int[][] grid, int currRoboRow, int roboCol1, int roboCol2, Integer[][][] memo) {
        //if any of the robots going out of bounds
        if (currRoboRow >= grid.length
                || roboCol1 < 0 || roboCol1 >= grid[0].length
                || roboCol2 < 0 || roboCol2 >= grid[0].length) {
            return 0;
        }

        if (memo[currRoboRow][roboCol1][roboCol2] != null) {
            return memo[currRoboRow][roboCol1][roboCol2];
        }

        //firstly we add the cherry picked by robot1
        int currCherryPicks = grid[currRoboRow][roboCol1];
        //secondly we will add the cherry picked by robot2 but if robot2 is already
        //at the same location of robot1 then robot2 can't pick from there as already
        //picked by robot1 so cherry becomes 0
        currCherryPicks += (roboCol1 == roboCol2) ? 0 : grid[currRoboRow][roboCol2];

        //now we will try check which next positions for both the robots will give
        //max cherry pick ups
        int maxCherryPicks = 0;
        //since both the robots can make 3 moves in the next row from their curr
        //cols respec, i.e, diagonal-left(-1), down(0), diagonal-right(+1)
        //suppose our robot1 makes a move to next-row and diagonal-left col, there
        //are 3 movement possibilities for robot2. so for 3 movements for robot1
        //there are 3 movements for robot2
        //robot1(diagonal-left, down, diagonal-right) * robot2(diagonal-left, down, diagonal-right)
        //below nested for loop is for the same 3 * 3 == 9 movements possibilities
        for (int newRoboCol1 = roboCol1 - 1; newRoboCol1 <= roboCol1 + 1; newRoboCol1++) {
            for (int newRoboCol2 = roboCol2 - 1; newRoboCol2 <= roboCol2 + 1; newRoboCol2++) {
                maxCherryPicks = Math.max(maxCherryPicks,
                        cherryPickupTwo_Recursive_Memoization_Helper(grid,
                                currRoboRow + 1, newRoboCol1, newRoboCol2, memo));
            }
        }

        currCherryPicks += maxCherryPicks;
        return memo[currRoboRow][roboCol1][roboCol2] = currCherryPicks;

    }

    public void cherryPickupTwo_Recursive_Memoization(int[][] grid) {
        //https://leetcode.com/problems/cherry-pickup-ii/
        //https://leetcode.com/problems/cherry-pickup-ii/solutions/880135/cherry-pickup-ii/
        int ROW = grid.length;
        int COL = grid[0].length;
        //rows remain same for both the robots but col locations may be diff
        //for robot1 and robot2
        Integer[][][] memo = new Integer[ROW][COL][COL];
        //both robot iniatlly at row = 0;
        int currRoboRow = 0;
        //first robot is at top-left(currRoboRow, 0)
        int roboCol1 = 0;
        //second robot is at top-right(currRoboRow, COL - 1)
        int roboCol2 = COL - 1;

        int maxCherryPicks = cherryPickupTwo_Recursive_Memoization_Helper(grid, currRoboRow, roboCol1, roboCol2, memo);
        //output
        System.out.println("Max cherry pickups by two robots: " + maxCherryPicks);
    }

    private int dungeonGame_Recursive_Memoization_Helper(int[][] dungeon, int row, int col, Integer[][] memo) {
        int ROW = dungeon.length;
        int COL = dungeon[0].length;

        //if either row or col going out of bounds
        if (row >= ROW || col >= COL) {
            return Integer.MIN_VALUE;
        }

        //if we reached the bottom-right corner of dungeon
        if (row == ROW - 1 && col == COL - 1) {
            return dungeon[row][col];
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        int healthRemaining1 = dungeonGame_Recursive_Memoization_Helper(dungeon, row + 1, col, memo);
        int healthRemaining2 = dungeonGame_Recursive_Memoization_Helper(dungeon, row, col + 1, memo);

        int currMinHealthReq = Math.min(dungeon[row][col],
                dungeon[row][col] + Math.max(healthRemaining1, healthRemaining2));

        return memo[row][col] = currMinHealthReq;
    }

    public void dungeonGame_Recursive_Memoization(int[][] dungeon) {
        //https://leetcode.com/problems/dungeon-game/description/
        //https://leetcode.com/problems/dungeon-game/solutions/52777/dfs-with-memoization/
        int ROW = dungeon.length;
        int COL = dungeon[0].length;
        Integer[][] memo = new Integer[ROW][COL];
        int minHealthReq = dungeonGame_Recursive_Memoization_Helper(dungeon, 0, 0, memo);
        minHealthReq = minHealthReq <= 0 ? -minHealthReq + 1 : 1;
        //output
        System.out.println("Dungeon game: " + minHealthReq);
    }

    private int buySellStocksWithCooldown_Recursive_Memoization_Helper(int[] prices,
            int day, boolean needToBuy, Integer[][] memo) {

        int maxDays = prices.length;

        if (day >= maxDays) {
            return 0;
        }

        if (memo[day][needToBuy ? 1 : 0] != null) {
            return memo[day][needToBuy ? 1 : 0];
        }

        //when we are allowed to buy
        if (needToBuy) {
            //2 options,
            //1. we will buy stock at curr 'day' by paying the price of prices[day]
            //if we are buying at curr 'day', then we 'need to buy' == false because we
            //need to sell then, we will move to next day (==> day + 1) possibly
            //we can sell on that day
            int buyStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(
                    prices, day + 1, false, memo) - prices[day];

            //2. we will still not buy the stock at curr 'day' and possibly move to 
            //next day (==> day + 1) to buy a stock at that day, and 'need to buy' == true
            int dontBuyStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, day + 1, true, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(buyStock, dontBuyStock);

        } //when we are allowed to sell
        else {
            //2 options,
            //1. we will sell stock at curr 'day' and receive the price of prices[day]
            //if we are selling at curr 'day', then we 'need to buy' == true but we also 
            //need to maintain a 'cooldown' period of 1 day, mean we are not going to buy
            //the next stock on just next day (==> day + 1) but day after tomorrow (==> day + 2)
            int sellStock = prices[day] + buySellStocksWithCooldown_Recursive_Memoization_Helper(
                    prices, day + 2, true, memo);

            //2. we will still not sell the stock at curr 'day' and possibly move to 
            //next day (==> day + 1) to sell the stock at that day, and 'need to buy' == false
            //as we are already holding a stock
            int dontSellStock = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, day + 1, false, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(sellStock, dontSellStock);
        }
    }

    public void buySellStocksWithCooldown_Recursive_Memoization(int[] prices) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
        //Explanation: https://youtu.be/iTvEXpOAyHY | https://www.youtube.com/watch?v=IGIe46xw3YY
        int n = prices.length;
        Integer[][] memo = new Integer[n + 1][2];
        int maxProfit = buySellStocksWithCooldown_Recursive_Memoization_Helper(prices, 0, true, memo);
        //output
        System.out.println("Max profit on buying & selling stock with cooldown: " + maxProfit);
    }

    private int buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(int[] prices,
            int fee, int day, boolean needToBuy, Integer[][] memo) {

        int maxDays = prices.length;

        if (day >= maxDays) {
            return 0;
        }

        if (memo[day][needToBuy ? 1 : 0] != null) {
            return memo[day][needToBuy ? 1 : 0];
        }

        //when we are allowed to buy
        if (needToBuy) {
            //2 options,
            //1. we will buy stock at curr 'day' by paying the price of prices[day]
            //if we are buying at curr 'day', then we 'need to buy' == false because we
            //need to sell then, we will move to next day (==> day + 1) possibly
            //we can sell on that day
            int buyStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, false, memo) - prices[day];

            //2. we will still not buy the stock at curr 'day' and possibly move to 
            //next day (==> day + 1) to buy a stock at that day, and 'need to buy' == true
            int dontBuyStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, true, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(buyStock, dontBuyStock);

        } //when we are allowed to sell
        else {
            //2 options,
            //1. we will sell stock at curr 'day' and receive the price of prices[day]
            //if we are selling at curr 'day', then we 'need to buy' == true and we move
            //to next day (==> day + 1) to buy the next stock of that day, also to note
            //here, we made a 'sell' transaction so each time we make profit on sell,
            //we will have to pay 'fee' on the profit earned on selling
            int sellStock = prices[day] + buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, true, memo) - fee;

            //2. we will still not sell the stock at curr 'day' and possibly move to 
            //next day (==> day + 1) to sell the stock at that day, and 'need to buy' == false
            //as we are already holding a stock
            int dontSellStock = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                    prices, fee, day + 1, false, memo);

            //take the maxProfit out of the 2 options
            return memo[day][needToBuy ? 1 : 0] = Math.max(sellStock, dontSellStock);
        }
    }

    public void buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(int[] prices, int fee) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
        //based on buySellStocksWithCooldown_Recursive_Memoization() with minor change
        int n = prices.length;
        Integer[][] memo = new Integer[n + 1][2];
        int maxProfit = buySellStocksWithTransactionFeeOnSell_Recursive_Memoization_Helper(
                prices, fee, 0, true, memo);
        //output
        System.out.println("Max profit on buying & selling stock with buy paying transaction fee: " + maxProfit);
    }

    public void dominoTrominoTiling_DP_Memoization(int n) {
        //https://leetcode.com/problems/domino-and-tromino-tiling/description/
        //Explanation: https://www.youtube.com/watch?v=E4-rFD6Ry50
        /*
        ref this quest about the shape of domino or tromino
        2 * n board will look like board[2][n]
        if n == 1, board[2][1]
        this shape of board will hold only 1 domino in its vertical form
        ==> Num of ways = 1
        
        if n == 2, board[2][2]
        1. this shape of board will hold 2 domino in its vertical form
        in board[][] col 0 and 1
        2. this shape of board will hold 2 domino in its horizontal form
        in board[][] row 0 and 1
        ==> Num of ways = 2
        
        if n == 3, board[2][3]
        will have 5 ways to arrange domino and tromino, see ex in quest
        ==> Num of ways = 5
        
        **the pattern to solve this quest**
        
        n    =  1   2   3   4
        ways =  1   2   5   11
        
        how when n == 4 ways is 11, its the quest of mathematical sequence
        if n == 4 then 11 = 5 * 2 + 1
        that means ==> 11 = (ways[n - 1]) * 2 + (ways[n - 3])
        similarly
        if n == 5, (ways[n - 1]) * 2 + (ways[n - 3])
        ==> (ways[5 - 1] * 2) + ways[5 - 3] 
        ==> (ways[4] * 2) + ways[2] 
        ==> 11 * 2 + 2
        ==> 24
        
         */
        if (n == 1 || n == 2) {
            System.out.println("Number of ways to tile an 2 x n board: " + n);
            return;
        }
        int mod = 100000007;
        Integer[] memo = new Integer[n + 1];
        memo[1] = 1;
        memo[2] = 2;
        memo[3] = 5;
        for (int i = 4; i < n + 1; i++) {
            memo[i] = ((memo[i - 1] * 2) % mod + memo[i - 3] % mod) % mod;
        }
        //output
        System.out.println("Number of ways to tile an 2 x n board: " + (memo[n] % mod));
    }

    private int pallindromePartitioningTwo_Recursive_Memoization_Helper(
            String str, int startIndex, int length, Integer[] memo) {
        if (startIndex == length) {
            return 0;
        }

        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int minPartition = Integer.MAX_VALUE;

        for (int endIndex = startIndex; endIndex < length; endIndex++) {
            //if the prefix part of str (i.e, str, startIndex, endIndex) is
            //pallindrome, that means 1 partition can be made here and we can divide the
            //the problem into sub problem to check if substring[i + 1, length]
            //can also be partitioned as pallindrome and choose the min partitions
            if (isStringPallindrome(str, startIndex, endIndex)) {
                minPartition = Math.min(minPartition,
                        1 + pallindromePartitioningTwo_Recursive_Memoization_Helper(
                                str, endIndex + 1, length, memo));
            }
        }

        return memo[startIndex] = minPartition;
    }

    public void pallindromePartitioningTwo_Recursive_Memoization(String str) {
        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
        //Explanation: https://youtu.be/_H8V5hJUGd0
        //based on pallindromePartitioning_Backtracking()
        int n = str.length();
        Integer[] memo = new Integer[n];
        int minPartition = pallindromePartitioningTwo_Recursive_Memoization_Helper(str, 0, n, memo) - 1;
        //output
        System.out.println("Pallindrome partitioning two Recursive Memoization: " + minPartition);
    }

    public void pallindromePartitioningTwo_DP_Memoization(String str) {
        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
        //Explanation: https://youtu.be/_H8V5hJUGd0
        //based on bottom-up DP
        int n = str.length();
        Integer[] memo = new Integer[n + 1];
        memo[n] = 0;
        for (int startIndex = n - 1; startIndex >= 0; startIndex--) {
            int minPartition = Integer.MAX_VALUE;
            for (int endIndex = startIndex; endIndex < n; endIndex++) {
                if (isStringPallindrome(str, startIndex, endIndex)) {
                    minPartition = Math.min(minPartition, 1 + memo[endIndex + 1]);
                }
            }
            memo[startIndex] = minPartition;
        }

        //output
        System.out.println("Pallindrome partitioning two DP Memoization: " + (memo[0] - 1));
    }

    private boolean wildCardMatching_Recursive_Memoization_Helper(
            String str, String pattern, int strIndex, int patternIndex, Boolean[][] memo) {

        //true when both my strings str and pattern reaches the end, meaning pattern
        //matched with str
        //ex: str = "abcd", pattern = "ab?d" ==> a == a, b == b, c == ?, d == d
        if (strIndex >= str.length() && patternIndex >= pattern.length()) {
            return true;
        }
        //false when patten only reached the end before the str reaches end, meaning
        //there are not enough chars(letter, ?, *) to match with chars in str
        //ex: str = "abcd", pattern = "ab?" ==> a == a, b == b, c == ?, d but pattern == pat.len
        //so pattern can't be matched with str fully
        if (patternIndex >= pattern.length()) {
            return false;
        }
        //third cond has two possibilities, suppose our main string has reached its end
        //but pattern string is still left
        //1. true when when pattern[patternIndex to pat.length] all are * char, in that case
        //each of this * char in pattern string can be considered as empty seq of chars ''
        //so if the left over chars in pattern are all * char, we will consider all those
        //* chars as empty seq and hence at the end of pattern it will still match with str
        //ex: str = "abcd", pattern = "ab?d**"
        //==> a == a, b == b, c == ?, d == d, '' == *, '' == *
        //2. false when pattern[patternIndex to pat.length] are not * char, in that case
        //we don't have any chars left in str (because already at strIndex >= str.length)
        //so any char which is not *, can't be compared
        //ex: str = "abcd", pattern = "ab?d*e"
        //==> a == a, b == b, c == ?, d == d, '' == *, strIndex == str.length but pattern has 'e' left
        if (strIndex >= str.length() && patternIndex < pattern.length()) {
            for (int leftChars = patternIndex; leftChars < pattern.length(); leftChars++) {
                if (pattern.charAt(leftChars) != '*') {
                    return false;
                }
            }
            return true;
        }

        if (memo[strIndex][patternIndex] != null) {
            return memo[strIndex][patternIndex];
        }

        //str[i] == pat[j] || pat[j] == '?'
        //ex: str = "abcd", pattern = "ab?d" now at strIndex == patternIndex == 2 
        //either str[2] == pattern[2] == c OR pattern[2] == '?' because '?' means any char
        //then move to next indexes in both strings to check further
        if (str.charAt(strIndex) == pattern.charAt(patternIndex) || pattern.charAt(patternIndex) == '?') {

            return memo[strIndex][patternIndex]
                    = wildCardMatching_Recursive_Memoization_Helper(
                            str, pattern, strIndex + 1, patternIndex + 1, memo);

        } else if (pattern.charAt(patternIndex) == '*') {

            return memo[strIndex][patternIndex] = /*
            now '*' char means it can match with any seq chars in string str
            //ex: str = "abxyzef", pattern = "ab*ef"
            //here a == a, b == b
            //but any of this can be true: '' == * OR row == * OR xy == * OR xyz == * OR xyze == * OR xyzef == *
            //so from above xyz == *, * matches seq of chars xyz
            //then e == e, f == f hence MATCHED
            //str: a | b | xyz | e | f
            //pat: a | b | *   | e | f
            //this includes call: (strIndex + 1, patternIndex) why?
            //because patternIndex remained at * char but strIndex moved to strIndex + 1 in dfs calls
            //this simulates picking up char as seq that can be matched with same * char
            //str: a | b | xyz | e | f
            //pat: a | b | *   | e | f
            //str[strIndex] = 'row',
            //str[strIndex + 1] = 'xy',
            //str[strIndex + 1] = 'xyz',
            //str[strIndex + 1] = 'xyze',
            //str[strIndex + 1] = 'xyzef',  
            //pattern[patternIndex] = '*' */ wildCardMatching_Recursive_Memoization_Helper(str, pattern, strIndex + 1, patternIndex, memo)
                    || /*also
            //ex: str = "abef", pattern = "ab*ef"
            //here a == a, b == b
            //but any of this can be true: '' == * OR e == * OR ef == *
            //so from above '' == *, * matches seq of chars '' i.e, empty seq
            //then e == e, f == f hence MATCHED
            //str: a | b | '' | e | f
            //pat: a | b | *   | e | f
            //this includes call: (strIndex, patternIndex + 1) why?
            //because strIndex remained same char but patternIndex moved to patternIndex + 1 in dfs calls
            //this simulates considering the * char as empty seq
            //str: a | b | '' | e | f
            //pat: a | b | *   | e | f
            //str[strIndex] = 'e',  
            //pattern[patternIndex] = '*',
            //pattern[patternIndex + 1] = 'e' */ wildCardMatching_Recursive_Memoization_Helper(str, pattern, strIndex, patternIndex + 1, memo);

        } else {
            //where nothing matches
            //neither it is ? nor * and both str & pattern chars also didn't match
            return memo[strIndex][patternIndex] = false;
        }
    }

    public void wildCardMatching_Recursive_Memoization(String str, String pattern) {
        //https://leetcode.com/problems/wildcard-matching/description/
        //Explanation: https://youtu.be/ZmlQ3vgAOMo
        int m = str.length();
        int n = pattern.length();
        Boolean[][] memo = new Boolean[m + 1][n + 1];
        boolean wildCardPatternMatched = wildCardMatching_Recursive_Memoization_Helper(str, pattern, 0, 0, memo);
        //output
        System.out.println(str + ": string wildcard matching with pattern: " + pattern + " : " + wildCardPatternMatched);
    }

    private int maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_BinarySearch(
            int[][] intervals, int start, int end, int prevEnd) {

        //here we already have end1 == prevEnd now we need to find the nextIndex
        //of [start2, end2, profit2] so that two intervals 
        //[start1, end1, profit1] and [start2, end2, profit2] are said to be
        //non-overlapping if [end1 <= start2] and [start1 < start2]
        int nextIndex = intervals.length;
        while (end >= start) {

            int mid = start + (end - start) / 2;

            if (prevEnd <= intervals[mid][0]) {
                nextIndex = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        return nextIndex;
    }

    private int maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_Helper(
            int[][] intervals, int index, Integer[] memo) {

        int n = intervals.length;

        if (index >= n) {
            return 0;
        }

        if (memo[index] != null) {
            return memo[index];
        }

        //to have max profits from the intervals we have 2 descisions to make
        //1. dont pick the intrval at curr index and move to next interval by index + 1
        int dontPick = maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_Helper(
                intervals, index + 1, memo);

        //2. pick the interval at curr index, so if we are taking it then we also
        //take the profit at this index( == intervals[index][2]) but after picking
        //interval at 'index' we have to move to nextIndex(because Two intervals 
        //[start1, end1, profit1] and [start2, end2, profit2] are said to be
        //non-overlapping if [end1 <= start2] and [start1 < start2]) so below binary
        //search method will help
        //here: index belongs to [start1, end1, profit1] & nextIndex belongs to [start2, end2, profit2]
        int currEnd = intervals[index][1];
        int nextIndex = maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_BinarySearch(
                intervals, index + 1, n - 1, currEnd);

        int pick = intervals[index][2]
                + maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_Helper(intervals, nextIndex, memo);

        return memo[index] = Math.max(pick, dontPick);
    }

    public void maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization(int[][] intervals) {
        //https://practice.geeksforgeeks.org/problems/649205908e04ac00f303626fa845261318adfa8f/1
        /*
        Two intervals [start1, end1, profit1] and [start2, end2, profit2] are
        said to be non-overlapping
        if [end1 <= start2] and [start1 < start2]
         */
        int n = intervals.length;
        Integer[] memo = new Integer[n + 1];
        //sort the intervals in incr order of start times, if two start times are
        //same then sort in incr order of their end times
        //this sorting will ensure cond: [start1 < start2]
        //since the intervals[][] is sorted, binary search can be used to find
        //next intervals that is not overlapping
        Arrays.sort(intervals, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);
        int maxProfit = maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization_Helper(intervals, 0, memo);
        //output
        System.out.println("Max profits by choosing subset of intervals: " + maxProfit);
    }

    private int maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
            int[][] piles, int pileIndex, int k, Integer[][] memo) {

        //if we dont have any piles left to pick coins from OR
        //we have picked k coins and now cant pick more
        if (pileIndex >= piles.length || k <= 0) {
            return 0;
        }

        if (memo[pileIndex][k] != null) {
            return memo[pileIndex][k];
        }

        int maxValueFromPick = 0;

        //pick coins
        //As we have to pick k coins in total, so we have two possibilities
        //1. chooses all the k coins from same pile at pileIndex
        //2. choose some coins from same pile at pileIndex but remaining k coins
        //from other piles at pileIndex + 1
        int coinsPickFromSamePile = 0;
        for (int currK = 0; currK < piles[pileIndex].length; currK++) {
            //as we can pick k coins, what if all the k coins are from same pile
            //i.e, from any pileIndex, coins picked should be [0 to k - 1] coins
            //currK is k-th coins picks and added in coinsPickFromSamePile so if
            //coins picked is exceeding than (k - 1) break
            if (currK > k - 1) {
                break;
            }

            //1. possibility is to pick all the k coins from same pile
            //pick the some k coins add its value in coinsPickFromSamePile
            coinsPickFromSamePile += piles[pileIndex][currK];

            //2. choose some coins(== currK) from the curr pile at pileIndex
            //and remaining(== k - currK - 1 ==> max k pick - already k coins picked - 1)
            //coins from other given piles(== pileIndex + 1)
            int coinsPickFromRemainingPiles = maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
                    piles, pileIndex + 1, k - currK - 1, memo);

            //choose the max coins value we get from this combinations
            maxValueFromPick = Math.max(maxValueFromPick,
                    coinsPickFromSamePile + coinsPickFromRemainingPiles);
        }

        //dont pick coins
        //don't pick the coin from curr pile but move to next pile(== pileIndex + 1)
        //since we have not picked any coins from curr pile at pileIndex so the k remains same
        int maxValueFromNotPick = maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(
                piles, pileIndex + 1, k, memo);

        //choose the max value from pick and dontPick
        return memo[pileIndex][k] = Math.max(maxValueFromPick, maxValueFromNotPick);
    }

    public void maxValueFromKCoinsFromPiles_Recursive_Memoization(int[][] piles, int k) {
        //https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/
        Integer[][] memo = new Integer[piles.length + 1][k + 1];
        int maxValueFromKCoinsPicks = maxValueFromKCoinsFromPiles_Recursive_Memoization_Helper(piles, 0, k, memo);
        //output
        System.out.println("Max value from k coins picks from given piles: " + maxValueFromKCoinsPicks);
    }

    public void bestTeamWithNoConflict_DP_Memoization(int[] scores, int[] ages) {
        //https://leetcode.com/problems/best-team-with-no-conflicts/description/
        //based on LONGEST INCREASING SUBSEQ, longestIncreasingSubsequence_DP_Memoization()
        int n = scores.length;
        int[][] scoresAges = new int[n][2];
        for (int i = 0; i < n; i++) {
            scoresAges[i][0] = scores[i];
            scoresAges[i][1] = ages[i];
        }

        //sort the given input according to their ages
        //if the ages are same, sort them incr order of their scores else incr
        //order of ages
        Arrays.sort(scoresAges, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);

        int[] longestIncrMaxScores = new int[n];
        int maxScores = 0;
        //for each i-th index the max scores is their respec i-th scores[i]
        for (int i = 0; i < n; i++) {
            longestIncrMaxScores[i] = scoresAges[i][0];
            maxScores = Math.max(maxScores, scoresAges[i][0]);
        }

        //based on longest incr subseq, here we are finding longest incr max scores
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (scoresAges[i][0] >= scoresAges[j][0]) {
                    longestIncrMaxScores[i] = Math.max(
                            longestIncrMaxScores[i],
                            scoresAges[i][0] + longestIncrMaxScores[j]);
                }
            }
            maxScores = Math.max(maxScores, longestIncrMaxScores[i]);
        }
        //output
        System.out.println("Best team with no conflict: " + maxScores);
    }

    public void greatestSumDivisibleByThree_DP_Memoization(int[] nums) {
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/description/
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/solutions/431077/java-c-python-one-pass-o-1-space/
        int[] memo = new int[3];
        for (int val : nums) {
            //Array.copyOf() creates the prevMemo array of memo while changing
            //memo at the same time
            for (int prevState : Arrays.copyOf(memo, memo.length)) {
                memo[(prevState + val) % 3] = Math.max(memo[(prevState + val) % 3], prevState + val);
            }
        }
        //output
        System.out.println("Greatest sum divisible by three: " + memo[0]);
    }

    private int minCostForTickets_Recursive_Memoization_Helper(
            int[] days, int[] costs, int index, int lastDay, Integer[] memo) {

        //if we have reached the end of the days[] means further we need not to
        //buy tickets/ pass, so cost becomes 0
        if (index >= days.length) {
            return 0;
        }

        //previously, we have bought pass/ tickets that will allow us to travel
        //some days. Assume prev, on day X we bought a pass/ tickets:
        //1-day pass: it would have used for day X only so lastDay == 0
        //7-days pass: it would be used untill (X + 6) days == lastDay
        //30-days pass: it would be used untill (X + 29) days == lastDay
        //so if curr days[index] <= lastDay == allowed no. of days through pass
        //we will move to next day(== index + 1) as long as we are allowed untill
        //lastDay
        if (days[index] <= lastDay) {
            return minCostForTickets_Recursive_Memoization_Helper(
                    days, costs, index + 1, lastDay, memo);
        }

        //cached
        if (memo[index] != null) {
            return memo[index];
        }

        //since we have 3 diff passes to choose from, so we will try to get minCost
        //out of 3-passes as available options
        int minCost = Math.min(
                //cost[0] == 1-day pass: already used for curr day @index so this pass can't
                //be used further hence lastDay == 0 and we will just move to next
                //day(== index + 1)
                costs[0] + minCostForTickets_Recursive_Memoization_Helper(days, costs, index + 1, 0, memo),
                Math.min(
                        //cost[1] == 7-day pass: already used for curr day @index and can be
                        //used for next 6 more days hence lastDay == days[index] + 6
                        //and we will just move to next day(== index + 1)
                        costs[1] + minCostForTickets_Recursive_Memoization_Helper(days, costs, index + 1, days[index] + 6, memo),
                        //cost[2] == 30-day pass: already used for curr day @index and can be
                        //used for next 29 more days hence lastDay == days[index] + 29
                        //and we will just move to next day(== index + 1)
                        costs[2] + minCostForTickets_Recursive_Memoization_Helper(days, costs, index + 1, days[index] + 29, memo)
                )
        );

        return memo[index] = minCost;
    }

    public void minCostForTickets_Recursive_Memoization(int[] days, int[] costs) {
        //https://leetcode.com/problems/minimum-cost-for-tickets/description/
        //explanation: https://youtu.be/4pY1bsBpIY4
        //given days[] is already sorted
        int n = days.length;
        Integer[] memo = new Integer[n];
        int minCost = minCostForTickets_Recursive_Memoization_Helper(days, costs, 0, 0, memo);
        //output
        System.out.println("Min cost for tickets: " + minCost);
    }

    private int reducingDishes_Recursive_Memoization_Helper(
            int[] satisfaction, Integer[][] memo, int index, int currTime) {

        //if we have traversed all the dishes, there will no more dishes to 
        //calulate like-time coeff value so return 0
        if (index >= satisfaction.length) {
            return 0;
        }

        if (memo[index][currTime] != null) {
            return memo[index][currTime];
        }

        //two options to decide
        //1. Cook the dish at curr index with the time taken as currTime
        //and move on to the next dish(== index + 1) with time as currTime + 1
        int pick = (satisfaction[index] * currTime) + reducingDishes_Recursive_Memoization_Helper(
                satisfaction, memo, index + 1, currTime + 1);

        // 2. Skip the current dish and move on to the next(== index + 1)
        //dish at the same time
        int dontPick = reducingDishes_Recursive_Memoization_Helper(
                satisfaction, memo, index + 1, currTime);

        //maximize the like-time coeff, so chose the one that gives the max
        return memo[index][currTime] = Math.max(pick, dontPick);
    }

    public void reducingDishes_Recursive_Memoization(int[] satisfaction) {
        //https://leetcode.com/problems/reducing-dishes/description/
        int n = satisfaction.length;
        Integer[][] memo = new Integer[n + 1][n + 1];
        Arrays.sort(satisfaction);
        int likeTimeCoeff = reducingDishes_Recursive_Memoization_Helper(satisfaction, memo, 0, 1);
        //output
        System.out.println("Max like time coefficient: " + likeTimeCoeff);
    }

    private boolean scrambledStrings_Recursive_Memoization_Helper(
            String str1, String str2, Map<String, Boolean> memo) {

        int n = str1.length();

        //if both strings are not equal in size
        if (str2.length() != n) {
            return false;
        }

        //if both strings are equal
        if (str1.equals(str2)) {
            return true;
        }

        //if we have reached to this condition then following are sure:
        //1. size of both string is equal
        //2. string are not equal
        //because above two if cond have failed
        //so size is equal(== 1) and they are not equal then obviously false
        //example 'a' and 'b' string are not equal, size is equal
        if (n == 1) {
            return false;
        }

        //if already cached
        String key = str1 + "," + str2;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        // for every iteration it can two condition
        // 1.we should proceed without swapping
        // 2.we should swap before looking next
        for (int i = 1; i < n; i++) {
            // ex of without swap: gr|eat and rg|eat
            boolean isScrambledWithoutSwap = ( // left part of first and second string
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(0, i), str2.substring(0, i), memo)
                    && // right part of first and second string;
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(i), str2.substring(i), memo));

            // if without swap give us right answer then we do not need
            // to call the recursion withswap
            if (isScrambledWithoutSwap) {
                memo.put(key, true);
                return true;
            }

            // ex of withswap: gr|eat rge|at
            // here we compare "gr" with "at" and "eat" with "rge"
            boolean isScrambledWithSwap = ( // left part of first and right part of second
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(0, i), str2.substring(n - i), memo)
                    && // right part of first and left part of second
                    scrambledStrings_Recursive_Memoization_Helper(str1.substring(i), str2.substring(0, n - i), memo));

            // if with swap give us right answer then we return true
            // otherwise the for loop do it work
            if (isScrambledWithSwap) {
                memo.put(key, true);
                return true;
            }
            // we are not returning false in else case
            // because we want to check further cases with the for loop
        }

        //if in above for() we have not encountered return true means the
        //curr strings str1 & str2 are not scrambled
        memo.put(key, false);

        return false;
    }

    public void scrambledStrings_Recursive_Memoization(String str1, String str2) {
        //https://leetcode.com/problems/scramble-string/description/
        //https://leetcode.com/problems/scramble-string/solutions/3357439/easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation/
        //explanation: https://youtu.be/Fx96uB9EIDQ
        Map<String, Boolean> memo = new HashMap<>();
        System.out.println("Strings scrambled: "
                + scrambledStrings_Recursive_Memoization_Helper(str1, str2, memo));
    }

    private int numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
            int ROW, int COL, int[][] prefixSum, Integer[][][] memo, int row, int col, int currCut) {

        //if the pizza cut segment with row & col don't have apples, then this
        //can be valid cut return 0
        if (prefixSum[row][col] == 0) {
            return 0;
        }

        //return 1 as possible way, if we have made all the valid-cuts and now
        //our currCut == 0 means we have cut pizza into k pieces
        if (currCut == 0) {
            return 1;
        }

        //cached, since currCut, row, col are the changing parameters
        if (memo[currCut][row][col] != null) {
            return memo[currCut][row][col];
        }

        int mod = 1000000007;
        int ways = 0;

        //below we are making the horizontal cuts(== hCut, row wise cuts)
        //but before we move next hCut we must check the curr cut at
        //horzonatal-index == row should have apples
        //(== prefixSum[row][col] - prefixSum[hCut][col] > 0)
        //if curr cut has apples > 0 we move to sub-problem recursively to make
        //next horizontal cut hCut and since we make cut at curr row so for next
        //currCut - 1
        for (int hCut = row + 1; hCut < ROW; hCut++) {
            if (prefixSum[row][col] - prefixSum[hCut][col] > 0) {
                ways = (ways + numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                        ROW, COL, prefixSum, memo, hCut, col, currCut - 1)) % mod;
            }
        }

        //below we are making the vertical cuts(== vCut, col wise cuts)
        //but before we move next vCut we must check the curr cut at
        //vertical-index == col should have apples
        //(== prefixSum[row][col] - prefixSum[row][vCut] > 0)
        //if curr cut has apples > 0 we move to sub-problem recursively to make
        //next vertical cut vCut and since we make cut at curr col so for next
        //currCut - 1
        for (int vCut = col + 1; vCut < COL; vCut++) {
            if (prefixSum[row][col] - prefixSum[row][vCut] > 0) {
                ways = (ways + numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                        ROW, COL, prefixSum, memo, row, vCut, currCut - 1)) % mod;
            }
        }

        return memo[currCut][row][col] = ways;
    }

    public void numberOfWaysOfCuttingPizza_Recursive_Memoization(String[] pizza, int k) {
        //https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description/
        //Explanation: https://www.youtube.com/watch?v=g2D-HymlQqQ&t=608s
        int ROW = pizza.length;
        int COL = pizza[0].length();
        Integer[][][] memo = new Integer[k][ROW][COL];
        int[][] prefixSum = new int[ROW + 1][COL + 1];

        for (int r = ROW - 1; r >= 0; r--) {
            for (int c = COL - 1; c >= 0; c--) {
                prefixSum[r][c] = prefixSum[r][c + 1] + prefixSum[r + 1][c]
                        - prefixSum[r + 1][c + 1] + (pizza[r].charAt(c) == 'A' ? 1 : 0);
            }
        }
        int waysToCutPizza = numberOfWaysOfCuttingPizza_Recursive_Memoization_Helper(
                ROW, COL, prefixSum, memo, 0, 0, k - 1);
        //output
        System.out.println("Ways to cut pizza: " + waysToCutPizza);
    }

    private int targetSum_Recursive_Memoization_Helper(
            int[] nums, int target, Map<String, Integer> memo, int index, int currSum) {

        //if there are no elements to pick from the array, then we will have to
        //check if our currSum becomes target or not
        if (index >= nums.length) {
            return currSum == target ? 1 : 0;
        }

        String key = index + "," + currSum;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int ways = 0;

        //2 options to choose from, either we will add or subtract the num @index
        //if by adding or subtracting currSum becomes equal to target at the end
        //of the array, we will get 1 way for making sum equal to target otherwise 0
        //1. we will add the curr num @index and we will move to next index
        //(== index + 1) hence our currSum will be currSum + nums[index]
        ways += targetSum_Recursive_Memoization_Helper(
                nums, target, memo, index + 1, currSum + nums[index]);
        //2. we will subtract the curr num @index and we will move to next index
        //(== index + 1) hence our currSum will be currSum - nums[index]
        ways += targetSum_Recursive_Memoization_Helper(
                nums, target, memo, index + 1, currSum - nums[index]);

        memo.put(key, ways);
        return ways;
    }

    public void targetSum_Recursive_Memoization(int[] nums, int target) {
        //https://leetcode.com/problems/target-sum/description/
        //explanation: https://youtu.be/g0npyaQtAQM
        Map<String, Integer> memo = new HashMap<>();
        int ways = targetSum_Recursive_Memoization_Helper(
                nums, target, memo, 0, 0);
        //output
        System.out.println("Target sum : " + ways);
    }

    private long waysToFormStringFromDict_Recursive_Memoization_Helper(
            int wordLen, String target, int[][] charFreqAtEachWordIndex,
            int targetCharIndex, int wordCharIndex, Integer[][] memo) {

        int mod = 1000000007;

        //since we have to make target string from dict words[] so if in making
        //this target string we reached where target-char-index is at end of target
        //string means we have successfully created this target so return 1
        if (targetCharIndex >= target.length()) {
            return 1;
        }

        //if the above if() cond didn't fulfil and at this cond we already exhaust
        //all the word-char-index to travel further means there are no more chars
        //in any of the word in words[] to form target string so return 0;
        if (wordCharIndex >= wordLen) {
            return 0;
        }

        //if already cached
        if (memo[targetCharIndex][wordCharIndex] != null) {
            return memo[targetCharIndex][wordCharIndex];
        }

        //don't pick the char at curr word char index
        //1. since we have to make the target string as a result means we can't
        //skip the char from target string at curr targetCharIndex but we can skip the
        //char of the word at wordCharIndex to be used in target and move to
        //(wordCharIndex + 1)
        long ways = waysToFormStringFromDict_Recursive_Memoization_Helper(
                wordLen, target, charFreqAtEachWordIndex, targetCharIndex, wordCharIndex + 1, memo);

        //pick the char at curr word char index
        //2. here we are picking the char targetChar which will also be there in
        //words of words[], now we are picking this 'targetChar' from wordCharIndex
        //of the word, but the catch here is, there can be many words in words[]
        //that will have same 'targetChar' at wordCharIndex means there will be 
        //that many ways to form our target string. That's why we have precomputed
        //the freq of char of all the words at particular word-char-index
        //ex: target = "aba", targetCharIndex = 0,
        //means we will pick targetChar = 'a' to be choosen from the words in word[]
        //lets say words[] = ["abba", "bbbb", "acac"] at wordCharIndex = 0, we
        //have two strings "abba", "acac" so our,
        //charFreqAtEachWordIndex[wordCharIndex][targetChar - 'a'] will have freq
        //charFreqAtEachWordIndex[0]['a'] = 2
        char targetChar = target.charAt(targetCharIndex);
        long pickWordCharIndex = charFreqAtEachWordIndex[wordCharIndex][targetChar - 'a']
                * waysToFormStringFromDict_Recursive_Memoization_Helper(
                        wordLen, target, charFreqAtEachWordIndex, targetCharIndex + 1, wordCharIndex + 1, memo);

        ways += pickWordCharIndex;

        return memo[targetCharIndex][wordCharIndex] = (int) (ways % mod);
    }

    public void waysToFormStringFromDict_Recursive_Memoization(String[] words, String target) {
        //https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/
        //explanation: https://youtu.be/_GF-0T-YjW8
        int targetLen = target.length();
        //all the words in given words[] dict is of same length
        int wordLen = words[0].length();

        //let say a word is "abcd", wordLen = 4 then each char-index = [0 to 3]
        //now if there are N words in words[] having same lengths then with
        //charFreqAtEachWordIndex[][] arrays we count freq of chars at curr
        //char-index for all the words
        /*
        words[] = [["acca","bbbb","caca"], wordLen = words[0].length = "acca".length()
        wordLen = 4, charFreqAtEachWordIndex[wordLen][26]
        
        char-index  |    words[]    | charFreqAtEachWordIndex[wordLen][26]
        0               a   b   c       0 = [a = 1, b = 1, c = 1]
        1               c   b   a       1 = [a = 1, b = 1, c = 1]
        2               c   b   c       2 = [a = 0, b = 1, c = 2]
        3               a   b   a       3 = [a = 2, b = 1, c = 0]
        
         */
        int[][] charFreqAtEachWordIndex = new int[wordLen][26];
        for (String word : words) {
            for (int index = 0; index < wordLen; index++) {
                char wordChar = word.charAt(index);
                charFreqAtEachWordIndex[index][wordChar - 'a']++;
            }
        }

        Integer[][] memo = new Integer[targetLen][wordLen];
        long ways = waysToFormStringFromDict_Recursive_Memoization_Helper(
                wordLen, target, charFreqAtEachWordIndex, 0, 0, memo);

        //output
        System.out.println("Number of ways to form string from given dictionary : " + ways);
    }

    private int profitableScheme_Recursive_Memoization_Helper(int n, int minProfit, int[] groups, int[] profits,
            int index, int currProfit, int members, Integer[][][] memo) {

        int mod = 1000000007;

        //if we have reached the end of our profits[] means we can't go further
        //to pick anything, from here if our currProfit is 'atleast' minProft
        //return 1
        if (index >= profits.length) {
            return currProfit >= minProfit ? 1 : 0;
        }

        if (memo[index][currProfit][members] != null) {
            return memo[index][currProfit][members];
        }

        int ways = 0;

        //there are 2 choices to make here,
        //1. if we don't pick, the group @index then the members of groups[index]
        //will not be counted and profit from this group as profit[index] will
        //also not be counter, and we move to next index as (index + 1) and
        //skip curr value
        ways = profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                index + 1,
                currProfit,
                members,
                memo);
        //2. if we choose to pick, the group @index then the members of groups[index]
        //will be counted and profit from this group as profit[index] will
        //also be counter, and we move to next index as (index + 1)
        //but here's a catch
        //while picking members from groups[] we can't take members more than
        //given n value, so if adding member from group[index] into our 'members'
        //is still less than n, we will proceed(== members + groups[index] <= n)
        if (members + groups[index] <= n) {
            ways = (ways
                    + profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                            index + 1,
                            //to be in bounds of memo[][][] we are picking min of profits
                            //because in base cond above we only want our currProfit to
                            //be 'atleast' minProfit
                            Math.min(minProfit, currProfit + profits[index]),
                            members + groups[index],
                            memo)) % mod;
        }

        return memo[index][currProfit][members] = ways;
    }

    public void profitableScheme_Recursive_Memoization(int n, int minProfit, int[] groups, int[] profits) {
        /*
        ........................T: O(N⋅M⋅K)
        We have three parameters index, count and profit. The index can vary
        from 0 to M - 1, and the count can again vary from 0 to N - 1 (as we
        consider crime only if it doesn't exceed the limit of N), the last
        param profit can vary largely but since we cap its value to minProfit
        it values can vary from 0 to minProfit. We need to calculate the answer
        to each of these states to solve the original problem; hence the total
        computation would be O(N⋅M⋅K).

        ........................S: O(N⋅M⋅K)
        The size of memo would equal the number of states as (N⋅M⋅K). Although
        we used the maximum value of 101 in the code to simplify things,
        we can also use the original values in the input as the size of memo.
        Also, there would be some space in the recursion as well, the total
        number of active recursion calls could be NNN one for each crime, and
        hence the total recursion space would be O(N).
         */
        //https://leetcode.com/problems/profitable-schemes/description/
        //explanation: https://youtu.be/CcLKQLKvOl8
        /*
        Constraints:

        1 <= n <= 100
        0 <= minProfit <= 100
        1 <= group.length <= 100
        1 <= group[i] <= 100
        profit.length == group.length
        0 <= profit[i] <= 100
         */
        //this quest has focused more on usage of contraints 
        //101 are the base constraints for this quest
        Integer[][][] memo = new Integer[101][101][101];
        int ways = profitableScheme_Recursive_Memoization_Helper(n, minProfit, groups, profits,
                0, 0, 0, memo);
        //output
        System.out.println("Ways to have profitable scheme : " + ways);
    }

    private int restoreArray_Recursive_Memoization_Helper(String str, int k, int startIndex, Integer[] memo) {

        int mod = 1000000007;
        int n = str.length();

        //return 1, if we have reached the end of the str meaning in the process
        //of restoring the array we have successfully restored it where all the
        //array elements are in the range of [1, k]
        if (startIndex >= n) {
            return 1;
        }

        //return 0, if the starting of possible new array element from this
        //startIndex is having leading 0s ex: 01, 034 no new array element should
        //be formed with a leading 0 in it
        if (str.charAt(startIndex) == '0') {
            return 0;
        }

        //if cached
        if (memo[startIndex] != null) {
            return memo[startIndex];
        }

        int ways = 0;

        for (int endIndex = startIndex; endIndex < n; endIndex++) {
            //form a new array element between start and end inclusive
            //alternative to use of substring(), we can form number as
            //number = number * 10 + (str.charAt(endIndex) - '0'), declare
            //int number = 0 above this loop
            String arrElement = str.substring(startIndex, endIndex + 1);
            //check if this new array element is bigger than k then we can't go
            //further from here it will always be bigger than k only, so break
            if (Long.parseLong(arrElement) > k) {
                break;
            }

            //if the curr array element formed as 'arrElement' is in the range
            //then we can move further to form new array elements,
            //since we have considered a num from [startIndex, endIndex] so
            //the next num should start from (endIndex + 1)
            ways = (ways
                    + restoreArray_Recursive_Memoization_Helper(str, k, endIndex + 1, memo)) % mod;
        }
        return memo[startIndex] = ways;
    }

    public void restoreArray_Recursive_Memoization(String str, int k) {
        /*
        .........................T: O(n * Log⁡k)
        We create memo of length n + 1 for memory, it takes O(n) steps to update them.
        At each step s[start], we look for all possible ending index end. In the
        worst-case scenario, we will iterate over Log⁡k indexes before currNumber
        is larger than k, because each iteration increases currNumber by a magnitude.
        To sum up, the overall time complexity is O(n * Log⁡k)

        .........................S: O(n)
        We create an array memo of length n + 1.

         */
        //https://leetcode.com/problems/restore-the-array/description/
        int n = str.length();
        Integer[] memo = new Integer[n + 1];
        int ways = restoreArray_Recursive_Memoization_Helper(str, k, 0, memo);
        //output
        System.out.println("Ways to restore the array where elements range between[1, k] : " + ways);
    }

    public void restoreArray_DP_Memoization(String str, int k) {
        /*
        .........................T: O(n * Log⁡k)
        We create memo of length n + 1 for memory, it takes O(n) steps to update them.
        At each step s[start], we look for all possible ending index end. In the
        worst-case scenario, we will iterate over Log⁡k indexes before currNumber
        is larger than k, because each iteration increases currNumber by a magnitude.
        To sum up, the overall time complexity is O(n * Log⁡k)

        .........................S: O(n)
        We create an array memo of length n + 1.

         */
        //https://leetcode.com/problems/restore-the-array/description/
        int mod = 1000000007;
        int n = str.length();
        int[] memo = new int[n + 1];
        memo[0] = 1;

        for (int startIndex = 0; startIndex < n; startIndex++) {
            if (str.charAt(startIndex) == '0') {
                continue;
            }
            for (int endIndex = startIndex; endIndex < n; endIndex++) {

                String arrElement = str.substring(startIndex, endIndex + 1);

                if (Long.parseLong(arrElement) > k) {
                    break;
                }

                memo[endIndex + 1] = (memo[endIndex + 1] + memo[startIndex]) % mod;
            }
        }

        //output
        System.out.println("Ways to restore the array where elements range between[1, k] (DP Memoization): "
                + memo[n]);
    }

    private int waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(
            String nums, int k, int m, int startIndex, int currPartition, Integer[][] memo) {

        int mod = 1000000007;
        int n = nums.length();

        //return 1, only if we have reached the end of our string and no further
        //digit we can pick from nums str also in process till here we should have
        //made currPartiton == k, if currPartition != k return 0
        if (startIndex >= n) {
            return (currPartition == k) ? 1 : 0;
        }

        //one of the requirement is that the partition of string we are making
        //it should start with an even digit, so here if the digit @startIndex
        //of nums str is not even then further in the loop below it will never
        //have first digit as even, return 0 then
        if ((nums.charAt(startIndex) - '0') % 2 != 0) {
            return 0;
        }

        //if cached
        if (memo[startIndex][currPartition] != null) {
            return memo[startIndex][currPartition];
        }

        int ways = 0;

        //generate valid partitons
        for (int endIndex = startIndex; endIndex < n; endIndex++) {

            //currNum is the partiton that will be formed from the nums str
            //[startIndex, endIndex] inclusive
            String currNum = nums.substring(startIndex, endIndex + 1);

            //one of the requiremnet is, the partition that we generating here
            //should have 'atleast' m length (means currNum.length >= m), if its
            //less than m(== currNum.length < m) then continue, add more digits to
            //currNum
            if (currNum.length() < m) {
                continue;
            }

            //one of the requirement is, the partition that we generating here
            //should have a last digit as odd, so here we are checking the same
            //if currNum's last digit (== currNum.length - 1) is not odd then
            //continue, add more digits to currNum
            if ((currNum.charAt(currNum.length() - 1) - '0') % 2 != 1) {
                continue;
            }

            //till here we will generate a partition as 'currNum' that will full
            //fill our requirements, then from here we can try to form another
            //partition from the remaining nums str (== endIndex + 1) and we made
            //valid partition here so for next partition we have (currPartition + 1)
            ways = (ways
                    + waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(
                            nums, k, m, endIndex + 1, currPartition + 1, memo)) % mod;
        }

        return memo[startIndex][currPartition] = ways;
    }

    public void waysToMakeKPartitionStringOfMLength_Recursive_Memoization(String nums, int k, int m) {
        //https://leetcode.com/discuss/interview-question/2257966/Google-OA
        /*
        You are given a string S of lenght N of digits 0 - 9. You need to partiton
        strings into K substrings such that

        1. Each substring has a minimum lenght of M
        2. Substring must start with even digit and ends with odd digit number
        
        Determine the number of ways to partitioin the strings which satisfy the above condition
        You should find answer modulo 1e9 + 7

        constraints :
        1 <= n<= 2x10^3
        1<= m<= n
        1<=k<=n
         */
        int n = nums.length();
        Integer[][] memo = new Integer[n + 1][k + 1];
        int ways = waysToMakeKPartitionStringOfMLength_Recursive_Memoization_Helper(nums, k, m, 0, 0, memo);
        //output
        System.out.println("Ways to make K partiton strings each of length M : " + ways);
    }

    private int combinationSumFour_Recursive_Memoization_Helper(
            int[] nums, int target, int index, Integer[][] memo) {

        int n = nums.length;

        //if we have reached the end of the nums[] from where we can't pick any
        //more values, then we check if our target value becomes exactly 0 or not
        //return 1 if target becomes 0 else 0
        if (index >= n) {
            return target == 0 ? 1 : 0;
        }

        if (memo[index][target] != null) {
            return memo[index][target];
        }

        int ways = 0;

        //two choice we have here,
        //1. don't pick the num @index from nums[] then target will remain same
        //and we will move to next index (== index + 1)
        ways += combinationSumFour_Recursive_Memoization_Helper(nums, target, index + 1, memo);

        //2. pick the num @index and then target will be reduced by nums[index]
        //(== target - nums[index]) also that we can pick number multiple times
        //from the starting of nums[] hence index needs to start from 0 again
        //also to keep in mind, we pick any number @index from nums[] should be
        //less than the target itself because if nums[index] > target then (==
        //target - nums[index] becomes negative but we needs to be in bounds of
        //memo[][]), so always check if(nums[index] <= target)
        if (nums[index] <= target) {
            ways += combinationSumFour_Recursive_Memoization_Helper(
                    nums, target - nums[index], 0, memo);
        }
        return memo[index][target] = ways;
    }

    public void combinationSumFour_Recursive_Memoization(int[] nums, int target) {
        //https://leetcode.com/problems/combination-sum-iv/description/
        int n = nums.length;
        Integer[][] memo = new Integer[n + 1][target + 1];
        //sort the nums[] so that we limit our traversal, means if any nums[index]
        //is greater than target itself then subtracting nums[index] from target
        //(== target - nums[index]) will be negative, avoid this case
        Arrays.sort(nums);
        int ways = combinationSumFour_Recursive_Memoization_Helper(nums, target, 0, memo);
        //output
        System.out.println("Combination sum four : " + ways);
    }

    private int waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
            int startPos, int endPos, int k, Map<String, Integer> memo) {

        int mod = 1000000007;

        //return 0, if we have used all our k steps
        if (k < 0) {
            return 0;
        }

        //if we have used exactly k steps(k == 0) then
        //return 1 only if startPos == endPos else return 0
        if (k == 0) {
            return (startPos == endPos) ? 1 : 0;
        }

        //if cached, Map<String, Integer> is used here because startPos could go
        //-ve which will not fall in bounds of memo[startPos][k]
        String key = startPos + "," + k;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int ways = 0;
        //two choices to make here,

        //1. in one steps (k - 1) we can go left from startPos(== startPos - 1)
        ways = (ways + waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos - 1, endPos, k - 1, memo)) % mod;

        //2. in one steps (k - 1) we can go right from startPos(== startPos + 1)
        ways = (ways + waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos + 1, endPos, k - 1, memo)) % mod;

        memo.put(key, ways);
        return ways;

    }

    public void waysToReachAPositionAfterKSteps_Recursive_Memoization(int startPos, int endPos, int k) {
        //https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/
        Map<String, Integer> memo = new HashMap<>();
        int ways = waysToReachAPositionAfterKSteps_Recursive_Memoization_Helper(
                startPos, endPos, k, memo);
        //output
        System.out.println("Ways to reach from start pos to end post in exactly k steps : " + ways);
    }

    private long solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
            int[][] questions, int index, Long[] memo) {

        int n = questions.length;

        //return 0, if we have solved all the questions from the given array
        if (index >= n) {
            return 0l;
        }

        //if cached
        if (memo[index] != null) {
            return memo[index];
        }

        long maxPoints = 0l;
        //here we have 2 choices to make
        //1. don't pick/ don't solve the curr question @index and simply move to
        //next index (== index + 1) and since we are not solving this curr question
        //then points associated with questions[index][point] will not be considered
        maxPoints = Math.max(maxPoints, solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                questions, index + 1, memo));

        //2. pick/ solve the curr question @index and by solving this curr question,
        //we will consider the points associated with questions[index][point] into
        //our 'maxPoints' and acc to problem statement, we will need to skip the further
        //questions represented as 'barinpower' from questions[index][brainpower]
        //that why, we need to move to index (== index + questions[index][1] + 1)
        //means from curr 'index' skip questions[index][1] and + 1 for the next index
        //that need to solve in the questions[][]
        maxPoints = Math.max(maxPoints,
                questions[index][0] + solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                        questions, index + questions[index][1] + 1, memo));

        return memo[index] = maxPoints;
    }

    public void solvingQuestionsWithBrainPower_Recursive_Memoization(int[][] questions) {
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        int n = questions.length;
        Long[] memo = new Long[n + 1];
        long maxPoints = solvingQuestionsWithBrainPower_Recursive_Memoization_Helper(
                questions, 0, memo);
        //output
        System.out.println("Max points obtained by solving questions : " + maxPoints);
    }

    public void solvingQuestionsWithBrainPower_DP_Memoization(int[][] questions) {
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        //explanation: https://youtu.be/D7TD_ArkfkA
        //iterative BOTTOM-UP DP approach for recursive memoization
        /*
        the iterative loop has to start from last index (n - 1) why?
        as per the problem if we start from starting index then we need to
        skip next 'brainpower' amount of questions (== i + 'brainpower')
        
        benifit of starting from last index and having hashmap is that whenever
        we are calculating (i + 'brainpower' + 1) or (i + 1) for skipped questions
        we can easily do getOrDefault() and save from out-of-bounds on skipped
        questions[][] index
         */
        int n = questions.length;
        Map<Integer, Long> maxPointsMemo = new HashMap<>();
        for (int index = n - 1; index >= 0; index--) {

            Long maxPoints = Math.max(
                    //don't pick /don't solve question at curr @index then we 
                    //get the max points calculated at
                    //(index + 1, if this next index is out of bounds then 0)
                    maxPointsMemo.getOrDefault(index + 1, 0l),
                    //pick /solve question at curr @index then we have to consider
                    //the max points given by questions[index][points] and have to
                    //get the max points calculated at index
                    //(index + questions[index][brainpower] + 1, if this next index is out of bounds then 0)
                    questions[index][0] + maxPointsMemo.getOrDefault(index + questions[index][1] + 1, 0l));

            maxPointsMemo.put(index, maxPoints);
        }
        //output
        //after solving questions from (n - 1) back to 0-index, our maxPoints will
        //be stored at 0-th index
        System.out.println("Max points obtained by solving questions (DP Memoization): " + maxPointsMemo.get(0));
    }

    private int countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
            int low, int high, int zero, int one, int currLength, Integer[] memo) {

        int mod = 1000000007;

        //return 0, as we don't want to consider strings with
        //'currLength' greater than high value
        if (currLength > high) {
            return 0;
        }

        if (memo[currLength] != null) {
            return memo[currLength];
        }

        //as per requirement, the ideal good string should have a min length of
        //'low' hence if currLength >= low we must consider the curr string with
        //length as 'currLength'
        int countGoodStrings = currLength >= low ? 1 : 0;

        //add up the string counts if we only append 'zero' in our string with 'currLength' 
        countGoodStrings = (countGoodStrings
                + countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                        low, high, zero, one, currLength + zero, memo)) % mod;

        //add up the string counts if we only append 'one' in our string with 'currLength' 
        countGoodStrings = (countGoodStrings
                + countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                        low, high, zero, one, currLength + one, memo)) % mod;

        return memo[currLength] = countGoodStrings;
    }

    public void countWaysToBuildGoodStrings_Recursive_Memoization(int low, int high, int zero, int one) {
        //...................T: O(high)
        //...................S: O(high + 1)
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        //explanation: https://youtu.be/G-i4CveBSYI | https://youtu.be/JKpVHG2mhbk
        /*
        take an example: low = 2, high = 3, zero = 1, one = 2
        acc to question, we must count good strings having lengths in range [low, high]
        inclusive
        
        ==> starting from empty string "" with len = 0
        
        ==> each time we decide to either append "1" or "0"
        if we decide to append "1" in curr string, we need to append "1" given 'one' times
        and same if we decide to append "0" to curr string, we need to append "0" given 'zero' times
        
        ==> every time we append "1" or "0", we are only considering its lengths
        from empty string "" having length = 0, we form two string "11" with length = 2 & "0" with length = 1
        
        ==> at level 5, see with appending "1" we form a string "1111" with length = 4 that is greater than
        given 'high' value so we won't move further after that (hence our tree can go at max to depth of 'high')
        also to note, in any append operation if our string length becomes greater or equal 'low' that is our
        valid string that should be considered (hence countGoodStrings = currLength >= low ? 1 : 0)
        
        ==> observe a thing we started of appending "1" or "0" hence each time a string created further in tree
        will be unique string, how? because from starting empty string "" it is the first char itself that will
        make the distinction see:
        "" append("1") ==> "11" first char == 1
        "" append("0") ==> "0" first char == 0
        and further in tree this distinction will make it unique,
        only thing that is common in the tree is the repetition of length 'len'
        see, len = 2 is seen twice in tree & len = 3 also appearing twice hence the length itself is a
        SUB PROBLEM
        
        ==> if we memoise on the lengths, memo['length'] we will save these repeatitive length calculation
        hence this reduce the time complexity from O(2^high) to just O(high) as we will be checking a length
        atmost once and other time we will just get it from memo['length']
        
        
        1........................................."", len = 0
        .................................../.............\
        2..........................."1"(2)/.................\"0"(1)
        .............................../........................\
        3................."11",len = 2........................len = 1, "0"
        .............................../..................................\
        4...................."1"(2)/.......\"0"(1).............."1"(2)/........\"0"(1)
        ......................../.............\..................../..............\
        5..........."1111", len = 4......"110",len = 3........"011",len = 3.........len = 2,"00"
        
         */
        Integer[] memo = new Integer[high + 1];
        int countGoodString = countWaysToBuildGoodStrings_Recursive_Memoization_Helper(
                low, high, zero, one,
                //since we are starting from an empty string("") that will have
                //length == 0
                0, memo);
        //output
        System.out.println("Count ways to build good strings : " + countGoodString);
    }

    public void countWaysToBuildGoodStrings_DP_Memoization(int low, int high, int zero, int one) {
        //...................T: O(high)
        //...................S: O(high + 1)
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        //explanation: https://youtu.be/G-i4CveBSYI | https://youtu.be/JKpVHG2mhbk
        int mod = 1000000007;
        Map<Integer, Integer> memo = new HashMap<>();
        //as per question, a string with length == 0 can be considered as good string
        //so its count is 1
        memo.put(0, 1);

        int countGoodString = 0;

        for (int length = 1; length <= high; length++) {

            int count = 0;
            count = (count + memo.getOrDefault(length - zero, 0)) % mod;
            count = (count + memo.getOrDefault(length - one, 0)) % mod;

            memo.put(length, count);

            if (length >= low && length <= high) {
                countGoodString = (countGoodString + memo.get(length)) % mod;
            }
        }

        //output
        System.out.println("Count ways to build good strings (DP memoization): " + countGoodString);
    }

    private int sortIntegersByPowerValue_Recursive_Memoization_GetPower(
            int num, Map<Integer, Integer> numPowerMemo) {

        if (numPowerMemo.containsKey(num)) {
            return numPowerMemo.get(num);
        }
        //base cond, as we need to reach 1, the power of 1 will remain 0
        //if X = 1 and goal = 1 then acc to question power of X = 0 
        if (num == 1) {
            numPowerMemo.put(num, 0);
        } else if (num % 2 == 0) {
            //if curr num is even then add +1 to reach to curr num + steps to cover (num / 2)
            //until this num == 1
            numPowerMemo.put(num, 1 + sortIntegersByPowerValue_Recursive_Memoization_GetPower(
                    num / 2, numPowerMemo));
        } else {
            //if curr num is odd then add +1 to reach to curr num + steps to cover (3 * num + 1)
            //until this num == 1
            numPowerMemo.put(num, 1 + sortIntegersByPowerValue_Recursive_Memoization_GetPower(
                    3 * num + 1, numPowerMemo));
        }

        //return the power calculated in recursive call for our initial num == X
        return numPowerMemo.get(num);
    }

    public void sortIntegersByPowerValue_Recursive_Memoization(int low, int high, int k) {
        //https://leetcode.com/problems/sort-integers-by-the-power-value/description/
        //map is used here because as per the calucations based on even or odd num
        //the 'num' value can go beyond the given constraint (1 <= lo <= hi <= 1000)
        Map<Integer, Integer> numPowerMemo = new HashMap<>();
        List<int[]> saveNumToPower = new ArrayList<>();
        for (int num = low; num <= high; num++) {
            saveNumToPower.add(new int[]{
                num,
                sortIntegersByPowerValue_Recursive_Memoization_GetPower(num, numPowerMemo)});
        }

        //sort all the num to power list to get k-th num
        //if the power of the nums are same then sort the nums in incr order else
        //sort the power in incr order
        Collections.sort(saveNumToPower, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);
        //output
        int numAtK = saveNumToPower.get(k - 1)[0];
        System.out.println("K-th num in sorted integer by power value : " + numAtK);
    }

    private int maxScoreOfNOperations_Recursive_Memoization_GetGCD(int a, int b) {
        //function to calculate GCD of two num
        if (b == 0) {
            return a;
        }
        return maxScoreOfNOperations_Recursive_Memoization_GetGCD(b, a % b);
    }

    private int maxScoreOfNOperations_Recursive_Memoization_Helper(
            int[] nums, int maxOprn, int currOprn, boolean[] picked, Map<String, Integer> memo) {

        int n = nums.length;

        //as the array given is 2 * n but we only need to perform n oprn
        //our maxOprn == n and if currOprn > maxOprn return 0
        if (currOprn > maxOprn) {
            return 0;
        }

        //if cached
        //here our picked[] is itself our key how?
        //as we are picking (i, j) pair and mark it in the picked[], there are
        //sub-problems in recursion tree where the same state of picked[] is seen
        //repeating in diff branches
        String key = Arrays.toString(picked);
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        int maxScore = 0;

        //the below nested for loops will generate the possible pairs of n num[]
        //as per the requirement, if we pick a pair let say (nums[i], nums[j]) at
        //index (i, j) these pairs then can't be picked in the further recursions
        //hence we are using the picked[] boolean array, this helps in maintaining
        //marking those indexes both (i, j) as picked == true so that in recursion
        //we can 'continue' if we see the same (i, j) pair in loops
        for (int i = 0; i < n; i++) {

            //skip, the i-th index or nums[i] because it is already picked == true
            //in the previous recursion call
            if (picked[i]) {
                continue;
            }

            //if the i-th index or nums[i], was not picked in previous recursion
            //call stacks, mark it as picked here
            picked[i] = true;

            //now since we are picking nums[i] as first part of our pair (nums[i], 'second')
            //then using j loop, we will generate all possible j-th or nums[j] value as
            //'second' part of our pair
            for (int j = i + 1; j < n; j++) {

                //skip, the j-th index or nums[j] because it is already picked == true
                //in the previous recursion call
                if (picked[j]) {
                    continue;
                }

                //if the j-th index or nums[j], was not picked in previous recursion
                //call stacks, mark it as picked here
                picked[j] = true;

                //calculate the GCD of nums[i] & nums[j]
                int currPairGCD = maxScoreOfNOperations_Recursive_Memoization_GetGCD(nums[i], nums[j]);
                //as per question, need to calculate the curr pair score i.e, (oprn * gcd(nums[i], nums[j]))
                int currPairScore = currOprn * currPairGCD;
                //now, we are currently considering nums[i] & nums[j] as picked pairs
                //then we need to move further in recursion to pick remaining pairs,
                //in 'remainingPairScore' we will get the possible maxScore from their
                //respective recursion call stacks.
                //also, we performed 1 oprn here, further we need to perform (currOprn + 1) oprns
                int remainingPairScore = maxScoreOfNOperations_Recursive_Memoization_Helper(
                        nums, maxOprn, currOprn + 1, picked, memo);

                //calculate the maxScore from currPairScore + remainingPairScore
                maxScore = Math.max(maxScore, currPairScore + remainingPairScore);

                //once we are done j-th or nums[j] value as pair with nums[i], we
                //can move to next j-th index or nums[j] to check the next possible
                //maxScore, but this curr j-th index or nums[j] can be used in
                //remaining so mark as false again
                picked[j] = false;

            }

            //once we are done i-th or nums[i] value, we can move to next i-th
            //index or nums[i] to check the next possible maxScore
            picked[i] = false;
        }

        memo.put(key, maxScore);
        return maxScore;
    }

    public void maxScoreOfNOperations_Recursive_Memoization(int[] nums) {
        //https://leetcode.com/problems/maximize-score-after-n-operations/description/
        //explanation: https://youtu.be/CTYIzzT9agE 
        //this algo is highly time costly, commenting its method calls from main()
        int n = nums.length;
        int maxOprn = n / 2;
        boolean[] picked = new boolean[n];
        Map<String, Integer> memo = new HashMap<>();
        int maxScore = maxScoreOfNOperations_Recursive_Memoization_Helper(nums, maxOprn, 1, picked, memo);
        //output
        System.out.println("max score of N oprations : " + maxScore);
    }

    private int numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
            int[][] grid, int k, int row, int col, int currPathSum, Integer[][][] memo) {

        int ROW = grid.length;
        int COL = grid[0].length;
        int mod = 1000000007;

        //return 0, if the curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        if (row == ROW - 1 && col == COL - 1) {
            //adding the last grid value (==> grid[ROW - 1][COL - 1]) to our
            //currPathSum (==> remainder to be said) if that is still divisible
            //by k or not
            //return 1, if divisible else 0
            return (currPathSum + grid[row][col]) % k == 0 ? 1 : 0;
        }

        //if cached, here the overlapping subproblem occurs when we reach a particular
        //row & col and we see a same path-sum till that (row, col), keep in mind that
        //if we follow any path in grid, this state (row, col, currPathSum) may be
        //repeating in mutiple branches, so cache this state
        if (memo[row][col][currPathSum] != null) {
            return memo[row][col][currPathSum];
        }

        int ways = 0;

        //as we can only make two movements in the grid[][] that is,
        //move to right ==> col + 1 or move down ==> row + 1
        //each of the path we are going in we must add that grid[row][col] value
        //in our currPathSum BUT this path sum can become very large as we reach
        //our dest position (ROW - 1, COL - 1) so here is the thought, we don't
        //actually care about the curr-path-sum as we reach our dest position
        //we only need one thing from this path sum and that is whether this
        //curr-path-sum is divisible by k or not, so every time we move into a 
        //recursive call, we will add the remainder of the currPathSum % k because
        //if we add values to remainders in the path we follow, that also will give
        //the same information at the dest position.
        ways = (ways
                + numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                        grid, k, row + 1, col,
                        //passing the currPathSum + curr-grid-value remainder with k
                        (currPathSum + grid[row][col]) % k, memo)) % mod;

        ways = (ways
                + numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                        grid, k, row, col + 1,
                        //passing the currPathSum + curr-grid-value remainder with k
                        (currPathSum + grid[row][col]) % k, memo)) % mod;

        return memo[row][col][currPathSum] = ways;
    }

    public void numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(int[][] grid, int k) {
        //https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        //in our recursive calls we will be calculating currPathSum remainders
        //(currPathSum % k) and not the path-sum to be exact so our remainder of
        //path-sum becomes third changing parameter
        Integer[][][] memo = new Integer[ROW][COL][k + 1];

        int ways = numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization_Helper(
                grid, k, 0, 0, 0, memo);
        //output
        System.out.println("Number of paths in grid whose sum is divisible by k : " + ways);
    }

    private int numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
            int[][] types, int target, int typeIndex, Integer[][] memo) {

        int n = types.length;
        int mod = 1000000007;

        //we have reached end of types[][] and further we can't choose any more
        //questions, now if our target is 0 return 1 as there is atleast 1 way
        //else return 0
        if (typeIndex >= n) {
            return target == 0 ? 1 : 0;
        }

        //if cached
        if (memo[typeIndex][target] != null) {
            return memo[typeIndex][target];
        }

        int ways = 0;

        //2 choices we have,
        //1. don't pick the questions of the curr type @typeIndex and simply move
        //to next type (==> typeIndex + 1) and since we haven't solved any question
        //of curr type we will not consider a single point from this question type
        ways = (ways
                + numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
                        types, target, typeIndex + 1, memo)) % mod;

        //2. pick the questions form the curr type @typeIndex, so if we are picking
        //then we can decide how many questions we can do from the curr 'type', if
        //we do 'x' amount of question from curr 'type' then we can earn x * points
        //from those questions and if we have earned (x * points) then we can reduce
        //our target points by (x * points).
        //Also to note: if we have solved 'x' questions from curr 'type' then we
        //can also move to next type (==> typeIndex + 1) to solve the remaining
        //questions and earn remaining points from those 'type'
        //questionsCount = max amount of questions we can solve of curr 'type'
        int questionsCount = types[typeIndex][0];
        //questionPoint = point earn for each questions solved of 'type'
        int questionPoint = types[typeIndex][1];
        //pointsEarned = points accuired by solving 'x' questions of 'type'
        //==> x * questionPoint
        int pointsEarned = 0;

        for (int question = 1; question <= questionsCount; question++) {
            //pointsEarned = question * questionPoint
            pointsEarned = question * questionPoint;
            //break, if we have earned more points than curr target
            if (pointsEarned > target) {
                break;
            }
            //currently we have solved 'question' out of questionsCount and the
            //remaining questions we choose from next type(==> typeIndex + 1)
            //but we have earned 'pointsEarned' points by solving 'question'
            //so reduce the target with this much pointsEarned
            ways = (ways
                    + numberOfWaysToEarnPoints_Recursive_Memoization_Helper(
                            types, target - pointsEarned, typeIndex + 1, memo)) % mod;
        }

        return memo[typeIndex][target] = ways;
    }

    public void numberOfWaysToEarnPoints_Recursive_Memoization(int[][] types, int target) {
        //https://leetcode.com/problems/number-of-ways-to-earn-points/description/
        //based on pattern of maxValueFromKCoinsFromPiles_Recursive_Memoization()
        int n = types.length;
        Integer[][] memo = new Integer[n + 1][target + 1];
        int ways = numberOfWaysToEarnPoints_Recursive_Memoization_Helper(types, target, 0, memo);
        //output
        System.out.println("Number of ways to earn points : " + ways);
    }

    private int stoneGameTwo_Recursive_Memoization_Helper(
            int[] piles, boolean isAlice, int index, int M, Integer[][][] memo) {

        int n = piles.length;

        //return alice score as 0 because we are at the end of our piles[] and further
        //we can't pick any pile from the piles[]
        if (index >= n) {
            return 0;
        }

        //if cached
        if (memo[isAlice ? 0 : 1][index][M] != null) {
            return memo[isAlice ? 0 : 1][index][M];
        }

        //we are simulating both alice and bob turns as players of this game
        //our main aim is to maximise alice's score, or as bob is playing against
        //alice so will bob try to minimize alice's score in both the cases bob's
        //own score doesn't matter. Only thing matter here is how alice is trying
        //to max her score and how bob is trying to min alice's score(in his turn)
        //here if currently its alice's turn (isAlice == true) then in order to
        //max her score we take a min default value(==> -1) and vice versa if its
        //bob's turn then in order to min alice score it will have max default value
        int aliceScore = isAlice ? -1 : 1000000;
        //each time we decide to pick X-th pile we will add the piles value
        int pilesTakenScore = 0;

        //as per questions, our piles picking range for both alice and bob is bounded
        //1 <= X <= 2 * M
        //here X is starting from 1 to 2 * M, but our piles index starts from 0
        //so we need to offset our index to pick the correct pile value for the
        //current player
        //ex: index = 0, X = 1, then we should pick 0-th index index + X - 1
        //add an offset of -1 == index + X - 1 ==> 0 + 1 - 1 = 0
        for (int X = 1; X <= Math.min(2 * M, n - index); X++) {

            //pick the curr piles, simulating picking X-th piles from our bounded
            //range[1 <= X <= 2 * M]
            pilesTakenScore += piles[index + X - 1];

            //currently its alice's turn, so alice will try to max her score
            if (isAlice) {
                aliceScore = Math.max(aliceScore,
                        pilesTakenScore + stoneGameTwo_Recursive_Memoization_Helper(
                                piles, false, index + X, Math.max(M, X), memo));
            } else {
                //currently its bob's turn, here we don't really need to calculate
                //bob's score but bob will try to minimize alice score, so here
                //we don't need to consider 'pilesTakenScore' for bob
                aliceScore = Math.min(aliceScore,
                        stoneGameTwo_Recursive_Memoization_Helper(
                                piles, true, index + X, Math.max(M, X), memo));
            }
        }
        return memo[isAlice ? 0 : 1][index][M] = aliceScore;
    }

    public void stoneGameTwo_Recursive_Memoization(int[] piles) {
        //https://leetcode.com/problems/stone-game-ii/description/
        //explanation: https://youtu.be/9f1vzDFVnGA | https://youtu.be/I-z-u0zfQtg
        int n = piles.length;
        Integer[][][] memo = new Integer[2][n + 1][n + 1];
        int maxAliceScore = stoneGameTwo_Recursive_Memoization_Helper(piles, true, 0, 1, memo);
        //output
        System.out.println("Stone game two (alice max score) : " + maxAliceScore);
    }

    private int stoneGameThree_Recursive_Memoization_Helper(int[] stoneValue, int index, Integer[] memo) {

        int n = stoneValue.length;

        if (index >= n) {
            return 0;
        }

        if (memo[index] != null) {
            return memo[index];
        }

        int currWinner = Integer.MIN_VALUE;

        int stoneTaken = 0;

        for (int X = 1; X <= Math.min(3, n - index); X++) {
            stoneTaken += stoneValue[index + X - 1];
            currWinner = Math.max(currWinner,
                    stoneTaken - stoneGameThree_Recursive_Memoization_Helper(
                            stoneValue, index + X, memo));
        }

        return currWinner;
    }

    public void stoneGameThree_Recursive_Memoization(int[] stoneValue) {
        //https://leetcode.com/problems/stone-game-iii/description/
        //explanation: https://youtu.be/KI8suf35r38 | https://youtu.be/HsLG5QW9CFQ
        int n = stoneValue.length;
        Integer[] memo = new Integer[n];
        int winner = stoneGameThree_Recursive_Memoization_Helper(stoneValue, 0, memo);
        //output
        System.out.println("Stone game three (winner name) : "
                + (winner == 0 ? "Tie" : (winner > 0 ? "Alice" : "Bob")));
    }

    public void stoneGameThree_DP_Memoization(int[] stoneValue) {
        //https://leetcode.com/problems/stone-game-iii/description/
        //explanation: https://youtu.be/KI8suf35r38 | https://youtu.be/HsLG5QW9CFQ
        int n = stoneValue.length;
        int[] memo = new int[n + 1];
        //same as recursive method's currWinner == INT_MIN
        Arrays.fill(memo, Integer.MIN_VALUE);
        //same as recursive base cond
        memo[n] = 0;

        for (int index = n - 1; index >= 0; index--) {

            int stoneTaken = 0;

            for (int X = 1; X <= Math.min(3, n - index); X++) {

                stoneTaken += stoneValue[index + X - 1];
                memo[index] = Math.max(memo[index], stoneTaken - memo[index + X]);
            }
        }
        //output
        int winner = memo[0];
        System.out.println("Stone game three (winner name) (DP Memoization) : "
                + (winner == 0 ? "Tie" : (winner > 0 ? "Alice" : "Bob")));
    }

    private int minCostToCutStick_Recursive_Memoization_Helper(
            int[] cuts, int start, int end, Map<String, Integer> memo) {

        int cutLength = cuts.length;

        //rather having a proper 'length' as a parameter we maintain a range
        //which will tell the length of the segments (end - start)
        int currSegmentLength = (end - start);

        //we can make make profit/reduce cost by making cuts on the
        //given segment having some length as 'length'(==> (end - start))
        //now think it this way, a segment length of 1 can't be further
        //divided so if we can't make cuts then our cost to make cut becomes 0,
        //hence return 0
        if (currSegmentLength == 1) {
            return 0;
        }

        //Map is more memory optimized as compared to 2D memo array
        //due to large 'n' size
        String key = start + "," + end;
        if (memo.containsKey(key)) {
            return memo.get(key);
        }

        //our aim is to minimize our cost on making cuts, hence
        //the initial value should be a INT_MAX value, but also
        //to keep in mind that we might come accros a situation
        //where a cut is not possible on the curr segment length
        //in that case minCost should then be 0
        int minCost = Integer.MAX_VALUE;

        //any cut can be made in any order, hence to try all possibilties, loop
        //for all the cuts that we have every time for every cut segments but
        //maintain the check that this cuts[i] is valid cut on the cut segment(start, end)
        //where start or end will tell starting or ending of that segment
        //if a cuts[i] is made on segment(start, end) then this cuts[i]
        //will create two different cut segement that might have diff lengths
        //where cuts[i] becomes ending of the first cut segment AND starting
        //of the second cut segment
        //ex: initial segment length = 7 i.e, [start, end] = [0, 7]
        //assume we made a cuts[i] = 3, it will create two segments now
        //first cut segment = [start, cuts[i]] = [0, 3]
        //second cut segment = [cuts[i], end] = [3, 7]
        for (int index = 0; index < cutLength; index++) {

            //any cut of cuts[i] can only be made on a cut segment of length
            //'length' ==> (end - start) if this cuts[i] lie within the range
            //of (start, end) both non-inclusive
            //ex: a cut segment length = 3 ==> (start, end) = (2, 5)
            //and a cuts[i] = 1 then its not possible to make this cut
            //in-between the curr cut segment
            //so we need to check if a cut of cuts[i] falls within the range
            //of the cut segment length
            if (cuts[index] > start && cuts[index] < end) {

                //take the min cost of making cuts
                minCost = Math.min(minCost,
                        //cost as curr cut segment length
                        //+ cost in making further cuts on first cut segment (start, cuts[index])
                        //+ cost in making further cuts on second cut segment (cuts[index], end)
                        currSegmentLength
                        + minCostToCutStick_Recursive_Memoization_Helper(cuts, start, cuts[index], memo)
                        + minCostToCutStick_Recursive_Memoization_Helper(cuts, cuts[index], end, memo));
            }
        }

        //as mentioned, if any cuts is not possible then minCost should be returned 0
        minCost = minCost == Integer.MAX_VALUE ? 0 : minCost;

        memo.put(key, minCost);

        return minCost;
    }

    public void minCostToCutStick_Recursive_Memoization(int segment, int[] cuts) {
        //https://leetcode.com/problems/minimum-cost-to-cut-a-stick/description/
        //explanation: https://youtu.be/EVxTO5I0d7w
        //in this quest, Map is more memory optimized as compared to the use of
        //2D memo[segment + 1][segment + 1] array due to large value of 'segment'
        Map<String, Integer> memo = new HashMap<>();
        int minCost = minCostToCutStick_Recursive_Memoization_Helper(cuts, 0, segment, memo);
        //output
        System.out.println("Min cost to cut stick : " + minCost);
    }

    public void nMeetingRooms_Greedy(int[] startTime, int[] finishTime) {

        int n = startTime.length;

        int[][] input = new int[n][3];

        for (int i = 0; i < n; i++) {
            input[i][0] = startTime[i];
            input[i][1] = finishTime[i];
            input[i][2] = i;
        }

        //sort the input in incr order of finishTime i.e, input[i][1]
        Arrays.sort(input, (a, b) -> a[1] - b[1]);

        int meetingsCanBeConducted = 1; //at least one meeting can be held
        List<Integer> indexOfMeetingTimings = new ArrayList<>();
        indexOfMeetingTimings.add(input[0][2] + 1); // 1 based index
        int prevEndTime = input[0][1];
        for (int i = 1; i < n; i++) {

            int currStartTime = input[i][0];
            int currEndTime = input[i][1];

            if (prevEndTime < currStartTime) {
                meetingsCanBeConducted++;
                prevEndTime = currEndTime;
                indexOfMeetingTimings.add(input[i][2] + 1);
            }
        }

        System.out.println("No. of meetings can be conducted: " + meetingsCanBeConducted);
        System.out.println("Index of meetings can be conducted: " + indexOfMeetingTimings);
    }

    public void pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(int[] movieLength, int K) {

        //prepare index wise data
        int[][] input = new int[movieLength.length][2];
        for (int i = 0; i < movieLength.length; i++) {
            input[i][0] = movieLength[i];
            input[i][1] = i;
        }

        //sort the input
        Arrays.sort(input, new Comparator<int[]>() {

            @Override
            public int compare(int[] a, int[] b) {
                //0th index holds movieLength and sortng asc on basis of that
                //shortest movie length first
                return a[0] - b[0];
            }
        });

        int n = movieLength.length;
        int start = 0;
        int end = n - 1;
        int i = 0;
        int j = 0;
        int sum = 0;
        while (end > start) {

            int firstMovie = input[start][0];
            int secondMovie = input[end][0];

            if (firstMovie + secondMovie <= K) {

                if (sum < firstMovie + secondMovie) {
                    sum = firstMovie + secondMovie;
                    i = input[start][1];
                    j = input[end][1];
                }
                start++;
            } else if (firstMovie + secondMovie > K) {
                end--;
            }
        }

        //output:
        System.out.println("Pair of movies can be watched during flight duration K: "
                + (i + "," + j) + "-"
                + (movieLength[i] + "," + movieLength[j]));
    }

    public int choclateDistribution_Greedy(int[] choclates, int students) {

        //.........................T: O(N.LogN)
        //https://www.geeksforgeeks.org/chocolate-distribution-problem/
        //if no choclates are there OR there are no student available for distribution
        if (choclates.length == 0 || students == 0) {
            return 0;
        }

        //if the no. of choclates is less than the no. of student
        if (choclates.length < students) {
            return -1;
        }

        //sort the no of choclates
        Arrays.sort(choclates);

        int minDiff = Integer.MAX_VALUE;
        for (int i = 0; i + students - 1 < choclates.length; i++) {
            int currDiff = choclates[i + students - 1] - choclates[i];
            minDiff = Math.min(minDiff, currDiff);
        }

        //output:
        return minDiff;
    }

    public void minimumPlatformNeeded_BruteForce(int[] arr, int[] dep) {

        //.......................T: O(N^2)
        int n = arr.length;

        int maxPlatform = 1;
        for (int i = 0; i < n; i++) {
            int currPlatform = 1;
            for (int j = i + 1; j < n; j++) {
                if ((arr[i] >= arr[j] && arr[i] <= dep[j])
                        || (arr[j] >= arr[i] && arr[j] <= dep[i])) {
                    currPlatform++;
                }
                maxPlatform = Math.max(maxPlatform, currPlatform);
            }
        }

        //output:
        System.out.println("max platfrm needed: " + maxPlatform);
    }

    public void minimumPlatformNeeded_Greedy(int[] arrival, int[] depart) {

        //.......................T: O(N.LogN)
        int n = arrival.length;

        //.................T: O(N.LogN)
        Arrays.sort(arrival);
        Arrays.sort(depart);

        int arrivalIndex = 1;
        int departIndex = 0;
        int maxPlatform = 1;
        int currPlatform = 1;

        while (arrivalIndex < n && departIndex < n) {

            if (arrival[arrivalIndex] <= depart[departIndex]) {
                currPlatform++;
                arrivalIndex++;
            } else if (arrival[arrivalIndex] > depart[departIndex]) {
                currPlatform--;
                departIndex++;
            }

            maxPlatform = Math.max(maxPlatform, currPlatform);
        }

        //output:
        System.out.println("max platform needed: " + maxPlatform);
    }

    public void fractionalKnapsack(int[] weight, int[] value, int W) {

        int n = weight.length;

        //prepare data
        double[][] input = new double[n][3];
        //0: weight, 1: value, 2: costPerWeight
        for (int i = 0; i < n; i++) {

            input[i][0] = weight[i];
            input[i][1] = value[i];
            input[i][2] = (double) value[i] / (double) weight[i];
        }

        //sort the input on basis of costPerWeight desc
        Arrays.sort(input, (a, b) -> (int) (b[2] - a[2])); //2: costPerWeight

        double maxValue = 0;
        for (int i = 0; i < n; i++) {

            int currWeight = (int) input[i][0];
            int currValue = (int) input[i][1];

            if (W - currWeight >= 0) {
                W -= currWeight;
                maxValue += currValue;
            } else {

                //if we can't pick up an item as whole
                //we will calculate the fraction we can pick up
                //i.e W/currWeight
                double frac = (double) W / currWeight;
                //value per frac
                maxValue += (currValue * frac);
                //estimating balanced capacity
                W = (int) (W - (currWeight * frac));
            }
        }

        //output:
        System.out.println("Max value can be picked up by fractional knapsack: " + maxValue);
    }

    public void swapTwoDigitAtMostToFormAGreaterNumber_Greedy(int num) {

        //https://leetcode.com/problems/maximum-swap/
        char[] digit = String.valueOf(num).toCharArray();
        int[] index = new int[10];
        for (int i = 0; i < digit.length; i++) {
            index[digit[i] - '0'] = i;
        }

        for (int i = 0; i < digit.length; i++) {
            for (int d = 9; d > digit[i] - '0'; d--) {
                if (index[d] > i) {
                    char temp = digit[i];
                    digit[i] = digit[index[d]];
                    digit[index[d]] = temp;
                    System.out.println("Greater number after 2 digit swaps atmost: " + Integer.parseInt(String.valueOf(digit)));
                    return;
                }
            }
        }

        //output
        System.out.println("Greater number after 2 digit swaps atmost: " + num);
    }

    public void singleThreadedCPU_Greedy(int[][] tasks) {
        //https://leetcode.com/problems/single-threaded-cpu/
        //explanation: https://youtu.be/RR1n-d4oYqE

        class Task {

            int startTime;
            int processingTime;
            int taskIndex;

            public Task(int startTime, int processingTime, int taskIndex) {
                this.startTime = startTime;
                this.processingTime = processingTime;
                this.taskIndex = taskIndex;
            }
        }

        int n = tasks.length;
        int[] result = new int[n];
        List<Task> tasksList = new ArrayList<>();
        //cpu task waiting queue based on which smallest processing time
        //task can be picked up
        PriorityQueue<Task> minHeap = new PriorityQueue<>(
                (a, b) -> a.processingTime == b.processingTime
                        ? a.taskIndex - b.taskIndex
                        : a.processingTime - b.processingTime);

        for (int i = 0; i < n; i++) {
            int startTime = tasks[i][0];
            int processingTime = tasks[i][1];
            int taskIndex = i;
            tasksList.add(new Task(startTime, processingTime, taskIndex));
        }

        Collections.sort(tasksList, (a, b) -> a.startTime - b.startTime);

        int resIndex = 0;
        int i = 0;
        //since our tasks are sorted by startTime, cpu will pick up the
        //task that is coming first acc to startTime and cpu will be
        //booked for this curr task initially
        int cpuBookedTime = tasksList.get(0).startTime;

        while (resIndex < n) {
            //since my cpu is already booked until cpuBookedTime
            //that means cpu will process the current task until this cpuBookedTime
            //so all the task that cpu will not be able to take because being busy
            //will go to cpu task waiting queue, where it will be sorted acc to
            //processingTime and taskIndex
            while (i < n && tasksList.get(i).startTime <= cpuBookedTime) {
                minHeap.add(tasksList.get(i));
                i++;
            }

            //cpu task waiting queue is empty that means, cpu is idle
            //we can directly assign the curr i-th task to cpu coming at
            //startTime
            if (minHeap.isEmpty()) {
                cpuBookedTime = tasksList.get(i).startTime;
                continue;
            }

            //if the cpu is not idle, we pick the optimal task from waiting queue,
            //simulate, cpuBookedTime by adding currTask processingTime added to it
            //that would mean whatever the task cpu is processing right now, after
            //finishing that assign the currTask to it. In that order we take taskIndex
            Task currTask = minHeap.poll();
            cpuBookedTime += currTask.processingTime;
            result[resIndex++] = currTask.taskIndex;
        }

        //output
        System.out.println("Order of tasks in which tasks can be consumed:");
        Arrays.stream(result).boxed().forEach(x -> System.out.print(x + " "));
        System.out.println();
    }

    public void minimumArrowsToBurstBalloons_Greedy(int[][] balloonPoints) {
        //https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
        //sort on balloon end point
        Arrays.sort(balloonPoints, (a, b) -> Integer.compare(a[1], b[1]));
        int prevEnd = balloonPoints[0][1];
        int n = balloonPoints.length;
        int minArrow = 1;
        for (int i = 0; i < n; i++) {
            int currStart = balloonPoints[i][0];
            int currEnd = balloonPoints[i][1];
            //curr start should be strictly greater than the prev end
            //that way we know we need extra arrows to burst these curr ballons
            //otherwise all the curr start that lesser than prev end falls under 
            //the range of single arrow shot.
            if (currStart > prevEnd) {
                minArrow++;
                prevEnd = currEnd;
            }
        }
        //output
        System.out.println("Minimum arrows required to burst all balloon: " + minArrow);
    }

    public void partitionArrSuchThatMaxDiffIsK_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/
        int n = nums.length;
        Arrays.sort(nums);
        int partition = 1;
        int prevIndex = 0;

        for (int i = 1; i < n; i++) {
            int currDiffInMaxAndMinVals = nums[i] - nums[prevIndex];
            if (currDiffInMaxAndMinVals > k) {
                partition++;
                prevIndex = i;
            }
        }
        //output
        System.out.println("Partitions : " + partition);
    }

    public void efficientJanitor_Greedy(double[] arr) {
        //https://leetcode.com/problems/boats-to-save-people/
        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
        //TWO POINTER approach 1
        /*
         ex: {1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7}
         Output: 5 groups: (1.01 , 1.99), (1.01, 1.7), (3.0), (2.7), (2.3)
         */
        int n = arr.length;
        int start = 0;
        int end = n - 1;

        int groups = 0;
        Arrays.sort(arr);

        while (end >= start) {

            if (end == start) {
                groups++;
                break;
            } else if (arr[start] + arr[end] <= 3.0) {
                start++;
                end--;
                groups++;
            } else {
                end--;
                groups++;
            }
        }

        //output
        System.out.println("Groups of item with sum at most 3(approach 1): " + groups);
    }

    public void efficientJanitor2_Greedy(double[] arr) {
        //https://leetcode.com/problems/boats-to-save-people/
        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
        //TWO POINTER approach 2
        /*
         ex: {1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7}
         Output: 5 groups: (1.01 , 1.99), (1.01, 1.7), (3.0), (2.7), (2.3)
         */
        int n = arr.length;
        int start = 0;
        int end = n - 1;

        int groups = 0;
        Arrays.sort(arr);

        while (end >= start) {
            groups++;
            if (arr[start] + arr[end] <= 3.0) {
                start++;
            }
            end--;
        }

        //output
        System.out.println("Groups of item with sum at most 3(approach 2): " + groups);
    }

    public int farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(
            int[] heights, int bricks, int ladders) {
        //https://leetcode.com/problems/furthest-building-you-can-reach/
        int n = heights.length;
        int bricksUsed = 0;
        int index = 1;

        PriorityQueue<Integer> minHeapHeightDiff = new PriorityQueue<>();

        while (index < n) {

            int buildingHeightDiff = heights[index] - heights[index - 1];

            //if the buildingHeightDiff is less than or equal 0, means the prev
            //building heights[index - 1] was a higher than curr heights[index]
            //for prev higher building to curr lower height  we don't need any
            //ladder or bricks, just straight move to curr heights[index]
            if (buildingHeightDiff <= 0) {
                continue;
            }

            //if the curr index-th building height is greater than its prev building
            //that means we have used either bricks or ladder to reach curr building
            //but in some optimal way so add diff of heights in min heap
            minHeapHeightDiff.add(buildingHeightDiff);

            //here we greedily wants to use ladder first if our min heap's size is
            //lesser or equal to given ladder that means we can use ladders for
            //all the buildingHeightDiff in the min heap (==> size)
            if (minHeapHeightDiff.size() <= ladders) {
                continue;
            }

            //here we have used all ladders provided now we need to consume bricks
            //we want to use bricks as min as possible & from min heap we get the
            //min diff of heights that means we have consumed that much of bricks
            bricksUsed += minHeapHeightDiff.poll();
            //if our brickUsed is more than the brick given that means we could
            //not have reached curr index so return index - 1;
            if (bricksUsed > bricks) {
                return index - 1;
            }
            index++;
        }
        return n - 1;
    }

    public void taskSchedular_Greedy(char[] tasks, int n) {
        //https://leetcode.com/problems/task-scheduler/
        //https://leetcode.com/problems/task-scheduler/discuss/2314557/Easiest-Solution-or-O(n)-time-O(26)-space-or-Detailed-and-Easiest-explanation
        int len = tasks.length;
        int[] freqMap = new int[26];
        int maxFreq = 0;
        int maxFreqCount = 0;

        for (char task : tasks) {
            int index = task - 'A';
            freqMap[index]++;
            if (freqMap[index] > maxFreq) {
                //reset
                maxFreq = freqMap[index];
                maxFreqCount = 1;
            } else if (freqMap[index] == maxFreq) {
                maxFreqCount++;
            }
        }
        //output
        int output = Math.max(len, (maxFreq - 1) * (n + 1) + maxFreqCount);
        System.out.println("Least unit of time cpu will take to finish all tasks: " + output);
    }

    public void twoCityScheduling_Greedy(int[][] costs) {
        //https://leetcode.com/problems/two-city-scheduling/
        //explanation: https://youtu.be/d-B_gk_gJtQ

        class CostDiff {

            int costDiff;
            int costA;
            int costB;

            public CostDiff(int costDiff, int costA, int costB) {
                this.costDiff = costDiff;
                this.costA = costA;
                this.costB = costB;
            }

        }

        List<CostDiff> diffs = new ArrayList<>();
        //calculating the cost diff with intuition of how musch
        //extra we have to pay if we send ith person to cityB so
        //cityB - cityA = diff
        for (int[] cost : costs) {
            int costA = cost[0];
            int costB = cost[1];
            diffs.add(new CostDiff(costB - costA, costA, costB));
        }

        //sort the list on basis of costDiff, this will sort diffs in incr order
        //that means on the left side of diffs list we will have min cost diff for ith
        //person to send to cityB, Now acc to quest we need to half of the person to cityA and 
        //other half to cityB, we are greedily choosing min cost at which we can send
        //half ith person to cityB first and remaining can go to cityA
        Collections.sort(diffs, (d1, d2) -> d1.costDiff - d2.costDiff);
        int minCost = 0;
        for (int i = 0; i < diffs.size(); i++) {
            if (i < diffs.size() / 2) {
                minCost += diffs.get(i).costB;
            } else {
                minCost += diffs.get(i).costA;
            }
        }
        //output
        System.out.println("Total min cost at which half of people can travel to city A and half to cityB: "
                + minCost);
    }

    public int superWashingMachines_Greedy(int[] machines) {
        //https://leetcode.com/problems/super-washing-machines/
        //https://leetcode.com/problems/super-washing-machines/discuss/2309704/c-simple-loop
        int n = machines.length;

        int totalClothes = 0;

        for (int clothe : machines) {
            totalClothes += clothe;
        }

        //if all the clothes are not enough to equally balanced in n machines
        if (totalClothes % n != 0) {
            return -1;
        }

        int clothesPerMachineWanted = totalClothes / n;
        int moves = 0;
        int delta = 0;

        for (int currClothe : machines) {
            delta += currClothe - clothesPerMachineWanted;
            moves = Math.max(moves,
                    Math.max(
                            currClothe - clothesPerMachineWanted,
                            Math.abs(delta)));
        }
        return moves;
    }

    public void courseSchedule_3_Greedy(int[][] courses) {
        //https://leetcode.com/problems/course-schedule-iii/
        //sort on the basis of lastDay of courses
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);

        PriorityQueue<Integer> maxHeapDurations = new PriorityQueue<>(
                (a, b) -> b - a);

        int totalDuration = 0;

        for (int[] course : courses) {
            int duration = course[0];
            int lastDay = course[1];

            if (totalDuration + duration <= lastDay) {
                totalDuration += duration;
                maxHeapDurations.add(duration);
            } else if (!maxHeapDurations.isEmpty() && maxHeapDurations.peek() > duration) {
                totalDuration += duration - maxHeapDurations.poll();
                maxHeapDurations.add(duration);
            }
        }
        //output
        System.out.println("Total courses we can take: " + maxHeapDurations.size());
    }

    public void numberOfWeakCharactersInGame_Greedy(int[][] properties) {
        //https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/
        int n = properties.length;
        int ATTACK = 0;
        int DEFENSE = 1;
        Arrays.sort(properties, (a, b) -> a[ATTACK] == b[ATTACK]
                ? Integer.compare(b[DEFENSE], a[DEFENSE])
                : Integer.compare(a[ATTACK], b[ATTACK]));
        int weakCharacters = 0;
        int maxDefense = properties[n - 1][DEFENSE];
        for (int i = n - 2; i >= 0; i--) {
            int currDefense = properties[i][DEFENSE];
            if (maxDefense > currDefense) {
                weakCharacters++;
            } else {
                maxDefense = currDefense;
            }
        }
        //output
        System.out.println("Number of weak characters in game: " + weakCharacters);
    }

    public void maxPerformanceOfTeam_Greedy(int n, int k, int[] efficiency, int[] speed) {
        //https://leetcode.com/problems/maximum-performance-of-a-team/
        //explanation: https://youtu.be/Y7UTvogADH0
        class Engineer {

            int efficiency;
            int speed;

            public Engineer(int efficiency, int speed) {
                this.efficiency = efficiency;
                this.speed = speed;
            }

        }

        int mod = 1000000007;
        long maxPerformance = 0;
        long currSpeedSum = 0;
        PriorityQueue<Integer> minHeapSpeed = new PriorityQueue<>();
        List<Engineer> engineers = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            engineers.add(new Engineer(
                    efficiency[i],
                    speed[i]
            ));
        }

        //sort the engineers in descending order of their efficiency
        //because each time we need to take the min efficiency
        Collections.sort(engineers, (a, b) -> Integer.compare(b.efficiency, a.efficiency));

        for (Engineer engineer : engineers) {
            //since we are only choosing atmost k engineers and in below
            //line we are going to add in minHeapSpeed but before adding
            //check if the we already have added k enineers before, so
            //remove the min speed from heap and adjust the currSpeedSum
            if (minHeapSpeed.size() == k) {
                currSpeedSum -= minHeapSpeed.poll();
            }
            //from all the engieers choose atmost k engineers here
            minHeapSpeed.add(engineer.speed);
            currSpeedSum += engineer.speed;
            maxPerformance = Math.max(maxPerformance, (engineer.efficiency * currSpeedSum));
        }
        //output
        System.out.println("Max performance of team: " + (maxPerformance % mod));
    }

    public void bagOfTokens_Greedy(int[] tokens, int power) {
        //https://leetcode.com/problems/bag-of-tokens/
        //based on TWO POINTER & GREEDY
        int n = tokens.length;
        int start = 0;
        int end = n - 1;
        int currScore = 0;
        int maxScore = 0;

        //sorting the tokens will allow us to pick tokens in a greedy way
        //those tokens where given power >= token[i]
        Arrays.sort(tokens);

        while (end >= start) {
            //If your current power is at least tokens[i], you may play the 
            //ith token face up, losing tokens[i] power and gaining 1 score
            if (power >= tokens[start]) {
                currScore++;
                power -= tokens[start++];
                maxScore = Math.max(maxScore, currScore);
            } else if (power < tokens[start] && currScore >= 1) {
                //If your current score is at least 1, you may play the ith 
                //token face down, gaining tokens[i] power and losing 1 score.
                currScore--;
                power += tokens[end--];
            } else {
                break;
            }
        }
        //output
        System.out.println("Max score from bag of tokens: " + maxScore);
    }

    public int maxNumberOfGroupsEnteringCompetition_Greedy(int[] grades) {
        //https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
        int n = grades.length;
        Arrays.sort(grades);
        int start = 0;
        int groupSize = 0;
        int groups = 0;
        for (; start < n; start += groupSize) {
            groups++;
            groupSize++;
        }
        if (start > n) {
            return groups - 1;
        }
        return groups;
    }

    public void removeStonesToMinimizeTotal_Greedy(int[] piles, int k) {
        //https://leetcode.com/problems/remove-stones-to-minimize-the-total/
        //somewhat based on minCostOfRope()
        PriorityQueue<Integer> maxHeapStones = new PriorityQueue<>(
                (a, b) -> b - a);
        for (int stone : piles) {
            maxHeapStones.add(stone);
        }
        while (!maxHeapStones.isEmpty() && k > 0) {
            k--;
            int stone = maxHeapStones.poll();
            //new stone is greatest integer that is smaller than or equal to row (i.e., rounds row down).
            //basically a ceil value on double division even though quest says it need floor(row)
            int newStone = (int) Math.ceil((double) stone / 2.0);
            maxHeapStones.add(newStone);
        }

        int minStones = 0;
        while (!maxHeapStones.isEmpty()) {
            minStones += maxHeapStones.poll();
        }
        //output
        System.out.println("Remove stones to minimize the total stones in pile: " + minStones);
    }

    public void minOperationToHalveTheArraySum_Greedy(int[] arr) {
        //https://leetcode.com/problems/minimum-operations-to-halve-array-sum/
        //somewhat based on minCostOfRope() & removeStonesToMinimizeTotal_Greedy()
        //since we are using maxHeap of Double, avoid using the comparator this
        //way ((a, b) - (int)(b - a)) because this typecasting to int will cause issue
        //in maxHeap, hence cause wrong answer
        PriorityQueue<Double> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        double sum = 0.0;
        for (double val : arr) {
            sum += val;
            maxHeap.add(val);
        }

        int oprn = 0;
        double currSum = sum;
        double halfTheSum = sum / 2.0;

        while (!maxHeap.isEmpty()) {
            oprn++;
            double val = maxHeap.poll();
            double half = val / 2.0;

            currSum = currSum - half;
            maxHeap.add(half);

            if (currSum < halfTheSum) {
                break;
            }
        }
        //output
        System.out.println("Min operation to halve the array sum: " + oprn);
    }

    public void reduceArraySizeTohalf_Greedy(int[] arr) {
        //https://leetcode.com/problems/reduce-array-size-to-the-half/
        Map<Integer, Integer> freqMap = new HashMap<>();
        for (int val : arr) {
            freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);
        }

        List<Integer> freqVals = new ArrayList<>(freqMap.values());
        //sort max freq first
        Collections.sort(freqVals, (a, b) -> b - a);

        int arraySize = arr.length;
        int half = arraySize / 2;
        int removed = 0;
        while (arraySize > half) {
            arraySize -= freqVals.get(removed++);
        }
        //output
        System.out.println("Removals to make array half: " + removed);
    }

    public void minimizeMaxPairSumInArray_Greedy(int[] arr) {
        //https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/
        int n = arr.length;
        int start = 0;
        int end = n - 1;
        //sort the arr in incr order
        Arrays.sort(arr);
        int minimizedMaxPairSum = 0;
        while (end > start) {
            //here we are minimizing the pair sum by choosing the max value from
            //end of arr and min value from start of the arr in sorted array,
            //and choosing max value from them
            minimizedMaxPairSum = Math.max(minimizedMaxPairSum, arr[start] + arr[end]);
            start++;
            end--;
        }
        //output
        System.out.println("Minimized max pair sum: " + minimizedMaxPairSum);
    }

    public void minSubseqOfNonIncreasingOrder_Greedy_HeapBased(int[] nums) {
        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
        //somewhat based on subseqOfLengthKWithLargestSum()
        class Pair {

            int val;
            int index;

            public Pair(int val, int index) {
                this.val = val;
                this.index = index;
            }
        }

        List<Integer> result = new ArrayList<>();
        PriorityQueue<Pair> maxHeap = new PriorityQueue<>((a, b) -> b.val - a.val);
        int totalSum = 0;
        for (int i = 0; i < nums.length; i++) {
            totalSum += nums[i];
            maxHeap.add(new Pair(nums[i], i));
        }

        int maxSum = 0;
        while (!maxHeap.isEmpty()) {
            Pair currPair = maxHeap.poll();
            maxSum += currPair.val;
            totalSum -= currPair.val;
            result.add(currPair.val);
            if (maxSum > totalSum) {
                break;
            }
        }
        //output
        System.out.println("Min subseq where its sum is stricly greater than the left over elements sum: " + result);
    }

    public void minSubseqOfNonIncreasingOrder_Greedy(int[] nums) {
        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
        //simple straight forward sorting & OPTIMIZED
        List<Integer> result = new ArrayList<>();
        int n = nums.length;

        Arrays.sort(nums);

        int totalSum = 0;
        for (int val : nums) {
            totalSum += val;
        }

        int maxSum = 0;
        //after sorting the greater nums are in the end of the array
        //creating the maxSum from end and also reducing the same value from totalSum
        //until our maxSum > totalSum (maxSum strictly greater than totalSum)
        //all those max nums we are taking, we will put in result
        for (int i = n - 1; i >= 0; i--) {
            maxSum += nums[i];
            totalSum -= nums[i];
            result.add(nums[i]);
            if (maxSum > totalSum) {
                break;
            }
        }

        //output
        System.out.println("Min subseq where its sum is stricly greater than the left over elements sum: " + result);
    }

    public int minRoundsToCompleteAllTasks_Greedy(int[] tasks) {
        //https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/
        Map<Integer, Integer> freq = new HashMap<>();
        for (int val : tasks) {
            freq.put(val, freq.getOrDefault(val, 0) + 1);
        }

        int rounds = 0;
        //can pick task that are 2 or 3 in freq, if we can't pick the task in 
        //such freq return -1
        for (int key : freq.keySet()) {
            int count = freq.get(key);
            if (count < 2) {
                return -1;
            } else if (count < 3) {
                rounds++;
            } else if (count % 3 == 0) {
                rounds += (count / 3);
            } else {
                rounds += (count / 3) + 1;
            }
        }
        return rounds;
    }

    public void maxMatchingOfPlayersWithTrainers_Greedy(int[] players, int[] trainers) {
        //https://leetcode.com/problems/maximum-matching-of-players-with-trainers/
        //based on GREEDY & TWO POINTERS
        int n = players.length;
        int m = trainers.length;
        int i = 0;
        int j = 0;
        int match = 0;
        Arrays.sort(players);
        Arrays.sort(trainers);
        while (i < n && j < m) {
            //skip all the trainers j that can't train
            //players i, where the loop break that trainer
            //will be perfect match for player
            while (j < m && players[i] > trainers[j]) {
                j++;
            }

            //if in between trainers end, break because there is no need to
            //increase a match
            if (j >= m) {
                break;
            }

            //one trainer matched with player
            match++;
            //and move to next player
            i++;
            //since 1 player can be matched with 1 trainer only
            //so move to next trainer
            j++;
        }
        //output
        System.out.println("Max players with trainers match: " + match);
    }

    public void eliminateMaxNumberOfMosnter_Greedy(int[] dist, int[] speed) {
        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/discuss/2730968/JAVA-oror-Sorting-oror-Greedy
        int n = dist.length;
        double[] times = new double[n];
        for (int i = 0; i < n; i++) {
            times[i] = ((double) dist[i] / speed[i]);
        }
        Arrays.sort(times);
        int minute = 0;
        int kills = 0;
        int index = 0;
        while (index < n) {
            if (times[index] > minute) {
                kills++;
                index++;
            } else {
                break;
            }
            minute++;
        }
        //output
        System.out.println("Max monster kills: " + kills);
    }

    public void maxBagsCompletelyFilledWithRocks_Greedy(int[] capacities, int[] rocks, int additionalRocks) {
        //https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/
        class Bag {

            int capacityLeft;

            public Bag(int capacityLeft) {
                this.capacityLeft = capacityLeft;
            }

        }

        int n = capacities.length;
        int bagsCompletelyFilled = 0;
        //min heap capacity of bags, all those bags with smaller capacity will be
        //filled faster, so a greedy way
        PriorityQueue<Bag> minHeapCapacity = new PriorityQueue<>(
                (a, b) -> a.capacityLeft - b.capacityLeft);

        for (int i = 0; i < n; i++) {
            int bagMaxCapacity = capacities[i];
            int currRocksInBag = rocks[i];
            //if the curr bag is already filled with rocks upto its
            //maxCapacity
            if (bagMaxCapacity - currRocksInBag == 0) {
                bagsCompletelyFilled++;
            } else {
                //else put the left over capacity of the bag that is yet to be
                //filled completly
                minHeapCapacity.add(new Bag(bagMaxCapacity - currRocksInBag));
            }
        }

        while (!minHeapCapacity.isEmpty() && additionalRocks > 0) {
            Bag currBag = minHeapCapacity.poll();
            //break when the additionalRocks are less compared
            //to capacityLeft to completely fill this currBag,
            //means with the curr additionalRocks left the curr bag can't be
            //filled compeletly
            if (currBag.capacityLeft > additionalRocks) {
                break;
            }
            additionalRocks -= currBag.capacityLeft;
            bagsCompletelyFilled++;
        }
        //output
        System.out.println("Bags that completly filled with rocks: " + bagsCompletelyFilled);
    }

    public int minMovesToReachTarget_Greedy(int target, int maxDoubles) {
        //https://leetcode.com/problems/minimum-moves-to-reach-target-score/
        //https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
        //https://leetcode.com/problems/count-operations-to-obtain-zero/
        //aim is to reach target from src == 1 either by
        //1. adding 1 to src or
        //2. doubling the src(2 * src)
        //here backward approach is used, going from target to src using the
        //reverse oprn that means reducing by 1 or dividing by 2
        //since we can't reduce our target half as maxDoubles == 0, the max oprn
        //we can perform to reach to src == 1 from target is target - src
        //=> target - 1 oprns
        if (maxDoubles == 0) {
            return target - 1;
        }
        int oprn = 0;
        while (target > 1 && maxDoubles > 0) {
            if (target % 2 == 0) {
                target /= 2;
                maxDoubles--;
            } else {
                target -= 1;
            }
            oprn++;
        }
        //if above loops breaks because we used all our maxDoubles and target still
        //not reached 1 then total oprns to perform is curr oprn we did + remaining
        //oprns to each from curr target to src == 1 i.e, target - src
        //=> target - 1 ==> oprn + (target - 1)
        //else if above loop break because we reached to target == src == 1
        //we can simply return oprn we perform in that
        return target > 1 ? oprn + (target - 1) : oprn;
    }

    public int maximizeTopmostElementAfterKMoves_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/
        int n = nums.length;
        if (n == 1 && k % 2 == 1) {
            return -1;
        }
        int maxPile = -1;
        for (int pile : nums) {
            if (k == 0 || k > 1) {
                maxPile = Math.max(maxPile, pile);
            }
        }
        return maxPile;
    }

    public int minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(int[] nums) {
        //https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/
        int n = nums.length;
        if (n <= 4) {
            return 0;
        }

        int minDiff = Integer.MAX_VALUE;
        Arrays.sort(nums);

        minDiff = Math.min(minDiff, nums[n - 1] - nums[3]);
        minDiff = Math.min(minDiff, nums[n - 2] - nums[2]);
        minDiff = Math.min(minDiff, nums[n - 3] - nums[1]);
        minDiff = Math.min(minDiff, nums[n - 4] - nums[0]);

        return minDiff;
    }

    public void previousPermutationWithOneSwap_Greedy(int[] num) {
        //https://leetcode.com/problems/previous-permutation-with-one-swap/description/
        //somewhat same as nextPermutation()
        /*
        ex: num[] = [3,1,1,3], n = 4
        output = [1,3,1,3]
        
        1313 as a num value is just smaller/previous permutaion of 3113 as num
        1. index = n - 1 == 3, currVal = 3, rightSide = [index + 1, n] == [n, n]
        Not valid for() loop
        2. index = 2, currVal = 1, rightSide = [index + 1, n] == [3, n] == num == [3]
        no smallerThanCurrVal in rightSide
        3. index = 1, currVal = 1, rightSide = [idnex + 1, n] == [2, n] == num == [1,3]
        no smallerThanCurrVal in rightSide
        4. index = 0, currVal = 3, rightSide = [index + 1, n] == [1, n] == num == [1,1,3]
        smallerThanCurrVal in rightSide == num[1] == 1 (num[i] < currVal)
        therefore 
        [3,1,1,3] = swap(0, 1) = [1,3,1,3]
         */
        int n = num.length;
        int index = n - 1;
        while (index >= 0) {
            //curr val at index-th
            int currVal = num[index];
            //default smaller value
            int smallerThanCurrVal = -1;
            //default smaller val's index
            int smallerThanCurrValIndex = -1;
            //with this for loop we will find the a smallerThanCurrVal == num[i],
            //in the right side of the index-th point which is smaller than
            //curr val but this num[i] should be max in num[index + 1, n]
            for (int i = index + 1; i < n; i++) {
                //num[i] should be less than currVal
                if (num[i] < currVal) {
                    //but this num[i] should be max in num[index + 1, n]
                    if (num[i] > smallerThanCurrVal) {
                        smallerThanCurrVal = num[i];
                        smallerThanCurrValIndex = i;
                    }
                }
            }
            //if smallerThanCurrValIndex is a valid index then we can swap
            //the values at curr index & smallerThanCurrValIndex. since only 
            //one swap is allowed then we have to break/return from here
            if (smallerThanCurrValIndex != -1) {
                //swap
                int temp = num[index];
                num[index] = num[smallerThanCurrValIndex];
                num[smallerThanCurrValIndex] = temp;
                break;
            }
            index--;
        }
        //output
        System.out.println("Previous permutation with one swap: " + Arrays.toString(num));
    }

    public void maxIcecreamBars_Greedy(int[] costs, int coins) {
        //https://leetcode.com/problems/maximum-ice-cream-bars/description/
        //based on BASIC GREEDY LOGIC
        //sort all the icecreams by their cost, so min cost first
        //motive is to pick as many bars as possible from the given
        //coins, so pick all the min cost bars first
        Arrays.sort(costs);
        int icecreamPicks = 0;
        for (int cost : costs) {
            //if at any point we have less coins that can't buy this bar at curr
            //cost, break; we can't even buy further
            if (coins < cost) {
                break;
            }
            //picking a bar with curr cost, so we will reduce our coins by that
            //cost of bar
            coins -= cost;
            //picked this bar
            icecreamPicks++;
        }
        //output
        System.out.println("Max icecreams bars: " + icecreamPicks);
    }

    public void longestChunkedPallindromeDecomposition_Greedy(String word) {
        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/
        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/solutions/350560/java-c-python-easy-greedy-with-prove/
        /*
        looping the word from 0 to n so that the
        
        1. chunk will be counted as 1 when there is no intermediate pallindrome
        chunk is possible
        ex: "merchant", there is no intermediate pallindrome chunk so when
        i == n - 1, leftChunk == "merchant", rightChunk == "merchant" hence
        at this point chunk++ ==> 1 and loop ends
        
        2. chunk itself will be doubled
        ex: word = "ghiabcdefhelloadamhelloabcdefghi"
        #1.
        leftChar = g, rightChar = i
        leftChunk = append() = "g", rightChunk = insert(0) = "i"
        #2.
        leftChar = h, rightChar = h
        leftChunk = append() = "gh", rightChunk = insert(0) = "hi"
        #3.
        leftChar = i, rightChar = g
        leftChunk = append() = "ghi", rightChunk = insert(0) = "ghi"
        ==> leftChunk == rightChunk
        ====> partiiton++
        //reset chunks once leftChunk equals to rightChunk
        ====> leftChunk = "", rightChunk = ""
        ....
        iteratively, next chunk will be picked
        
        also since we are looping 0 to n, when i reaches (n / 2)
        left & right chunks will be seen again, hence our chunks will get doubled
        
         */
        int n = word.length();
        int chunk = 0;
        StringBuilder leftChunk = new StringBuilder();
        StringBuilder rightChunk = new StringBuilder();

        for (int i = 0; i < n; i++) {
            char leftChar = word.charAt(i);
            char rightChar = word.charAt(n - i - 1);

            leftChunk.append(leftChar);
            rightChunk.insert(0, rightChar);

            if (leftChunk.toString().equals(rightChunk.toString())) {
                chunk++;
                //reset chunks
                leftChunk.setLength(0);
                rightChunk.setLength(0);
            }
        }
        //output
        System.out.println("Longest chunked pallindrome decomposition: " + chunk);
    }

    public void appendKIntegerWithMinSum_Greedy(int[] nums, int k) {
        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/
        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/solutions/1823848/java-solution-use-n-n-1-2/
        int n = nums.length;
        Arrays.sort(nums);
        Set<Integer> set = new HashSet<>();
        long sum = 0;
        for (int val : nums) {
            if (!set.contains(val) && val <= k) {
                k++;
                sum += val;
            }
            set.add(val);
        }
        long minSum = (long) (1 + k) * k / 2 - sum;
        //output
        System.out.println("Minimal sum : " + minSum);
    }

    public boolean canPlaceFlowers_Greedy(int[] flowerbed, int flowers) {
        //https://leetcode.com/problems/can-place-flowers/description/
        int len = flowerbed.length;
        if (flowers == 0) {
            return true;
        }

        for (int i = 0; i < len; i++) {
            //if curr bed is first index(== 0) OR the prev bed has 0 flower in it
            if ((i == 0 || flowerbed[i - 1] == 0)
                    //if curr i-th bed has no flowers in it
                    && flowerbed[i] == 0
                    //if curr bed is last index(== len - 1) OR the next bed has 0
                    //flower in it
                    && (i == len - 1 || flowerbed[i + 1] == 0)) {
                //then pick 1 flower and place it in the flowerbed at i-th location
                //that has 0 flower in prev bed and 0 flower in next bed
                flowers--;
                flowerbed[i] = 1;
            }
            //if we have used all the flowers return true
            if (flowers == 0) {
                return true;
            }
        }
        //not possible
        return false;
    }

    public void maxScoreForString_Greedy(String str, int x, int y) {
        //https://leetcode.com/problems/maximum-score-from-removing-substrings/description/
        //https://practice.geeksforgeeks.org/problems/d25f415de2ff3e02134de03e17ad019d723ab2e9/1
        long totalScore = 0;
        //this StringBuilder will act as stack
        StringBuilder sb = new StringBuilder();
        //greedily choose which substring will give more score at first, then
        //process all the substring for that
        //here if score("ab") >= score("ba") then process all "ab" first then
        //process "ba" latter on the left over chars of given string
        if (x >= y) {
            //process all "ab" first
            for (char ch : str.toCharArray()) {
                if (sb.length() > 0 && sb.charAt(sb.length() - 1) == 'a' && ch == 'b') {
                    totalScore += x;
                    //pop the last added a because curr chr == b hence substring
                    //formed is "ab"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }

            //process all "ba" latter on left over chars of str in StringBuilder
            str = sb.toString();
            //reset stack
            sb.setLength(0);
            for (char ch : str.toCharArray()) {
                if (sb.length() > 0 && sb.charAt(sb.length() - 1) == 'b' && ch == 'a') {
                    totalScore += y;
                    //pop the last added b because curr chr == a hence substring
                    //formed is "ba"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }
        } else {
            //process all "ba" first
            for (char ch : str.toCharArray()) {
                if (sb.length() > 0 && sb.charAt(sb.length() - 1) == 'b' && ch == 'a') {
                    totalScore += y;
                    //pop the last added b because curr chr == a hence substring
                    //formed is "ba"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }

            //process all "ab" latter on left over chars of str in StringBuilder
            str = sb.toString();
            //reset stack
            sb.setLength(0);
            for (char ch : str.toCharArray()) {
                if (sb.length() > 0 && sb.charAt(sb.length() - 1) == 'a' && ch == 'b') {
                    totalScore += x;
                    //pop the last added a because curr chr == b hence substring
                    //formed is "ab"
                    sb.deleteCharAt(sb.length() - 1);
                } else {
                    sb.append(ch);
                }
            }
        }

        //output
        System.out.println("Max score of string ab Or ba: " + totalScore);
    }

    public void reducingDishes_Greedy(int[] satisfaction) {
        //https://leetcode.com/problems/reducing-dishes/description/
        //this is GREEDY solution to same question solved with Recursive memo
        int n = satisfaction.length;
        Arrays.sort(satisfaction);
        int maxSatisfaction = 0;
        int currSatisfaction = 0;

        for (int i = n - 1; i >= 0; i--) {
            if (currSatisfaction + satisfaction[i] < 0) {
                break;
            }
            currSatisfaction += satisfaction[i];
            maxSatisfaction += currSatisfaction;
        }
        //output
        System.out.println("Max like time coefficient (Greedy): " + maxSatisfaction);
    }

    public void minStepsReqToMakeStringEmpty_Greedy(String str) {
        //https://practice.geeksforgeeks.org/problems/6a1b365b520f10c8a29b533eb72951b4b4237b57/1
        //given string str only contains a and b, count all the groups that has
        //some consecutive groups of either a's OR b's
        int n = str.length();
        int count = 0;
        for (int i = 0; i < n; i++) {
            //at these indexes (i - 1) and i where the consecutivity breaks like
            //ab or ba do count++
            if (i > 0 && str.charAt(i - 1) != str.charAt(i)) {
                count++;
            }
        }
        //output
        System.out.println("Min steps required to make string empty: "
                + ((int) Math.ceil(count / 2.0) + 1));
    }

    public void minimizeMaxArray_Greedy(int[] nums) {
        //.....................T: O(N), N is length of the array
        //https://leetcode.com/problems/minimize-maximum-of-array/description/
        //https://leetcode.com/problems/minimize-maximum-of-array/editorial/
        //explanation: https://youtu.be/AeHMvcKuR0Y
        int n = nums.length;
        long minimizedMaxVal = 0;
        long prefixSum = 0;

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];
            //below expression (prefixSum + i) / (i + 1) is same as
            //Math.ceil(prefixSum / (i + 1))
            minimizedMaxVal = Math.max(minimizedMaxVal, (prefixSum + i) / (i + 1));
        }
        //output
        System.out.println("Minimized max value in array: " + minimizedMaxVal);
    }

    public void stringWithoutAAAOrBBB_Greedy(int a, int b) {
        //https://leetcode.com/problems/string-without-aaa-or-bbb/description/
        int[] freq = {a, b};
        char prevChar = '.';

        StringBuilder sb = new StringBuilder();

        while (true) {
            //default
            char currChar = '.';
            int currMaxFreq = 0;

            //choose a char which has a max freq and should also not be same as
            //prev char to prevent AAA or BBB
            for (char ch = 'a'; ch <= 'b'; ch++) {
                if (ch != prevChar && freq[ch - 'a'] > currMaxFreq) {
                    currMaxFreq = freq[ch - 'a'];
                    currChar = ch;
                }
            }

            if (currMaxFreq == 0) {
                break;
            }

            //we picked up this currChar having max freq as currMaxFreq so we
            //must reduce by 1 for choosing this char
            sb.append(currChar);
            freq[currChar - 'a']--;

            //here we need to check if we can take one more char of the same
            //currChar because we need to stop AAA or BBB that means we can have
            //atmost AA or BB
            if (currMaxFreq >= 2 && (prevChar == '.' || currMaxFreq > freq[prevChar - 'a'])) {
                sb.append(currChar);
                freq[currChar - 'a']--;
            }
            prevChar = currChar;
        }
        //output
        System.out.println("String without AAA or BBB: " + sb);
    }

    public void maxNumberOfMarkedIndices_Greedy(int[] nums) {
        //https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/description/
        /*
        nums[] = [9,2,5,4]
        sort() = [2,4,5,9]
        n = 4
        i = (n / 2) - 1 = 1
        j = n - 1 = 3
        count = 0
        
        #1 i = 1, j = 3
        2 * nums[1] <= nums[3] ==> 2 * 4 <= 9 OK
        ===>count += 2 (mark i & j) => 2
        ===>j-- => 2
        ==>i-- => 0
        
        #1 i = 0, j = 2
        2 * nums[0] <= nums[2] ==> 2 * 2 <= 5 OK
        ===>count += 2 (mark i & j) => 4
        ===>j-- => 1
        ==>i-- => -1
        
         */
        int n = nums.length;
        int i = (n / 2) - 1;
        int j = n - 1;
        int count = 0;
        Arrays.sort(nums);
        while (i >= 0) {
            if (2 * nums[i] <= nums[j]) {
                // +2 because at this point we are marking 2 indices i & j
                count += 2;
                //since we used index j need to move to next j-th index
                j--;
            }
            i--;
        }
        //output
        System.out.println("Find max number of marked indices : " + count);
    }

    public void dota2Senate_Greedy(String senate) {
        //........................T: O(N)
        //........................S: O(N)
        //https://leetcode.com/problems/dota2-senate/description/
        //explanation: https://youtu.be/zZA5KskfMuQ
        int n = senate.length();
        Queue<Integer> radiant = new LinkedList<>();
        Queue<Integer> dire = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            if (senate.charAt(i) == 'R') {
                radiant.add(i);
            } else {
                dire.add(i);
            }
        }

        while (!radiant.isEmpty() && !dire.isEmpty()) {
            int radiantIndex = radiant.poll();
            int direIndex = dire.poll();

            //whoever came earlier, gets to apply the rule on other
            if (radiantIndex < direIndex) {
                //radiant came first, so it cancels the right to vote for next
                //dire candidate.
                //but this radiant candiadte needs to be there in count
                radiant.add(radiantIndex + n);
            } else {
                //dire came first, so it cancels the right to vote for next
                //radiant candidate.
                //but this dire candiadte needs to be there in count
                dire.add(direIndex + n);
            }
        }
        //output
        //above loop will break when either radiant or dire party memeber loose
        //all the votes count
        //if there are voters left from radiant party only(== !radiant.isEmpty())
        //then radiant is the winner otherwise dire
        String winner = !radiant.isEmpty() ? "Radiant" : "Dire";
        System.out.println("Dota2 senate : " + winner);
    }

    public void minTimeToFillCups_Greedy(int[] amount) {
        //https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/description/
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);
        for (int val : amount) {
            if (val != 0) {
                maxHeap.add(val);
            }
        }

        int time = 0;
        //greedily pick 2 cups at a time to fill them until we are allowed to pick
        //2 cups
        while (maxHeap.size() >= 2) {
            time++;

            int cup1 = maxHeap.poll();
            int cup2 = maxHeap.poll();

            cup1--;
            if (cup1 > 0) {
                maxHeap.add(cup1);
            }

            cup2--;
            if (cup2 > 0) {
                maxHeap.add(cup2);
            }
        }
        //outpput
        //once there are just X amount of one-type of cups left then this X amount
        //of the cups in heap will be the amount of time in seconds required additionally
        //else if heap is empty that means we have successfully used all cups and no
        //additional time is required
        //time required
        time = time + (maxHeap.isEmpty() ? 0 : maxHeap.peek());
        System.out.println("Min time to fill the cups : " + time);
    }

    public void minElementsToAddToFormGivenSum_Greedy(int[] nums, int limit, int goal) {
        //https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/description/
        //convert the given int[] to long[] so the total sum of nums[] can be held
        long[] longArr = Arrays.stream(nums).mapToLong(val -> val).toArray();
        //sum up the value in longArr[]
        long arrSum = Arrays.stream(longArr).sum();
        //the diff between goal & curr arrSum is the sum needs to add to become 'goal'
        double requiredSumToAdd = Math.abs((long) goal - arrSum);
        //required sum / limit will give the no of new elements to add (where each
        //new elements should be less than equal to limit) this division can be fractional
        //so as we need a min no of elements, we need to ceil this divison
        int minCountOfElementsToInclude = (int) Math.ceil(requiredSumToAdd / (double) limit);
        //output
        System.out.println("Min elements to add to form a given sum : " + minCountOfElementsToInclude);
    }

    public void scoreForArrayAfterMarkingAllElements_Greedy(int[] nums) {
        //......................T: O(N * LogN), N is length of the nums[]
        //......................S: O(N), N is length of the marked[]
        //https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/
        int n = nums.length;
        boolean[] marked = new boolean[n];
        PriorityQueue<Integer> indexes = new PriorityQueue<>(
                //if two nums values are same then sort the indexes in incr order
                //else sort them in incr order of nums[i] value
                (a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]);

        //put all the nums[] index in indexes heap
        for (int index = 0; index < n; index++) {
            indexes.add(index);
        }

        long score = 0;
        while (!indexes.isEmpty()) {
            //pick the index with the smallest value that is 'smallestValIndex'
            int smallestValIndex = indexes.poll();
            //if this smallestValIndex is already marked, we can't consider
            //this value in score hence continue
            if (marked[smallestValIndex]) {
                continue;
            }

            //mark this smallestValIndex as true
            marked[smallestValIndex] = true;

            //mark the adjacent left value(== that is (smallestValIndex - 1)) of
            //'smallestValIndex' as true
            if (smallestValIndex - 1 >= 0) {
                marked[smallestValIndex - 1] = true;
            }

            //mark the adjacent right value(== that is (smallestValIndex + 1)) of
            //'smallestValIndex' as true
            if (smallestValIndex + 1 < n) {
                marked[smallestValIndex + 1] = true;
            }

            //add the nums['smallestValIndex'] in our score
            score += nums[smallestValIndex];
        }
        //output
        System.out.println("Score of array after marking all elements : " + score);
    }

    public void addMinNumberOfRungs_Greedy(int[] rungs, int dist) {
        //https://leetcode.com/problems/add-minimum-number-of-rungs/description/
        /*
        intuition here is,
        initially we are standing at height = 0 ==> prevHeight = 0
        and from some prevHeight we need to cover a 'dist' and if there is
        prevHeight + dist >= rungs[i] then it is good we can atleast reach our
        rungs[i] as we have covered plenty of range from [prevHeight, prevHeight + dist] 
        as prevheight < rungs[i] <= (prevHeight + dist)
        
        BUT 
        
        if our prevHeight + dist < rungs[i] we don't have much range to reach our
        rungs[i] so what we have to do is to add new rungs in between prevHeight
        and rungs[i] so to calculate that 
        dest = rungs[i]
        src = prevHeight
        adjust = -1 "adjust", why? 
        because, as we need to reach to dest from our src and we also know that
        we definitely have dest == rungs[i] available so we don't need to count
        the dest rungs but those required in between thats why!!!
        
        so with this we need to cover a 'total-length' of (dest - src - 1) between src & dest
        so how many rungs would be reuired to cover this 'total-length' provided that we can
        move by dist 'dist', then rungs required would be ('total-length' / 'dist')
        
        hence, number of rungs required to add
        ==> addedRungs = ((dest - src - 1) / dist);
        ==> ((rungs[i] - prevHeight - 1) / dist)
        
         */
        int n = rungs.length;
        int prevHeight = 0;
        int addedRungs = 0;
        for (int i = 0; i < n; i++) {
            if (prevHeight + dist < rungs[i]) {
                addedRungs += ((rungs[i] - prevHeight - 1) / dist);
            }
            prevHeight = rungs[i];
        }
        //output
        System.out.println("Min numbers of rungs added to reach the last point : " + addedRungs);
    }

    public void maxSubsequenceScore_Greedy(int[] nums1, int[] nums2, int k) {
        //https://leetcode.com/problems/maximum-subsequence-score/description/
        //explanation: https://youtu.be/z9oUzKhEYJU | https://youtu.be/ax1DKi5lJwk
        /*
        
        ex: nums1[] = [1,3,3,2], nums2[] = [2,1,3,4], k = 3
        
        As per questions, we need to pick same k indices from both the arrays
        nums1 and nums2,
        
        k indices 'value' picked from nums1[] are to be added 
        and
        k indices 'value' picked from nums2[], need to find min 'value' from all
        picked values
        
        hence our score will be sum(k-indices-nums1-value) * min(k-indices-nums2-value)
        and we need to max our score
        
        from the given ex: our result is 12
        as k = {0, 2, 3}
        then k-indices-values from nums1[] is {1, 3, 2} and from nums2[] is {2, 1, 4}
        score = sum({1,3,2}) * min({2,1,4}) ==> 6 * 2 ==> 12
        
        the DP solution to solve this will give TLE
        
        here is the Greedy intuition
        
        ==> make pair as pairs[][] of both nums1 and nums2 for the same i-th index
        pairs[i][0] = nums1, pairs[i][1] = nums2
        pairs[i][] = [|1|2|
                      |3|1|
                      |3|3|
                      |2|4|]
        
        ==> sort the pairs[][] in decreasing order of values in nums2
        pairs[i][] = [|2|4|
                      |3|3|
                      |1|2|
                      |3|1|]
        
        now consider the row = index = 0 as min value BUT keep in mind that, since
        pairs[][] is sorted in decr order so curr nums2 value @index is max value
        from rest other values of nums2 currently in pairs[][]
        4 > 3 > 2 > 1
        
        to understand better lets rearrange pairs[][]
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        @index = 0, condider min = 4, now we can't consider values on right because
        in that case our min value will change to 3 and so on but we still need to pick
        k indices and there are no further values to left of curr @index hence we can't
        pick min as 4 @index = 0
        
        ==> due to above reason, we will process first k value 
        put first k nums1 values from pairs into minHeap
        also add first k nums1 values from pairs[][] into initial kSum
        
        during first k process we would have considered this,
        .............______|
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        .............------|
        
        i.e, |2|3|1|
             |4|3|2|
        
        here our very first k indices process will be
        maxSubseqScore = kSum * pairs[k - 1][1]; ==> 12
        ==> kSum = sum({2,3,1}) * min(4,3,2) = 6 * 2 = 12
        
        ==> later on we need to process the remaining values of our pair
        .............________|
        pairs[][] = [|2|3|1|3|
                     |4|3|2|1|]
        .............--------|
        
        i.e, |2|3|1|3|
             |4|3|2|1|
        
        now here our min is shifted to nums2 value == 1
        but we need to adjust our kSum because we would have summed all the values
        i.e 2 + 3 + 1 + 3 but only need k value, so think here how can we make our
        curr kSum max by maintaining picking k-values thats greedy, just subtract
        the min nums1 value from kSum i.e, nums1 value 1
        for that reason minHeapNums1 is maintained to subtract the min nums1 value
        
         */
        int n = nums1.length;
        long maxSubseqScore = 0;
        int[][] pairs = new int[n][2];
        for (int i = 0; i < n; i++) {
            pairs[i] = new int[]{nums1[i], nums2[i]};
        }

        //sort the pairs[][] in decreasing order of nums2 added in pairs @index = 1
        Arrays.sort(pairs, (a, b) -> b[1] - a[1]);

        PriorityQueue<Integer> minHeapNums1 = new PriorityQueue<>();

        int index = 0;
        long kSum = 0;

        //add the first k elements in minHeap and also take the sum of nums1 of
        //first k elements from pairs[][]
        while (index < k) {
            kSum += pairs[index][0];
            minHeapNums1.add(pairs[index][0]);
            index++;
        }

        maxSubseqScore = kSum * pairs[k - 1][1];

        while (index < n) {

            kSum += pairs[index][0] - minHeapNums1.poll();

            minHeapNums1.add(pairs[index][0]);

            maxSubseqScore = Math.max(maxSubseqScore, kSum * pairs[index][1]);

            index++;
        }
        //output
        System.out.println("Max subsequence score : " + maxSubseqScore);
    }

    public void maxSplitOfPositiveEvenIntegers_Greedy(long finalSum) {
        //https://leetcode.com/problems/maximum-split-of-positive-even-integers/description/
        List<Long> splitsEvenIntegers = new ArrayList<>();

        //if the given final sum is an odd value, then we can never split it with
        //even integers, print empty list
        if (finalSum % 2L == 1) {
            System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
            return;
        }

        long counter = 2;

        //greedily reduce the final sum by positive even integer that is 'counter'
        //also we need to take unique even integer so same 'counter' should not be
        //used again hence counter should be increamented to next positive even integer
        //i.e, +2
        while ((finalSum - counter) >= 0) {
            splitsEvenIntegers.add(counter);
            finalSum -= counter;
            counter += 2;
        }

        //if on reducing the final sum by counter our final sum becomes 0
        //print all the positive even integer we took to make it '0'
        if (finalSum == 0) {
            System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
            return;
        }

        //here final sum is not yet '0', then we will add the the remaining final sum
        //in the last value of 'splitsEvenInteger' list
        int size = splitsEvenIntegers.size();
        splitsEvenIntegers.set(size - 1, finalSum + splitsEvenIntegers.get(size - 1));

        System.out.println("Max split of positive even integers : " + splitsEvenIntegers);
    }

    public void graphBFSAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        System.out.println("Actual graph : ");
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<Integer> result = new ArrayList<>();

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;

        queue.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!queue.isEmpty()) {

            int node = queue.poll();

            result.add(node);

            List<Integer> childrens = adjList.get(node);

            if (childrens == null || childrens.isEmpty()) {
                continue;
            }

            for (int childVertex : childrens) {

                if (visited[childVertex]) {
                    continue;
                }
                queue.add(childVertex);
                visited[childVertex] = true;
            }
        }

        //output:
        System.out.println("BFS of graph: " + result);
    }

    public void graphBFSLevelOrderAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        System.out.println("Actual graph : ");
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<List<Integer>> result = new ArrayList<>();

        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;

        queue.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!queue.isEmpty()) {

            int size = queue.size();
            List<Integer> level = new ArrayList<>();

            for (int i = 0; i < size; i++) {
                int node = queue.poll();

                level.add(node);
                List<Integer> childrens = adjList.get(node);

                if (childrens == null || childrens.isEmpty()) {
                    continue;
                }

                for (int childVertex : childrens) {

                    if (visited[childVertex]) {
                        continue;
                    }
                    queue.add(childVertex);
                    visited[childVertex] = true;
                }
            }
            result.add(level);
        }

        //output:
        System.out.println("BFS level order of graph: " + result);
    }

    public void graphDFSAdjList_Graph(int V, List<List<Integer>> adjList) {

        if (adjList == null || adjList.isEmpty()) {
            return;
        }

        //actual
        for (int i = 0; i < adjList.size(); i++) {
            System.out.print(i + ": ");
            for (int v : adjList.get(i)) {
                System.out.print(v + " ");
            }
            System.out.println();
        }

        List<Integer> result = new ArrayList<>();

        Stack<Integer> stack = new Stack<>();
        boolean[] visited = new boolean[V];
        //source point
        int sourceVertex = 0;
        stack.add(sourceVertex);
        visited[sourceVertex] = true;

        while (!stack.isEmpty()) {

            int node = stack.pop();

            result.add(node);

            List<Integer> childrens = adjList.get(node);

            if (childrens == null || childrens.isEmpty()) {
                continue;
            }

            for (int childVertex : childrens) {
                if (visited[childVertex]) {
                    continue;
                }
                stack.push(childVertex);
                visited[childVertex] = true;
            }
        }

        //output:
        System.out.println("DFS of graph: " + result);
    }

    private void graphDFSAdjList_Recursive_Helper(List<List<Integer>> adjList, int vertex,
            boolean[] visited, List<Integer> result) {

        visited[vertex] = true;
        result.add(vertex);
        List<Integer> childrens = adjList.get(vertex);
        for (int childVertex : childrens) {
            if (visited[childVertex] != true) {
                graphDFSAdjList_Recursive_Helper(adjList, childVertex, visited, result);
            }
        }
    }

    public void graphDFSAdjList_Recursive_Graph(int V, List<List<Integer>> adjList) {
        List<Integer> result = new ArrayList<>();
        boolean[] visited = new boolean[V];
        int sourceVertex = 0; //source point
        graphDFSAdjList_Recursive_Helper(adjList, sourceVertex, visited, result);
        System.out.println("DFS using recursion: " + result);
    }

    private void findPathRatInMaze_Helper(int[][] m, int n, int x, int y,
            StringBuilder sb, ArrayList<String> output) {

        if (x < 0 || x >= n || y < 0 || y >= n || m[x][y] == 0) {
            return;
        }

        if (x == n - 1 && y == n - 1 && m[x][y] == 1) {
            output.add(sb.toString());
            return;
        }

        int original = m[x][y];
        m[x][y] = 0;

        //Down
        sb.append("D");
        findPathRatInMaze_Helper(m, n, x + 1, y, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Right
        sb.append("R");
        findPathRatInMaze_Helper(m, n, x, y + 1, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Left
        sb.append("L");
        findPathRatInMaze_Helper(m, n, x, y - 1, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        //Up
        sb.append("U");
        findPathRatInMaze_Helper(m, n, x - 1, y, sb, output);
        sb.deleteCharAt(sb.length() - 1);

        m[x][y] = original;
    }

    public void findPathRatInMaze_Graph(int[][] m, int n) {
        ArrayList<String> output = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        findPathRatInMaze_Helper(m, n, 0, 0, sb, output);
        System.out.println("All possible paths: " + output);
    }

    private void numberOfIslands_Helper(int[][] grid, int x, int y,
            int[][] dir, boolean[][] visited) {

        if (x < 0 || x >= grid.length || y < 0 || y >= grid[x].length
                || grid[x][y] == 0
                || visited[x][y] == true) {
            return;
        }

        visited[x][y] = true;
        for (int i = 0; i < dir.length; i++) {

            int x_ = x + dir[i][0];
            int y_ = y + dir[i][1];
            numberOfIslands_Helper(grid, x_, y_, dir, visited);
        }
    }

    public void numberOfIslands_Graph(int[][] grid) {
        //https://leetcode.com/problems/number-of-islands
        //https://leetcode.com/problems/battleships-in-a-board/
        //https://leetcode.com/problems/max-area-of-island/
        //based on above max-area-of-islands //https://leetcode.com/problems/number-of-enclaves/
        int[][] dir = {
            {-1, -1},
            {-1, 0},
            {-1, 1},
            {0, -1},
            {0, 1},
            {1, -1},
            {1, 0},
            {1, 1}
        };
        boolean[][] visited = new boolean[grid.length][grid[0].length];
        int islandCount = 0;
        for (int x = 0; x < grid.length; x++) {
            for (int y = 0; y < grid[x].length; y++) {

                if (grid[x][y] == 1 && visited[x][y] != true) {
                    islandCount++;
                    numberOfIslands_Helper(grid, x, y, dir, visited);
                }
            }
        }

        System.out.println("Number of separated islands: " + islandCount);
    }

    public void numberOfClosedIslands_Graph(int[][] grid) {
        //https://leetcode.com/problems/number-of-closed-islands/description/
        //based on DFS, numberOfIslands_Graph() and surroundedRegions_Graph()
        int ROW = grid.length;
        int COL = grid[0].length;

        int LAND = 0;
        int REMOVE_LAND = -1;
        int VISITED_LAND = 2;

        int TOP_BOUNDARY = 0;
        int BOTTOM_BOUNDARY = ROW - 1;
        int LEFT_BOUNDARY = 0;
        int RIGHT_BOUNDARY = COL - 1;

        //both removeLandAtBoundary() & numberOfCLosedIslands() below
        //are DFS methods & doing the same things but just for clarity and
        //readbiltiy, made 2 separate methods here
        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void removeLandAtBoundary(int[][] grid, int row, int col) {
                if (isOutOfBounds(row, col) || grid[row][col] != LAND) {
                    return;
                }

                grid[row][col] = REMOVE_LAND;

                removeLandAtBoundary(grid, row - 1, col);
                removeLandAtBoundary(grid, row + 1, col);
                removeLandAtBoundary(grid, row, col - 1);
                removeLandAtBoundary(grid, row, col + 1);
            }

            //number of islands
            void numberOfCLosedIslands(int[][] grid, int row, int col) {
                if (isOutOfBounds(row, col) || grid[row][col] != LAND) {
                    return;
                }

                grid[row][col] = VISITED_LAND;

                numberOfCLosedIslands(grid, row - 1, col);
                numberOfCLosedIslands(grid, row + 1, col);
                numberOfCLosedIslands(grid, row, col - 1);
                numberOfCLosedIslands(grid, row, col + 1);
            }

        }

        Helper helper = new Helper();
        int numberOfClosedIslands = 0;

        //here we are removing all the LAND cells and their connected LAND cells
        //that are on the boundary because those LAND cells are not covered 4-dir
        //between WATER(== 1) cells around them
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == LAND
                        && ((r == TOP_BOUNDARY || r == BOTTOM_BOUNDARY)
                        || (c == LEFT_BOUNDARY || c == RIGHT_BOUNDARY))) {
                    helper.removeLandAtBoundary(grid, r, c);
                }
            }
        }

        //now from the above removeLand DFS call, we have left with those LAND
        //cells that actually surrounded 4-dir by WATER(== 1) cells, now we can
        //do the same number of islands dfs logic to count the closed islands
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == LAND) {
                    numberOfClosedIslands++;
                    helper.numberOfCLosedIslands(grid, r, c);
                }
            }
        }

        //output
        System.out.println("Number of closed islands in between water: " + numberOfClosedIslands);
    }

    private boolean detectCycleInUndirectedGraphDFS_Helper(
            List<List<Integer>> adjList, int vertex, int parent, boolean[] visited) {

        visited[vertex] = true;
        List<Integer> childrens = adjList.get(vertex);
        for (int childVertex : childrens) {
            if (visited[childVertex] != true) {
                if (detectCycleInUndirectedGraphDFS_Helper(adjList, childVertex, vertex, visited)) {
                    return true;
                }
            } else if (childVertex != parent) {
                return true;
            }
        }
        return false;
    }

    public boolean detectCycleInUndirectedGraphDFS_Graph(int V, List<List<Integer>> adjList) {

        boolean[] visited = new boolean[V];
        for (int u = 0; u < V; u++) {
            if (visited[u] != true) {
                if (detectCycleInUndirectedGraphDFS_Helper(adjList, u, -1, visited)) {
                    return true;
                }
            }
        }
        return false;
    }

    private void topologicalSort_Helper(List<List<Integer>> adjList, int vertex, boolean[] visited, Stack<Integer> resultStack) {

        visited[vertex] = true;
        List<Integer> childrens = adjList.get(vertex);
        for (int childVertex : childrens) {
            if (visited[childVertex] != true) {
                topologicalSort_Helper(adjList, childVertex, visited, resultStack);
            }
        }

        resultStack.push(vertex);
    }

    public void topologicalSort_Graph(int V, List<List<Integer>> adjList) {

        Stack<Integer> resultStack = new Stack<>();
        boolean[] visited = new boolean[V];
        for (int u = 0; u < V; u++) {
            if (visited[u] != true) {
                topologicalSort_Helper(adjList, u, visited, resultStack);
            }
        }

        System.out.println("Topological sort: ");
        while (!resultStack.isEmpty()) {
            System.out.print(resultStack.pop() + " ");
        }
        System.out.println();
    }

    public boolean detectCycleInDirectedGraphDFS_Helper(List<List<Integer>> adjList, int vertex,
            boolean[] visited, boolean[] recurStack) {

        if (recurStack[vertex]) {
            return true;
        }

        if (visited[vertex]) {
            return false;
        }

        recurStack[vertex] = true;
        visited[vertex] = true;

        List<Integer> childrens = adjList.get(vertex);
        if (childrens != null && childrens.size() > 0) {
            for (int childVertex : childrens) {
                if (detectCycleInDirectedGraphDFS_Helper(adjList, childVertex, visited, recurStack)) {
                    return true;
                }
            }
        }
        recurStack[vertex] = false;
        return false;
    }

    public boolean detectCycleInDirectedGraphDFS_Graph(int V, List<List<Integer>> adjList) {
        boolean[] visited = new boolean[V];
        boolean[] recurStack = new boolean[V];
        for (int u = 0; u < V; u++) {
            if (detectCycleInDirectedGraphDFS_Helper(adjList, u, visited, recurStack)) {
                return true;
            }
        }
        return false;
    }

    private void djikstraAlgorithm_Graph_Helper(
            Map<Integer, List<GraphEdge>> graph, int V, int src) {
        //Single source shortest path
        int MAX = Integer.MAX_VALUE;

        //parents arr is optional
        int[] parents = new int[V];
        Arrays.fill(parents, MAX);

        int[] minWeights = new int[V];
        Arrays.fill(minWeights, MAX);

        int weightToSrc = 0;
        minWeights[src] = weightToSrc;

        int parentToSrc = -1;
        parents[src] = parentToSrc;

        //minHeap of weights to get the least weighted edge from the breadth first order
        PriorityQueue<GraphEdge> minHeapWeightQueue = new PriorityQueue<>(
                (g1, g2) -> g1.weight - g2.weight);

        minHeapWeightQueue.add(new GraphEdge(src, weightToSrc));

        while (!minHeapWeightQueue.isEmpty()) {

            GraphEdge currEdge = minHeapWeightQueue.poll();
            int currVertex = currEdge.vertex;

            for (GraphEdge childEdge : graph.getOrDefault(currVertex, new ArrayList<>())) {

                int childVertex = childEdge.vertex;
                //cost to reach child vertex
                int childWeight = childEdge.weight;

                if (minWeights[currVertex] + childWeight < minWeights[childVertex]) {

                    minWeights[childVertex] = minWeights[currVertex] + childWeight;
                    //updating the child edge weight with new weight which is less
                    //costlier than previous
                    childEdge.weight = minWeights[childVertex];

                    parents[childVertex] = currVertex;

                    minHeapWeightQueue.add(childEdge);
                }
            }
        }
        //output
        for (int u = 0; u < V; u++) {
            System.out.println("From src: "
                    + src
                    + " to vertex: "
                    + u
                    + " min weight is: "
                    + (minWeights[u] == MAX ? " Not Possible " : minWeights[u])
                    + " parent of "
                    + u
                    + " is "
                    + (parents[u] == MAX ? " Not Possible " : parents[u]));
        }
    }

    public void djikstraAlgorithm_Graph() {
        //..........................T: O(V^2)
        //Djikstra algo fails for negatve weight cycle
        //input
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        int V = 5;
        for (int u = 0; u < V; u++) {
            graph.put(u, new ArrayList<>());
        }

        graph.get(0).addAll(Arrays.asList(
                new GraphEdge(2, 6),
                new GraphEdge(3, 6)));
        graph.get(1).addAll(Arrays.asList(
                new GraphEdge(0, 3)));
        graph.get(2).addAll(Arrays.asList(
                new GraphEdge(3, 2)));
        graph.get(3).addAll(Arrays.asList(
                new GraphEdge(1, 1),
                new GraphEdge(2, 1)));
        graph.get(4).addAll(Arrays.asList(
                new GraphEdge(1, 4),
                new GraphEdge(3, 2)));

        djikstraAlgorithm_Graph_Helper(graph, V, 4);
        djikstraAlgorithm_Graph_Helper(graph, V, 0);
    }

    public void networkTimeDelay_Graph(int[][] times, int V, int source) {
        //https://leetcode.com/problems/network-delay-time/
        //based on DJIKSTRA ALGO
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] time : times) {

            int u = time[0];
            int v = time[1];
            int weight = time[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));
        }

        int MAX = Integer.MAX_VALUE;

        int[] timeDelay = new int[V + 1];

        Arrays.fill(timeDelay, MAX);

        int sourceTime = 0;

        timeDelay[source] = sourceTime;

        Queue<GraphEdge> queue = new PriorityQueue<>((a, b) -> a.weight - b.weight);
        queue.add(new GraphEdge(source, sourceTime));

        while (!queue.isEmpty()) {

            GraphEdge currEdge = queue.poll();

            for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, new ArrayList<>())) {

                if (timeDelay[childEdge.vertex] > timeDelay[currEdge.vertex] + childEdge.weight) {

                    timeDelay[childEdge.vertex] = timeDelay[currEdge.vertex] + childEdge.weight;

                    queue.add(new GraphEdge(childEdge.vertex, timeDelay[childEdge.vertex]));
                }
            }
        }

        int maxNetworkDelayTime = Integer.MIN_VALUE;
        //considering [1 to V] nodes as given
        for (int i = 1; i < timeDelay.length; i++) {
            int delayTime = timeDelay[i];
            //if from [1 to V] any node is not reachable(disconnected graph) that node's
            //delay time will be left as MAX in that case we have to return -1
            if (delayTime == MAX) {
                maxNetworkDelayTime = -1;
                break;
            }
            maxNetworkDelayTime = Math.max(maxNetworkDelayTime, delayTime);
        }
        //output
        System.out.println("Max network delay time to reach far end node: " + maxNetworkDelayTime);
    }

    public void findEventualSafeNodes_Graph(int[][] edges) {
        //https://leetcode.com/problems/find-eventual-safe-states/
        int V = edges.length;
        //using boolean[] for marking nodes safe beacause this will keep
        //nodes in sorted order, which is req in question
        boolean[] markSafeNodes = new boolean[V];
        List<Integer> safeNodes = new ArrayList<>();
        Queue<Integer> terminalNodesQueue = new LinkedList<>();
        //graph or parent = [child] relation
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        //parent graph or child = [parent] relation
        Map<Integer, Set<Integer>> parentGraph = new HashMap<>();

        for (int parent = 0; parent < V; parent++) {
            //if a parent node don't have any outgoing edges(terminal node)
            if (edges[parent].length == 0) {
                terminalNodesQueue.add(parent);
            }
            for (int childVertex : edges[parent]) {
                graph.putIfAbsent(parent, new HashSet<>());
                graph.get(parent).add(childVertex);

                parentGraph.putIfAbsent(childVertex, new HashSet<>());
                parentGraph.get(childVertex).add(parent);
            }
        }

        //queue will start from terminal nodes where we can't move further
        //and we will fill the parents in queue if they can be made terminal
        //node while going the rev graph
        while (!terminalNodesQueue.isEmpty()) {
            int terminalNode = terminalNodesQueue.poll();
            //if any node is taken out of the queue, that means this curr terminal
            //node don't have any outgoing edges
            markSafeNodes[terminalNode] = true;

            for (int parentVertex : parentGraph.getOrDefault(terminalNode, new HashSet<>())) {
                //we will remove curr terminal node from its parent graph
                //nodes if that parent can be made terminal. Because if that parent
                //can't be made terminal node that would mean, there will exist a node from
                //this parent where that whole path will lead to no terminal node
                graph.get(parentVertex).remove(terminalNode);
                //parent nodes list is empty means it has become a terminal node now
                //we can add it in the queue
                if (graph.get(parentVertex).isEmpty()) {
                    terminalNodesQueue.add(parentVertex);
                }
            }
        }

        for (int src = 0; src < V; src++) {
            if (markSafeNodes[src]) {
                safeNodes.add(src);
            }
        }
        //output
        System.out.println("Safe nodes in sorted format: " + safeNodes);
    }

    private void numberOfProvince_Graph_HelperDFS(
            Map<Integer, List<Integer>> graph, int src, Set<Integer> visited) {
        if (visited.contains(src)) {
            return;
        }
        visited.add(src);
        for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {
            numberOfProvince_Graph_HelperDFS(graph, childVertex, visited);
        }
    }

    public void numberOfProvince_Graph(int[][] isConnected) {
        //https://leetcode.com/problems/number-of-provinces/
        //this questions is somewhat similar to number of islands problem
        //and actually based on graph connected components
        //acc to quest row or col is V
        int ROW = isConnected.length;
        int COL = isConnected[0].length;
        int provinces = 0;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();
        //all the vertices are 1-based thats why r + 1 and c + 1 is done here
        for (int r = 0; r < ROW; r++) {
            graph.putIfAbsent(r + 1, new ArrayList<>());
            for (int c = 0; c < COL; c++) {
                if (r != c && isConnected[r][c] == 1) {
                    graph.get(r + 1).add(c + 1);
                }
            }
        }

        for (int src = 1; src <= ROW; src++) {
            //a single dfs call from curr src will visit all of its
            //connected child vertices. In that way each time we are entring
            //below if cond that means we are going to do a dfs on a disconnected graph
            //ex: 1 = [2,3], 2 = [1], 3 = [1], 4 = []
            //graph : 1 <--> 2 <--> 3     4
            //two component [1,2,3], [4]
            if (!visited.contains(src)) {
                provinces++;
                numberOfProvince_Graph_HelperDFS(graph, src, visited);
            }
        }
        //output
        System.out.println("Number of provinces (number of disconnected graphs): " + provinces);
    }

    public void numberOfProvince_Graph_UnionFind(int[][] isConnected) {
        //https://leetcode.com/problems/number-of-provinces/
        //based on UNION FIND/ CONNECTED GRAPH COMPONENTS
        //acc to quest row or col is V
        int V = isConnected.length;

        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V + 1];
                rank = new int[V + 1];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int nod1, int node2) {
                int parent1 = find(nod1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                connectedGroups--;
            }

            public int numberOfProvinces() {
                return connectedGroups;
            }
        }

        UnionFind unionFind = new UnionFind(V);
        for (int src = 0; src < V; src++) {
            for (int dest = 0; dest < V; dest++) {
                if (src == dest) {
                    continue;
                }
                if (isConnected[src][dest] == 1) {
                    //1-based vertex
                    unionFind.union(src + 1, dest + 1);
                }
            }
        }
        //output
        System.out.println("Number of provinces (Union Find): " + unionFind.numberOfProvinces());
    }

    private void mostStonesRemovedInSameRowCol_Graph_DFS(int index, int[][] stones, boolean[] visited) {
        if (visited[index]) {
            return;
        }
        visited[index] = true;
        for (int i = 0; i < stones.length; i++) {
            if (visited[i]) {
                continue;
            }
            //visiting all those stones index whose either curr i-th index row or col
            //is same as curr index, this way we will do dfs on connected indexes
            //that are on same row or col and by dfs we will put these indexes in 
            //visited
            if (stones[index][0] == stones[i][0] || stones[index][1] == stones[i][1]) {
                mostStonesRemovedInSameRowCol_Graph_DFS(i, stones, visited);
            }
        }
    }

    public void mostStonesRemovedInSameRowCol_Graph(int[][] stones) {
        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/discuss/2813985/dfs-solution
        int n = stones.length;
        boolean[] visited = new boolean[n];
        int disconnectedIndexCount = 0;
        for (int i = 0; i < n; i++) {
            //if the curr i-th index is visited that means this i-th index
            //has been a part of a previous connected point(means belongs to same
            //row or col)
            if (visited[i]) {
                continue;
            }
            //if i-th index is not in visited that means this i-th index is a disconnected
            //index from a previously visited stones points
            disconnectedIndexCount++;
            mostStonesRemovedInSameRowCol_Graph_DFS(i, stones, visited);
        }
        System.out.println("Connected stones removed: " + (n - disconnectedIndexCount));
    }

    public void reorderPathsToMakeAllCitiesReachToCityZero_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/2449037/Easy-to-understand-BFS-solution-in-Java
        /*
        
        for ex: [0,1],[1,3],[2,3],[4,0],[4,5]
        graph = {0 = [-1, 4], 1 = [0, -3], 2 = [-3], 3 = [1, 2], 4 = [0, -5], 5 = [4]}
        src = 0
        BFS:
        ....................................0
        .........................[-ve]/............\[+ve]
        .............................1..............4
        ......................[vis]/...\[-ve].[vis]/.\[-ve]
        ..........................0.....3.........0...5
        ..........................[vis]/.\[+ve]........\[vis]
        ..............................1...2.............4
        ............................[vis]/
        ................................3
        each of the [-ve] edged childVertex needs to be reordered
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            //in actual (u --> v) edge, the dest vertex v
            //as an outgoing edge(u --> v) is add as -ve
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(-v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int pathReordered = 0;
        int src = 0;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();
        queue.add(src);

        while (!queue.isEmpty()) {

            int size = queue.size();
            for (int i = 0; i < size; i++) {

                int currSrc = queue.poll();

                visited.add(currSrc);

                for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {

                    int absChildVertex = Math.abs(childVertex);

                    //above intuition's [vis], no need to go to vertex
                    //that is already visited
                    if (visited.contains(absChildVertex)) {
                        continue;
                    }
                    //above intuition's [-ve], each time we see a -ve edge
                    //vertex we must reorder it, so that this edge(or path going from this edge)
                    //should reach to city zero(since our src = 0)
                    if (childVertex < 0) {
                        pathReordered++;
                    }
                    //since there are no actual -ve edges in input,
                    //we must add the childVertex in their abs form
                    queue.add(absChildVertex);
                }
            }
        }
        //output
        System.out.println("Path reordered: " + pathReordered);
    }

    public void minObstaclesRemovalToReachBottomRightCorner_Graph(int[][] grid) {
        //https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/
        //this quest is also like minimum path sum from top-left to bottom-right corner
        //but in binary matrix
        class Cell {

            int obstaclesRemoved;
            int row;
            int col;

            public Cell(int obstaclesRemoved, int row, int col) {
                this.obstaclesRemoved = obstaclesRemoved;
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        int initRow = 0;
        int initCol = 0;
        int initObstacleRemoved = 0;

        boolean[][] visited = new boolean[ROW][COL];

        //to remove obstacles in min way possible,choose the
        //min obstacles path
        Queue<Cell> minHeapObstacles = new PriorityQueue<>(
                (a, b) -> a.obstaclesRemoved - b.obstaclesRemoved);

        minHeapObstacles.add(new Cell(initObstacleRemoved, initRow, initCol));
        visited[initRow][initCol] = true;

        int minObstaclesRemoval = 0;

        while (!minHeapObstacles.isEmpty()) {

            Cell currCell = minHeapObstacles.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                minObstaclesRemoval = currCell.obstaclesRemoved;
                break;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if the new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if the new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                minHeapObstacles.add(new Cell(
                        currCell.obstaclesRemoved + grid[newRow][newCol],
                        newRow,
                        newCol));
            }
        }
        //output
        System.out.println("Min obstacles removal: " + minObstaclesRemoval);
    }

    public void shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
            int[][] grid, int k) {
        //https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
        //based on minObstaclesRemovalToReachBottomRightCorner_Graph()
        /*
        intution behind this solution, is to save the cell's data in queue.
        each cell value will also hold kThRemoval variable, this will denote while doing
        bfs if we reach a OBSTACLE( == 1) then we will count it as a movable path but
        since we are considering it as a movable path that means we have removed this OBSTACLE
        so for this removal we will increase the kThRemoval count by 1 for that cell.
        And whenever we encounter any other OBSTACLE in a given path we will simulate this 
        kThRemoval until kThRemoval <= k
         */
        class Cell {

            int dist;
            int row;
            int col;
            int kThRemoval;

            public Cell(int dist, int row, int col, int kThRemoval) {
                this.dist = dist;
                this.row = row;
                this.col = col;
                this.kThRemoval = kThRemoval;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int OBSTACLE = 1;
        int EMPTY_SPACE = 0;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        int initRow = 0;
        int initCol = 0;
        int initObstacle = 0;
        int initKThRemoval = 0;

        boolean[][][] visited = new boolean[ROW][COL][k + 1];

        Queue<Cell> queue = new PriorityQueue<>(
                (a, b) -> a.dist - b.dist);

        queue.add(new Cell(initObstacle, initRow, initCol, initKThRemoval));
        visited[initRow][initCol][k] = true;

        int shortestPathWithAtMostKObstacleRemoval = -1;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                shortestPathWithAtMostKObstacleRemoval = currCell.dist;
                break;
            }

            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if the new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //if this new row & col is an OBSTACLE but we can still try to 
                //remove this OBSTACLE because our currCell KThRemoval count is
                //greater than equal to k and also this  new row & col & (currCell.KThRemoval - 1)
                //combination path should not have previously visited, then we will
                //add it to queue and mark the state as visited means this OBSTACLE
                //will be count as a movable path
                if (grid[newRow][newCol] == OBSTACLE
                        && currCell.kThRemoval - 1 >= 0
                        && !visited[newRow][newCol][currCell.kThRemoval - 1]) {

                    visited[newRow][newCol][currCell.kThRemoval - 1] = true;
                    queue.add(new Cell(currCell.dist + 1, newRow, newCol, currCell.kThRemoval - 1));
                }

                //if this new row & col is an EMPY_SPACE, we can move normally,
                //we don't have removal restrictions on EMPTY_SPACE only thing we need to
                //check is the same new row & col with currKThRemoval is not visited previously
                if (grid[newRow][newCol] == EMPTY_SPACE
                        && ! !visited[newRow][newCol][currCell.kThRemoval]) {

                    visited[newRow][newCol][currCell.kThRemoval] = true;
                    queue.add(new Cell(currCell.dist + 1, newRow, newCol, currCell.kThRemoval));
                }
            }
        }
        //output
        System.out.println("Shortest path from top-left to bottom-right with atmost k obstacle removal: "
                + shortestPathWithAtMostKObstacleRemoval);

    }

    public void minHeightTrees_Graph_BruteForce(int V, int[][] edges) {
        //https://leetcode.com/problems/minimum-height-trees/
        //okay but it will give TLE
        List<Integer> minHeightTreeNodes = new ArrayList<>();
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int minLevel = Integer.MAX_VALUE;
        Set<Integer> visited;
        Queue<Integer> queue = new LinkedList<>();

        //for each src node u, we will consider that this u is the root of our
        //tree and we will do BFS(basically to calculate height) to min level
        for (int u = 0; u < V; u++) {

            visited = new HashSet<>();
            queue.add(u);
            int currLevel = 0;

            //perform a simple BFS on each src node u and calculate the level and
            //maintain the minLevel trees formed from all the src node u
            while (!queue.isEmpty()) {

                int size = queue.size();
                for (int i = 0; i < size; i++) {

                    int currSrc = queue.poll();

                    if (visited.contains(currSrc)) {
                        continue;
                    }

                    visited.add(currSrc);

                    for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {
                        queue.add(childVertex);
                    }
                }
                currLevel++;
            }
            //after each BFS from the curr src node u, we can compare the levels
            //formed with the minLevel, if we have seen a currLevel which is
            //now smaller than the prev minLevel, that means all the previousy
            //saved minHeightTreeNodes are not req, clear them, and save the new
            //new tree node starting from u
            if (currLevel < minLevel) {
                minLevel = currLevel;
                minHeightTreeNodes.clear();
                minHeightTreeNodes.add(u);
            } else if (currLevel == minLevel) {
                //if there are other tree nodes u that gives the same min tree height
                //also save them
                minHeightTreeNodes.add(u);
            }
        }
        //output
        System.out.println("Min height tree nodes(Brute force): " + minHeightTreeNodes);
    }

    public void minHeightTrees_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/minimum-height-trees/
        //edge case
        if (V < 2) {
            List<Integer> leaves = new ArrayList<>();
            for (int u = 0; u < V; u++) {
                leaves.add(u);
            }
            System.out.println("Min height tree nodes: " + leaves);
            return;
        }

        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        Queue<Integer> leaves = new LinkedList<>();

        for (int u = 0; u < V; u++) {
            if (graph.get(u).size() == 1) {
                leaves.add(u);
            }
        }

        while (V > 2) {
            V -= leaves.size();
            Queue<Integer> newLeaves = new LinkedList<>();

            for (int leaf : leaves) {

                for (int parentVertex : graph.getOrDefault(leaf, new ArrayList<>())) {
                    //for object removal, not the position wise removal
                    graph.get(parentVertex).remove((Integer) leaf);
                    if (graph.get(parentVertex).size() == 1) {
                        newLeaves.add(parentVertex);
                    }
                }
            }
            leaves = newLeaves;
        }

        //output
        System.out.println("Min height tree nodes: " + leaves);
    }

    private int uniquePaths_Graph_Memoization_DFS(
            int row, int col, int ROW, int COL, Integer[][] pathCountsCache) {

        //return 0, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        if (row == ROW - 1 && col == COL - 1) {
            return 1;
        }

        if (pathCountsCache[row][col] != null) {
            return pathCountsCache[row][col];
        }

        int currPathCount = 0;

        currPathCount += uniquePaths_Graph_Memoization_DFS(row + 1, col, ROW, COL, pathCountsCache);
        currPathCount += uniquePaths_Graph_Memoization_DFS(row, col + 1, ROW, COL, pathCountsCache);

        return pathCountsCache[row][col] = currPathCount;
    }

    public void uniquePaths_Graph_Memoization(int row, int col) {
        //https://leetcode.com/problems/unique-paths/
        //https://leetcode.com/problems/unique-paths-ii/
        Integer[][] pathCountsCache = new Integer[row][col];
        int uniquePathCount = uniquePaths_Graph_Memoization_DFS(0, 0, row, col, pathCountsCache);
        //output
        System.out.println("Unique paths count in given row & col grid: " + uniquePathCount);
    }

    public void uniquePathsThree_Graph(int[][] grid) {
        //https://leetcode.com/problems/unique-paths-iii/description/
        int ROW = grid.length;
        int COL = grid[0].length;

        int SRC_CELL = 1;
        int DEST_CELL = 2;
        int EMPTY_CELL = 0;
        int BLOCKED_CELL = -1;

        int srcRow = 0;
        int srcCol = 0;

        int totalCellToCoverInPath = 0;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        class Helper {

            int srcToDestPathCount = 0;

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void srcToDestPathCount(int[][] grid, int row, int col, int cellsLeftInPath) {

                //if the curr row & col cell is out of bounds or already visited or its a BLOCKED_CELL
                if (isOutOfBounds(row, col) || visited[row][col] || grid[row][col] == BLOCKED_CELL) {
                    return;
                }

                //when the curr row & col reaches the DEST_CELL, cells to cover in the path
                //should be 0, that means from src to dest we should have travelled all the cells
                //except those are BLOCKED_CELL
                if (grid[row][col] == DEST_CELL && cellsLeftInPath == 0) {
                    //successfully covered a path by covering all the cells
                    //means (1 -> all 0s -> 2)
                    srcToDestPathCount++;
                    return;
                }

                //for the curr on-going path this curr row & col is marked visited
                //so that we don't reach the same cell in DFS 
                visited[row][col] = true;

                for (int[] dir : dirs) {
                    int newRow = row + dir[0];
                    int newCol = col + dir[1];
                    srcToDestPathCount(grid, newRow, newCol, cellsLeftInPath - 1);
                }

                //once we have covered all the 4-dirs from this curr row & col
                //we can mark the curr row & col as un-visited
                visited[row][col] = false;
            }

        }

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == SRC_CELL) {
                    srcRow = r;
                    srcCol = c;
                } else if (grid[r][c] == EMPTY_CELL) {
                    totalCellToCoverInPath++;
                }
            }
        }

        //add 1 because path is to be counted from src and should end at dest cell
        //by the time the dfs reaches the dest-cell totalCellToCoverInPath should be 0
        totalCellToCoverInPath += SRC_CELL;

        Helper helper = new Helper();

        helper.srcToDestPathCount(grid, srcRow, srcCol, totalCellToCoverInPath);
        //output
        System.out.println("Unique paths count from src to dest covering all empty cells: " + helper.srcToDestPathCount);
    }

    public void parallelCourseThree_Graph(int V, int[][] edges, int[] time) {
        //https://leetcode.com/problems/parallel-courses-iii/
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[V];
        for (int[] edge : edges) {
            //to used it as 0-based index that's why -1
            int u = edge[0] - 1;
            int v = edge[1] - 1;

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
            //all the vertex who have incoming edges to them
            indegree[v]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        int[] completionTime = new int[V];

        for (int u = 0; u < V; u++) {
            //for all those vertexes who don't have any incoming edges to them
            //they can be taken first individually
            if (indegree[u] == 0) {
                completionTime[u] = time[u];
                queue.add(u);
            }
        }

        int minTimeUsed = 0;

        while (!queue.isEmpty()) {
            int src = queue.poll();
            minTimeUsed = Math.max(minTimeUsed, completionTime[src]);
            for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {

                completionTime[childVertex] = Math.max(
                        completionTime[childVertex], completionTime[src]);

                indegree[childVertex]--;

                if (indegree[childVertex] == 0) {
                    completionTime[childVertex] += time[childVertex];
                    queue.add(childVertex);
                }
            }
        }
        //output
        System.out.println("Min time used to complete the course: " + minTimeUsed);
    }

    public void parallelCourseThree_Graph_TopologicalSort(int V, int[][] edges, int[] time) {
        //https://leetcode.com/problems/parallel-courses-iii/
        //based on GRAPH TOPOLOGICAL SORT
        Map<Integer, List<Integer>> graph = new HashMap<>();
        boolean[] visited = new boolean[V];
        List<Integer> topoSort = new ArrayList<>();
        int[] completionTime = new int[V];

        class Helper {

            void topoSortHelper(int vertex, List<Integer> topoSort) {

                visited[vertex] = true;

                for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
                    //skip, if the child vertex is already visited
                    if (visited[childVertex]) {
                        continue;
                    }
                    topoSortHelper(childVertex, topoSort);
                }

                topoSort.add(vertex);
            }
        }

        Helper helper = new Helper();

        //create graph
        for (int[] edge : edges) {
            //to used it as 0-based index that's why -1
            int u = edge[0] - 1;
            int v = edge[1] - 1;
            //directed graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        //do a topoSort on the graph vertex, the graph can be disconnected
        //hence we need to loop over all the vetices of the graph
        for (int u = 0; u < V; u++) {
            //skip, if the curr src vertex == u is already visited in some previous
            //topo sort dfs call
            if (visited[u]) {
                continue;
            }
            helper.topoSortHelper(u, topoSort);
        }

        //by reverse we will get the most independent course first, course that
        //must be taken first before any other course
        Collections.reverse(topoSort);

        //loop over all the course in topo sort
        for (int i = 0; i < topoSort.size(); i++) {
            //get the first independent course that must be taken first before
            //any other course
            int course = topoSort.get(i);
            //initial completion time for each course
            completionTime[course] = time[course];
        }

        for (int i = 0; i < topoSort.size(); i++) {
            //get the first independent course that must be taken first before
            //any other course
            int course = topoSort.get(i);

            //in order to complete curr 'course', we might need to complete
            //child course first, hence we need to calculate the max time taken
            //for the curr 'childCourse'
            for (int childCourse : graph.getOrDefault(course, new ArrayList<>())) {

                if (completionTime[childCourse] < completionTime[course] + time[childCourse]) {

                    completionTime[childCourse] = completionTime[course] + time[childCourse];
                }
            }
        }

        int minTimeUsed = 0;

        for (int timeTaken : completionTime) {
            minTimeUsed = Math.max(minTimeUsed, timeTaken);
        }

        //output
        System.out.println("Min time used to complete the course (using topological sort): " + minTimeUsed);
    }

    public int shortestPathInBinaryMatrix_Graph(int[][] grid) {
        //https://leetcode.com/problems/shortest-path-in-binary-matrix/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1
        //based on BFS
        //our shortest path should go from 0 in binary matrix, 1 means block
        class Cell {

            int cost;
            int row;
            int col;

            public Cell(int cost, int row, int col) {
                this.cost = cost;
                this.row = row;
                this.col = col;
            }

        }
        int ROW = grid.length;
        int COL = grid[0].length;

        if (grid[0][0] == 1 || grid[ROW - 1][COL - 1] == 1) {
            return -1;
        }

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1},
            {-1, -1},
            {-1, 1},
            {1, -1},
            {1, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        //to choose the shortest path from (0,0) to (ROW - 1, COL - 1)
        //minHeap cost to pick the shortest path of all possibility
        PriorityQueue<Cell> queue = new PriorityQueue<>((a, b) -> a.cost - b.cost);
        //curr cost, curr row, curr col
        queue.add(new Cell(1, 0, 0));
        visited[0][0] = true;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.cost;
            }

            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //if new row & col is isOutOfBounds
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL
                        //if new row & col is blocked ( == 1)
                        || grid[newRow][newCol] == 1
                        //if new row & col is previously visited
                        || visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                queue.add(new Cell(currCell.cost + 1, newRow, newCol));
            }
        }
        return -1;
    }

    public boolean satisfiabilityOfEqualityEquation_Graph(String[] equations) {
        //https://leetcode.com/problems/satisfiability-of-equality-equations/
        //https://leetcode.com/problems/satisfiability-of-equality-equations/discuss/2625039/LeetCode-The-Hard-Way-Explained-Line-By-Line
        //based on UNION-FIND DISJOINT SET
        class UnionFind {

            int[] parent;
            int[] rank;

            public UnionFind() {
                parent = new int[26];
                rank = new int[26];
                for (int node = 0; node < 26; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind();

        for (String eqn : equations) {
            if (eqn.charAt(1) == '=') {
                int nodeU = eqn.charAt(0) - 'a';
                int nodeV = eqn.charAt(3) - 'a';
                unionFind.union(nodeU, nodeV);
            }
        }

        for (String eqn : equations) {
            if (eqn.charAt(1) == '!') {
                int nodeU = eqn.charAt(0) - 'a';
                int nodeV = eqn.charAt(3) - 'a';
                if (unionFind.find(nodeU) == unionFind.find(nodeV)) {
                    return false;
                }
            }
        }
        return true;
    }

    public void countReachableNodesWithRestrictions_Graph(int[][] edges, int[] restrictions) {
        //https://leetcode.com/problems/reachable-nodes-with-restrictions/
        Set<Integer> blocked = new HashSet<>(IntStream
                .of(restrictions)
                .boxed()
                .collect(Collectors.toSet()));
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();

        queue.add(root);
        visited.add(root);

        int count = 0;

        while (!queue.isEmpty()) {

            root = queue.poll();

            if (!blocked.contains(root)) {
                count++;
            }

            for (int childVertex : graph.getOrDefault(root, new ArrayList<>())) {
                if (visited.contains(childVertex) || blocked.contains(childVertex)) {
                    continue;
                }

                visited.add(childVertex);
                queue.add(childVertex);
            }
        }
        //output
        System.out.println("All the reachable nodes after the given node restrictions: " + count);
    }

    public void asFarFromLandAsPossible_Graph(int[][] grid) {
        //https://leetcode.com/problems/as-far-from-land-as-possible/
        //https://leetcode.com/problems/as-far-from-land-as-possible/discuss/360963/C%2B%2B-with-picture-DFS-and-BFS
        //based on BFS and somewhat similar to rottenOranges_HashBased()
        class Cell {

            int row;
            int col;
            int dist;

            public Cell(int row, int col, int dist) {
                this.row = row;
                this.col = col;
                this.dist = dist;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        boolean[][] visited = new boolean[ROW][COL];

        Queue<Cell> currLandCells = new LinkedList<>();
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 1) {
                    currLandCells.add(new Cell(r, c, 1));
                    visited[r][c] = true;
                }
            }
        }

        Queue<Cell> nextReachableLandCells = new LinkedList<>();
        int maxDist = 0;

        while (!currLandCells.isEmpty()) {

            Cell currLand = currLandCells.poll();

            int srcRow = currLand.row;
            int srcCol = currLand.col;

            maxDist = Math.max(maxDist, currLand.dist);

            //for the curr land cell coord (srcRow, srcCol) we are only traversing
            //its immediate 4-neighbour, if its a water cell then we can reach
            //there by dist of currLand.dist + 1
            for (int[] dir : dirs) {
                int newRow = srcRow + dir[0];
                int newCol = srcCol + dir[1];

                //isOutOfBounds
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL
                        || visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                nextReachableLandCells.add(new Cell(newRow, newCol, currLand.dist + 1));
            }

            //once we have traversed all the land cells of the curr land cells
            //coord  and currLandCells queue is empty beacuse of that then only
            //add all the new reachable land cells to the next traversable land
            //cells
            if (currLandCells.isEmpty()) {
                currLandCells.addAll(nextReachableLandCells);
                nextReachableLandCells.clear();
            }
        }
        //output
        System.out.println("Farthest water cell from the land cell: " + (maxDist == 1 ? -1 : maxDist - 1));
    }

    public int minGeneticMutation_Graph(String start, String end, List<String> bank) {
        //https://leetcode.com/problems/minimum-genetic-mutation/
        //based on BFS
        Set<String> geneBank = new HashSet<>(bank);
        if (!geneBank.contains(end)) {
            return -1;
        }

        Set<Character> genes = new HashSet<>();
        genes.add('A');
        genes.add('C');
        genes.add('G');
        genes.add('T');

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        queue.add(start);
        visited.add(start);

        int mutation = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                String currGene = queue.poll();

                if (end.equals(currGene)) {
                    return mutation;
                }

                char[] currGeneArr = currGene.toCharArray();

                //try to generate all the possible genes from the
                //currGene by changing each char at each j-th position
                for (int j = 0; j < currGene.length(); j++) {
                    char original = currGeneArr[j];
                    for (char gene : genes) {

                        currGeneArr[j] = gene;
                        String newGene = String.valueOf(currGeneArr);
                        //if the new gene combination is not in given bank or it
                        //is already visited then continue
                        if (!geneBank.contains(newGene) || visited.contains(newGene)) {
                            continue;
                        }
                        queue.add(newGene);
                        visited.add(newGene);
                    }
                    //after generating all the possible gene by trying out all the
                    //chars at curr j-th position place the original char at j-th
                    //position
                    currGeneArr[j] = original;
                }
            }
            mutation++;
        }
        return -1;
    }

    public int wordLadder_Graph(String startWord, String endWord, List<String> wordList) {
        //https://leetcode.com/problems/word-ladder/
        //based on BFS & minGeneticMutation_Graph()
        Set<String> words = new HashSet<>(wordList);
        if (!words.contains(endWord)) {
            return 0;
        }

        Set<String> visited = new HashSet<>();
        Queue<String> queue = new LinkedList<>();

        queue.add(startWord);
        visited.add(startWord);

        int ladder = 1;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                String currWord = queue.poll();

                if (endWord.equals(currWord)) {
                    return ladder;
                }

                char[] currWordArr = currWord.toCharArray();

                //try to generate all the possible words from the
                //currWord by changing each char at each j-th position
                for (int j = 0; j < currWord.length(); j++) {
                    char original = currWordArr[j];
                    for (char ch = 'a'; ch <= 'z'; ch++) {

                        currWordArr[j] = ch;
                        String newWord = String.valueOf(currWordArr);
                        //if the new word is not in given wordList or it is already
                        //visited then continue
                        if (!words.contains(newWord) || visited.contains(newWord)) {
                            continue;
                        }
                        queue.add(newWord);
                        visited.add(newWord);
                    }
                    //after generating all the possible words by trying out all the
                    //chars at curr j-th position place the original char at j-th
                    //position
                    currWordArr[j] = original;
                }
            }
            ladder++;
        }
        return 0;
    }

    private int whereWillTheBallsFall_Graph_GetLocation(int[][] board, int row, int currBallCol) {
        //ball reaches the end of board, return the final location of ball
        if (row == board.length) {
            return currBallCol;
        }

        //nextBallCol = currBallCol + dirFrom(baord[row][currBallCol])
        int nextBallCol = currBallCol + board[row][currBallCol];

        //hitting the left-edge wall, how?
        //if currBallCol = 0 and dir = -1 means slide-to-left-diagonal-col
        //nextBallCol = 0 + -1 = -1 < 0, board left-edge wall
        if (nextBallCol < 0
                //hitting the right-edge wall, how?
                //if currBallCol = COL - 1 and dir = 1 means slide-to-right-diagonal-col
                //nextBallCol = (COL - 1) + 1 = COL >= 0, board right-edge wall
                || nextBallCol >= board[0].length
                //blocked within 'V' shape, how?
                //if the ball reaches a point where the next move is not
                //possible by forming 'V' block i.e, [-1, 1] or [1, -1]
                || board[row][currBallCol] != board[row][nextBallCol]) {
            return -1;
        }
        //if not blocked above move the ball to nextBallCol but its a
        //slide-to-[left/right]-diagonal movement that means also move to row + 1
        return whereWillTheBallsFall_Graph_GetLocation(board, row + 1, nextBallCol);
    }

    public void whereWillTheBallsFall_Graph(int[][] board) {
        //https://leetcode.com/problems/where-will-the-ball-fall/
        //https://leetcode.com/problems/where-will-the-ball-fall/solution/
        //based on DFS
        int ROW = board.length;
        int COL = board[0].length;
        int[] lastLocation = new int[COL];
        for (int ball = 0; ball < COL; ball++) {
            lastLocation[ball] = whereWillTheBallsFall_Graph_GetLocation(board, 0, ball);
        }
        //output
        System.out.println("Ball's final location: " + Arrays.toString(lastLocation));
    }

    private boolean wordSearchTwo_Graph_DFSHelper(char[][] board, int row, int col, int wordIndex, String word) {
        if (wordIndex == word.length()) {
            return true;
        }

        //isOutOfBounds
        if (row < 0 || row >= board.length || col < 0 || col >= board[row].length
                || board[row][col] == '.'
                || wordIndex > word.length()
                || board[row][col] != word.charAt(wordIndex)) {
            return false;
        }

        char original = board[row][col];
        board[row][col] = '.';

        boolean found = false;
        found = found || wordSearchTwo_Graph_DFSHelper(board, row - 1, col, wordIndex + 1, word);
        found = found || wordSearchTwo_Graph_DFSHelper(board, row + 1, col, wordIndex + 1, word);
        found = found || wordSearchTwo_Graph_DFSHelper(board, row, col - 1, wordIndex + 1, word);
        found = found || wordSearchTwo_Graph_DFSHelper(board, row, col + 1, wordIndex + 1, word);

        board[row][col] = original;

        return found;
    }

    public void wordSearchTwo_Graph(char[][] board, String[] words) {
        //https://leetcode.com/problems/word-search-ii/
        //based on DFS, but it was giving TLE for long inputs
        List<String> matched = new ArrayList<>();

        int ROW = board.length;
        int COL = board[0].length;

        for (String word : words) {

            int wordIndex = 0;
            boolean found = false;
            for (int r = 0; r < ROW; r++) {
                for (int c = 0; c < COL; c++) {
                    if (board[r][c] == word.charAt(wordIndex)) {
                        if (wordSearchTwo_Graph_DFSHelper(board, r, c, wordIndex, word)) {
                            matched.add(word);
                            found = true;
                            break;
                        }
                    }
                }
                if (found) {
                    break;
                }
            }
        }

        //output
        System.out.println("Words that are found in matrix (DFS): " + matched);
    }

    public void wordSearchTwo_Graph_TrieBased(char[][] board, String[] words) {
        //https://leetcode.com/problems/word-search-ii/
        class TrieNode {

            Map<Character, TrieNode> map;
            boolean isEnd;
            String word;

            public TrieNode() {
                this.map = new HashMap<>();
                this.isEnd = false;
                this.word = "";
            }

        }

        class TrieUtil {

            TrieNode ROOT;

            public TrieUtil(TrieNode ROOT) {
                this.ROOT = ROOT;
            }

            void addToTrie(String word) {
                TrieNode currNode = ROOT;
                for (char ch : word.toCharArray()) {
                    if (currNode.map.containsKey(ch)) {
                        currNode = currNode.map.get(ch);
                    } else {
                        TrieNode node = new TrieNode();
                        currNode.map.put(ch, node);
                        currNode = node;
                    }
                }
                currNode.isEnd = true;
                currNode.word = word;
            }

            /*
            how trie based approach is working here?
            first, from the given words[] we will create the trie structure.
            then we will loop over the matrix and char at each matrix[row][col]
            we will check if this char can be used to from a word already in the trie (prefix check),
            if yes, we will move char by char in all four dir of matrix and check
            which char will help in forming a word(char that get add up to form prefix of the word)
            because by the end of forming a word we will reach the root.isEnd for
            that word and there we can add that word in our result list also we
            will mark this word isEnd as false so that we dont get the same word again and again
            (how we can get the same word again and again? the matrix may contain
            the same char at different row & col locations that will match
            initial or complete prefix part of word in trie, so if we reach the same
            word more than once its isEnd need to be marked as false.
            so when we first time reach a word's end or root.isEnd == true mark it as false)
            
             */
            void searchWordFromMatrix(char[][] board, int row, int col, TrieNode root, List<String> matched) {

                if (root.isEnd) {
                    matched.add(root.word);
                    root.isEnd = false;
                }

                //isOutOfBounds
                if (row < 0 || row >= board.length || col < 0 || col >= board[row].length
                        || board[row][col] == '.'
                        || !root.map.containsKey(board[row][col])) {
                    return;
                }

                char originalLetter = board[row][col];
                board[row][col] = '.';

                searchWordFromMatrix(board, row - 1, col, root.map.get(originalLetter), matched);
                searchWordFromMatrix(board, row + 1, col, root.map.get(originalLetter), matched);
                searchWordFromMatrix(board, row, col - 1, root.map.get(originalLetter), matched);
                searchWordFromMatrix(board, row, col + 1, root.map.get(originalLetter), matched);

                board[row][col] = originalLetter;
            }

        }

        TrieNode ROOT = new TrieNode();
        TrieUtil trieUtil = new TrieUtil(ROOT);

        List<String> matched = new ArrayList<>();

        int ROW = board.length;
        int COL = board[0].length;

        for (String word : words) {
            trieUtil.addToTrie(word);
        }

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                trieUtil.searchWordFromMatrix(board, r, c, ROOT, matched);
            }
        }

        //output
        System.out.println("Words that are found in matrix (Trie Based): " + matched);
    }

    public int nearestExitFromMaze_Graph(char[][] maze, int[] entrance) {
        //https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/

        class Cell {

            int row;
            int col;
            int dist;

            public Cell(int row, int col, int dist) {
                this.row = row;
                this.col = col;
                this.dist = dist;
            }

        }

        int ROW = maze.length;
        int COL = maze[0].length;

        int TOP_EDGE = 0;
        int BOTTOM_EDGE = ROW - 1;
        int LEFT_EDGE = 0;
        int RIGHT_EDGE = COL - 1;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        int srcRow = entrance[0];
        int srcCol = entrance[1];
        int srcDist = 0;

        boolean[][] visited = new boolean[ROW][COL];

        //queue to maintain the shortest dist (minHeapDist)
        Queue<Cell> queue = new PriorityQueue<>((a, b) -> a.dist - b.dist);

        queue.add(new Cell(srcRow, srcCol, srcDist));
        visited[srcRow][srcCol] = true;

        while (!queue.isEmpty()) {

            Cell currCell = queue.poll();

            //should not consider the currCell row & col if they are same as
            //entrance[] points
            boolean isSameAsEntrance = (currCell.row == srcRow && currCell.col == srcCol);

            //curr coord should not be same as entrance coord even if that is on edge 
            if (!isSameAsEntrance
                    //curr coord should be an empty cell( == '.')
                    && maze[currCell.row][currCell.col] == '.'
                    //curr coord should be at any edge of maze to exit
                    && (currCell.row == TOP_EDGE
                    || currCell.row == BOTTOM_EDGE
                    || currCell.col == LEFT_EDGE
                    || currCell.col == RIGHT_EDGE)) {
                return currCell.dist;
            }

            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //isOutOfBounds
                if ((newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL)
                        //if curr coord is wall( == '+')
                        || maze[newRow][newCol] == '+'
                        || visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;
                queue.add(new Cell(newRow, newCol, currCell.dist + 1));
            }
        }
        return -1;
    }

    public void nodesWithHighestEdgeScore_Graph(int[] edges) {
        //https://leetcode.com/problems/node-with-highest-edge-score/
        int nodes = edges.length;
        long[] indegreeScores = new long[nodes];
        for (int i = 0; i < nodes; i++) {
            indegreeScores[edges[i]] += i;
        }

        int resultIndex = -1;
        long maxEdgeScore = Long.MIN_VALUE;
        for (int i = 0; i < nodes; i++) {
            if (indegreeScores[i] > maxEdgeScore) {
                maxEdgeScore = indegreeScores[i];
                resultIndex = i;
            }
        }
        //output
        System.out.println("Node with max edge score: " + resultIndex);
    }

    private long countUnreachablePairOfNodes_Graph_Helper(
            Map<Integer, List<Integer>> graph, Set<Integer> visited, int vertex) {
        //here we will count all the nodes that connected in the given graph
        visited.add(vertex);
        long connectedNodesCount = 1;
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (visited.contains(childVertex)) {
                continue;
            }
            connectedNodesCount += countUnreachablePairOfNodes_Graph_Helper(graph, visited, childVertex);
        }
        return connectedNodesCount;
    }

    public void countUnreachablePairOfNodes_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/
        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solutions/2195836/fully-explained-simple-logic-connected-component-dfs-cpp/
        /*
        graph: n = 5, edges: [[0, 1],[1, 2], [0, 2], [3, 4]]
        undirected graph: 0 ---- 1
        ...................\..../
        .....................2
        .........................
        .........................
        ...................3 --- 4
        
        there 2 disconnected graphs in the given graph
        DFS helper method will count the nodes in each of disconnected graph
        1. starting from any of nodes = 0, 1 or 2 connectedNodesCount will be 3 as 3 nodes are there
        in this that are connected
        pairs += connectedNodesCount * (n - connectedNodesCount)
                   3 * (5 - 3)
        means curr nodes count paired with rest of remaining nodes in graph
        3 * 2 = 6
        
        2. starting from any of nodes = 3 or 4 connectedNodesCount will be 3 as 3 nodes are there
        in this that are connected
        pairs += connectedNodesCount * (n - connectedNodesCount)
                   2 * (5 - 2)
        means curr nodes count paired with rest of remaining nodes in graph
        2 * 3 = 6
        
        using this we ae counting pairs twice thats why output pair should be / 2
        
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        long pairs = 0;
        //in the for loop we will count nodes of connected nodes of sub-graph
        //in the disconnected graph
        for (int u = 0; u < n; u++) {
            if (visited.contains(u)) {
                continue;
            }
            //if the curr src == u is not visited that means this u will be
            //a part of separate disconnected graph then we will do DFS on this
            //to count all the nodes that are connected in this disconnected graph
            long connectedNodesCount = countUnreachablePairOfNodes_Graph_Helper(graph, visited, u);
            pairs += (connectedNodesCount * (n - connectedNodesCount));
        }
        //output
        System.out.println("Count of pairs of nodes that are unreachable from each other: " + (pairs / 2l));
    }

    public int shortestBridge_Graph(int[][] grid) {
        //https://leetcode.com/problems/shortest-bridge/description/
        //https://leetcode.com/problems/shortest-bridge/solutions/189235/java-bidirectional-bfs/
        //based on Number of islands, DFS, BI-DIRECTION BFS
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        int ISLAND = 1;
        int VISITED_BY_ISLAND_A = 2;
        int VISITED_BY_ISLAND_B = 3;

        //as there are going to be 2 islands in the grid[][], between which we need
        //to make the bridge
        //island A will hold cell for all the '1' as part of connected island A 
        Queue<Cell> islandA = new LinkedList<>();
        //island B will hold cell for all the '1' as part of connected island B
        Queue<Cell> islandB = new LinkedList<>();

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void numberOfIsland_DFS_Helper(int[][] grid, int row, int col, Queue<Cell> island, int VISITED) {
                if (isOutOfBounds(row, col) || grid[row][col] != ISLAND) {
                    return;
                }

                grid[row][col] = VISITED;

                island.add(new Cell(row, col));

                numberOfIsland_DFS_Helper(grid, row - 1, col, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row + 1, col, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row, col - 1, island, VISITED);
                numberOfIsland_DFS_Helper(grid, row, col + 1, island, VISITED);
            }

        }

        Helper helper = new Helper();

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (grid[r][c] == 1) {
                    //if island A is empty then we fill all the cell coord for island A
                    //then we move to fill the cell coord for island B
                    if (islandA.isEmpty()) {
                        //since firstly we fill cells for island A, then we mark all
                        //the connected island parts with VISITED_BY_ISLAND_A (also
                        // says the this whole group is island A)
                        helper.numberOfIsland_DFS_Helper(grid, r, c, islandA, VISITED_BY_ISLAND_A);
                    } else {
                        //since secondly we fill cells for island B, then we mark all
                        //the connected island parts with VISITED_BY_ISLAND_B (also
                        // says the this whole group is island B)
                        helper.numberOfIsland_DFS_Helper(grid, r, c, islandB, VISITED_BY_ISLAND_B);
                    }
                }
            }
        }

        //bi-direction BFS
        //our goal with bi-directional BFS is that, since we have two set of island
        //groups A & B in grid[][], we make a move from both the islands at same
        //time so that when either A touch B OR B touch A at a particular cell, the
        //dist calculated till that touch point is the shortest bridge
        int dist = 0;
        while (!islandA.isEmpty() && !islandB.isEmpty()) {

            //doing BFS from island A side
            int sizeA = islandA.size();
            for (int i = 0; i < sizeA; i++) {

                Cell currCell = islandA.poll();

                for (int[] dir : dirs) {

                    int newRow = currCell.row + dir[0];
                    int newCol = currCell.col + dir[1];

                    //skip if new row & col is out of bounds
                    //OR this new row & col is already a part of the same island A
                    if (helper.isOutOfBounds(newRow, newCol)
                            || grid[newRow][newCol] == VISITED_BY_ISLAND_A) {
                        continue;
                    }

                    //this if block is the point where if A is making a move
                    //and it touches the a cell that is already visited by island B
                    //that means the shortest bridge between these 2 islands is dist
                    //here A touch B
                    if (grid[newRow][newCol] == VISITED_BY_ISLAND_B) {
                        return dist;
                    }

                    //here in this move, island A is currently making a next move
                    //form currCell, so if the above new row & col was not previoulsy
                    //visited by island A and also not visited by island B then this
                    //new row & col is just touched by island A only so mark it 
                    //VISITED_BY_ISLAND_A (cell occupied by island A)
                    grid[newRow][newCol] = VISITED_BY_ISLAND_A;
                    islandA.add(new Cell(newRow, newCol));
                }
            }

            //doing BFS from island B side
            int sizeB = islandB.size();
            for (int i = 0; i < sizeB; i++) {

                Cell currCell = islandB.poll();

                for (int[] dir : dirs) {

                    int newRow = currCell.row + dir[0];
                    int newCol = currCell.col + dir[1];

                    //skip if new row & col is out of bounds
                    //OR this new row & col is already a part of the same island B
                    if (helper.isOutOfBounds(newRow, newCol)
                            || grid[newRow][newCol] == VISITED_BY_ISLAND_B) {
                        continue;
                    }

                    //this if block is the point where if B is making a move
                    //and it touches the a cell that is already visited by island A
                    //that means the shortest bridge between these 2 islands is dist + 1
                    //here B touch A
                    if (grid[newRow][newCol] == VISITED_BY_ISLAND_A) {
                        return dist + 1;
                    }

                    //here in this move, island B is currently making a next move
                    //form currCell, so if the above new row & col was not previoulsy
                    //visited by island B and also not visited by island A then this
                    //new row & col is just touched by island B only so mark it 
                    //VISITED_BY_ISLAND_B (cell occupied by island B)
                    grid[newRow][newCol] = VISITED_BY_ISLAND_B;
                    islandB.add(new Cell(newRow, newCol));
                }
            }

            //since both island A & island B are moving simultaneously
            //in the single BFS move, both are travelling 1 dist from their
            //respec currCells, so 1 move from island A cell & 1 move from island B cell
            //adds up to +2 dist move 
            dist += 2;
        }
        return 1;
    }

    public void detonateMaxBombs_Graph(int[][] bombs) {
        //https://leetcode.com/problems/detonate-the-maximum-bombs/description/
        //https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/1623297/python-bfs-dfs-start-with-every-point-explanation/
        //based on BFS
        int n = bombs.length;
        int X = 0;
        int Y = 1;
        int RADIUS = 2;
        Map<Integer, List<Integer>> graph = new HashMap<>();

        //create the directed graph where a bomb[v] coord falls under the area of
        //bomb[u], that means if bomb[u] is started with detonation then all the
        //v-index bombs connected to u-index bomb will be exploded
        //why directed? because if bomb[u] is able to explode bomb[v] it is not
        //always true that bomb[v] can also explode bomb[u] because of the dist
        //& radius range between them, as bomb[v] radius might be so small that
        //it is not able to cover the dist to bomb[u] hence graph become directed
        for (int u = 0; u < n; u++) {
            for (int v = 0; v < n; v++) {
                if (u == v) {
                    continue;
                }

                int[] bombU = bombs[u];
                int[] bombV = bombs[v];

                long xSqr = (long) Math.pow(bombU[X] - bombV[X], 2);
                long ySqr = (long) Math.pow(bombU[Y] - bombV[Y], 2);

                //euclidean dist between the 2 centers coords (dist^2 = (x2- x1)^2 + (y2 - y1)^2)
                //of curr bomb[u] and curr bomb[v]
                long distance = xSqr + ySqr;

                long areaOfBombU = (long) Math.pow(bombU[RADIUS], 2);

                //if the dist between the 2 centers coords is covered under the
                //bomb[u] radius range
                if (distance <= areaOfBombU) {
                    graph.putIfAbsent(u, new ArrayList<>());
                    graph.get(u).add(v);
                }
            }
        }

        int maxExplode = 0;
        Set<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new LinkedList<>();

        //if srcBomb is the bomb that if detonated then from this point how many
        //bombs that can be chain-exploded, choose the maxExplode
        for (int srcBomb = 0; srcBomb < n; srcBomb++) {

            visited.clear();
            queue.clear();

            queue.add(srcBomb);
            visited.add(srcBomb);

            int explode = 0;

            while (!queue.isEmpty()) {

                int currBomb = queue.poll();

                for (int childBomb : graph.getOrDefault(currBomb, new ArrayList<>())) {
                    if (visited.contains(childBomb)) {
                        continue;
                    }

                    visited.add(childBomb);
                    queue.add(childBomb);
                }
                explode++;
            }
            maxExplode = Math.max(maxExplode, explode);
        }

        //output
        System.out.println("Detonate max bombs: " + maxExplode);
    }

    public void findAllGroupOfFarmland_Graph(int[][] land) {
        //https://leetcode.com/problems/find-all-groups-of-farmland/description/
        //based on numberOfIsland(), DFS
        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = land.length;
        int COL = land[0].length;

        //number of islands helper
        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            void numberOfIsland(int[][] land, int row, int col, Cell bottomRight) {
                if (isOutOfBounds(row, col) || land[row][col] != 1) {
                    return;
                }

                //find the farthest posiible row & col of farmland (== 1)
                bottomRight.row = Math.max(bottomRight.row, row);
                bottomRight.col = Math.max(bottomRight.col, col);

                //curr farmland at row & col is visited
                land[row][col] = 0;

                //DFS on curr farmland to go in depth/far of the land
                //to find the max row & col of this farmland
                numberOfIsland(land, row - 1, col, bottomRight);
                numberOfIsland(land, row + 1, col, bottomRight);
                numberOfIsland(land, row, col - 1, bottomRight);
                numberOfIsland(land, row, col + 1, bottomRight);
            }
        }

        //contains the top-left and bottom-right row & col in int[] for
        //all the farm/ island
        List<int[]> groupsOfFarmland = new ArrayList<>();
        Helper helper = new Helper();

        for (int topLeftRow = 0; topLeftRow < ROW; topLeftRow++) {
            for (int topLeftCol = 0; topLeftCol < COL; topLeftCol++) {
                if (land[topLeftRow][topLeftCol] == 1) {
                    //starting from topLeftRow & topLeftCol as the start point
                    //find the farthest row and col of this farm/ island
                    //in the bottomRight.
                    Cell bottomRight = new Cell(topLeftRow, topLeftCol);
                    helper.numberOfIsland(land, topLeftRow, topLeftRow, bottomRight);
                    groupsOfFarmland.add(new int[]{topLeftRow, topLeftCol, bottomRight.row, bottomRight.col});
                }
            }
        }
        //output
        //return coord.toArray(new int[coord.size()][]);
        groupsOfFarmland.stream().forEach(farmCoord -> System.out.println(Arrays.toString(farmCoord)));
        System.out.println();
    }

    private void sumOfDistancesInTree_Graph_DFS1(Map<Integer, List<Integer>> graph,
            int[] distances, int[] count, int vertex, int parent) {
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (childVertex == parent) {
                continue;
            }
            sumOfDistancesInTree_Graph_DFS1(graph, distances, count, childVertex, vertex);
            count[vertex] += count[childVertex];
            distances[vertex] += distances[childVertex] + count[childVertex];
        }
    }

    private void sumOfDistancesInTree_Graph_DFS2(Map<Integer, List<Integer>> graph,
            int[] distances, int[] count, int vertex, int parent, int n) {
        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            if (childVertex == parent) {
                continue;
            }
            distances[childVertex] = distances[vertex] - count[childVertex] + n - count[childVertex];
            sumOfDistancesInTree_Graph_DFS2(graph, distances, count, childVertex, vertex, n);
        }
    }

    public void sumOfDistancesInTree_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/sum-of-distances-in-tree/description/
        //https://leetcode.com/problems/sum-of-distances-in-tree/solutions/130611/sum-of-distances-in-tree/
        int[] distances = new int[n];
        int[] count = new int[n];

        Arrays.fill(count, 1);

        Map<Integer, List<Integer>> graph = new HashMap<>();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        sumOfDistancesInTree_Graph_DFS1(graph, distances, count, 0, -1);
        sumOfDistancesInTree_Graph_DFS2(graph, distances, count, 0, -1, n);
        //output
        System.out.println("Sum of distances in tree: " + Arrays.toString(distances));
    }

    public void allAncestorsOfAllNodesInDAG_Graph(int n, int[][] edges) {
        //https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/
        //based on BFS
        List<List<Integer>> ancestors = new ArrayList<>();
        //here create a graph that will hold the relation of child -> [parents]
        Map<Integer, Set<Integer>> parentGraph = new HashMap<>();
        for (int[] edge : edges) {
            //u == parent
            int u = edge[0];
            //v == child
            int v = edge[1];

            parentGraph.putIfAbsent(v, new HashSet<>());
            //child -> [parents]
            parentGraph.get(v).add(u);
        }

        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();

        for (int v = 0; v < n; v++) {
            queue.clear();
            visited.clear();

            queue.add(v);
            visited.add(v);

            //here v == child node, we will find all the ancestors of this
            //child node using BFS
            //TreeSet is used here to keep all the ancestor of curr child node
            //in sorted order as req in quest
            Set<Integer> ancestorOfCurrChild = new TreeSet<>();

            while (!queue.isEmpty()) {
                int currChild = queue.poll();
                //if the currChild has any parents it will add to ancestor
                //if the currChild doesn't have any parent, use default empty set
                //currChild may not have parents if child is super root node OR
                //if this child node doesn't have any incoming edges only outgoing edge are there
                ancestorOfCurrChild.addAll(parentGraph.getOrDefault(currChild, new HashSet<>()));

                for (int parentVertex : parentGraph.getOrDefault(currChild, new HashSet<>())) {
                    if (visited.contains(parentVertex)) {
                        continue;
                    }
                    visited.add(parentVertex);
                    queue.add(parentVertex);
                }
            }
            ancestors.add(new ArrayList<>(ancestorOfCurrChild));
        }
        //output
        System.out.println("All ancestors of all nodes in directed acyclic graph: " + ancestors);
    }

    public void kThAncestorOfTreeNode_Graph(int n, int[] parent, int[][] queries) {
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/solutions/686256/java-treemap/
        //child to ancestor wise graph
        //<child, <k-th ancestor level, parent>>
        Map<Integer, TreeMap<Integer, Integer>> graph = new HashMap<>();
        int firstAncestorLevel = 1;
        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;

            graph.put(v, new TreeMap<>());
            //u is the 1-level parent of child v
            graph.get(v).put(firstAncestorLevel, u);
        }

        class Helper {

            int getKthAncestorNode(int childNode, int k) {

                //since 0 is the root node and -1 is the default parent of the root == 0
                //so if the query is for the root node(childNode == root == 0) we should
                //return -1 as there can't be any ancestor above the root node
                if (k > 0 && (childNode == 0 || childNode == -1)) {
                    return -1;
                }

                //if for the curr childNode we can have its k-th ancestor level, simply
                //return the ancestor node of the curr childNode at k-th level
                if (graph.get(childNode).containsKey(k)) {
                    return graph.get(childNode).get(k);
                }

                //if the k-th ancestor level is not have found for the curr childNode
                //then we will start finding that node from the closest reachable ancestor
                //level (i.e, floorKey(k) will give the closest ancestor level from curr
                //k-th level that will be reachableAncestorLevel <= k)
                int reachableAncestorLevel = graph.get(childNode).floorKey(k);
                //curr ancestor node at the closest reachable ancestor level
                int reachableAncestorNode = graph.get(childNode).get(reachableAncestorLevel);

                //recursively find the remaing k - reachableAncestorLevel from the closest
                //reachable ancestor node (== reachableAncestorNode) of curr childNode
                int ancestorNode = getKthAncestorNode(
                        reachableAncestorNode,
                        k - reachableAncestorLevel
                );

                //also store the newly found k-th ancestor node of curr childNode
                //the child->{kth, ancestor node} graph
                graph.get(childNode).put(k, ancestorNode);

                return ancestorNode;
            }
        }

        Helper helper = new Helper();

        for (int[] query : queries) {
            int node = query[0];
            int ancestorLevel = query[1];
            int ancestorNode = helper.getKthAncestorNode(node, ancestorLevel);
            System.out.println("K-th: " + ancestorLevel + " of parent node: " + node + " is: " + ancestorNode);
        }
    }

    public void coloringBorders_Graph(int[][] grid, int row, int col, int color) {
        //https://leetcode.com/problems/coloring-a-border/description/
        //actual:
        System.out.println("Actual grid: ");
        for (int[] rows : grid) {
            System.out.println(Arrays.toString(rows));
        }

        class Cell {

            int row;
            int col;

            public Cell(int row, int col) {
                this.row = row;
                this.col = col;
            }

        }

        int ROW = grid.length;
        int COL = grid[0].length;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        Queue<Cell> queue = new LinkedList<>();
        queue.add(new Cell(row, col));

        boolean[][] visited = new boolean[ROW][COL];
        visited[row][col] = true;

        List<Cell> borderCells = new ArrayList<>();

        while (!queue.isEmpty()) {
            Cell currCell = queue.poll();
            for (int[] dir : dirs) {
                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];
                //for each square, color it if it has a neighbor that is
                //outside the grid or a different color.

                //is out of bounds
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL
                        //OR neighbouring new row & col has diff color than curr
                        //row & col, then is the cond for border cells
                        || grid[newRow][newCol] != grid[currCell.row][currCell.col]) {

                    borderCells.add(currCell);
                } else if (!visited[newRow][newCol]) {
                    //else if this new row & col is not prev visited
                    //then mark it visited and add in the queue
                    visited[newRow][newCol] = true;
                    queue.add(new Cell(newRow, newCol));
                }

            }
        }

        for (Cell cell : borderCells) {
            grid[cell.row][cell.col] = color;
        }

        //output
        System.out.println("Output grid: ");
        for (int[] rows : grid) {
            System.out.println(Arrays.toString(rows));
        }
    }

    private int minTimeToCollectAllApplesInATree_Graph_Helper(
            Map<Integer, List<Integer>> graph, boolean[] hasApple, int root, int parent) {

        int timeTakeTillCurrRoot = 0;
        int timeTakenByChildSubtree = 0;

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {

            if (childRoot == parent) {
                continue;
            }

            timeTakenByChildSubtree = minTimeToCollectAllApplesInATree_Graph_Helper(
                    graph, hasApple, childRoot, root);

            //if nodes in childRoot's subtree also has apples then there will be
            //time to pick those apples that will be timeTakenByChildSubtree > 0
            //OR the childRoot node itself has apple hasApple[childRoot] = true
            if (timeTakenByChildSubtree > 0 || hasApple[childRoot]) {
                timeTakeTillCurrRoot += timeTakenByChildSubtree + 2;
            }
        }
        return timeTakeTillCurrRoot;
    }

    public void minTimeToCollectAllApplesInATree_Graph(int n, int[][] edges, boolean[] hasApple) {
        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/
        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/2864715/minimum-time-to-collect-all-apples-in-a-tree/
        /*
        Given edges[][] are of tree
        Here we have to start dfs from root and add up all the time taken to reach
        nodes that has apple (== hasApple[node] = true)
        hasApple[] = [false,false,true,false,true,true,false]
        tree nodes/index that has apples = [2,4,5]
        tree: ................0
        ..................../...\
        ...................1.....2
        ................../.\.../.\
        .................4...5..3..6
        
        route to pick apple and back to root again:
        0 -> 1 -> 4 -> 1 -> 5 -> 1 -> 0 -> 2 -> 0
        each path in this route takes 1 unit of time = timeTaken = 8
        
        Intution is to calulate the time to reach a node with apple and back to root
        ex here node 4, 5 & 2 has apple
        node: 2 = 0 -> 2 -> 0 = 2 unit time
        node: 4 = 0 -> 1 -> 4 -> 1 -> 0 = 4 unit time
        node: 5 = 0 -> 1 -> 4 -> 1 -> 0 = 4 unit time
        
        but technically there is a route common to them (0 -> 1 -> 0)
        optimal route be: 
        0 -> 1 -> 4 -> 1 -> 5 -> 1 -> 0 = 6 unit time
        0 -> 2 -> 0 = 2 unit time
        so totalTime = 6 + 2 = 8 unit time
        
        so calculate time, each parent to its immediate child that will always be 2
        meaning parent -> child -> parent again
        0 -> 1 -> 0 = 2 unit time
        1 -> 4 -> 1 = 2 unit time
        1 -> 5 -> 1 = 2 unit time
        0 -> 2 -> 0 = 2 unit time
        2 -> 3 -> 2 = 2 unit time
        2 -> 6 -> 2 = 2 unit time
        
        for each curr root node, while itertaing over its childRoot using dfs calls
        we will consider two possibility
        1. if the childRoot's subtree also has some apples in it so there will be
        some time taken to fetch them in that case childTimeTaken > 0
        2. we will also check if that childRoot is a node that hasApple[node] == true
        
        if any of these cond meets
        if (childTimeTaken > 0 || hasApple[childRoot]) {
            timeTakeTillCurrRoot += timeTakenByChildSubtree + 2;
        }
        
        timeTakenTillCurrRoot will be time taken to fetch apples in child's subtree
        + time taken between curr parent -> child -> parent == 2 unit time
        
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        int timeTaken = minTimeToCollectAllApplesInATree_Graph_Helper(graph, hasApple, root, -1);
        //output
        System.out.println("Time taken to collect all apples and return back to root: " + timeTaken);
    }

    private Map<Character, Integer> numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
            Map<Integer, List<Integer>> graph, int root, int parent,
            String labels, int[] nodesWithSameLabelInSubtree) {

        Map<Character, Integer> currRootLabelFreq = new HashMap<>();

        //add 1 for the label associated with this curr root
        char currRootLabel = labels.charAt(root);
        currRootLabelFreq.put(currRootLabel, 1);

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {
            //its undirected graph so if any childRoot is same as its parent, skip
            if (childRoot == parent) {
                continue;
            }

            //childRoots will return the count of labels for itself and their subtrees
            Map<Character, Integer> currChildRootSubtreeLabelFreq
                    = numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
                            graph, childRoot, root, labels, nodesWithSameLabelInSubtree);

            //merge all childRoots subtree lable counts in the curr root's
            //currRootLabelFreq one by one
            for (char subtreeLabel : currChildRootSubtreeLabelFreq.keySet()) {
                //if already the key exist in curr root's label count then add this
                //childRoot subtree's label counts with that existing freq
                currRootLabelFreq.put(subtreeLabel,
                        currRootLabelFreq.getOrDefault(subtreeLabel, 0)
                        + currChildRootSubtreeLabelFreq.get(subtreeLabel));
            }
        }

        //now fetch how many counts are there in curr root's subtree that matches
        //the label as that of curr root(== currRootlabel)
        nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel);

        return currRootLabelFreq;
    }

    public void numberOfNodesInSubtreeWithSameLabel_Graph(int n, int[][] edges, String labels) {
        //https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description/
        /*
        Given edges[][] is of tree(could be n-ary tree)
        labels = "abaedcd" where i-th belongs to labels[i-th node]
        ==> [0 = a, 1 = b, 2 = a, 3 = e, 4 = d, 5 = c, 6 = d]
        tree: ................0
        ..................../...\
        ...................1.....2
        ................../.\.../.\
        .................4...5..3..6
        
        **DFS call will go in depth first simulating Bottom-top recursion stack**
        
        nodes 4, 5, 3, 6 being leaf nodes so they will count labels for themselves
        
        callStack(root = 4, parent = 1)
            
            char currRootLabel = labels.charAt(root); == d
            currRootLabelFreq.put(currRootLabel, 1); == {d = 1}
            
            for(childRoot : graph[4] -> [1]) childRoot == parent == 1 ==> skipped and loop end
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {d = 1} = 1
            ==result[4] = 1
            
            return currRootLabelFreq == {d = 1} to parent root == 1
        
        callStack(root = 5, parent = 1)
            
            char currRootLabel = labels.charAt(root); == c
            currRootLabelFreq.put(currRootLabel, 1); == {c = 1}
            
            for(childRoot : graph[5] -> [1]) childRoot == parent == 1 ==> skipped and loop end
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {c = 1} = 1
            ==result[5] = 1
            
            return currRootLabelFreq == {c = 1} to parent root == 1
        
        callStack(root = 3, parent = 2)
            
            char currRootLabel = labels.charAt(root); == e
            currRootLabelFreq.put(currRootLabel, 1); == {e = 1}
            
            for(childRoot : graph[3] -> [2]) childRoot == parent == 2 ==> skipped and loop end
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {e = 1} = 1
            ==result[3] = 1
            
            return currRootLabelFreq == {e = 1} to parent root == 2
        
        callStack(root = 6, parent = 2)
            
            char currRootLabel = labels.charAt(root); == d
            currRootLabelFreq.put(currRootLabel, 1); == {d = 1}
            
            for(childRoot : graph[6] -> [2]) childRoot == parent == 2 ==> skipped and loop end
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {d = 1} = 1
            ==result[6] = 1
            
            return currRootLabelFreq == {d = 1} to parent root == 2
        
        **moving back to parent callStack**
        node 1, 2
        
        callStack(root = 1, parent = 0)
            
            char currRootLabel = labels.charAt(root); == b
            currRootLabelFreq.put(currRootLabel, 1); == {b = 1}
            
            for(childRoot : graph[1] -> [0,4,5])
                1. childRoot == parent == 0 ==> skipped
                
                2. childRoot == 4, currChildRootSubtreeLabelFreq = {d = 1}
                merge with currRootLabelFreq == {b = 1, d = 1}
                
                3. childRoot == 5, currChildRootSubtreeLabelFreq = {c = 1}
                merge with currRootLabelFreq == {b = 1, d = 1, c = 1}
                loop end...
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {b = 1} = 1
            ==result[1] = 1
            
            return currRootLabelFreq == {b = 1, d = 1, c = 1} to parent root == 0
        
        callStack(root = 2, parent = 0)
            
            char currRootLabel = labels.charAt(root); == a
            currRootLabelFreq.put(currRootLabel, 1); == {a = 1}
            
            for(childRoot : graph[2] -> [0,3,6])
                1. childRoot == parent == 0 ==> skipped
                
                2. childRoot == 3, currChildRootSubtreeLabelFreq = {e = 1}
                merge with currRootLabelFreq == {a = 1, e = 1}
                
                3. childRoot == 5, currChildRootSubtreeLabelFreq = {d = 1}
                merge with currRootLabelFreq == {a = 1, e = 1, d = 1}
                loop end...
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {a = 1} = 1
            ==result[2] = 1
            
            return currRootLabelFreq == {a = 1, e = 1, d = 1} to parent root == 0
        
        **moving back to parent callStack**
        node 0
        
        callStack(root = 0, parent = -1)
            
            char currRootLabel = labels.charAt(root); == a
            currRootLabelFreq.put(currRootLabel, 1); == {a = 1}
            
            for(childRoot : graph[0] -> [1,2])
                1. childRoot == 1, currChildRootSubtreeLabelFreq = {b = 1, d = 1, c = 1}
                merge with currRootLabelFreq == {a = 1, b = 1, d = 1, c = 1}
                
                2. childRoot == 5, currChildRootSubtreeLabelFreq = {a = 1, e = 1, d = 1}
                merge with currRootLabelFreq == {a = 2, b = 1, d = 2, c = 1, e = 1}
                loop end...
            
            nodesWithSameLabelInSubtree[root] = currRootLabelFreq.get(currRootLabel); == {a = 2} = 2
            ==result[0] = 2
            
            return currRootLabelFreq == {a = 2, b = 1, d = 2, c = 1, e = 1} to main call()
        
        **END**
            
        
         */
        int[] nodesWithSameLabelInSubtree = new int[n];
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        numberOfNodesInSubtreeWithSameLabel_Graph_Helper(
                graph, root, -1, labels, nodesWithSameLabelInSubtree);

        //output
        System.out.println("Number of nodes in subtree with same label: " + Arrays.toString(nodesWithSameLabelInSubtree));
    }

    private int longestPathWithDiffAdjacentCharsInTree_Graph_Helper(
            Map<Integer, List<Integer>> graph, String labels, int root, int parent) {

        //label associated with curr root
        int currRootLabel = labels.charAt(root);

        //store all the path lengths calculated form childRoot of this curr root
        //only if label[root] != label[childRoot]
        List<Integer> childRootPathLengths = new ArrayList<>();

        for (int childRoot : graph.getOrDefault(root, new ArrayList<>())) {
            //since the given graph is tree, so if childRoot is same as parent, skip
            if (childRoot == parent) {
                continue;
            }

            //label associated with child root
            int childRootLabel = labels.charAt(childRoot);

            //do dfs call for the childRoot to calculate the path lengths from 
            //child to its parent
            int childRootPathLength = longestPathWithDiffAdjacentCharsInTree_Graph_Helper(
                    graph, labels, childRoot, root);

            //if label[childRoot] == label[root] then this childRootPathLength 
            //will not be propagated to parent of curr root, as per cond of quest
            //ex: parent = [-1,0,1], label = "aab"
            //here 1 -> 2 is the path where label chars of these adjacent nodes
            //are not same 1 = a, 2 = b, hence longestPath == 2
            if (childRootLabel == currRootLabel) {
                //but still this childRootPathLength must be checked with longestLength
                //why? because there may be a subtree in the childRoot where there
                //exist a path which is longest than any other subtree so we don't
                //want to loose that path existing in some internal subtree
                longestPathWithDiffAdjacentCharsInTree_LongestLength = Math.max(
                        longestPathWithDiffAdjacentCharsInTree_LongestLength,
                        childRootPathLength);
                continue;
            }

            //if label[childRoot] doesn't match with label[root] then add that
            //childRootPathLength to List childRootPathLengths
            //why? because this given graph could be n-ary tree so there may be 
            //more than 2 childs(compared to binary trees). save all the childRoot
            //path lengths in list then we need to find 2 max path lengths out of them
            //why 2 max path length? there is possibility that longestPath is not
            //always starting from main root, but this longest path may be anywhere in
            //the tree. so from a paricular node there must exist atmost 2 branches/paths 
            //which should form a internal path. now in order to have longest path
            //these 2 branches from a node should be max path
            childRootPathLengths.add(childRootPathLength);
        }

        //2 branches from the curr root node
        int childMaxPath1 = 0;
        int childMaxPath2 = 0;

        int size = childRootPathLengths.size();

        //if curr root node has just one valid childRoot path length
        //so 1 branch is possible in this case
        if (size == 1) {
            childMaxPath1 = childRootPathLengths.get(size - 1);
        } else if (size > 1) {
            //but if curr root node has more than 1 childRoot path length
            //then we need 2 branches of max paths so sort all the path lengths
            //take last 2 braches/paths from childRoot
            Collections.sort(childRootPathLengths);
            childMaxPath1 = childRootPathLengths.get(size - 1);
            childMaxPath2 = childRootPathLengths.get(size - 2);
        }

        //now the longestPath can be formed from this curr root node and including
        //2 branches of max paths
        longestPathWithDiffAdjacentCharsInTree_LongestLength = Math.max(
                longestPathWithDiffAdjacentCharsInTree_LongestLength,
                //2 branches of max path + 1 for curr root
                childMaxPath1 + 1 + childMaxPath2);

        //now choose the max from both max branches/path + 1 for curr root node
        return Math.max(childMaxPath1, childMaxPath2) + 1;
    }

    private int longestPathWithDiffAdjacentCharsInTree_LongestLength;

    public void longestPathWithDiffAdjacentCharsInTree_Graph(int[] parent, String labels) {
        //https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/
        //somewhat based on DIAMETER OF TREE
        int n = parent.length;

        longestPathWithDiffAdjacentCharsInTree_LongestLength = 0;

        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int u = parent[i];
            int v = i;

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;
        longestPathWithDiffAdjacentCharsInTree_Graph_Helper(graph, labels, root, -1);

        //output
        System.out.println("Longest path with diff adjacent chars: "
                + longestPathWithDiffAdjacentCharsInTree_LongestLength);
    }

    private int lexicographicallySmallestEquivalentString_Graph_Helper(
            Map<Character, Set<Character>> graph, char vertex,
            Set<Character> visited, Set<Character> connectedComponent) {

        visited.add(vertex);

        connectedComponent.add(vertex);

        int minCharAscii = Integer.MAX_VALUE;

        for (char childVertex : graph.getOrDefault(vertex, new HashSet<>())) {

            if (visited.contains(childVertex)) {
                continue;
            }

            minCharAscii = Math.min(minCharAscii,
                    lexicographicallySmallestEquivalentString_Graph_Helper(
                            graph, childVertex, visited, connectedComponent));
        }

        return Math.min(minCharAscii, vertex);
    }

    public void lexicographicallySmallestEquivalentString_Graph(String str1, String str2, String baseStr) {
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/2867563/lexicographically-smallest-equivalent-string/
        /*
        str1 = "parker", str2 = "morris", baseStr = "parser"
        smallestString = "makkek"
        
        undirected edges between the chars of str1 & str2
        p -> m | m -> p
        a -> o | o -> a
        r -> r | r -> r
        k -> r | r -> k
        e -> i | i -> e
        r -> s | s -> r
        
        simplified groups of char/ connected component in graph
        [m, p] = m & p has relation with each other == minChar = m
        [a, o] = a & o has relation with each other == minChar = a
        [k, r, s] = r, k & s has relation with each other == minChar = k
        [e, i] = e & i has relation with each other == minChar = e
        
        so minChar will be mapped like
        for m = minChar = m
        for p = minChar = m
        for a = minChar = a
        for o = minChar = a
        for k = minChar = k
        for r = minChar = k
        for s = minChar = k
        for e = minChar = e
        for i = minChar = e
        
        now each char for baseStr if this char is in minCharMap then get that minChar
        otherwise keep the same char from baseStr as it is
        
         */
        //given str1.length = str2.length = n
        int n = str1.length();

        Map<Character, Set<Character>> graph = new HashMap<>();
        for (int i = 0; i < n; i++) {
            char u = str1.charAt(i);
            char v = str2.charAt(i);

            graph.put(u, new HashSet<>());
            graph.get(u).add(v);

            graph.put(v, new HashSet<>());
            graph.get(v).add(u);
        }

        //all the chars from our str1 and str2 that can associated to some
        //min char in their connected component/ vertexes
        Map<Character, Character> minCharMap = new HashMap<>();

        Set<Character> visited = new HashSet<>();

        for (char src = 'a'; src <= 'z'; src++) {

            //if curr src is already visited, skip
            if (visited.contains(src)) {
                continue;
            }

            //all the connected component/ vertex from curr src
            Set<Character> connectedComponent = new HashSet<>();

            //do dfs from curr src to all of its connected vertex/component (here chars)
            //during this dfs we will do 2 things
            //1. save all those connected component in connectedComponent
            //2. find and return the min char ascii out of all its connected vertex
            //(means find the min char in a particular connected graph of chars from src)
            int minCharConnectedToSrc = lexicographicallySmallestEquivalentString_Graph_Helper(
                    graph, src, visited, connectedComponent);

            //all the connected component from/including curr src will have same
            //minChar ascii associated to them
            for (char connectecVertex : connectedComponent) {
                minCharMap.put(connectecVertex, (char) minCharConnectedToSrc);
            }
        }

        StringBuilder smallestString = new StringBuilder();
        //to make the lexicographically equivalent smallest string for the
        //baseStr made from str1 and str2
        for (char ch : baseStr.toCharArray()) {
            //if we have any minChar associated to curr chr then get that
            //else we will keep chr as default char in our smallest string
            smallestString.append(minCharMap.getOrDefault(ch, ch));
        }

        //output
        System.out.println("Lexicographically smallest equivalent string: " + smallestString.toString());
    }

    private void accountsMerge_Graph_Helper(
            Map<String, List<String>> graph, String email, List<String> connectedEmails, Set<String> visited) {

        visited.add(email);
        connectedEmails.add(email);

        for (String childEmail : graph.getOrDefault(email, new ArrayList<>())) {

            if (visited.contains(childEmail)) {
                continue;
            }

            accountsMerge_Graph_Helper(graph, childEmail, connectedEmails, visited);
        }
    }

    public void accountsMerge_Graph(String[][] accounts) {
        //https://leetcode.com/problems/accounts-merge/description/
        //based on GRAPH, CONNECTED COMPONENT
        /*
        accounts[][] = [
        ["John","johnsmith@mail.com","john_newyork@mail.com"],
        ["John","johnsmith@mail.com","john00@mail.com"],
        ["Mary","mary@mail.com"],
        ["John","johnnybravo@mail.com"]]
        
        email 'johnnybravo@mail.com' also has owner name as 'John' just like
        other 2 'John' accounts but 'johnnybravo@mail.com' is not a common email to
        any of the other 2 accounts of 'John'
        
        graph = {
            johnsmith@mail.com = [john_newyork@mail.com, john00@mail.com],
            john_newyork@mail.com = [johnsmith@mail.com],
            john00@mail.com = [johnsmith@mail.com],
            mary@mail.com = [],
            johnnybravo@mail.com = []
        }
         */
        List<List<String>> mergedAccounts = new ArrayList<>();
        //graph will hold all the emails that are connected to each other
        Map<String, List<String>> graph = new HashMap<>();
        Map<String, String> emailToOwner = new HashMap<>();
        Set<String> visited = new HashSet<>();

        //since we need to merge accounts based on emails, where the cond for this
        //merge is a particular email say: emailX is present in multiple
        //account[] in accounts[][] then all this account[] should be merged into one
        //and all emails in the merged account should be sorted as well
        //accounts[][] = [[owner1, email1, email2, emailX,...],
        //[owner2, email3, email4, email5,...],
        //[owner1, email6, email7, emailX,...]]
        //so here account for owner1 should be merged as they have emailX common
        //[[owner1, email1, email2, email6, email7, emailX], [owner2, email3, email4, email5,...]]
        //curr owner's all account
        //ex: [owner, email1, email2, ...]
        for (String[] account : accounts) {

            //owner will be at 0-th index
            String emailOwner = account[0];

            //creating graph for all connected emails, hence starting from 1
            //(starting index of emails as 0-th index has owner)
            for (int i = 1; i < account.length; i++) {

                //i-th index will be src email == u
                String emailU = account[i];

                //map all unique u-emails to their owner as well
                emailToOwner.put(emailU, emailOwner);

                //now going to store all other emails in this same account
                //where each u-email connected to v-email and vice versa in
                //undirected graph way
                graph.putIfAbsent(emailU, new ArrayList<>());

                for (int j = i + 1; j < account.length; j++) {

                    String emailV = account[j];

                    //u-email -> v-email
                    graph.get(emailU).add(emailV);

                    //v-email -> u-email
                    graph.putIfAbsent(emailV, new ArrayList<>());
                    graph.get(emailV).add(emailU);

                    //also map all unique v-emails to their owner as well
                    emailToOwner.put(emailV, emailOwner);
                }
            }
        }

        //now we have all unique emails mapped to their owner
        //so considering each email as a srcEmail do a dfs on it find out all the
        //connected emails attached to it
        for (String srcEmail : emailToOwner.keySet()) {

            //as output requires owner in it
            String emailOwner = emailToOwner.get(srcEmail);

            //if a particular src email is already visited that means this src email
            //has already been a part of a connected email group that has previously
            //been traveresed
            if (visited.contains(srcEmail)) {
                continue;
            }

            //now if a src email is not visited, we have to find all the connected
            //emails to it
            List<String> connectedEmails = new ArrayList<>();

            //do dfs call to find & list together all the connected emails to this
            //src email
            accountsMerge_Graph_Helper(graph, srcEmail, connectedEmails, visited);

            //since we needed the connected emails in sorted order
            Collections.sort(connectedEmails);
            //also output should have onwer of this connected email group
            connectedEmails.add(0, emailOwner);

            //put this merged connected email group in result list
            mergedAccounts.add(connectedEmails);
        }

        //output
        System.out.println("Account merged: " + mergedAccounts);
    }

    public void snakesAndLadder_Graph(int[][] board) {
        //https://leetcode.com/problems/snakes-and-ladders/description/
        //https://leetcode.com/problems/snakes-and-ladders/solutions/2912646/snakes-and-ladders/
        //based on GRAPH, DJIKSTRA ALGO
        //board is n * n matrix
        class Cell {

            int label;
            int row;
            int col;

            public Cell(int label, int row, int col) {
                this.label = label;
                this.row = row;
                this.col = col;
            }

        }

        int n = board.length;
        int target = n * n;

        List<Integer> altCols = new ArrayList<>();
        for (int col = 0; col < n; col++) {
            altCols.add(col);
        }

        int startLabel = 1;

        Map<Integer, Cell> labelToCell = new HashMap<>();
        int currLabel = startLabel;
        for (int row = n - 1; row >= 0; row--) {
            for (int col : altCols) {
                labelToCell.put(currLabel, new Cell(currLabel, row, col));
                currLabel++;
            }
            //reverse col after creating labels for each row, this ways the actual
            //snakes & ladder board will have its look
            Collections.reverse(altCols);
        }

        //since we need to find the min dist/steps to reach the target(== n * n)
        //cell but inorder to include that target in dist we need target + 1 size
        int[] dist = new int[target + 1];
        int UNREACHABLE = -1;
        //default dist/steps to reach i-th label cell in board is UNREACHABLE
        Arrays.fill(dist, UNREACHABLE);

        //we always have to start from 1 just like actual snake & ladded game
        //so dist/steps to reach the start label is 0 (basic djikstra)
        dist[startLabel] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(startLabel);

        while (!queue.isEmpty()) {

            currLabel = queue.poll();

            //this will simulate generating the next possible value from curr lable
            //if we roll a dice on board
            int start = currLabel + 1;
            int end = Math.min(currLabel + 6, n * n);

            for (int nextLabel = start; nextLabel <= end; nextLabel++) {
                //actual row & col location for the next label generated here
                int row = labelToCell.get(nextLabel).row;
                int col = labelToCell.get(nextLabel).col;

                //from this actual row & col location, we will check what can be
                //the possible next move based on the info given in board[][]
                //if board[row][col] == -1 means we can move to that next label
                //if board[row][col] != -1 means there is either snake or ladder
                //which will give you dest label (dest to snake tail after snake
                //bite or ladder top after climbing ladder)
                int destLabel = board[row][col] == UNREACHABLE ? nextLabel : board[row][col];

                //if previously this dest label was unreachable(== -1)
                //now it can be reached by dist[currLable] + 1
                if (dist[destLabel] == -1) {
                    dist[destLabel] = dist[currLabel] + 1;
                    queue.add(destLabel);
                }
            }
        }
        //output
        System.out.println("Min steps to reach target in snake & ladder game: " + dist[target]);
    }

    private int[] findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(int[] edges, int node) {
        int n = edges.length;

        Set<Integer> visited = new HashSet<>();

        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[node] = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(node);

        while (!queue.isEmpty()) {

            int currNode = queue.poll();

            if (visited.contains(currNode)) {
                continue;
            }

            visited.add(currNode);

            int childNode = edges[currNode];
            if (childNode != -1 && !visited.contains(childNode)) {
                dist[childNode] = 1 + dist[currNode];
                queue.add(childNode);
            }
        }
        return dist;
    }

    public void findClosestNodeToGivenTwoNodes_Graph(int[] edges, int node1, int node2) {
        //https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/
        //based on BFS, DIJIKSTRA ALGO
        int n = edges.length;
        //get the smallest dist to reach other vertices from given nodes 1 & 2 respec
        int[] distFromNode1 = findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(edges, node1);
        int[] distFromNode2 = findClosestNodeToGivenTwoNodes_Graph_GetDistFromNode(edges, node2);

        //resultant node that will be closest to both the given nodes
        int closestNode = -1;
        //this is the max dist we can think of, that we need to minimize
        int minimizedDist = Integer.MAX_VALUE;

        for (int currNode = 0; currNode < n; currNode++) {
            //max dist to reach the curr node as dist calculated from both node1
            //and node2 respec
            int maxOfDists = Math.max(distFromNode1[currNode], distFromNode2[currNode]);
            //minimize the max dists
            if (minimizedDist > maxOfDists) {
                minimizedDist = maxOfDists;
                closestNode = currNode;
            }
        }
        //output
        System.out.println("Closest node to given two nodes: " + closestNode);
    }

    public void shortestPathWithAlternatingColors_Graph(int n, int[][] redEdges, int[][] blueEdges) {
        //https://leetcode.com/problems/shortest-path-with-alternating-colors/description/
        int RED = 1;
        int BLUE = -1;

        class Edge {

            //<color, set<Vertex>>
            Map<Integer, Set<Integer>> coloredEdge;

            public Edge() {
                this.coloredEdge = new HashMap<>();
                this.coloredEdge.put(RED, new HashSet<>());
                this.coloredEdge.put(BLUE, new HashSet<>());
            }

        }

        //shortest path to be filled from src 0 to each i-th index/ vertex
        int[] shortestPathWithAlternateColors = new int[n];
        Arrays.fill(shortestPathWithAlternateColors, -1);

        //adj list: [src-index/ u: Edge]
        List<Edge> graph = new ArrayList<>();

        class Helper {

            //<color, set<visited vertex>>
            Map<Integer, Set<Integer>> visitedViaColor;

            private void shortestPathWithAlternatingColors_Graph_ShortestPath(int src, int color) {

                //for each color based BFS call to find shortest path, we have to
                //reset visitedViaColor
                visitedViaColor = new HashMap<>();
                visitedViaColor.put(RED, new HashSet<>());
                visitedViaColor.put(BLUE, new HashSet<>());

                visitedViaColor.get(color).add(src);

                Queue<Integer> queue = new LinkedList<>();
                queue.add(src);

                shortestPathWithAlternateColors[src] = 0;

                int distance = 0;

                while (!queue.isEmpty()) {

                    //make the curr color alternate(that's why above RED and BLUE
                    //color were given values as 1 &  -1 because below alteration
                    //will always changes signs 1 to -1 and -1 to 1)
                    color = -color;

                    distance++;

                    int size = queue.size();

                    for (int i = 0; i < size; i++) {
                        int currSrc = queue.poll();
                        //since we have altered the color above now we need to
                        //do bfs on those child vertex that belongs to this altered
                        //color
                        //childVertex of currSrc == graph.get(currSrc)
                        //but in altered color == graph.get(currSrc).coloredEdge.get(color)
                        for (int childVertex : graph.get(currSrc).coloredEdge.get(color)) {

                            if (visitedViaColor.get(color).contains(childVertex)) {
                                continue;
                            }

                            visitedViaColor.get(color).add(childVertex);
                            queue.add(childVertex);

                            shortestPathWithAlternateColors[childVertex]
                                    = //if we reach the childVertex very first time
                                    //then only shortest path is curr distance
                                    //else we have reached the curr childVertex before
                                    //then we have to choose the min of curr shortest path
                                    //and distance
                                    shortestPathWithAlternateColors[childVertex] == -1
                                            ? distance
                                            : Math.min(shortestPathWithAlternateColors[childVertex], distance);

                        }
                    }
                }
            }
        }

        Helper helper = new Helper();

        for (int vertex = 0; vertex < n; vertex++) {
            graph.add(new Edge());
        }

        for (int[] edge : redEdges) {
            int u = edge[0];
            int v = edge[1];

            //src-index/ u, via color-red edge is connected to dest v
            //src-index/ u == graph.get(u) = Edge associated with index/ u
            //via color-red edge == graph.get(u).coloredEdge.get(RED) == color of
            //directed edge, u -> v belongs 
            //is connected to dest v == graph.get(u).coloredEdge.get(RED).add(v);
            graph.get(u).coloredEdge.get(RED).add(v);
        }

        for (int[] edge : blueEdges) {
            int u = edge[0];
            int v = edge[1];

            //src-index/ u, via color-blue edge is connected to dest v
            //src-index/ u == graph.get(u) = Edge associated with index/ u
            //via color-blue edge == graph.get(u).coloredEdge.get(BLUE) == color of
            //directed edge, u -> v belongs 
            //is connected to dest v == graph.get(u).coloredEdge.get(BLUE).add(v);
            graph.get(u).coloredEdge.get(BLUE).add(v);
        }

        //since we have two colors, we have two possibilities to find shortest path
        //form src node 0 to every other node, i.e, find shortest path from both
        //colors
        helper.shortestPathWithAlternatingColors_Graph_ShortestPath(0, RED);
        helper.shortestPathWithAlternatingColors_Graph_ShortestPath(0, BLUE);

        //output
        System.out.println("Shortest path with alternating colors: "
                + Arrays.toString(shortestPathWithAlternateColors));
    }

    public void minFuelToReachCapitalCity_Graph(int[][] roads, int seats) {
        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/
        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/3080167/minimum-fuel-cost-to-report-to-the-capital/
        /*
        roads[][] = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2
        tree = 
        .......................0
        ..................../..|..\
        ...................1...4...5
        ................../....|....
        .................3.....6....
        ................/...........
        ...............2............
        
        its a tree dfs so here the approach is to reach the leaf ends of tree
        and calculate size(== representative) of that node in its substree
        
        ex: 2 there is no substree and 2 is only representative == 1
        same for 6 & 5
        
        2 == represn. == 1
        6 == represn. == 1
        5 == represn. == 1
        
        from these end nodes we will only recurse back in the call stack to calling node 0
        so before going back to previous call stack we have calculate the fuel used for
        curr node for it(and other representative, if any) to travel to its parent(means prev
        call stack)
        
        since end nodes are not node 0, we can caluculate fuel used
        
        fuel += Math.ceil(representative / seat)
        
        the above line means that if at any point the curr node and its representative, if any
        has to travel to its parent, we are limited by the seats in the car that curr node has
        now we have X represenatative that should travel and only Y can sit a car
        then how many cars can be required to take all the representative?
        that will be number of cars req == X / Y == (representative / seat)
        this division will be double so use ceil() to have upper limit of fuel req
        the number of cars req is same as total fuel from curr node to its parent
        
        fuel = 0
        call stack at end nodes 2, 6, 5
        
        call(2, 3)
        ---represn = 1
        ---for(childVertex : graph[2] -> [3]) childVertex == parent; END
        ---if(vertex != 0) == (2 != 0) fuel += ceil(represen / seat) == ceil(1 / 2) = 1
        -----fuel = 0 + 1 == 1
        ---return represen == 1
        
        going back to previous call stack of node 2 i.e node 3
        
        call(3, 1)
        ---represn = 1
        ---for(childVertex : graph[3] -> [1,2])
        ----- 1. for node 1 == childVertex == parent; CONTINUE
        ----- 2. for node 2 (ret 1) == represn += 1 == 1 + 1 = 2
        ---if(vertex != 0) == (3 != 0) fuel += ceil(represen / seat) == ceil(2 / 2) = 1
        -----fuel = 3 + 1 == 4
        ---return represen == 2
        
        going back to previous call stack of node 3 i.e node 1
        
        call(1, 0)
        ---represn = 1
        ---for(childVertex : graph[1] -> [0,3])
        ----- 1. for node 0 == childVertex == parent; CONTINUE
        ----- 2. for node 3 (ret 2) == represn += 1 == 2 + 1 = 3
        ---if(vertex != 0) == (1 != 0) fuel += ceil(represen / seat) == ceil(3 / 2) = 2
        -----fuel = 5 + 2 == 7 ***
        ---return represen == 3
        
        ..........................
        call(6, 4)
        ---represn = 1
        ---for(childVertex : graph[6] -> [4]) childVertex == parent; END
        ---if(vertex != 0) == (6 != 0) fuel += ceil(represen / seat) == ceil(1 / 2) = 1
        -----fuel = 1 + 1 == 2
        ---return represen == 1
        
        going back to previous call stack of node 6 i.e node 4
        
        call(4, 0)
        ---represn = 1
        ---for(childVertex : graph[4] -> [0,6])
        ----- 1. for node 0 == childVertex == parent; CONTINUE
        ----- 2. for node 6 (ret 1) == represn += 1 == 1 + 1 = 2
        ---if(vertex != 0) == (4 != 0) fuel += ceil(represen / seat) == ceil(2 / 2) = 1
        -----fuel = 4 + 1 == 5
        ---return represen == 2
        
        .............................
        call(5, 0)
        ---represn = 1
        ---for(childVertex : graph[5] -> [0]) childVertex == parent; END
        ---if(vertex != 0) == (5 != 0) fuel += ceil(represen / seat) == ceil(1 / 2) = 1
        -----fuel = 2 + 1 == 3
        ---return represen == 1
        
        .........................
        call(0, -1)
        ---represn = 1
        ---for(childVertex : graph[0] -> [1,4,5])
        ----- 1. for node 1(ret 3) == represn += 1 == 1 + 3 = 4
        ----- 2. for node 4 (ret 2) == represn += 1 == 4 + 2 = 6
        ----- 2. for node 5 (ret 2) == represn += 1 == 6 + 1 = 7
        ---if(vertex != 0) == (0 != 0) FALSE
        ---return represen == 2
        
        fuel == 7
         */
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] road : roads) {
            int u = road[0];
            int v = road[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        class Helper {

            long fuel = 0;

            int minFuelToReachCapitalCity_Graph_DFS(int vertex, int parent) {

                int representative = 1;

                for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {

                    if (childVertex == parent) {
                        continue;
                    }

                    representative += minFuelToReachCapitalCity_Graph_DFS(childVertex, vertex);
                }

                if (vertex != 0) {
                    fuel += Math.ceil((double) representative / (double) seats);
                }

                return representative;
            }
        }

        Helper helper = new Helper();
        helper.minFuelToReachCapitalCity_Graph_DFS(0, -1);

        //output
        System.out.println("Min Fuel to reach to capital city: " + helper.fuel);
    }

    public void cheapestFlightsWithinKStops_Graph(int n, int[][] flights, int src, int dest, int k) {
        //https://leetcode.com/problems/cheapest-flights-within-k-stops/description/
        //based on LEVEL-WISE BFS TRAVERSAL
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] flight : flights) {
            int u = flight[0];
            int v = flight[1];
            int weight = flight[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));
        }

        int MAX = Integer.MAX_VALUE;
        int[] dist = new int[n];
        Arrays.fill(dist, MAX);
        dist[src] = 0;

        Queue<GraphEdge> queue = new LinkedList<>();
        queue.add(new GraphEdge(src, 0));

        int stops = 0;

        while (!queue.isEmpty() && stops <= k) {

            int size = queue.size();
            for (int i = 0; i < size; i++) {

                GraphEdge currEdge = queue.poll();

                for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, Collections.emptyList())) {

                    if (dist[childEdge.vertex] > currEdge.weight + childEdge.weight) {

                        dist[childEdge.vertex] = currEdge.weight + childEdge.weight;
                        queue.add(new GraphEdge(childEdge.vertex, dist[childEdge.vertex]));
                    }
                }
            }
            stops++;
        }
        //output
        int minPriceWithinKStops = dist[dest] == MAX ? -1 : dist[dest];
        System.out.println("Cheapest flights within k stops: " + minPriceWithinKStops);
    }

    public void createBinaryTreeFromDescription_Graph(int[][] descriptions) {
        //https://leetcode.com/problems/create-binary-tree-from-descriptions/description/
        class Edge {

            int vertex;
            boolean isLeft;

            public Edge(int vertex, boolean isLeft) {
                this.vertex = vertex;
                this.isLeft = isLeft;
            }

        }

        Map<Integer, List<Edge>> graph = new HashMap<>();

        class Helper {

            TreeNode<Integer> createTreeDFS(int parentNode) {

                TreeNode<Integer> root = new TreeNode<>(parentNode);

                for (Edge childEdge : graph.getOrDefault(parentNode, new ArrayList<>())) {

                    TreeNode<Integer> child = createTreeDFS(childEdge.vertex);

                    if (childEdge.isLeft) {
                        root.setLeft(child);
                    }

                    if (!childEdge.isLeft) {
                        root.setRight(child);
                    }
                }

                return root;
            }
        }

        for (int[] desc : descriptions) {

            int root = desc[0];
            int child = desc[1];
            boolean isLeft = desc[2] == 1;

            graph.putIfAbsent(root, new ArrayList<>());
            graph.get(root).add(new Edge(child, isLeft));
        }

        //push all the possible root nodes in getRoot and then remove all the
        //child nodes given in descriptions[] then we will only left with a single
        //value in getRoot that node will be the root node
        Set<Integer> getRoot = new HashSet<>(graph.keySet());
        for (int[] desc : descriptions) {
            int child = desc[1];
            getRoot.remove(child);
        }

        int rootNode = getRoot.iterator().next();
        TreeNode<Integer> root = new Helper().createTreeDFS(rootNode);
        //output
        new BinaryTree<Integer>(root).treeBFS();
        System.out.println();
    }

    public int minNumberOfOperationsToConvertNumber_Graph(int[] nums, int start, int goal) {
        //https://leetcode.com/problems/minimum-operations-to-convert-number/description/
        //based on BFS
        Queue<Integer> queue = new LinkedList<>();
        queue.add(start);

        Set<Integer> visited = new HashSet<>();

        int oprn = 0;

        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                int currNum = queue.poll();

                //if we have reached our goal return min oprn
                if (currNum == goal) {
                    return oprn;
                }

                //skip, if currNum is not in this range or currNum is already visited
                if (!(currNum >= 0 && currNum <= 1000) || visited.contains(currNum)) {
                    continue;
                }

                //if currNum is not already visited, add it to visited
                if (!visited.contains(currNum)) {
                    visited.add(currNum);
                }

                //generate all possible next numbers from currNum
                for (int val : nums) {
                    queue.add(currNum + val);
                    queue.add(currNum - val);
                    queue.add(currNum ^ val);
                }
            }
            oprn++;
        }
        return -1;
    }

    private void minScoreOfPathBetweenTwoCities_Graph_Helper(
            Map<Integer, List<GraphEdge>> graph, Set<Integer> visited, List<Integer> nodes, int src) {

        //simple DFS
        visited.add(src);
        for (GraphEdge childEdge : graph.getOrDefault(src, new ArrayList<>())) {

            //if a child vertex is laready visited, skip it
            if (visited.contains(childEdge.vertex)) {
                continue;
            }

            nodes.add(childEdge.vertex);
            minScoreOfPathBetweenTwoCities_Graph_Helper(graph, visited, nodes, childEdge.vertex);
        }
    }

    public void minScoreOfPathBetweenTwoCities_Graph(int n, int[][] roads) {
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3326589/daily-leetcoding-challenge-march-day-22/
        //constraint: There is at least one path between 1 and n.
        int minDist = Integer.MAX_VALUE;
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] road : roads) {
            int u = road[0];
            int v = road[1];
            int dist = road[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, dist));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, dist));
        }

        int src = 1;
        Set<Integer> visited = new HashSet<>();
        //since our starting src node is src == 1 so this nodes list will save
        //all the intermediate nodes connected to src == 1 in a DFS way also a constraint
        //is given that there is atleast one edge connecting 1 to n-th node
        //so through this nodes list we can check all the edges connected and hence
        //there will always a path 1 to n-th node we just need to find an egde
        //with min dist
        List<Integer> nodes = new ArrayList<>();

        minScoreOfPathBetweenTwoCities_Graph_Helper(graph, visited, nodes, src);

        //check edges to find the minDist
        for (int node : nodes) {
            for (GraphEdge childEdge : graph.getOrDefault(node, new ArrayList<>())) {
                //here dist == weight
                minDist = Math.min(minDist, childEdge.weight);
            }
        }
        //output
        System.out.println("Min score of path between two cities: " + minDist);
    }

    public void minScoreOfPathBetweenTwoCities_Graph_UnionFind(int n, int[][] roads) {
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
        //based on GRAPH DISJOINT SET/ UNION FIND
        //constraint: There is at least one path between 1 and n.
        class UnionFind {

            int n;
            int[] parent;
            int[] rank;

            public UnionFind(int n) {
                this.n = n;
                parent = new int[n + 1];
                rank = new int[n + 1];
                for (int node = 0; node <= n; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind(n);
        int minDist = Integer.MAX_VALUE;

        for (int[] road : roads) {
            int nodeU = road[0];
            int nodeV = road[1];
            //put all the roads/ edges into the union()
            unionFind.union(nodeU, nodeV);
        }

        for (int[] road : roads) {
            int nodeU = road[0];
            int dist = road[2];
            //now here in this loop for roads/ edges, we are checking if each of
            //the roads[i]/ edge given is a connected part of node '1' then we can
            //calculate the minDist, why we are checking each nodeU is connected with
            //node '1'? because we need to find the minDist of the paths between node
            //'1' to 'n'
            if (unionFind.find(1) == unionFind.find(nodeU)) {
                minDist = Math.min(minDist, dist);
            }
        }

        //output
        System.out.println("Min score of path between two cities: " + minDist);
    }

    private void numberOfOperationToMakeNetworkConnected_Graph_Helper(
            Map<Integer, List<Integer>> graph, Set<Integer> visited, int src) {

        //simple DFS call
        visited.add(src);
        for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {
            if (visited.contains(childVertex)) {
                continue;
            }

            numberOfOperationToMakeNetworkConnected_Graph_Helper(graph, visited, childVertex);
        }
    }

    public int numberOfOperationToMakeNetworkConnected_Graph(int n, int[][] connections) {
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        //connections[][] array contains edges/ wires that connect these n nodes
        //some nodes may not be conncted to each other in group but we can make
        //those nodes connected if we have edges/ wires atleast (n - 1)
        int edges = connections.length;
        //if there no sufficient edges/ wires to connect other nodes then not
        //operations can be made so return -1
        if (edges < n - 1) {
            return -1;
        }

        Map<Integer, List<Integer>> graph = new HashMap<>();
        Set<Integer> visited = new HashSet<>();

        for (int[] connection : connections) {
            int u = connection[0];
            int v = connection[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        //this will keep the count of all the connected graph in the given graph
        //connections
        int connectedGraphComponent = 0;

        //loop over all the nodes so that we can visit all the connected graph
        //component and count all the components
        for (int src = 0; src < n; src++) {
            //if any node src is already visited(because it might be a part of
            //connected graph component that we already process) then skip this node
            if (visited.contains(src)) {
                continue;
            }

            //from this curr src node we will visit all of its connected nodes
            //hence form a connected graph component
            connectedGraphComponent++;
            //DFS call to visit all the connected nodes from curr src node
            numberOfOperationToMakeNetworkConnected_Graph_Helper(graph, visited, src);
        }
        //since we have already checked that we sufficient edges/ wires that we
        //can readjust among other connected gragh component, so there will be
        //one edge/ wire req to connect one connected graph component to another
        //so we need to adjust edges or re-wire (connectedGraphComponent - 1)
        //so all the connected graph forms a single graph component
        return connectedGraphComponent - 1;
    }

    public int numberOfOperationToMakeNetworkConnected_Graph_UnionFind(int n, int[][] connections) {
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        //based on UNION-FIND, CONNECTED COMPONENT GRAPH
        //same as numberOfOperationToMakeNetworkConnected_Graph()
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];
                //initially each node is in its own groups and parent of itself
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                //each time we union node1 & node2, connected groups reduces
                connectedGroups--;
            }

            public int connectionsRequired() {
                return connectedGroups - 1;
            }
        }

        //if we have n nodes in graph, so to connect each node together we need
        //atleast n - 1 edges between them
        int edges = connections.length;
        if (edges < n - 1) {
            return -1;
        }

        UnionFind unionFind = new UnionFind(n);

        for (int[] connection : connections) {
            int u = connection[0];
            int v = connection[1];

            unionFind.union(u, v);
        }
        return unionFind.connectionsRequired();
    }

    private boolean checkIfValidPathInStreetGrid_Graph_Helper(int[][] grid, boolean[][] visited,
            Map<Integer, int[][]> dirs, int row, int col) {

        int ROW = grid.length;
        int COL = grid[0].length;

        //isOutOfBounds() OR row and col already visited
        if (row < 0 || row >= ROW || col < 0 || col >= COL || visited[row][col]) {
            return false;
        }

        if (row == ROW - 1 && col == COL - 1) {
            return true;
        }

        boolean isPathValid = false;

        visited[row][col] = true;

        int currStreet = grid[row][col];

        //a specific street has a specific allowed dir of movement 
        for (int[] nextDir : dirs.get(currStreet)) {

            int nextRow = row + nextDir[0];
            int nextCol = col + nextDir[1];

            //isOutOfBounds() OR next row and col already visited
            //this check is req here because we need to validate this next row & col
            //below
            if (nextRow < 0 || nextRow >= ROW || nextCol < 0 || nextCol >= COL || visited[nextRow][nextCol]) {
                continue;
            }

            //now from this potential next street where we can move to, we need
            //to validate that we can also go back to the prev cell from here
            //if we can validate this thing, then we can go to next row and col 
            int nextStreet = grid[nextRow][nextCol];

            for (int[] backDir : dirs.get(nextStreet)) {
                //from this next row and col if we can go back to prev row and col
                if (nextRow + backDir[0] == row && nextCol + backDir[1] == col) {
                    isPathValid = isPathValid || checkIfValidPathInStreetGrid_Graph_Helper(
                            grid, visited, dirs, nextRow, nextCol);
                }
            }
        }

        visited[row][col] = false;

        return isPathValid;
    }

    public void checkIfValidPathInStreetGrid_Graph(int[][] grid) {
        //https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        boolean[][] visited = new boolean[ROW][COL];
        //<street, dirs>
        Map<Integer, int[][]> dirs = new HashMap<>();
        //refer question for street wise images
        /*  ------  movement: LEFT(0, -1), RIGHT(0, 1) */
        dirs.put(1, new int[][]{{0, -1}, {0, 1}});
        /*  
            |
            |
            |
        movement: TOP(-1, 0), BOTTOM(1, 0) */
        dirs.put(2, new int[][]{{-1, 0}, {1, 0}});
        /*  
        -----
            |
            |
        movement: LEFT(0, -1), BOTTOM(1, 0) */
        dirs.put(3, new int[][]{{0, -1}, {1, 0}});
        /*  
            -----
            |
            |
        movement: RIGHT(0, 1), BOTTOM(1, 0) */
        dirs.put(4, new int[][]{{0, 1}, {1, 0}});
        /* 
            |
            |
        -----
        movement: LEFT(0, -1), TOP(-1, 0) */
        dirs.put(5, new int[][]{{0, -1}, {-1, 0}});
        /* 
            |
            |
            -----
        movement: RIGHT(0, 1), TOP(-1, 0) */
        dirs.put(6, new int[][]{{0, 1}, {-1, 0}});

        boolean isPathValid = checkIfValidPathInStreetGrid_Graph_Helper(grid, visited, dirs, 0, 0);
        //output
        System.out.println("Is path valid in street grid: " + isPathValid);
    }

    private boolean longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
            int[] edges, boolean[] visited, boolean[] recurStack,
            Map<Integer, Integer> nodeToPathStep, int srcVertex, int currSteps) {

        //if at any point from a given src node u there is no outgoing edge == -1
        //then we can't move further hence no path exist ahead hence no possibilty
        //of any cycle
        //note: in a version of HashMap based graph, this if cond is handled
        //by getOrDefault()
        if (edges[srcVertex] == -1) {
            return false;
        }

        //note: here recurStack and nodeToPathStep are basically the same thing
        //doing slightly different work
        //if (recurStack[srcVertex]) can be replaced with
        //if (nodeToPathStep.containsKey(srcVertex))
        //OR
        //instead of using boolean[] recurStack we can use Integer[] recurStack
        //any of the above can do the same thing, just for simplicity & understanding
        //keeping these two things separately
        if (recurStack[srcVertex]) {
            longestCycleInGraph_Graph_MaxCycleLength = Math.max(
                    longestCycleInGraph_Graph_MaxCycleLength,
                    //calculates the length of path having cycle
                    currSteps - nodeToPathStep.get(srcVertex));
            return true;
        }

        if (visited[srcVertex]) {
            return false;
        }

        recurStack[srcVertex] = true;
        visited[srcVertex] = true;

        nodeToPathStep.put(srcVertex, currSteps);

        boolean hasCycle = longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
                edges, visited, recurStack,
                nodeToPathStep, edges[srcVertex], currSteps + 1);

        recurStack[srcVertex] = false;

        return hasCycle;
    }

    private int longestCycleInGraph_Graph_MaxCycleLength;

    public void longestCycleInGraph_Graph(int[] edges) {
        //https://leetcode.com/problems/longest-cycle-in-a-graph/description/
        //based on detectCycleInDirectedGraphDFS_Graph()
        //here given edges[] will be our graph that we generally create as HashMap
        //u = i-th index & v = edges[i]
        //the given graph is directed and each node can have atmost 1 outgoing
        //edge, so if there is a cycle then a particular node can be part of a
        //cyle only once(because of atmost one outgoign edge from node)
        int n = edges.length;

        boolean[] visited = new boolean[n];

        //here recurStack will check if we encounter a cycle 
        boolean[] recurStack = new boolean[n];
        //this will keep step count for each node in DFS call so when we are in
        //cycle path and see a node already in nodeToPathStep previously
        //then there we will calculate our cycle length by curr step at that time
        //minus step already in nodeToPathStep for that node
        Map<Integer, Integer> nodeToPathStep = new HashMap<>();

        //default value is -1 if there is no cycle in the graph
        longestCycleInGraph_Graph_MaxCycleLength = -1;

        //since the graph can be disconnected/ connected graph component
        //a cycle may occur in any sub-graph so we have to check all the
        //src == u for longest cycle path
        for (int u = 0; u < n; u++) {
            //skip, if a src == u already been visited
            //or if there is no outgoing edge from a src == u node meaning
            //edges[u] == v == -1
            if (visited[u] || edges[u] == -1) {
                continue;
            }
            longestCycleInGraph_Graph_DetectCycleInDirectedGraph(
                    edges, visited, recurStack, nodeToPathStep, u, 0);
        }
        //output
        System.out.println("Longest cycle length in graph: " + longestCycleInGraph_Graph_MaxCycleLength);
    }

    private int largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
            Map<Integer, List<Integer>> graph, boolean[] recurStack, boolean[] visited,
            String colors, int[][] nodeToColorFreq, int vertex) {

        //based on detect cycle of directed graph
        //color associated to the vertex
        int vertexColorIndex = colors.charAt(vertex) - 'a';

        //if a vertex is already there in the recur stack, means we are visiting
        //a vertex again in the same path, hence its a cycle, reurn MAX_VALUE
        //representing cycle in graph
        if (recurStack[vertex]) {
            return Integer.MAX_VALUE;
        }

        //if a vertex is already visited, means we must have calculated color
        //freqs starting from this vertex in that path, hence return the
        //maxColorFreq already calculated at vertex for colorIndex == vertexColorIndex
        if (visited[vertex]) {
            return nodeToColorFreq[vertex][vertexColorIndex];
        }

        recurStack[vertex] = true;
        visited[vertex] = true;

        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {
            //if there is cycle in the graph, represent it with MAX_VALUE
            if (largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
                    graph, recurStack, visited, colors, nodeToColorFreq, childVertex) == Integer.MAX_VALUE) {
                return Integer.MAX_VALUE;
            }

            for (int colorIndex = 0; colorIndex < 26; colorIndex++) {
                nodeToColorFreq[vertex][colorIndex] = Math.max(
                        nodeToColorFreq[vertex][colorIndex],
                        nodeToColorFreq[childVertex][colorIndex]);
            }
        }

        nodeToColorFreq[vertex][vertexColorIndex]++;

        recurStack[vertex] = false;
        return nodeToColorFreq[vertex][vertexColorIndex];
    }

    public int largestColorValueInDirectedGraph_Graph(String colors, int[][] edges) {
        //https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/
        //explanation: https://youtu.be/xLoDjKczUSk
        int V = colors.length();
        //given colors string will have [a-z] named colors means limited to only
        //26 colors to all the V nodes of the given graph
        int TOTAL_COLORS = 26;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        boolean[] recurStack = new boolean[V];
        boolean[] visited = new boolean[V];
        //this will hold the max freq of each color type(a-z) under the curr
        //node(== u) at that time.
        int[][] nodeToColorFreq = new int[V][TOTAL_COLORS];

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        int maxColorFreq = 0;
        for (int u = 0; u < V; u++) {
            maxColorFreq = Math.max(maxColorFreq,
                    largestColorValueInDirectedGraph_Graph_DetectCycleInDirectedGraph(
                            graph, recurStack, visited, colors, nodeToColorFreq, u));
        }
        return maxColorFreq == Integer.MAX_VALUE ? -1 : maxColorFreq;
    }

    public void similarStringGroups_Graph(String[] strs) {
        /*
        Here n is the size of strs and m is length of each word in strs.

        ..................T: O(n^2 * m)
        To iterate over all the pairs of words that can be formed using strs, we need O(n^2)
        time. We also need O(m) time to determine whether the chosen two words are similar or
        not, which results in O(n^2 * m) operations to check all the pairs.
        The dfs function visits each node once, which takes O(n) time because there are n nodes
        in total. We can have up to O(n^2) edges between n nodes (assume every word is similar
        to every other word). Because we have undirected edges, each edge can only be iterated
        twice (by nodes at the end), resulting in O(n^2) operations total in the worst-case
        scenario while visiting all nodes.
        
        ..................S: O(n^2)
        As there can be a maximum of O(n^2) edges, building the adjacency list takes O(n^2) space.
        The visit array takes O(n) space. The recursion call stack used by dfs can have no more
        than nnn elements in the worst-case scenario. It would take up O(n) space in that case.
         */
        //https://leetcode.com/problems/similar-string-groups/description/
        //based on GRAPH, CONNECTED GRAPH COMPONENTS
        int V = strs.length;
        boolean[] visited = new boolean[V];
        Map<Integer, List<Integer>> graph = new HashMap<>();

        class Helper {

            boolean isSimilar(String str1, String str2) {
                int n = str1.length();
                int mismatchedChar = 0;
                for (int i = 0; i < n; i++) {
                    if (str1.charAt(i) != str2.charAt(i)) {
                        mismatchedChar++;
                    }
                }
                //if 2 strings have to be similar then they should either have
                //0 mismatched OR only 2 mismatched chars acc to question
                return mismatchedChar == 0 || mismatchedChar == 2;
            }

            void helperDFS(int srcVertex) {
                //simple DFS call to mark all the connected srcVertex
                //(index of string of strs[]) of the curr connected graph
                visited[srcVertex] = true;
                for (int childVertex : graph.getOrDefault(srcVertex, new ArrayList<>())) {
                    if (visited[childVertex]) {
                        continue;
                    }
                    helperDFS(childVertex);
                }
            }
        }

        Helper helper = new Helper();

        //from given strs[], we will try to form u -> v & v -> u edge between each
        //pair for strings in strs[]
        for (int u = 0; u < V; u++) {
            for (int v = u + 1; v < V; v++) {

                //if 2 strings are similar then they are part of the same connected
                //graph hence the src u can have edge to dest v and vice versa in
                //undirected graph structure
                //those 2 strings, that are not similar with each other will actually
                //form a separate graph
                //hence after this we might have a disconnected graph structure
                //from given strs[]
                if (helper.isSimilar(strs[u], strs[v])) {

                    graph.putIfAbsent(u, new ArrayList<>());
                    graph.get(u).add(v);

                    graph.putIfAbsent(v, new ArrayList<>());
                    graph.get(v).add(u);
                }
            }
        }

        //now, here we will count the number of different connected graph, that
        //connected graph is basically the connected edges of all those similar
        //strings
        int similarStringGroups = 0;
        for (int u = 0; u < V; u++) {

            //if the particular index (== u) of the strs[] is already visited
            //that means this u-index string is already a part of similar string
            //that might previously visited in some connected groups
            if (visited[u]) {
                continue;
            }
            //starting of a connected graph(here it means connected groups
            //similar strings)
            similarStringGroups++;
            //do a DFS call from src vertex u to mark all the connected index as
            //visited
            helper.helperDFS(u);
        }
        //output
        System.out.println("Similar string groups : " + similarStringGroups);
    }

    public void similarStringGroups_Graph_UnionFind(String[] strs) {
        /*
        Here nnn is the size of strs and m is length of each word in strs.

        .....................T: O(n^2 * m)
        We need O(n^2) time to iterate over all the pairs of words that can be formed
        using strs. We further need O(m) time to check whether the chosen two words
        are similar or not, resulting in O(n^2 * m) operations to check all the pairs.
        For T operations, the amortized time complexity of the union-find algorithm
        (using path compression with union by rank) is O(alpha(T)). Here, α(T) is the
        inverse Ackermann function that grows so slowly, that it doesn't exceed 4 for
        all reasonable T (approximately T<10^600). You can read more about the complexity
        of union-find here. Because the function grows so slowly, we consider it to be O(1).
        Initializing UnionFind takes O(n) time beacuse we are initializing the parent and
        rank arrays of size n each.
        We iterate through every edge and use the find operation to find the component of
        nodes connected by each edge. It takes O(1) per operation and takes O(e) time for
        all the e edges. As discussed above, we can have a maximum of O(n^2) edges in between
        n nodes, so it would take O(n^2) time. If nodes from different components are connected
        by an edge, we also perform union of the nodes, which takes O(1) time per operation.
        In the worst-case scenario, it may be called O(n) times to connect all the components
        to form a connected graph with only one component.
        
        ......................S: O(n)
        We are using the parent and rank arrays, both of which require O(n) space each.
         */
        //https://leetcode.com/problems/similar-string-groups/description/
        //based on UNION FIND
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedGroups;

            public UnionFind(int V) {
                connectedGroups = V;
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
                connectedGroups--;
            }

            public int countSimilarGroups() {
                return connectedGroups;
            }
        }

        class Helper {

            public boolean isSimilarStrings(String str1, String str2) {
                int n = str1.length();
                int mismatchedChars = 0;
                for (int i = 0; i < n; i++) {
                    if (str1.charAt(i) != str2.charAt(i)) {
                        mismatchedChars++;
                    }
                }
                return mismatchedChars == 0 || mismatchedChars == 2;
            }
        }

        int V = strs.length;

        UnionFind unionFind = new UnionFind(V);
        Helper helper = new Helper();

        for (int u = 0; u < V; u++) {
            for (int v = u + 1; v < V; v++) {
                if (helper.isSimilarStrings(strs[u], strs[v])) {
                    unionFind.union(u, v);
                }
            }
        }
        //output
        System.out.println("Similar string groups : " + unionFind.countSimilarGroups());
    }

    private int graphAsTreeDiameter_Graph_Helper(Map<Integer, List<Integer>> graph, int root, int parent) {

        //from the curr root node, there should be 2 max length branches going
        //down from this 'root'
        int maxLengthBranch1 = 0;
        int maxLengthBranch2 = 0;

        for (int childVertex : graph.getOrDefault(root, new ArrayList<>())) {
            if (childVertex == parent) {
                continue;
            }

            int branchLength = graphAsTreeDiameter_Graph_Helper(graph, childVertex, root);

            if (branchLength > maxLengthBranch1) {
                maxLengthBranch2 = maxLengthBranch1;
                maxLengthBranch1 = branchLength;
            } else if (branchLength > maxLengthBranch2) {
                maxLengthBranch2 = branchLength;
            }
        }

        //max diameter can be formed from max-left-branch(== maxLengthBranch1)
        //and max-right-branch(== maxLengthBranch2) + 1 for the root node itself
        graphAsTreeDiameter_Graph_MaxDiameter = Math.max(
                graphAsTreeDiameter_Graph_MaxDiameter,
                maxLengthBranch1 + 1 + maxLengthBranch2);

        //futher find a max diameter, so choose one from 
        //max-left-branch or max-right-branch + 1 for root node itself
        return Math.max(maxLengthBranch1, maxLengthBranch2) + 1;
    }

    private int graphAsTreeDiameter_Graph_MaxDiameter;

    public void graphAsTreeDiameter_Graph(int[][] edges) {
        //https://leetcode.com/problems/tree-diameter/
        //https://leetcode.ca/all/1245.html
        //based on TREE DIAMETER
        graphAsTreeDiameter_Graph_MaxDiameter = Integer.MIN_VALUE;
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];

            //undirected graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int root = 0;

        graphAsTreeDiameter_Graph_Helper(graph, root, -1);

        //output
        System.out.println("Graph as tree diameter (nodes in diameter): "
                + graphAsTreeDiameter_Graph_MaxDiameter);
        System.out.println("Graph as tree diameter (length diameter): "
                + (graphAsTreeDiameter_Graph_MaxDiameter - 1));
    }

    public void shorestPathInWeightedUndirectedGraph_Graph(int V, int[][] edges) {
        //same but for directed weighted graph : https://leetcode.com/problems/design-graph-with-shortest-path-calculator/description/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
        //explanation : https://youtu.be/icVJUN45f1E
        //based on DJIKSTRA ALGO
        List<Integer> path = new ArrayList<>();
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, weight));
        }

        int src = 1;
        int dest = V;

        int[] parent = new int[V + 1];
        int[] dist = new int[V + 1];

        Arrays.fill(parent, Integer.MAX_VALUE);
        Arrays.fill(dist, Integer.MAX_VALUE);

        //parent of the src is -1
        parent[src] = -1;
        //dist to reach the src vertex is 0
        dist[src] = 0;

        PriorityQueue<GraphEdge> queue = new PriorityQueue<>(
                (a, b) -> a.weight - b.weight);

        queue.add(new GraphEdge(src, 0));

        while (!queue.isEmpty()) {

            GraphEdge currEdge = queue.poll();

            for (GraphEdge childEdge : graph.getOrDefault(currEdge.vertex, new ArrayList<>())) {

                if (dist[currEdge.vertex] + childEdge.weight < dist[childEdge.vertex]) {

                    dist[childEdge.vertex] = dist[currEdge.vertex] + childEdge.weight;
                    queue.add(new GraphEdge(childEdge.vertex, dist[childEdge.vertex]));

                    parent[childEdge.vertex] = currEdge.vertex;
                }
            }
        }

        if (parent[dest] == Integer.MAX_VALUE) {
            System.out.println(String.format("No path from src : %d to dest : %d is possible", src, V));
            return;
        }

        path.add(dest);
        //backtrack from dest vertex's parent to src vertex
        //so src vertex's parent is -1
        while (parent[dest] != -1) {
            path.add(parent[dest]);
            dest = parent[dest];
        }

        Collections.reverse(path);
        //output
        System.out.println(String.format("Path from src : %d to dest : %d is : ", src, V) + path);
    }

    private boolean checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(
            Map<Integer, List<GraphEdge>> graph, boolean[] visited,
            int srcVertex, int destVertex, int limit) {

        //simple DFS call but it will give TLE
        if (srcVertex == destVertex) {
            return true;
        }

        visited[srcVertex] = true;

        boolean hasPath = false;

        for (GraphEdge childNode : graph.getOrDefault(srcVertex, new ArrayList<>())) {

            //skip, if a vertex is already visited earlier
            if (visited[childNode.vertex]) {
                continue;
            }

            //skip, if the weight associated to this child vertex is more or equal
            //to limit, as we need to choose those paths/edges where their weight
            //is STRICTLY LESS than given limit
            if (childNode.weight >= limit) {
                continue;
            }

            //if there exists such path where the weight of each edge in that path
            //is less than given limit, then hasPath will be true
            hasPath = hasPath
                    || checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(graph, visited,
                            childNode.vertex, destVertex, limit);
        }

        //since we might need to check many paths from the same srcVertex, we have
        //to un-visit srcVertex here after we have complete DFS on path from this
        //srcVertex
        visited[srcVertex] = false;

        return hasPath;
    }

    public void checkExistenceOfEdgeLengthLimitedPaths_Graph(int V, int[][] edges, int[][] queries) {
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //based on DFS but TLE
        int m = queries.length;
        boolean[] result = new boolean[m];
        Map<Integer, List<GraphEdge>> graph = new HashMap<>();
        boolean[] visited = new boolean[V];

        //undirected graph
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new GraphEdge(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new GraphEdge(u, weight));
        }

        for (int i = 0; i < m; i++) {
            int src = queries[i][0];
            int dest = queries[i][1];
            int limit = queries[i][2];

            boolean hasPath = checkExistenceOfEdgeLengthLimitedPaths_Graph_HelperDFS(
                    graph, visited, src, dest, limit);
            result[i] = hasPath;
        }
        //output
        System.out.println("Check existence of edge length limited paths : " + Arrays.toString(result));
    }

    public void checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(
            int V, int[][] edges, int[][] queries) {
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/editorial/
        //based on UNION FIND
        class UnionFind {

            //explanation union-find : https://youtu.be/Kptz-NVA2RE
            private int[] group;
            private int[] rank;

            UnionFind(int size) {
                group = new int[size];
                rank = new int[size];
                for (int i = 0; i < size; ++i) {
                    group[i] = i;
                }
            }

            public int find(int node) {
                if (group[node] == node) {
                    return node;
                }
                return group[node] = find(group[node]);
            }

            public void join(int node1, int node2) {
                int group1 = find(node1);
                int group2 = find(node2);

                // node1 and node2 already belong to same group.
                if (group1 == group2) {
                    return;
                }

                if (rank[group1] > rank[group2]) {
                    group[group2] = group1;
                } else if (rank[group1] < rank[group2]) {
                    group[group1] = group2;
                } else {
                    group[group1] = group2;
                    rank[group2] += 1;
                }
            }

            public boolean areConnected(int node1, int node2) {
                int group1 = find(node1);
                int group2 = find(node2);
                return group1 == group2;
            }
        }

        UnionFind unionFind = new UnionFind(V);
        int queriesLen = queries.length;
        boolean[] answer = new boolean[queriesLen];

        // Store original indices with all queries.
        int[][] queriesWithIndex = new int[queriesLen][4];
        for (int i = 0; i < queriesLen; ++i) {
            queriesWithIndex[i][0] = queries[i][0];
            queriesWithIndex[i][1] = queries[i][1];
            queriesWithIndex[i][2] = queries[i][2];
            queriesWithIndex[i][3] = i;
        }

        // Sort all edges in increasing order of their edge weights.
        Arrays.sort(edges, (a, b) -> a[2] - b[2]);
        // Sort all queries in increasing order of the limit of edge allowed.
        Arrays.sort(queriesWithIndex, (a, b) -> a[2] - b[2]);

        int edgesIndex = 0;

        // Iterate on each query one by one.
        for (int queryIndex = 0; queryIndex < queriesLen; queryIndex++) {
            int src = queriesWithIndex[queryIndex][0];
            int dest = queriesWithIndex[queryIndex][1];
            int limit = queriesWithIndex[queryIndex][2];
            int queryOriginalIndex = queriesWithIndex[queryIndex][3];

            //we can attach all edges which satisfy the limit given by the query.
            //since the edges and queries are sorted by their weight/ limits, from
            //below while loop, we will form the disjoint set of only those edges
            //whose edge-weight is STRICTLY LESS than the curr query limit
            while (edgesIndex < edges.length && edges[edgesIndex][2] < limit) {
                int u = edges[edgesIndex][0];
                int v = edges[edgesIndex][1];
                unionFind.join(u, v);
                edgesIndex += 1;
            }

            // If both nodes belong to the same component, it means we can reach them. 
            answer[queryOriginalIndex] = unionFind.areConnected(src, dest);
        }
        //output
        System.out.println("Check existence of edge length limited paths : " + Arrays.toString(answer));
    }

    public void redundantConnections_Graph(int[][] edges) {
        //https://leetcode.com/problems/redundant-connection/description/
        //based on UNION FIND/ DISJOINT SET
        int n = edges.length;
        class UnionFind {

            //explanation union-find : https://youtu.be/Kptz-NVA2RE
            int[] parent;
            int[] rank;

            public UnionFind(int n) {
                //n + 1 because nodes in this graphs are labeled as [1 to n]
                parent = new int[n + 1];
                rank = new int[n + 1];
                //initailly each node u is representative of itself
                for (int u = 0; u < n + 1; u++) {
                    parent[u] = u;
                }
            }

            public int find(int node) {
                //for a given node 'node' find the top most root/representative
                //of this node in a certain set
                if (parent[node] == node) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int rep1 = find(node1);
                int rep2 = find(node2);

                //if the representative of both the nodes node1 & node2 are same
                //that means these two nodes have the same root, hence an edge
                //between node1 to node2 or vice versa will a redundant connection
                if (rep1 == rep2) {
                    return;
                }

                if (rank[rep1] < rank[rep2]) {
                    parent[rep1] = rep2;
                } else if (rank[rep1] > rank[rep2]) {
                    parent[rep2] = rep1;
                } else {
                    //both the representative have the same ranks then we can
                    //assign anyone as others node's representative
                    //here rep1 will become parent of rep2 hence rank of rep1 should
                    //be increased
                    parent[rep2] = rep1;
                    rank[rep1]++;
                }
            }
        }

        UnionFind unionFind = new UnionFind(n);
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int repU = unionFind.find(u);
            int repV = unionFind.find(v);
            //if the representative of nodes u & v are same, means they already
            //have a common root with which this u & v are connected then here
            //if we form an edge u -> v or v -> u that will a redundant connection
            //And any redundant connection/edge that occurs first in given edges[][]
            //return that
            if (repU == repV) {
                System.out.println("Redundant connection : " + Arrays.toString(new int[]{u, v}));
                return;
            }
            //if the above if() cond fails, means there is no common representative
            //or root of the nodes u & v yet, now we can put them in a set and then
            //we will have a common representative/root for them later on
            unionFind.union(u, v);
        }
        //if no redundant connection occures, however according to question there
        //will always a redundant edge
        System.out.println("Redundant connection : " + Arrays.toString(new int[]{}));
    }

    public void removeMaxEdgesToKeepGraphFullyTraversable_Graph(int V, int[][] edges) {
        //https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/
        class UnionFind {

            int[] parent;
            int[] rank;
            int connectedSet;

            public UnionFind(int n) {
                //a connectedSet in union find will tell how many diff disjoint sets/groups
                //are there in the graph
                //initially, each node in graph is in its own group hence connectedSet = n
                connectedSet = n;
                parent = new int[n + 1];
                rank = new int[n + 1];
                //initially, each node is the root/representative of itself
                for (int u = 0; u < n + 1; u++) {
                    parent[u] = u;
                }
            }

            public int find(int node) {
                if (parent[node] == node) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public int union(int node1, int node2) {
                int rep1 = find(node1);
                int rep2 = find(node2);

                //if the root/representative of both the nodes node1 & node2 are
                //same then no union needs to perform, return 0
                if (rep1 == rep2) {
                    return 0;
                }

                if (rank[rep1] > rank[rep2]) {
                    parent[rep2] = rep1;
                } else if (rank[rep1] < rank[rep2]) {
                    parent[rep1] = rep2;
                } else {
                    parent[rep2] = rep1;
                    rank[rep1]++;
                }

                //here we have successfully performed union on node1 & node2 that
                //means now either node1 is in node2 group OR node2 is in node1
                //group but any of the case we are merging one group into another
                //hence one connectedSet is removed with this
                connectedSet--;
                //return 1, as we have successfully performed union
                return 1;
            }

            public boolean areAllNodesConnected() {
                //with this question, we need that from every node in the graph,
                //we should be able to traverse to every other nodes, in terms of
                //disjoints set/ union-find, if every node is traversable by every
                //other nodes of the graph then all those nodes/edges are in the
                //same group that means initially connectedSet started off as n
                //(each nodes in its own set), now after union operations if
                //connectedSet == 1 means that all nodes are now in same group
                //and hence tells that we can traverse every node from every other node.
                return connectedSet == 1;
            }
        }

        int totalEdges = edges.length;
        int connectedEdges = 0;
        UnionFind aliceSet = new UnionFind(V);
        UnionFind bobSet = new UnionFind(V);

        //first add all the common edge(type == 3)
        for (int[] edge : edges) {
            int type = edge[0];
            int u = edge[1];
            int v = edge[2];

            if (type == 3) {
                //bitwise OR(|) means (0 | 1 == 1), (0 | 0 == 0), (1 | 1 == 1)
                //similar to (aliceSet.union(u, v) == 1 || bobSet.union(u, v) == 1) ? 1 : 0;
                //if a common edge can be added in these to diff sets that means
                //we have used 1 edge that allows both alice & bob to travel
                connectedEdges += (aliceSet.union(u, v) | bobSet.union(u, v));
            }
        }

        //now add all alice edges(type == 1) and bob edges(type == 2) but here if
        //any edge already exists as type == 3 edge previously then here alice &
        //bob respective edges will be 'redundant edges' and will not be counted
        //here we only add those edges related to alice and bob respectively to their
        //sets, now having all the union operations on alice and bob set, if all
        //the nodes are connected (connectedSet == 1) in both alice and bob that
        //means with all the given types of edges as 'type', we can traverse every
        //node from every other node.
        for (int[] edge : edges) {
            int type = edge[0];
            int u = edge[1];
            int v = edge[2];

            //if any u & v that belongs to either alice(type == 1) or bob(type == 2)
            //edges and this u & v are already in union find of either alice or bob
            //via above loop for type == 3 then that union() will give 0, otherwise 1
            if (type == 1) {
                connectedEdges += aliceSet.union(u, v);
            } else if (type == 2) {
                connectedEdges += bobSet.union(u, v);
            }
        }

        if (aliceSet.areAllNodesConnected() && bobSet.areAllNodesConnected()) {
            System.out.println("Max edge removed to keep all the nodes fully traversable : "
                    + (totalEdges - connectedEdges));
            return;
        }
        System.out.println("Max edge removed to keep all the nodes fully traversable : -1");
    }

    public void detectCycleIn2DGrid_Graph(char[][] grid) {
        //https://leetcode.com/problems/detect-cycles-in-2d-grid/description/
        int ROW = grid.length;
        int COL = grid[0].length;
        boolean[][] visited = new boolean[ROW][COL];
        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        class Helper {

            boolean isOutOfBounds(int row, int col) {
                return row < 0 || row >= ROW || col < 0 || col >= COL;
            }

            boolean helperDFS(char[][] grid, int row, int col, int prevRow, int prevCol, char toMatch) {

                if (isOutOfBounds(row, col)) {
                    return false;
                }

                //if the row & col, is already in visited, means we are in the cycle here
                if (visited[row][col]) {
                    return true;
                }

                visited[row][col] = true;

                boolean hasCycle = false;

                for (int[] dir : dirs) {
                    int newRow = row + dir[0];
                    int newCol = col + dir[1];

                    //skip, if new row & col are not valid locations on grid
                    if (isOutOfBounds(newRow, newCol)) {
                        continue;
                    }

                    //skip, if new row & col is same as prev row & col from where we come here
                    //we don't want to traverse back to same location from where have come, also
                    //to note, we can't use visited[][] for this if() block, why? because this
                    //will give a FALSE presence of cycle in the curr path, cycle path is checked
                    //in starting of recur 
                    if (newRow == prevRow && newCol == prevCol) {
                        continue;
                    }

                    //skip, if char at new row & col in grid is not same as the char we need to 'toMatch'
                    if (grid[newRow][newCol] != toMatch) {
                        continue;
                    }
                    //traverse in all 4-dir to check if there is any cycle
                    //newRow & newCol will become curr row & col for next recur
                    //here curr row & col will become prevRow & prevCol for next recur
                    //toMatch remain same, as we need to find cycle in grid[][] having
                    //char same as 'toMatch'
                    hasCycle = hasCycle || helperDFS(grid, newRow, newCol, row, col, toMatch);
                }
                return hasCycle;
            }
        }

        Helper helper = new Helper();

        boolean hasCycle = false;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                if (visited[r][c]) {
                    continue;
                }
                //bitwise OR check (|=) same as hasCycle = hasCycle || helper(...)
                //starting to check the cycle in grid from row & col == r & c
                //-1, -1 as prev row & col, as there is no prev row & col to r & c
                //and the cycle should contains char same as 'grid[r][c]'
                //In question, we need to return true if we find a single cycle
                //if(helper.helperDFS(grid, r, c, -1, -1, grid[r][c])) return true
                hasCycle |= helper.helperDFS(grid, r, c, -1, -1, grid[r][c]);
            }
        }
        //output
        System.out.println("Detect cycle in 2D grid : " + hasCycle);
    }

    public int makingALargeIsland_Graph(int[][] grid) {
        //https://leetcode.com/problems/making-a-large-island/description/
        //https://leetcode.com/problems/making-a-large-island/solutions/2460067/java-simple-easy-to-understand-using-dsu/
        //based on DSU/ UNION FIND on 2D grid graph
        //given grid is N * N matrix hence ROW == COL == N
        int ROW = grid.length;
        int COL = ROW;

        int[][] dirs = new int[][]{
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        //if grid contains only 1 row and col(means single element) and that is
        //also 1 then return 1
        if (ROW == 1 && grid[0][0] == 1) {
            return 1;
        }

        int maxConnectedIslandSize = 0;

        class UnionFind {

            int[] parent;
            int[] rank;
            int[] size;

            int maxSizeDistinctIsland = 0;

            public UnionFind(int V) {
                parent = new int[V];
                rank = new int[V];
                //size of connected groups, initially all the nodes are in their
                //own group hence their individual size is 1
                size = new int[V];
                Arrays.fill(size, 1);
                //initially all the nodes are in their own group hence each node
                //is parent of its own group
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {

                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                    //since parent1 is now the parent of connected group that
                    //contains all the nodes from parent1 & now parent2
                    //hence the size[parent1] also increased by size[parent2]
                    //means total nodes under parent1 = nodes under parent1 + nodes under parent2
                    size[parent1] += size[parent2];
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                    //since parent2 is now the parent of connected group that
                    //contains all the nodes from parent2 & now parent1
                    //hence the size[parent2] also increased by size[parent1]
                    //means total nodes under parent2 = nodes under parent1 + nodes under parent2
                    size[parent2] += size[parent1];
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                    //since parent1 is now the parent of connected group that
                    //contains all the nodes from parent1 & now parent2
                    //hence the size[parent1] also increased by size[parent2]
                    //means total nodes under parent1 = nodes under parent1 + nodes under parent2
                    size[parent1] += size[parent2];
                }

                //this represents the max size of any distinct/sparated island group
                maxSizeDistinctIsland = Math.max(
                        maxSizeDistinctIsland,
                        Math.max(size[parent1],
                                size[parent2]));

            }

            public int sizeOfConnectedIslandGroup(int parent) {
                return size[parent];
            }
        }

        UnionFind unionFind = new UnionFind(ROW * COL);

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {

                if (grid[r][c] == 1) {
                    //src node u == cell index of curr grid[r][c] cell
                    int nodeU = r * ROW + c;

                    //generate all the 4 adjacent row & col from the curr r & c
                    for (int[] dir : dirs) {
                        int newRow = r + dir[0];
                        int newCol = c + dir[1];

                        //skip, if new row & col locations on grid 'isOutOfBounds'
                        if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                            continue;
                        }

                        //skip, if new row & col locations on grid is not '1' cell
                        if (grid[newRow][newCol] == 0) {
                            continue;
                        }

                        //valid dest node V == cell index of 4-dir adjacent to curr r & c
                        int nodeV = newRow * ROW + newCol;
                        //make a union between nodeU and nodeV, where both
                        //nodeU and nodeV belongs to diff but 4-dir adjacent (row, col)
                        //having '1' in their cells
                        unionFind.union(nodeU, nodeV);
                    }
                }
            }
        }

        //from here we will check which '0' cell on grid will give us the larger
        //connected island group if we convert that '0' cell to '1' cell
        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                //if the curr cell is '0', then check to which '1' it is connected,
                //in adjacent 4-dir, find the parent for that '1' island group
                if (grid[r][c] == 0) {

                    Set<Integer> parents = new HashSet<>();

                    //generate all the 4 adjacent row & col from the curr r & c
                    //if these new row & col are valid and have '1' in cell then
                    //find the parent for this '1' island group
                    for (int[] dir : dirs) {

                        int newRow = r + dir[0];
                        int newCol = c + dir[1];

                        //skip, if new row & col locations on grid 'isOutOfBounds'
                        if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                            continue;
                        }

                        //skip, if new row & col locations on grid is not '1' cell
                        if (grid[newRow][newCol] == 0) {
                            continue;
                        }

                        //a node == cell index, which is 4-dir adjacent to curr
                        //r & c
                        int node = newRow * ROW + newCol;
                        int parent = unionFind.find(node);
                        parents.add(parent);
                    }

                    //connectedIslandSize is 1 because we are simulating to convert
                    //curr '0' as '1' AND, it will add up all the distinct island sizes
                    //connected to each other
                    int connectedIslandSize = 1;
                    for (int parent : parents) {
                        connectedIslandSize += unionFind.sizeOfConnectedIslandGroup(parent);
                    }

                    maxConnectedIslandSize = Math.max(
                            maxConnectedIslandSize,
                            connectedIslandSize);
                }
            }
        }
        return Math.max(maxConnectedIslandSize, unionFind.maxSizeDistinctIsland);
    }

    public boolean validateBinaryTreeNodes_Graph(int n, int[] leftChild, int[] rightChild) {
        //......................T: O(N * alpha(N)), N is total roots provided,
        //alpha(N) is inverse ackmann function which is near about constant.
        //find() & union) operations take alpha(n) time and we have to perform
        //find & union operation over N roots hence gives the O(N * alpha(N))
        //......................S: O(N), N is space required by parent[]
        //https://leetcode.com/problems/validate-binary-tree-nodes/description/
        //based on UNION FIND
        class UnionFind {

            //here rank[] is not neccessary as we just want to assign/make union of
            //each child nodes (left or right) to its 'root' node
            int[] parent;
            int connectedGroups;

            public UnionFind(int n) {
                connectedGroups = n;
                parent = new int[n];
                for (int node = 0; node < n; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public boolean union(int root, int child) {
                //parent1 is top-most root node/parent of curr 'root'
                int parent1 = find(root);
                //parent2 is top-most root node/parent of curr 'child'
                //but while finding a parent to any child at this point should
                //only belongs to itself (==> child should be parent of
                //itself ==> parent2 == child
                //==> only for this question and given condition) 
                int parent2 = find(child);

                //union is not possible(== return false) because
                //1. root & child forming a cycle condition (parent1 == parent2)
                //2. child is already associated to different parent but
                //ideally all the child should be parent of itself initailly (parent2 != child)
                if (parent1 == parent2 || parent2 != child) {
                    return false;
                }

                //rank[] is not necessary here and use of rank[] might give you
                //the wrong answer, why?
                //because with use of rank[] we determine that either 'parent1'
                //will become parent of 'parent2' group or vice verse but here
                //we already know that given 'root' will be the parent of child
                //below statement is same as parent['child'] = 'root'
                parent[parent2] = parent1;

                connectedGroups--;
                return true;
            }

            public boolean isTree() {
                return connectedGroups == 1;
            }
        }

        UnionFind unionFind = new UnionFind(n);

        for (int root = 0; root < n; root++) {
            int left = leftChild[root];
            int right = rightChild[root];

            if (left != -1 && !unionFind.union(root, left)) {
                return false;
            }

            if (right != -1 && !unionFind.union(root, right)) {
                return false;
            }
        }
        return unionFind.isTree();
    }

    public void maximalNetworkRank_Graph(int n, int[][] roads) {
        //https://leetcode.com/problems/maximal-network-rank/description/
        /*
        The network rank of two different cities is defined as the total number
        of directly connected roads to either city. If a road is directly connected
        to both cities, it is only counted once.
         */
        boolean[][] isConnected = new boolean[n][n];
        int[] inDegrees = new int[n];

        for (int[] road : roads) {

            int cityA = road[0];
            int cityB = road[1];

            //given road[] are bidirectional, cityA has an outgoing edge to cityB
            //causing indegree to cityB
            //similarly, cityB also has an outgoing edge to cityA causing indegree
            //to cityA
            inDegrees[cityA]++;
            inDegrees[cityB]++;

            //given roads[] are bidirectional, so cityA is connected to cityB
            //and cityB is connected to cityA
            //cityA <--> cityB
            isConnected[cityA][cityB] = true;
            isConnected[cityB][cityA] = true;
        }

        int maxRank = 0;

        //there can be disconnected roads in roads[] so need to check all the pairs
        for (int cityA = 0; cityA < n; cityA++) {
            for (int cityB = cityA + 1; cityB < n; cityB++) {
                maxRank = Math.max(
                        maxRank,
                        //ranks for curr city A & B will be, all the road connections from A to other cities
                        //+ all the road connections from B to other cities
                        //- remove 1, if both city A & B are also connected to each other causing
                        //indegrees to be counted twice between city A & B
                        //otherwise if they are not connected then nothing to remove (==> 0)
                        inDegrees[cityA] + inDegrees[cityB] - (isConnected[cityA][cityB] ? 1 : 0)
                );
            }
        }
        //output
        System.out.println("Maximal network ranks : " + maxRank);
    }

    public void evaluateDivision_Graph(String[][] equations, double[] values, String[][] queries) {
        //https://leetcode.com/problems/evaluate-division/description/
        //based on BFS and some basic maths divisions
        class Node {

            String vertex;
            double value;

            public Node(String vertex, double value) {
                this.vertex = vertex;
                this.value = value;
            }

        }

        int eqnLen = equations.length;
        Map<String, List<Node>> graph = new HashMap<>();

        int qLen = queries.length;
        double[] evaluatedResult = new double[qLen];

        class Helper {

            double helperBFS(String srcVertex, String destVertex) {

                //return -1.0, if either of the numerator or denominator is not
                //present in the graph means the equation "srcVertex / destVertex" is
                //invalid
                if (!graph.containsKey(srcVertex) || !graph.containsKey(destVertex)) {
                    return -1.0;
                }

                Set<String> visited = new HashSet<>();
                Queue<Node> queue = new LinkedList<>();

                //initial src == srcVertex, initial product value == 1
                queue.add(new Node(srcVertex, 1));
                visited.add(srcVertex);

                while (!queue.isEmpty()) {

                    Node currNode = queue.poll();

                    //if we have reached our dest vertex, we can return our final
                    //product value == currNode.value
                    if (currNode.vertex.equals(destVertex)) {
                        return currNode.value;
                    }

                    for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                        if (visited.contains(childNode.vertex)) {
                            continue;
                        }

                        visited.add(childNode.vertex);
                        queue.add(new Node(childNode.vertex, currNode.value * childNode.value));
                    }
                }
                return -1.0;
            }

        }

        Helper helper = new Helper();

        for (int i = 0; i < eqnLen; i++) {

            String nodeU = equations[i][0];
            String nodeV = equations[i][1];
            double value = values[i];

            //in the curr equations[i] ex: ["a", "b"] whose value = values[i]
            //any curr i-th equation will mean "a" / "b" = 'value'
            //by basic math logic we have a relationship that is,
            //expression : a/b = value then reciprocated relationship will be
            //expression : b/a = 1/value
            //here we need to form a graph which will be undirected-weighted graph
            //means each numerator and denominator value from the equation will
            //have a weighted edge to each other based on maths division & reciprocal
            //concept
            //nodeU --> {nodeV, value} ==> "a" --> {"b", 'value'}
            graph.putIfAbsent(nodeU, new ArrayList<>());
            graph.get(nodeU).add(new Node(nodeV, value));

            //nodeV --> {nodeU, 1 / value} ==> "b" --> {"a", '1.0 / value'}
            graph.putIfAbsent(nodeV, new ArrayList<>());
            graph.get(nodeV).add(new Node(nodeU, (1.0 / value)));
        }

        for (int i = 0; i < qLen; i++) {

            String nodeU = queries[i][0];
            String nodeV = queries[i][1];

            evaluatedResult[i] = helper.helperBFS(nodeU, nodeV);
        }
        //output
        System.out.println("Evaluate division : " + Arrays.toString(evaluatedResult));
    }

    public void cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(int n, int[][] edges, int distThreshold) {
        //https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/
        //based on DIJKSTRA ALGO, SHORTEST PATH from all NODES to all OTHER-NODES
        class Node {

            int vertex;
            int weight;

            public Node(int vertex, int weight) {
                this.vertex = vertex;
                this.weight = weight;
            }

        }

        Map<Integer, List<Node>> graph = new HashMap<>();

        class Helper {

            int helperDijkstraForShortestPathWithinThreshold(int srcCity) {

                int[] dist = new int[n];
                Arrays.fill(dist, Integer.MAX_VALUE);

                int srcCityConnectedCities = 0;

                PriorityQueue<Node> minHeapWeight = new PriorityQueue<>(
                        (a, b) -> a.weight - b.weight);

                minHeapWeight.add(new Node(srcCity, 0));
                dist[srcCity] = 0;

                while (!minHeapWeight.isEmpty()) {

                    Node currNode = minHeapWeight.poll();

                    for (Node childNode : graph.getOrDefault(currNode.vertex, new ArrayList<>())) {

                        //skip, if the dist to reach next child node from curr node
                        //having weight in between as 'childNode.weight' is more than
                        //the threshold given
                        if (dist[currNode.vertex] + childNode.weight > distThreshold) {
                            continue;
                        }

                        //if the dist to reach child node from curr node is under the threshold
                        //we can perform our typical 'dijkstra algo'
                        if (dist[childNode.vertex] > dist[currNode.vertex] + childNode.weight) {

                            //here we are updating the dist to reach child node for the
                            //first time, because only for the first time dist[childNode.vertex]
                            //will be Integer.MAX_VALUE hence this curr child node is reachable
                            //via the curr node under threshold limit given and we only need to
                            //count these connected cities only once
                            if (dist[childNode.vertex] == Integer.MAX_VALUE) {
                                srcCityConnectedCities++;
                            }

                            dist[childNode.vertex] = dist[currNode.vertex] + childNode.weight;
                            minHeapWeight.add(new Node(childNode.vertex, dist[childNode.vertex]));
                        }
                    }
                }
                return srcCityConnectedCities;
            }

        }

        Helper helper = new Helper();

        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            int weight = edge[2];

            //undirected-weighted graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(new Node(v, weight));

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(new Node(u, weight));
        }

        //minConnectedCities = will have the least number of cities connected to
        //a city
        int minConnectedCities = Integer.MAX_VALUE;
        //city = city that have the smallest number of cities connected
        int city = -1;

        for (int srcCity = 0; srcCity < n; srcCity++) {

            int currNodeConnectedCities = helper.helperDijkstraForShortestPathWithinThreshold(srcCity);

            if (currNodeConnectedCities < minConnectedCities) {
                minConnectedCities = currNodeConnectedCities;
                city = srcCity;
            } else if (currNodeConnectedCities == minConnectedCities) {
                //if two cities have same number of cities connected to them then
                //choose the city with bigger city index(its a linear loop so curr
                //srcCity will always be bigger than previous 'city')
                city = srcCity;
            }
        }
        //output
        System.out.println("City with smallest number of cities connected within given threshold : " + city);
    }

    public void floodFill_Helper(int[][] image, int row, int col,
            int srcColor, int newColor, boolean[][] visited) {

        //is out of bounds
        if (row < 0 || row >= image.length || col < 0 || col >= image[row].length
                || visited[row][col]
                || image[row][col] != srcColor) {
            return;
        }

        visited[row][col] = true;

        image[row][col] = newColor;

        //UP
        floodFill_Helper(image, row - 1, col, srcColor, newColor, visited);

        //DOWN
        floodFill_Helper(image, row + 1, col, srcColor, newColor, visited);

        //LEFT
        floodFill_Helper(image, row, col - 1, srcColor, newColor, visited);

        //RIGHT
        floodFill_Helper(image, row, col + 1, srcColor, newColor, visited);
    }

    public void floodFill(int[][] image, int srcR, int srcC, int newColor) {
        //https://leetcode.com/problems/flood-fill/
        //actual
        System.out.println();
        for (int[] r : image) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }

        int srcColor = image[srcR][srcC];
        boolean[][] visited = new boolean[image.length][image[0].length];
        floodFill_Helper(image, srcR, srcC, srcColor, newColor, visited);

        //output
        System.out.println("output: ");
        for (int[] r : image) {
            for (int c : r) {
                System.out.print(c + "\t");
            }
            System.out.println();
        }
    }

    public boolean checkIfGivenUndirectedGraphIsBinaryTree(int V, List<List<Integer>> adjList) {

        //two condition for a undirected graph to be tree
        //1. should not have a cycle
        //2. the graph should be connected
        boolean[] visited = new boolean[V];

        //check undriected cycle
        //if all nodes is reachable via vertex 0 without forming a cycle
        //if cycle is present then its not tree and return false
        //it will also mark visited = true all those nodes that are connected to each other
        if (detectCycleInUndirectedGraphDFS_Helper(adjList, 0, -1, visited)) {
            //if all the vertexes are connected and still there is cycle anywhere in the graph
            //it will be detected here. In case if a part of graph is not connected and that contains
            //cycle(which is not detectable), still below isConnected loop will return false as
            //all nodes are not connected. in visited[]
            return false;
        }

        for (boolean isConnected : visited) {
            if (!isConnected) {
                return false;
            }
        }

        return true;
    }

    private void allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
            Map<Integer, List<Integer>> graph, int src, int dest,
            boolean[] visited, List<Integer> currPath, List<List<Integer>> paths) {

        if (src == dest) {
            paths.add(new ArrayList<>(currPath));
            return;
        }

        visited[src] = true;

        for (int childVertex : graph.getOrDefault(src, new ArrayList<>())) {

            if (visited[childVertex]) {
                continue;
            }

            currPath.add(childVertex);

            allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
                    graph, childVertex, dest, visited, currPath, paths);

            currPath.remove(currPath.size() - 1);
        }

        visited[src] = false;
    }

    public void allPathFromSourceToTargetInDirectedAcyclicGraph(int[][] edges) {
        //https://leetcode.com/problems/all-paths-from-source-to-target/
        //based graph DFS, backtracking
        List<List<Integer>> paths = new ArrayList<>();

        if (edges[0].length == 0 && edges[1].length == 0) {
            return;
        }

        //prepare data
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int src = 0; src < edges.length; src++) {
            graph.put(src, new ArrayList<>());
            for (int childVertex : edges[src]) {
                graph.get(src).add(childVertex);
            }
        }

        int source = 0;
        int target = graph.size() - 1; //target = V - 1

        boolean[] visited = new boolean[edges.length];

        List<Integer> currPath = new ArrayList<>();
        currPath.add(source);

        allPathFromSourceToTargetInDirectedAcyclicGraph_Helper(
                graph, source, target, visited, currPath, paths);

        //output:
        System.out.println("All paths from source to destination in DAG: " + paths);
    }

    private boolean checkIfPathExistsFromSourceToDestination_DFS(int[][] grid, int x, int y) {

        if (x < 0 || x >= grid.length || y < 0 || y >= grid[x].length
                || grid[x][y] == 0) {
            return false;
        }

        if (grid[x][y] == 2) {
            return true;
        }

        int original = grid[x][y];
        grid[x][y] = 0;

        boolean anyPathPossible
                = checkIfPathExistsFromSourceToDestination_DFS(grid, x - 1, y)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x + 1, y)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x, y - 1)
                || checkIfPathExistsFromSourceToDestination_DFS(grid, x, y + 1);

        grid[x][y] = original;

        return anyPathPossible;
    }

    public boolean checkIfPathExistsFromSourceToDestination(int[][] grid) {

        int r = grid.length;
        int c = grid[0].length;

        for (int x = 0; x < r; x++) {
            for (int y = 0; y < c; y++) {
                if (grid[x][y] == 1 && checkIfPathExistsFromSourceToDestination_DFS(grid, x, y)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean canWeVisitAllTheRooms_Graph(List<List<Integer>> rooms) {
        //problem: https://leetcode.com/problems/keys-and-rooms
        //explanation: https://youtu.be/Rz_-Kx0LN-E
        //based on BFS
        int n = rooms.size();

        int currRoom = 0;

        Queue<Integer> queue = new LinkedList<>();
        queue.add(currRoom);

        boolean[] visited = new boolean[n];
        //curr room is visited as we are starting from this one
        visited[currRoom] = true;

        //do BFS to mark what all rooms we can visit
        while (!queue.isEmpty()) {

            int size = queue.size();

            for (int i = 0; i < size; i++) {

                currRoom = queue.poll();

                for (int childRoom : rooms.get(currRoom)) {
                    if (visited[childRoom]) {
                        continue;
                    }

                    visited[childRoom] = true;
                    queue.add(childRoom);
                }
            }
        }

        //if after traversing all the rooms, there is any room left 
        //unvisited then return false;
        for (boolean isRoomVisited : visited) {
            if (!isRoomVisited) {
                return false;
            }
        }

        return true;
    }

    private void vertexWithWeightAllSourceToDestinationPath_Helper(List<List<VertexWithWeight>> adj,
            int mainSource, int source, int target,
            int currWeight, boolean[] vis, Map<String, Integer> result) {

        if (source == target) {
            if (!result.containsKey(target + "-" + mainSource)) {
                result.put(mainSource + "-" + target, currWeight);
            }
        }

        vis[source] = true;
        List<VertexWithWeight> childs = adj.get(source);
        for (VertexWithWeight cv : childs) {

            if (vis[cv.vertex] != true) {
                vertexWithWeightAllSourceToDestinationPath_Helper(adj, mainSource, cv.vertex, target, currWeight + cv.weight, vis, result);
            }
        }
        vis[source] = false;
    }

    public void vertexWithWeightAllSourceToDestinationPath(List<List<VertexWithWeight>> adj) {

        int V = adj.size();
        Map<String, Integer> result = new HashMap<>();
        boolean[] vis = new boolean[V];
        for (int u = 0; u < V; u++) {

            for (int v = 0; v < V; v++) {
//                Arrays.fill(vis, false);
                if (u != v) {
                    vertexWithWeightAllSourceToDestinationPath_Helper(adj, u, u, v, 0, vis, result);
                }
            }
        }

        //output:
        result.entrySet()
                .stream()
                .sorted((a, b) -> a.getKey().compareTo(b.getKey()))
                .forEach(e -> System.out.println(e.getKey() + " = " + e.getValue()));

    }

    public void vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(int V, int[][] edges) {

        //https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
        //explanation: https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/discuss/1179313/best-solution
        /*
         all Vertex Through Other Nodes Can Be Reached are those nodes who doesn't have any
         incoming directions to them
         ex: [{0,1},{0,2},{2,5},{3,4},{4,2}]
         0 : [1,2]
         2 : [5]
         3 : [4]
         4 : [2]
         only 0 and 3 are the vertex who doesn't have incoming req
         */
        List<Integer> allVertexThroughOtherNodesCanBeReached = new ArrayList<>();
        int[] incomingRequest = new int[V];
        for (int i = 0; i < edges.length; i++) {
            incomingRequest[edges[i][1]]++;
        }

        for (int i = 0; i < V; i++) {
            if (incomingRequest[i] == 0) {
                allVertexThroughOtherNodesCanBeReached.add(i);
            }
        }

        //output
        System.out.println("Vertexes in DAG through all other vertex can be reached: " + allVertexThroughOtherNodesCanBeReached);
    }

    public boolean checkIfGraphIsBipartite_Graph(int[][] graph) {
        //https://leetcode.com/problems/is-graph-bipartite/
        /*A graph is bipartite if the nodes can be partitioned into two independent 
         sets A and B such that every edge in the graph connects a node 
         in set A and a node in set B.*/
        int V = graph.length;

        int UNCOLORED = -1;
        int BLUE_COLOR = 1;
        int RED_COLOR = 0;

        int[] colors = new int[V];
        //initially all the vertex are uncolored(== -1)
        Arrays.fill(colors, UNCOLORED);

        Queue<Integer> queue = new LinkedList<>();

        //we will move over all the vertex, incase if our graph is disconnected
        for (int src = 0; src < V; src++) {
            //skip if the curr src vertex was already colored in some previous iterations
            if (colors[src] != UNCOLORED) {
                continue;
            }

            //mark the inital color of curr src vertex as BLUE, all the child vertex
            //from this curr src are to be colored oppsite of the curr src color
            colors[src] = BLUE_COLOR;
            queue.add(src);

            //BFS
            while (!queue.isEmpty()) {

                int currSrc = queue.poll();

                for (int childVertex : graph[currSrc]) {
                    //if the child vertex of curr src vertex already have the same color
                    //as that of the its parent i.e curr src vertex, that means there
                    //can't be bipartition
                    if (colors[childVertex] == colors[currSrc]) {
                        return false;
                    }

                    //if the child vertex is not already colored, we will color
                    //this child vertex opposite of its parent i.e, curr src
                    if (colors[childVertex] == UNCOLORED) {
                        colors[childVertex] = colors[currSrc] == BLUE_COLOR ? RED_COLOR : BLUE_COLOR;
                        queue.add(childVertex);
                    }
                }
            }
        }
        return true;
    }

    public boolean possibleBipartition_Graph(int n, int[][] dislikes) {
        //https://leetcode.com/problems/possible-bipartition/description/
        //based on graph bipartition, checkIfGraphIsBipartite_Graph()
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int[] dislike : dislikes) {
            int u = dislike[0];
            int v = dislike[1];

            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);

            graph.putIfAbsent(v, new ArrayList<>());
            graph.get(v).add(u);
        }

        int UNCOLORED = -1;
        int BLUE_COLOR = 1;
        int RED_COLOR = 0;

        int[] colors = new int[n + 1];
        //initially all the vertex are uncolored(== -1)
        Arrays.fill(colors, UNCOLORED);

        Queue<Integer> queue = new LinkedList<>();

        //we will move over all the vertex, incase if our graph is disconnected
        for (int src = 1; src <= n; src++) {
            //skip if the curr src vertex was already colored in some previous iterations
            if (colors[src] != UNCOLORED) {
                continue;
            }

            //mark the inital color of curr src vertex as BLUE, all the child vertex
            //from this curr src are to be colored oppsite of the curr src color
            colors[src] = BLUE_COLOR;
            queue.add(src);

            //BFS
            while (!queue.isEmpty()) {

                int currSrc = queue.poll();

                for (int childVertex : graph.getOrDefault(currSrc, new ArrayList<>())) {
                    //if the child vertex of curr src vertex already have the same color
                    //as that of the its parent i.e curr src vertex, that means there
                    //can't be bipartition
                    if (colors[childVertex] == colors[currSrc]) {
                        return false;
                    }

                    //if the child vertex is not already colored, we will color
                    //this child vertex opposite of its parent i.e, curr src
                    if (colors[childVertex] == UNCOLORED) {
                        colors[childVertex] = colors[currSrc] == BLUE_COLOR ? RED_COLOR : BLUE_COLOR;
                        queue.add(childVertex);
                    }
                }
            }
        }
        return true;
    }

    private boolean courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
            Map<Integer, List<Integer>> graph, int course,
            boolean[] visited, boolean[] recurStack, List<Integer> courseOrderings) {

        //same as detect cycle in directed graph but with map based graph input
        if (recurStack[course]) {
            return true;
        }

        if (visited[course]) {
            return false;
        }

        recurStack[course] = true;
        visited[course] = true;

        for (int mandateCourse : graph.getOrDefault(course, new ArrayList<>())) {
            if (courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
                    graph, mandateCourse, visited, recurStack, courseOrderings)) {
                //if there is cycle is graph ex: courseSchedule[][] =  [[0, 1], [1, 0]]
                return true;
            }
        }

        courseOrderings.add(course);

        recurStack[course] = false;

        return false;
    }

    public void courseScheduleTwo_Graph(int[][] courseSchedule, int courses) {

        //https://leetcode.com/problems/course-schedule-ii/
        //https://leetcode.com/discuss/interview-question/742238/Amazon-or-Student-Order
        //Directed graph
        Map<Integer, List<Integer>> graph = new HashMap<>();
        //check cycle in Directed acyclic graph
        boolean[] visited = new boolean[courses];
        boolean[] recurStack = new boolean[courses];
        //here stack is not used as the natural order will be same in list as we 
        //required in the output array
        List<Integer> courseOrderings = new ArrayList<>();

        for (int[] schedule : courseSchedule) {

            int u = schedule[0];
            int v = schedule[1];

            //directed graph
            graph.putIfAbsent(u, new ArrayList<>());
            graph.get(u).add(v);
        }

        //for all the course from given courses
        for (int course = 0; course < courses; course++) {

            //if a particular course is already visited/ completed for some other
            //previous course, then we need not to visited this course again
            if (visited[course]) {
                continue;
            }

            //we will perform the topo sort on the graph and at the same time
            //we will check if there is a cycle in the graph or not, since the
            //given graph is directed one so we will use detect cycle in directed
            //graph
            if (courseScheduleTwo_TopoSort_With_DetectDirectedGraphCycle(
                    graph, course, visited, recurStack, courseOrderings)) {
                //if there is a cycle in the graph, we can't complete the course
                //hence our result is empty array
                System.out.println("Course schedule two order : " + Arrays.toString(new int[]{}));
                return;
            }
        }

        //output
        //simply, courseOrderings can be printed directly but as question required
        //coverting it to array
        int[] courseOrderingArray = courseOrderings.stream().mapToInt(course -> course).toArray();
        System.out.println("Course schedule two order: " + Arrays.toString(courseOrderingArray));
    }

    private void alienDictionary_Graph_TopoSort(
            Map<Integer, List<Integer>> graph, int vertex, boolean[] visited, Stack<Integer> stack) {

        visited[vertex] = true;

        for (int childVertex : graph.getOrDefault(vertex, new ArrayList<>())) {

            if (visited[childVertex]) {
                continue;
            }

            alienDictionary_Graph_TopoSort(graph, childVertex, visited, stack);
        }

        stack.push(vertex);
    }

    public void alienDictionary_Graph(String[] dict, int alphabets) {

        //.............................T: O(N + alphabets)
        //https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/
        //explanation: https://youtu.be/6kTZYvNNyps
        /*
         The first step to create a graph takes O(n + alhpa) time where n is 
         number of given words and alpha is number of characters in given 
         alphabet. The second step is also topological sorting. Note that 
         there would be alpha vertices and at-most (n-1) edges in the graph. 
         The time complexity of topological sorting is O(V+E) which is 
         O(n + aplha) here. So overall time complexity is 
         O(n + aplha) + O(n + aplha) which is O(n + aplha).
         */
        //prepare input
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for (int i = 0; i < dict.length - 1; i++) {
            String wrd1 = dict[i];
            String wrd2 = dict[i + 1];
            int minLenWrd = Math.min(wrd1.length(), wrd2.length());
            for (int j = 0; j < minLenWrd; j++) {
                char chWrd1 = wrd1.charAt(j);
                char chWrd2 = wrd2.charAt(j);
                //this if will find the first non matching char in both the words
                //ex: wrd1 = "wrt" wrd2 = "wrf" first non matching char be t & f
                if (chWrd1 != chWrd2) {
                    graph.putIfAbsent(chWrd1 - 'a', new ArrayList<>());
                    graph.get(chWrd1 - 'a').add(chWrd2 - 'a');
                    break;
                }
            }
        }

        //do topo sort
        boolean[] visited = new boolean[alphabets];
        Stack<Integer> stack = new Stack<>();

        for (int u = 0; u < alphabets; u++) {

            if (visited[u]) {
                continue;
            }

            alienDictionary_Graph_TopoSort(graph, u, visited, stack);
        }

        String orderOfAlienAlphabet = "";
        while (!stack.isEmpty()) {
            orderOfAlienAlphabet += (char) (stack.pop() + 'a') + ", ";
        }

        //output
        //for removing last from string ", "
        String res = orderOfAlienAlphabet.substring(0, orderOfAlienAlphabet.length() - 2);
        System.out.println("Order of alphabet in alien language: " + res);
    }

    private boolean alienDictionary2_Graph_Cycle_Check_DFS(
            Map<Character, Set<Character>> graph, char vertex,
            Set<Character> visited, Stack<Character> topo) {

        if (visited.contains(vertex)) {
            return true;
        }

        visited.add(vertex);

        for (char childVertex : graph.getOrDefault(vertex, new HashSet<>())) {
            if (alienDictionary2_Graph_Cycle_Check_DFS(graph, childVertex, visited, topo)) {
                return true;
            }
        }
        visited.remove(vertex);
        topo.push(vertex);
        return false;
    }

    public void alienDictionary2_Graph(String[] dict) {

        //.............................T: O(N + alphabets)
        //https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/
        //explanation: https://youtu.be/6kTZYvNNyps
        //prepare input
        Map<Character, Set<Character>> graph = new HashMap<>();
        for (int i = 0; i < dict.length - 1; i++) {
            String wrd1 = dict[i];
            String wrd2 = dict[i + 1];
            int minLenWrd = Math.min(wrd1.length(), wrd2.length());
            for (int j = 0; j < minLenWrd; j++) {
                char chWrd1 = wrd1.charAt(j);
                char chWrd2 = wrd2.charAt(j);
                //this if will find the first non matching char in both the words
                //ex: wrd1 = "wrt" wrd2 = "wrf" first non matching char be t & f
                if (chWrd1 != chWrd2) {
                    graph.putIfAbsent(chWrd1, new HashSet<>());
                    graph.get(chWrd1).add(chWrd2);
                    break;
                }
            }
        }

        //do topo sort
        Set<Character> visited = new HashSet<>();
        Stack<Character> topo = new Stack<>();

        for (char key : graph.keySet()) {
            if (alienDictionary2_Graph_Cycle_Check_DFS(graph, key, visited, topo)) {
                System.out.println("Order of alphabet in alien language: NOT POSSIBLE");
                //return "";
            }
        }

        String orderOfAlienAlphabet = "";
        int charReq = graph.size();
        while (!topo.isEmpty() && charReq != 0) {
            orderOfAlienAlphabet += topo.pop() + ", ";
            charReq--;
        }

        //output
        //for removing last from string ", "
        String res = orderOfAlienAlphabet.substring(0, orderOfAlienAlphabet.length() - 2);
        System.out.println("Order of alphabet in alien language: " + res);
    }

    public int findTownJudge_Graph(int n, int[][] trusts) {
        //https://leetcode.com/problems/find-the-town-judge/
        //https://leetcode.com/problems/find-the-town-judge/discuss/2106467/Simple-yet-efficient-java-solution
        int[] inDegree = new int[n];
        for (int[] trust : trusts) {
            //0th person(trust[0]) trust 1st person(trust[1])
            //that way trust[1] got inDegree from trust[0]
            //but if later on it is found that trust[1] is also trusting
            //someone else that means we have to reduce its inDegree
            inDegree[trust[1] - 1]++;
            inDegree[trust[0] - 1]--;
        }
        for (int i = 0; i < n; i++) {
            if (inDegree[i] == n - 1) {
                return i + 1;
            }
        }
        return -1;
    }

    private void surroundedRegions_Graph_DFS(char[][] board, int row, int col) {
        if (row < 0 || row >= board.length
                || col < 0 || col >= board[row].length
                || board[row][col] != 'O') {
            return;
        }

        //replace the O at the border regions with temp char T
        board[row][col] = 'T';
        //convert all the other O that are connected with O at the border regions
        surroundedRegions_Graph_DFS(board, row - 1, col);
        surroundedRegions_Graph_DFS(board, row + 1, col);
        surroundedRegions_Graph_DFS(board, row, col - 1);
        surroundedRegions_Graph_DFS(board, row, col + 1);
    }

    public void surroundedRegions_Graph(char[][] board) {
        //https://leetcode.com/problems/surrounded-regions/
        //https://leetcode.com/problems/number-of-enclaves/
        //explanantion: https://youtu.be/9z2BunfoZ5Y

        int row = board.length;
        int col = board[0].length;

        //actual
        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                System.out.print(board[r][c] + " ");
            }
            System.out.println();
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //First convert all the O at the border region and all other O 
                //that is connected to these O
                if (board[r][c] == 'O'
                        //border regions ==> row == TOP EDGE || BOTTOM EDGE, col == LEFT EDGE || RIGHT EDGE
                        && ((r == 0 || r == row - 1) || (c == 0 || c == col - 1))) {
                    surroundedRegions_Graph_DFS(board, r, c);
                }
            }
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //once all the Os at the border regions are replaced with temp char T
                //we will be left with those O which are surrounded by X only
                //because only those O were not reachable from above dfs
                //we can easily convert these Os to X as per question
                if (board[r][c] == 'O') {
                    board[r][c] = 'X';
                }
            }
        }

        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                //once all the Os that were surrounded by X are replaced with X 
                //in previous loop, we can replace temp char T back with O again
                if (board[r][c] == 'T') {
                    board[r][c] = 'O';
                }
            }
        }

        //output
        System.out.println("Surrounded regions output: ");
        for (int r = 0; r < row; r++) {
            for (int c = 0; c < col; c++) {
                System.out.print(board[r][c] + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    private int longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
            int[][] matrix, int row, int col, int prevVal, Integer[][] memo) {

        //return 0, if the curr row & col 'isOutOfBounds'
        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length) {
            return 0;
        }

        //return 0, if curr row & col is not forming any longest incr path because
        //its prevVal is greater or equal to curr matrix[row][col] val
        if (matrix[row][col] <= prevVal) {
            return 0;
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        //for each value in matrix that value itself is a longest incr path
        //atleast of length 1
        int currLongestIncrPath = 1;

        //UP
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row - 1, col, matrix[row][col], memo) + 1);
        //DOWN
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row + 1, col, matrix[row][col], memo) + 1);
        //LEFT
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col - 1, matrix[row][col], memo) + 1);
        //RIGHT
        currLongestIncrPath = Math.max(currLongestIncrPath,
                longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col + 1, matrix[row][col], memo) + 1);

        return memo[row][col] = currLongestIncrPath;
    }

    public void longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(int[][] matrix) {
        //https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
        //explanation: https://youtu.be/wCc_nd-GiEc
        int ROW = matrix.length;
        int COL = matrix[0].length;

        Integer[][] memo = new Integer[ROW][COL];

        int longestIncrPath = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                longestIncrPath = Math.max(
                        longestIncrPath,
                        longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                                matrix, r, c, -1, memo));
            }
        }
        //output
        System.out.println("Longest increasing path in matrix: " + longestIncrPath);
    }

    private int numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
            int[][] matrix, int row, int col, int prevVal, Integer[][] memo) {

        int ROW = matrix.length;
        int COL = matrix[0].length;
        int mod = 1000000007;

        //return 0, if curr row & col 'isOutOfBounds'
        if (row < 0 || row >= ROW || col < 0 || col >= COL) {
            return 0;
        }

        //since we need a strictly incr path, so if the curr matrix[row][col]
        //value is less or equal to prevVal, return 0
        if (matrix[row][col] <= prevVal) {
            return 0;
        }

        if (memo[row][col] != null) {
            return memo[row][col];
        }

        //for each value in matrix that value itself is a longest incr path count
        //atleast of length 1
        int currLongestIncrPathCount = 1;

        //UP
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row - 1, col, matrix[row][col], memo)) % mod;
        //DOWN
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row + 1, col, matrix[row][col], memo)) % mod;
        //LEFT
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col - 1, matrix[row][col], memo)) % mod;
        //RIGHT
        currLongestIncrPathCount = (currLongestIncrPathCount
                + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                        matrix, row, col + 1, matrix[row][col], memo)) % mod;

        //cache the currLongestIncrPathCount at curr row,col
        return memo[row][col] = currLongestIncrPathCount;
    }

    public void numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(int[][] matrix) {
        //https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/
        //based on longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization
        int ROW = matrix.length;
        int COL = matrix[0].length;
        int mod = 1000000007;

        //memo[row][col] = currLongestIncrPathCount
        Integer[][] memo = new Integer[ROW][COL];

        int longestIncrPathCount = 0;

        for (int r = 0; r < ROW; r++) {
            for (int c = 0; c < COL; c++) {
                longestIncrPathCount = (longestIncrPathCount
                        + numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization_DFS(
                                matrix, r, c, -1, memo)) % mod;
            }
        }
        //output
        System.out.println("Number of longest increasing path in matrix: " + longestIncrPathCount);
    }

    public int swimInRisingWater_Graph(int[][] grid) {
        //https://leetcode.com/problems/swim-in-rising-water/
        //explanation: https://youtu.be/amvrKlMLuGY
        //based on BFS
        class Cell {

            int time;
            int row;
            int col;

            public Cell(int time, int row, int col) {
                this.time = time;
                this.row = row;
                this.col = col;
            }

        }

        //grid[][] is n * n matrix
        int ROW = grid.length;
        int COL = ROW;

        int[][] dirs = {
            {1, 0},
            {-1, 0},
            {0, 1},
            {0, -1}
        };

        int srcRow = 0;
        int srcCol = 0;

        boolean[][] visited = new boolean[ROW][COL];
        PriorityQueue<Cell> minHeapTime = new PriorityQueue<>(
                (a, b) -> a.time - b.time);

        visited[srcRow][srcCol] = true;
        minHeapTime.add(new Cell(grid[srcRow][srcCol], srcRow, srcCol));

        while (!minHeapTime.isEmpty()) {

            Cell currCell = minHeapTime.poll();

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.time;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if tnew row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                visited[newRow][newCol] = true;

                minHeapTime.add(new Cell(
                        Math.max(currCell.time, grid[newRow][newCol]),
                        newRow, newCol));
            }
        }
        return -1;
    }

    public int pathWithMinEffort_Graph(int[][] heights) {
        //https://leetcode.com/problems/path-with-minimum-effort/
        //based on BFS and swimInRisingWater_Graph()
        class Cell {

            int effort;
            int row;
            int col;

            public Cell(int threshold, int row, int col) {
                this.effort = threshold;
                this.row = row;
                this.col = col;
            }

        }

        int ROW = heights.length;
        int COL = heights[0].length;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        int srcRow = 0;
        int srcCol = 0;
        int effortToSrc = 0;

        boolean[][] visited = new boolean[ROW][COL];
        PriorityQueue<Cell> minHeapEffort = new PriorityQueue<>(
                (a, b) -> a.effort - b.effort);

        minHeapEffort.add(new Cell(effortToSrc, srcRow, srcCol));

        while (!minHeapEffort.isEmpty()) {

            Cell currCell = minHeapEffort.poll();

            //this visited addition should be done here, because if you mark the
            //new row & col visited in below dirs[] loop, then the bottom-right
            //cell(==> ROW - 1 and COL - 1) will be marked visited before even
            //finding the actual answer for any other paths already in the queue
            visited[currCell.row][currCell.col] = true;

            if (currCell.row == ROW - 1 && currCell.col == COL - 1) {
                return currCell.effort;
            }

            for (int[] dir : dirs) {

                int newRow = currCell.row + dir[0];
                int newCol = currCell.col + dir[1];

                //skip, if new row & col is 'isOutOfBounds'
                if (newRow < 0 || newRow >= ROW || newCol < 0 || newCol >= COL) {
                    continue;
                }

                //skip, if new row & col is already visited
                if (visited[newRow][newCol]) {
                    continue;
                }

                int nextCellEffort = Math.abs(
                        heights[currCell.row][currCell.col] - heights[newRow][newCol]);

                minHeapEffort.add(new Cell(
                        //choose the max effort of the curr path that follows from
                        //prev (currCell row & col) to next (new row & col)
                        Math.max(currCell.effort, nextCellEffort),
                        newRow,
                        newCol));
            }
        }
        return -1;
    }

    public void minCostToConnectAllPoints_Graph(int[][] points) {
        //https://leetcode.com/problems/min-cost-to-connect-all-points/
        //explanation: https://youtu.be/f7JOBJIC-NA
        //BASED on prim's algo
        int n = points.length;
        //<srcVertex, List<List<dist, destVertex>>>
        Map<Integer, List<List<Integer>>> graph = new HashMap<>();
        for (int node = 0; node < n; node++) {
            graph.put(node, new ArrayList<>());
        }

        //if there are n points in points[][] then each coord is supposed to have
        //an edge with all the other coord points having weight/cost/dist as
        //manhattan dist of these two coord points
        for (int src = 0; src < n; src++) {
            int x1 = points[src][0];
            int y1 = points[src][1];
            for (int dest = src + 1; dest < n; dest++) {
                int x2 = points[dest][0];
                int y2 = points[dest][1];
                //manhattan dist
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);
                graph.get(src).add(Arrays.asList(dist, dest));
                graph.get(dest).add(Arrays.asList(dist, src));
            }
        }

        int totalDist = 0;
        int currSrc = 0;
        int currDist = 0;

        Set<Integer> visited = new HashSet<>();
        //List<dist, destVertex>
        PriorityQueue<List<Integer>> minHeapDist = new PriorityQueue<>(
                (l1, l2) -> l1.get(0) - l2.get(0)
        );

        minHeapDist.add(Arrays.asList(currDist, currSrc));

        while (visited.size() < n) {

            List<Integer> currEdge = minHeapDist.poll();
            currDist = currEdge.get(0);
            currSrc = currEdge.get(1);

            if (visited.contains(currSrc)) {
                continue;
            }

            totalDist += currDist;
            visited.add(currSrc);

            for (List<Integer> childEdge : graph.get(currSrc)) {
                int childVertex = childEdge.get(1);
                if (visited.contains(childVertex)) {
                    continue;
                }
                minHeapDist.add(childEdge);
            }
        }
        //output
        System.out.println("Min cost to connect all points: " + totalDist);
    }

    public void minCostToConnectAllPoints_Graph_UnionFind(int[][] points) {
        //https://leetcode.com/problems/min-cost-to-connect-all-points/
        //BASED on PRIM'S ALGO using DISJOINT SET/ UNION FIND
        /*
        intution here is same as prim's algo
        we will create all the edges with their associated weight and we will put
        it in the heap so that we can fetch the min weighted edges first from heap
        (typical prim's algo logic!!! :D )
        
        Now that we have all our edges in heap, we will pick out all the edges
        one by one from this heap and try to from minimum spanning tree/graph
        in the process of forming minimum spanning tree/graph, if we ever reach
        an edge that if we add it will form a cycle in it then we should reject 
        that edge (parent of nodes src & dest (u & v) should not match because
        if they match that means both the nodes are alredy in the same connected
        graph, hence adding another edge will form a cycle)
        
         */
        class Edge {

            int src;
            int dest;
            int dist;

            public Edge(int src, int dest, int dist) {
                this.src = src;
                this.dest = dest;
                this.dist = dist;
            }

        }

        class UnionFind {

            int V;
            int[] parent;
            int[] rank;

            public UnionFind(int V) {
                this.V = V;
                parent = new int[V];
                rank = new int[V];
                for (int node = 0; node < V; node++) {
                    parent[node] = node;
                }
            }

            public int find(int node) {
                if (node == parent[node]) {
                    return node;
                }
                return parent[node] = find(parent[node]);
            }

            public void union(int node1, int node2) {
                int parent1 = find(node1);
                int parent2 = find(node2);

                if (parent1 == parent2) {
                    return;
                }

                if (rank[parent1] > rank[parent2]) {
                    parent[parent2] = parent1;
                } else if (rank[parent1] < rank[parent2]) {
                    parent[parent1] = parent2;
                } else {
                    parent[parent2] = parent1;
                    rank[parent1]++;
                }
            }
        }

        int n = points.length;
        PriorityQueue<Edge> minHeapDist = new PriorityQueue<>(
                (a, b) -> a.dist - b.dist);

        //if there are n points in points[][] then each coord is supposed to have
        //an edge with all the other coord points having weight/cost/dist as
        //manhattan dist of these two coord points
        for (int u = 0; u < n; u++) {

            int x1 = points[u][0];
            int y1 = points[u][1];

            for (int v = u + 1; v < n; v++) {

                int x2 = points[v][0];
                int y2 = points[v][1];
                //manhattan dist
                //dist between coord point[u] and coord point[v]
                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);

                minHeapDist.add(new Edge(u, v, dist));
            }
        }

        UnionFind unionFind = new UnionFind(n);
        int totalDist = 0;

        while (!minHeapDist.isEmpty()) {
            Edge currEdge = minHeapDist.poll();

            //if the parents of both src & dest nodes (u & v) are not same then
            //we can add the min weighted edge in the minimum spanning tree/graph
            //and totalDist can upated with this min dist
            //unless, if the parents of both src & dest nodes (u & v) are same
            //then they will form a cycle in the minimum spanning tree/graph
            if (unionFind.find(currEdge.src) != unionFind.find(currEdge.dest)) {
                totalDist += currEdge.dist;
                unionFind.union(currEdge.src, currEdge.dest);
            }
        }
        //output
        System.out.println("Min cost to connect all points: " + totalDist);
    }

    class Coord {

        int row;
        int col;

        public Coord(int row, int col) {
            this.row = row;
            this.col = col;
        }

    }

    private boolean pacificAtlanticWaterFlow_IsOutOfBounds(int row, int col, int ROW, int COL) {
        return row < 0 || row >= ROW || col < 0 || col >= COL;
    }

    private void pacificAtlanticWaterFlow_HelperBFS(int[][] heights, Queue<Coord> queue,
            boolean[][] visited, int[][] dirs, int ROW, int COL) {

        while (!queue.isEmpty()) {

            Coord curr = queue.poll();

            visited[curr.row][curr.col] = true;

            for (int[] dir : dirs) {
                int newRow = curr.row + dir[0];
                int newCol = curr.col + dir[1];

                if (pacificAtlanticWaterFlow_IsOutOfBounds(newRow, newCol, ROW, COL)
                        || visited[newRow][newCol]
                        || heights[newRow][newCol] < heights[curr.row][curr.col]) {
                    continue;
                }
                queue.add(new Coord(newRow, newCol));
            }
        }
    }

    public void pacificAtlanticWaterFlow(int[][] heights) {
        //https://leetcode.com/problems/pacific-atlantic-water-flow/
        //https://www.geeksforgeeks.org/atlantic-pacific-water-flow/

        int ROW = heights.length;
        int COL = heights[0].length;

        List<List<Integer>> result = new ArrayList<>();

        int topEdge = 0;
        int bottomEdge = ROW - 1;
        int leftEdge = 0;
        int rightEdge = COL - 1;

        int[][] dirs = {
            {-1, 0},
            {1, 0},
            {0, -1},
            {0, 1}
        };

        Queue<Coord> queueAtlantic = new LinkedList<>();
        Queue<Coord> queuePacific = new LinkedList<>();

        boolean[][] visitedAtlantic = new boolean[ROW][COL];
        boolean[][] visitedPacific = new boolean[ROW][COL];

        //save all the top & bottom row edges that are touched by atlantic and pacific ocean
        for (int col = 0; col < COL; col++) {
            queueAtlantic.add(new Coord(bottomEdge, col));
            queuePacific.add(new Coord(topEdge, col));
        }

        //save all the left & right col edges that are touched by atlantic and pacific ocean
        for (int row = 0; row < ROW; row++) {
            queueAtlantic.add(new Coord(row, rightEdge));
            queuePacific.add(new Coord(row, leftEdge));
        }

        //Do BFS from all the atlantic ocean are corrds
        pacificAtlanticWaterFlow_HelperBFS(
                heights, queueAtlantic, visitedAtlantic, dirs, ROW, COL);

        //Do BFS from all the pacific ocean are corrds
        pacificAtlanticWaterFlow_HelperBFS(
                heights, queuePacific, visitedPacific, dirs, ROW, COL);

        for (int row = 0; row < ROW; row++) {
            for (int col = 0; col < COL; col++) {
                if (visitedAtlantic[row][col] && visitedPacific[row][col]) {
                    result.add(Arrays.asList(row, col));
                }
            }
        }
        //output
        System.out.println("All coordinates form pacific to atlantic ocean water flow: " + result);
    }

    public void minimumCostToFillGivenBag_DP_Memoization(int[] cost, int W) {

        //0-1Knapsack problem
        //problem statement: https://practice.geeksforgeeks.org/problems/minimum-cost-to-fill-given-weight-in-a-bag1956/1
        //create normal data
        List<Integer> value = new ArrayList<>();
        List<Integer> weight = new ArrayList<>();

        int actualSize = 0;
        for (int i = 0; i < cost.length; i++) {
            if (cost[i] != -1) {
                value.add(cost[i]);
                weight.add(i + 1);
                actualSize++;
            }
        }

        int[][] memo = new int[actualSize + 1][W + 1];
        for (int x = 0; x < actualSize + 1; x++) {
            for (int y = 0; y < W + 1; y++) {
                if (x == 0) {
                    memo[x][y] = Integer.MAX_VALUE;
                }
                if (y == 0) {
                    memo[x][y] = 0;
                }
            }
        }

        for (int x = 1; x < actualSize + 1; x++) {
            for (int y = 1; y < W + 1; y++) {
                if (weight.get(x - 1) > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = Math.min(value.get(x - 1) + memo[x][y - weight.get(x - 1)],
                            memo[x - 1][y]);
                }
            }
        }

        //output
        System.out.println("Min cost: " + memo[actualSize][W]);
    }

    private boolean checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
            String s1, int indexI, String s2, int indexJ, String s3, int indexK, Boolean[][][] memo) {

        //here string s1 got ended because we might have used all its chars in s3
        if (indexI >= s1.length()) {
            //remaining part of string s2 from indexJ to s2.length should be equal to
            //remaining part of string s3 from IndexK to s3.length
            return s2.substring(indexJ).equals(s3.substring(indexK));
        }

        //here string s2 got ended because we might have used all its chars in s3
        if (indexJ >= s2.length()) {
            //remaining part of string s1 from indexI to s1.length should be equal to
            //remaining part of string s3 from IndexK to s3.length
            return s1.substring(indexI).equals(s3.substring(indexK));
        }

        if (memo[indexI][indexJ][indexK] != null) {
            return memo[indexI][indexJ][indexK];
        }

        boolean isPossible = false;

        isPossible = isPossible
                || (s1.charAt(indexI) == s3.charAt(indexK) && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
                s1, indexI + 1, s2, indexJ, s3, indexK + 1, memo));

        isPossible = isPossible
                || (s2.charAt(indexJ) == s3.charAt(indexK) && checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
                s1, indexI, s2, indexJ + 1, s3, indexK + 1, memo));

        return memo[indexI][indexJ][indexK] = isPossible;
    }

    public boolean checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization(String s1, String s2, String s3) {
        //.............................T: O(M * N) M = a.length(), N = b.length()
        //https://leetcode.com/problems/interleaving-string/
        //explanation: https://youtu.be/3Rw3p9LrgvE
        if (s3.length() != s1.length() + s2.length()) {
            return false;
        }

        Boolean[][][] memo = new Boolean[s1.length()][s2.length()][s3.length()];
        boolean isPossible = checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization_Helper(
                s1, 0, s2, 0, s3, 0, memo);

        return isPossible;
    }

    public boolean checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization(String a, String b, String c) {

        //.............................T: O(M * N) M = a.length(), N = b.length()
        //https://leetcode.com/problems/interleaving-string/
        //explanation: https://youtu.be/3Rw3p9LrgvE
        if (c.length() != a.length() + b.length()) {
            return false;
        }

        boolean dp[] = new boolean[b.length() + 1];
        for (int i = 0; i <= a.length(); i++) {
            for (int j = 0; j <= b.length(); j++) {
                if (i == 0 && j == 0) {
                    dp[j] = true;
                } else if (i == 0) {
                    dp[j] = dp[j - 1] && b.charAt(j - 1) == c.charAt(i + j - 1);
                } else if (j == 0) {
                    dp[j] = dp[j] && a.charAt(i - 1) == c.charAt(i + j - 1);
                } else {
                    dp[j] = (dp[j] && a.charAt(i - 1) == c.charAt(i + j - 1))
                            || (dp[j - 1] && b.charAt(j - 1) == c.charAt(i + j - 1));
                }
            }
        }
        return dp[b.length()];
    }

    public void minimumDiffPartition_DP_Memoization(int[] arr) {

        //https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1#
        int sumArr = 0;
        for (int e : arr) {
            sumArr += e;
        }
        int n = arr.length;
        boolean[][] memo = new boolean[n + 1][sumArr + 1];
        for (int x = 0; x < n + 1; x++) {
            for (int y = 0; y < sumArr + 1; y++) {
                if (x == 0) {
                    memo[x][y] = false;
                }
                if (y == 0) {
                    memo[x][y] = true;
                }
            }
        }

        for (int x = 1; x < n + 1; x++) {
            for (int y = 1; y < sumArr + 1; y++) {
                if (arr[x - 1] > y) {
                    memo[x][y] = memo[x - 1][y];
                } else {
                    memo[x][y] = memo[x - 1][y] || memo[x - 1][y - arr[x - 1]];
                }
            }
        }

        int minDiff = Integer.MAX_VALUE;
        for (int currSum = (sumArr + 1) / 2; currSum >= 0; currSum--) {
            if (memo[n][currSum]) {
                minDiff = Math.abs(Math.min(minDiff, sumArr - 2 * currSum));
            }
        }

        //output
        System.out.println("Min diff between two sum of two partition of the array: " + minDiff);
    }

    public void maximalSquare_DP_Memoization(int[][] matrix) {
        //......................T: O(M*N), M = matrix row, N = matrix col
        //......................S: O(M*N), Using DP[M + 1][N + 1] OR O(1), Without using DP[][]
        //https://leetcode.com/problems/maximal-square/
        //https://practice.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1
        int R = matrix.length;
        int C = matrix[0].length;
        int maxSqrLen = 0;

        //Using extra DP[][] space
//        int[][] memo = new int[R + 1][C + 1];
//        for (int r = 1; r < memo.length; r++) {
//            for (int c = 1; c < memo[r].length; c++) {
//                if (matrix[r - 1][c - 1] == 1) {
//                    memo[r][c] = Math.min(
//                            //diagonal
//                            memo[r - 1][c - 1],
//                            //up, left
//                            Math.min(memo[r - 1][c], memo[r][c - 1])
//                    ) + 1;
//                    maxSqrLen = Math.max(maxSqrLen, memo[r][c]);
//                }
//            }
//        }
        //Wihtout using extra DP[][] space
        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {
                if (matrix[r][c] == 1) {

                    if (r == 0 || c == 0) {
                        maxSqrLen = Math.max(maxSqrLen, matrix[r][c]);
                        continue;
                    }

                    matrix[r][c] = Math.min(
                            //diagonal
                            matrix[r - 1][c - 1],
                            Math.min(
                                    //up
                                    matrix[r - 1][c],
                                    //left
                                    matrix[r][c - 1])) + 1;
                    maxSqrLen = Math.max(maxSqrLen, matrix[r][c]);
                }
            }
        }

        //Output:
        System.out.println("Max square in binary matrix: length: " + maxSqrLen + " area: " + (maxSqrLen * maxSqrLen));
    }

    public void countAllSquareWithOneInBinaryMatrix_DP_Memoization(int[][] matrix) {
        //......................T: O(M*N), M = matrix row, N = matrix col
        //......................S: O(M*N), Using DP[M + 1][N + 1] OR O(1), Without using DP[][]
        //https://leetcode.com/problems/count-square-submatrices-with-all-ones
        //explanation: https://youtu.be/Z2h3rkVXPeQ 
        int totalSquares = 0;
        int R = matrix.length;
        int C = matrix[0].length;

        for (int r = 0; r < R; r++) {
            for (int c = 0; c < C; c++) {

                //consider only 1 for our squares
                if (matrix[r][c] == 1) {
                    //first row & col, if they have 1 there, we can simply
                    //add in out total beacuse they at the top & left edge of matrix 
                    //they will not be forming any squares
                    if (r == 0 || c == 0) {
                        totalSquares += matrix[r][c]; //basically 1 at the top & left edge
                        continue;
                    }
                    matrix[r][c] = Math.min(
                            //diagonal
                            matrix[r - 1][c - 1],
                            Math.min(
                                    //row above
                                    matrix[r - 1][c],
                                    //left col
                                    matrix[r][c - 1])) + 1;
                    totalSquares += matrix[r][c];
                }
            }
        }
        //output:
        System.out.println("Total squares in given matrix: " + totalSquares);
    }

    public void longestStringChain_DP_Memoization(String[] words) {
        //https://leetcode.com/problems/longest-string-chain/
        //https://leetcode.com/problems/longest-string-chain/discuss/2094249/Java-DP

        //map<word, chain>, this map stores the no of chains can be formed by each word
        Map<String, Integer> memo = new HashMap<>();
        for (String word : words) {
            //every single word is in itself is a chain, thats why 1
            memo.put(word, 1);
        }

        //incr order of their lengths
        Arrays.sort(words, (s1, s2) -> s1.length() - s2.length());
        int maxChain = 0;
        for (String word : words) {
            //for each word in words[], try to remove one char and
            //check if that new string matches any previous string
            int currWordLength = word.length();
            for (int i = 0; i < currWordLength; i++) {
                //escape ith char from current word
                //because question says 
                //'we can insert exactly one letter anywhere in previousWord without
                //changing the order of the other characters to make it equal to curr word'
                String previousWord = word.substring(0, i) + word.substring(i + 1);
                if (memo.containsKey(previousWord)) {
                    memo.put(word,
                            //taking max because
                            //forming a chain with curr word may create a longer chain
                            //or the previousWord already have the longer chain( with their previous words)
                            //+ 1 for this curr word
                            Math.max(
                                    memo.get(word),
                                    memo.get(previousWord) + 1
                            ));
                }
            }
            maxChain = Math.max(maxChain, memo.get(word));
        }
        //output
        System.out.println("Max string chain formed: " + maxChain);
    }

    private int buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
            int[] prices, int k, int day, boolean stockInHand, Map<String, Integer> cache) {

        if (day == prices.length || k == -1) {
            return 0;
        }

        String key = k + "," + day + "," + stockInHand;
        if (cache.containsKey(key)) {
            return cache.get(key);
        }

        int maxProfit = Integer.MIN_VALUE;
        if (stockInHand) {
            maxProfit = Math.max(
                    prices[day] + buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, false, cache),
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, true, cache)
            );
        } else {
            maxProfit = Math.max(
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k - 1, day + 1, true, cache) - prices[day],
                    buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                            prices, k, day + 1, false, cache)
            );
        }
        cache.put(key, maxProfit);
        return maxProfit;
    }

    public void buyAndSellStocksAtMostkTimes_Recursive_Memoization(int[] prices, int k) {
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/2555708/Easy-solution-Explained-oror-Beginner-Friendly-oror-Best-Method
        Map<String, Integer> cache = new HashMap<>();
        int maxProfit = buyAndSellStocksAtMostkTimes_Recursive_Memoization_Helper(
                prices, k, 0, false, cache);
        //output
        System.out.println("Max profit buy and sell stocks at most k times: " + maxProfit);
    }

    private void minimumUnfairDistributionOfCookiesToKStudent_Backtracking_findUnfairness(
            int[] cookieSumToKthStudent) {

        int currMaxSum = cookieSumToKthStudent[0];
        for (int sum : cookieSumToKthStudent) {
            currMaxSum = Math.max(currMaxSum, sum);
        }
        minimumUnfairDistributionOfCookiesToKStudent_Result = Math.min(
                minimumUnfairDistributionOfCookiesToKStudent_Result,
                currMaxSum);
    }

    private void minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
            int[] cookies, int[] cookieSumToKthStudent, int currCookieTaken) {

        if (currCookieTaken >= cookies.length) {
            minimumUnfairDistributionOfCookiesToKStudent_Backtracking_findUnfairness(cookieSumToKthStudent);
            return;
        }

        for (int i = 0; i < cookieSumToKthStudent.length; i++) {
            cookieSumToKthStudent[i] += cookies[currCookieTaken];
            minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
                    cookies, cookieSumToKthStudent, currCookieTaken + 1);
            cookieSumToKthStudent[i] -= cookies[currCookieTaken];
        }
    }

    private int minimumUnfairDistributionOfCookiesToKStudent_Result;

    public void minimumUnfairDistributionOfCookiesToKStudent_Backtracking(int[] cookies, int k) {
        //https://leetcode.com/problems/fair-distribution-of-cookies/
        //https://leetcode.com/problems/fair-distribution-of-cookies/discuss/2212309/JAVA-oror-SIMPLE-BACKTRACKING
        int[] cookieSumToKthStudent = new int[k];
        minimumUnfairDistributionOfCookiesToKStudent_Result = Integer.MAX_VALUE;
        minimumUnfairDistributionOfCookiesToKStudent_Backtracking_Helper(
                cookies, cookieSumToKthStudent, 0);
        //output:
        System.out.println("Min unfairness in distribution of cookies: "
                + minimumUnfairDistributionOfCookiesToKStudent_Result);
    }

    private boolean partitionToKEqualSumSubset_Backtracking_Helper(int[] nums, int k,
            int index, int currSubsetSum, int sumPerKSubset, Set<Integer> indexUsed) {

        if (k == 0) {
            return true;
        }

        if (currSubsetSum == sumPerKSubset) {
            return partitionToKEqualSumSubset_Backtracking_Helper(nums, k - 1,
                    0, 0, sumPerKSubset, indexUsed);
        }

        for (int i = index; i < nums.length; i++) {
            if (indexUsed.contains(i)
                    //handle duplicates
                    || (i - 1 >= 0 && nums[i] == nums[i - 1] && !indexUsed.contains(i - 1))
                    //handles case where adding curr nums[i] to currSubsetSum
                    //will not give any solution
                    || currSubsetSum + nums[i] > sumPerKSubset) {
                continue;
            }

            indexUsed.add(i);
            if (partitionToKEqualSumSubset_Backtracking_Helper(
                    nums, k, i + 1, currSubsetSum + nums[i], sumPerKSubset, indexUsed)) {
                return true;
            }
            indexUsed.remove(i);
        }
        return false;
    }

    public boolean partitionToKEqualSumSubset_Backtracking(int[] nums, int k) {
        //.............................T: O(2^(k*N)), N is length of array, we will be
        //trying all possible k subsets by making decision if a index to be used in subset
        //for next time or not.
        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/
        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/discuss/2360226/Java-ororBeats-90-oror-Hardcore-expl'n-!!
        //explanation: https://youtu.be/mBk4I0X46oI

        //we cant make k partitions(non-empty subsets) if array element is less than k
        if (k > nums.length) {
            return false;
        }

        int arrSum = 0;
        for (int val : nums) {
            arrSum += val;
        }

        //k subset partition should have equal sum for each subset
        //if the total array sum is not divisible by k then one of the k 
        //partition will have more sum than the others
        //ex: nums = [5,5,5,5], k = 4 ==> arrSum = 20 where arrSum % k == 0
        //that means subset = {{5},{5},{5},{5}} all sub set have equal sum of 5
        //ex: nums = [5,5,5,6], k = 4 ==> arrSum = 21 where arrSum % k != 0
        //that means subset = {{5},{5},{5},{6}} all sub set doesn't have equal sum
        if (arrSum % k != 0) {
            return false;
        }
        //sum of each subset
        int sumPerKSubset = arrSum / k;
        Set<Integer> indexUsed = new HashSet<>();
        //sort nums so that we can handle duplicates while making decisions
        Arrays.sort(nums);
        return partitionToKEqualSumSubset_Backtracking_Helper(nums, k, 0, 0, sumPerKSubset, indexUsed);
    }

    private void nQueens_Backtracking_Helper_HashSetCheck(
            char[][] board, int col, int n,
            List<List<String>> queenPlacements, Set<String> previousPlacedQueens) {

        //if we have placed our queens successfully
        //starting from col == 0 to col == n - 1
        //then when col == n is called, we can say the curr placement of queens
        //are valid palcements
        if (col == n) {
            //as per output format, converting each row to string format
            List<String> currPlacement = new ArrayList<>();
            for (char[] row : board) {
                currPlacement.add(String.valueOf(row));
            }
            queenPlacements.add(currPlacement);
            return;
        }

        //for a given col we will try to place our queen in each row
        //of that col, if it is safe to place there we will move to next col
        //to try to place our next queen safely
        for (int row = 0; row < n; row++) {
            //first we will check if it is safe to place our curr queen
            //at a given row and col
            //safety rule:
            //1. no queen should already be there in upper-left diagonal
            //2. no queen should already be there in curr row straight-left col
            //3. no queen should already be there in bottom-left diagonal
            //if a queen is already placed on any of the below locations we don't
            //want to place our curr queen in alignment with previous queen
            if (previousPlacedQueens.contains("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row))
                    || previousPlacedQueens.contains("STRAIGHT-LEFT" + row)
                    || previousPlacedQueens.contains("BOTTOM-LEFT-DIAGONAL" + (row + col))) {
                continue;
            }
            //we will try place our Queen in each row
            //in a given col

            previousPlacedQueens.add("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row));
            previousPlacedQueens.add("STRAIGHT-LEFT" + row);
            previousPlacedQueens.add("BOTTOM-LEFT-DIAGONAL" + (row + col));

            board[row][col] = 'Q';

            nQueens_Backtracking_Helper_HashSetCheck(
                    board, col + 1, n, queenPlacements, previousPlacedQueens);

            board[row][col] = '.';

            previousPlacedQueens.remove("UPPER-LEFT-DIAGONAL" + (n - 1 + col - row));
            previousPlacedQueens.remove("STRAIGHT-LEFT" + row);
            previousPlacedQueens.remove("BOTTOM-LEFT-DIAGONAL" + (row + col));
        }
    }

    private boolean nQueens_Backtracking_IsSafeToPlaceQueen(
            char[][] board, int row, int col, int n) {
        /*
         //since we are moving col wise by placing our queen in curr col
         //and we are moving like [0 <= col < n] therefore from our col there will
         //be no queens placed in right, only before this curr col.
         //so keeping this in mind we will only check all the prev dires from the curr col
         //to check if there were any queen placed in previous itrations or not
         upper-left diagonal
         straight-left col
         bootom-left diagonal
         .\
         ..\
         ...\
         ....\
        
         ----- [COL]
        
         ..../
         .../
         ../
         ./
        
         */
        int currRow = row;
        int currCol = col;

        //upper-left diagonal
        while (currRow >= 0 && currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currRow--;
            currCol--;
        }

        currRow = row;
        currCol = col;
        //same row straight-left col
        while (currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currCol--;
        }

        currRow = row;
        currCol = col;
        //bottom-left diagonal
        while (currRow < n && currCol >= 0) {
            if (board[currRow][currCol] == 'Q') {
                return false;
            }
            currRow++;
            currCol--;
        }
        return true;
    }

    private void nQueens_Backtracking_Helper(
            char[][] board, int col, int n, List<List<String>> queenPlacements) {

        //if we have placed our queens successfully
        //starting from col == 0 to col == n - 1
        //then when col == n is called, we can say the curr placement of queens
        //are valid palcements
        if (col == n) {
            //as per output format, converting each row to string format
            List<String> currPlacement = new ArrayList<>();
            for (char[] row : board) {
                currPlacement.add(String.valueOf(row));
            }
            queenPlacements.add(currPlacement);
            return;
        }

        //for a given col we will try to place our queen in each row
        //of that col, if it is safe to place there we will move to next col
        //to try to place our next queen safely
        for (int row = 0; row < n; row++) {
            //first we will check if it is safe to place our curr queen
            //at a given row and col
            //safety rule:
            //1. no queen should already be there in upper-left diagonal
            //2. no queen should already be there in curr row straight-left col
            //3. no queen should already be there in bottom-left diagonal
            if (nQueens_Backtracking_IsSafeToPlaceQueen(board, row, col, n)) {
                //we will try place our Queen in each row
                //in a given col
                board[row][col] = 'Q';
                nQueens_Backtracking_Helper(board, col + 1, n, queenPlacements);
                board[row][col] = '.';
            }
        }
    }

    public void nQueens_Backtracking(int n) {
        //https://leetcode.com/problems/n-queens/
        //https://leetcode.com/problems/n-queens-ii/
        //explanation: https://youtu.be/i05Ju7AftcM
        List<List<String>> queenPlacements = new ArrayList<>();
        char[][] board = new char[n][n];
        for (int r = 0; r < n; r++) {
            for (int c = 0; c < n; c++) {
                board[r][c] = '.';
            }
        }
        nQueens_Backtracking_Helper(board, 0, n, queenPlacements);

        //on leetcode this set based checking was slow,
        //keep this approach if in case it was asked
//        Set<String> previousPlacedQueens = new HashSet<>();
//        nQueens_Backtracking_Helper_HashSetCheck(board, 0, n, queenPlacements, previousPlacedQueens);
        //output:
        System.out.println("All possible placement of N-Queens: " + queenPlacements);
    }

    private boolean sudokuSolver_Backtracking_IsValidToPutNum(
            char[][] board, int row, int col, char num) {
        for (int i = 0; i < board.length; i++) {
            //if in row wise dir already have same num as we are tyring to put
            if (board[i][col] == num) {
                return false;
            }
            //if in col wise dir already have same num as we are tyring to put
            if (board[row][i] == num) {
                return false;
            }
            //if the curr 3*3 submatrix already have same num as we are tyring to put
            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == num) {
                return false;
            }
        }
        return true;
    }

    private boolean sudokuSolver_Backtracking_Helper(char[][] board) {

        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                //if the curr spot is empty
                if (board[r][c] == '.') {
                    //with this loop we are trying to put in all the possible num
                    //in the given row and col
                    for (char num = '1'; num <= '9'; num++) {
                        //for curr num we will check if it is valid to place this num
                        //in curr row and col, if it is safe we will put that num into
                        //the curr empty spot and move to new location by recursion
                        if (sudokuSolver_Backtracking_IsValidToPutNum(board, r, c, num)) {
                            board[r][c] = num;
                            //if by recursion we find the sudoku is solved we will return true
                            //if it can't be solved keep the original empty spot in the curr row and col
                            if (sudokuSolver_Backtracking_Helper(board)) {
                                return true;
                            } else {
                                board[r][c] = '.';
                            }
                        }
                    }
                    //if above loop of [1 to 9] doesn't satisfy the sudoku board
                    return false;
                }
            }
        }
        return true;
    }

    public void sudokuSolver_Backtracking(char[][] board) {
        //https://leetcode.com/problems/sudoku-solver
        //explanation: https://youtu.be/FWAIf_EVUKE
        //actual:
        System.out.println("Empty sudoku board");
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }

        sudokuSolver_Backtracking_Helper(board);

        //output
        System.out.println("Solved sudoku");
        for (int r = 0; r < board.length; r++) {
            for (int c = 0; c < board[r].length; c++) {
                System.out.print(board[r][c] + "\t");
            }
            System.out.println();
        }
    }

    private void wordBreakTwo_Backtracking_Helper(
            String str, Set<String> wordSet, int startIndex, String currSentence, List<String> result) {

        int n = str.length();

        if (startIndex >= n) {
            result.add(currSentence.trim());
            return;
        }

        for (int endIndex = startIndex; endIndex < n; endIndex++) {
            String word = str.substring(startIndex, endIndex + 1);
            //if the curr word from str as substring[startIndex, endIndex] exists
            //in word dict, we will move inside as this word is a valid word to be
            //used in curr sentence
            if (wordSet.contains(word)) {
                wordBreakTwo_Backtracking_Helper(
                        str, wordSet, endIndex + 1,
                        //pass currSentence as new string object with curr combination
                        //of substr as (currStr + " " + substr)
                        //ex at i = 3 : these are recur combinations
                        //"" + " " + "cat" ==> recur
                        //" cat" + " " + "sand" ==> recur
                        //" cat sand dog" ==> recur then str.length() == 0 (Base Cond)
                        //at i = 4 : these are recur combinations
                        //"" + " " + "cats" ==> recur
                        //" cats" + " " + "and" ==> recur
                        //" cats and dog" ==> recur then str.length() == 0 (Base Cond)
                        String.valueOf(currSentence + " " + word),
                        result);
            }
        }
    }

    public void wordBreakTwo_Backtracking(String str, String[] wordDict) {
        //https://leetcode.com/problems/word-break-ii/
        //based on wordBreak_Recursive
        List<String> result = new ArrayList<>();
        Set<String> wordSet = new HashSet<>();
        wordSet.addAll(Arrays.asList(wordDict));
        wordBreakTwo_Backtracking_Helper(str, wordSet, 0, "", result);
        //output
        System.out.println("Word break all string combinations (Backtracking): " + result);
    }

    private void increasingSubsequences_Backtracking_Helper(int[] nums, int index,
            List<Integer> curr, Set<List<Integer>> setResult) {
        //we will add those curr list that have atleast 2 elements in it
        //Set<List> ensures that each added curr list is unique
        //we are not returning from this if block because we might have
        //more increasing subseq afterwards
        //that why below index == nums.length check is req so that we don't get
        //index out of bounds exceptions
        if (curr.size() >= 2) {
            setResult.add(curr);
        }

        if (index == nums.length) {
            return;
        }

        for (int i = index; i < nums.length; i++) {
            //curr.isEmpty() that means we are going to add our first element in the list
            //OR (!curr.isEmpty() && curr.get(curr.size() - 1) <= nums[i]) if curr is not
            //empty AND the curr nums[i] is greater or equal to last added element in curr list
            //this we will ensure that our curr list will have increasing subseq
            //curr = [val1, val2, val3, ... valn] where val1 <= val2 <= val3 <= ... valn
            //if we are not able to pick the curr nums[i] because it is not following
            //increasing subseq then we can move to else part and just go to next i + 1
            if (curr.isEmpty() || (!curr.isEmpty() && curr.get(curr.size() - 1) <= nums[i])) {
                curr.add(nums[i]);
                increasingSubsequences_Backtracking_Helper(nums, i + 1, new ArrayList<>(curr), setResult);
                curr.remove(curr.size() - 1);
            } else {
                increasingSubsequences_Backtracking_Helper(nums, i + 1, new ArrayList<>(), setResult);
            }
        }
    }

    public void increasingSubsequences_Backtracking(int[] nums) {
        //https://leetcode.com/problems/increasing-subsequences/
        int n = nums.length;
        Set<List<Integer>> setResult = new HashSet<>();
        increasingSubsequences_Backtracking_Helper(nums, 0, new ArrayList<>(), setResult);
        List<List<Integer>> increasingSubseq = new ArrayList<>(setResult);
        //output
        System.out.println("All the increasing subseq in given arr: " + increasingSubseq);
    }

    private void pallindromePartitioning_Backtracking_Helper(String str, int startIndex, int length,
            List<String> currList, List<List<String>> pallindromePartitions) {
        if (startIndex == length) {
            pallindromePartitions.add(new ArrayList<>(currList));
            return;
        }

        for (int endIndex = startIndex; endIndex < length; endIndex++) {
            if (isStringPallindrome(str, startIndex, endIndex)) {
                //req substring is str[startIndex, endIndex] both inclusive
                currList.add(str.substring(startIndex, endIndex + 1));
                pallindromePartitioning_Backtracking_Helper(str, endIndex + 1, length, currList, pallindromePartitions);
                currList.remove(currList.size() - 1);
            }
        }
    }

    public void pallindromePartitioning_Backtracking(String str) {
        //https://leetcode.com/problems/palindrome-partitioning/description/
        int n = str.length();
        List<List<String>> pallindromePartitions = new ArrayList<>();
        pallindromePartitioning_Backtracking_Helper(str, 0, n, new ArrayList<>(), pallindromePartitions);
        //output
        System.out.println("All the possible pallindrome partitions: " + pallindromePartitions);
    }

    private boolean restoreIPAddresses_Backtracking_IsValidSubnet(String subnet) {
        int n = subnet.length();
        //if curr subnet is empty string
        if (n == 0) {
            return false;
        }

        //acc to quest given range for a subnet is (0 to 255) so min length of
        //subnet string can be 1(== "0") & max length can be 3(== "255")
        //so if curr subnet length is more than 3 return false
        if (n >= 4) {
            return false;
        }

        //any subnet with a single 0 is valid ex: 0.0.0.0 but no single subnet
        //should have a preceeding 0 in it
        //ex: "01", "011" their length > 1 but subnet[0] == 0
        if (n > 1 && subnet.charAt(0) == '0') {
            return false;
        }

        //converting into int for just to check if curr subnet is in range of
        //(0 to 255)
        int subnetInt = Integer.parseInt(subnet);
        return subnetInt >= 0 && subnetInt <= 255;
    }

    private void restoreIPAddresses_Backtracking_Helper(
            String str, int index, int dots, StringBuilder ip, List<String> ipAddresses) {

        int n = str.length();

        //at this point we have used all the dots needed in the ip meaning inside
        //this if-block our ip string will look like this ex: 192.182.19
        //our ip string will have three valid subnet segments and here we will
        //check if we can create our last subnet segment from curr index to n
        //if that last subent is valid, concatenate both parts(ip.toString() + lastSubnet)
        //and add to result strings
        if (dots == 0) {
            String lastSubnet = str.substring(index);
            if (!restoreIPAddresses_Backtracking_IsValidSubnet(lastSubnet)) {
                return;
            }
            ipAddresses.add(ip.toString() + lastSubnet);
            return;
        }

        if (index >= n) {
            return;
        }

        for (int i = index; i < n; i++) {

            //pick a num to be added as subnet segment
            char num = str.charAt(i);

            //add this curr num to ip
            ip.append(num);

            //now we need to validate the curr subnet segment so here we have 2
            //situations, incase of first segment and incase of other segments
            //1. for first segment if we try to find '.' it will not be
            //there so lastDotIndex will be a -ve value so for this we need to
            //pick the first subnet for 0 index for ip string
            //ex: first subnet segment: 2, 25, 255 dot will be needed after this
            //so we will need to validate these 2, 25, 255 respec
            //2. for other subnet in ip, we need to pick & validate that subnet
            //that exist after the very last dot
            //ex: 192.182.19 from the last dot we need to check if 19 is a valid
            //subnet segment of not
            int lastDotIndex = ip.lastIndexOf(".");
            lastDotIndex = lastDotIndex < 0 ? 0 : lastDotIndex + 1;
            //fetch the subnet segment from last possible dot if exist
            String currSubnet = ip.substring(lastDotIndex);

            //validate this subnet, if the curr subnet is valid then only we can
            //move in and create futher subnet for ip string
            if (restoreIPAddresses_Backtracking_IsValidSubnet(currSubnet)) {
                //if my curr subnet segment is valid then we can add a dot after
                //this subnet and move next to create more subnets
                ip.append(".");
                //move to next index (== i + 1) to pick next num for other subnet
                //segment, since this curr subnet segment is valid and we placed
                //a '.' above means we are left with one dot less(== dots - 1)
                //send new ip string to next recursion
                restoreIPAddresses_Backtracking_Helper(
                        str, i + 1, dots - 1, new StringBuilder(ip.toString()), ipAddresses);
                //since we are sending a new ip string in recursion we have '.'
                //last added in this call stack, so deleting very last char means 
                //deleting '.'
                ip.deleteCharAt(ip.length() - 1);

            } else {
                //if at any point in time subnet is not valid with a num at curr
                //i-th index, there is no point in checking futher so break
                break;
            }
        }
    }

    public void restoreIPAddresses_Backtracking(String str) {
        //https://leetcode.com/problems/restore-ip-addresses/description/
        int n = str.length();
        List<String> ipAddresses = new ArrayList<>();
        //0 will be the starting index of our given string, 3 will be dots needed
        //to add to make an IP ex: 192.182.19.1, there are always 3 dots and
        //4 subnet segments so as our dots counts to 0(dots == 0) it means we
        //have successfully created the first three subnet segment and added these
        //3 dots in their places after that at dots == 0 we will only need to create
        //last subnet if thats valid
        restoreIPAddresses_Backtracking_Helper(str, 0, 3, new StringBuilder(), ipAddresses);
        //output
        System.out.println("Restore IP addresses: " + ipAddresses);
    }

    private void letterCasePermutation_Backtracking_Helper(char[] chArr, int index, List<String> permutations) {

        int n = chArr.length;

        //to save all the intermediate permutations as well
        //that will formed in between
        permutations.add(String.valueOf(chArr));

        for (int i = index; i < n; i++) {

            if (!Character.isAlphabetic(chArr[i])) {
                continue;
            }

            if (Character.isUpperCase(chArr[i])) {
                char org = chArr[i];
                chArr[i] = Character.toLowerCase(chArr[i]);
                letterCasePermutation_Backtracking_Helper(chArr, i + 1, permutations);
                chArr[i] = org;
            } else {
                char org = chArr[i];
                chArr[i] = Character.toUpperCase(chArr[i]);
                letterCasePermutation_Backtracking_Helper(chArr, i + 1, permutations);
                chArr[i] = org;
            }
        }
    }

    public void letterCasePermutation_Backtracking(String str) {
        //https://leetcode.com/problems/letter-case-permutation/description/
        List<String> permutations = new ArrayList<>();
        letterCasePermutation_Backtracking_Helper(str.toCharArray(), 0, permutations);
        //output
        System.out.println("Letter case permutations: " + permutations);
    }

    private boolean distributeRepeatingIntegers_Backtracking_Helper(
            int[] frequencies, List<Integer> quantities, int qtyIndex) {

        int n = quantities.size();

        if (qtyIndex >= n) {
            return true;
        }

        for (int i = 0; i < frequencies.length; i++) {

            //skip, if the curr freq is less than the quantities required @qtyIndex
            if (frequencies[i] < quantities.get(qtyIndex)) {
                continue;
            }

            frequencies[i] = frequencies[i] - quantities.get(qtyIndex);

            if (distributeRepeatingIntegers_Backtracking_Helper(frequencies, quantities, qtyIndex + 1)) {
                return true;
            }

            frequencies[i] = frequencies[i] + quantities.get(qtyIndex);
        }
        return false;
    }

    public void distributeRepeatingIntegers_Backtracking(int[] nums, int[] quantity) {
        //https://leetcode.com/problems/distribute-repeating-integers/description/
        Map<Integer, Integer> valFreq = new HashMap<>();
        for (int val : nums) {
            valFreq.put(val, valFreq.getOrDefault(val, 0) + 1);
        }

        //array that will only hold the freqs of each unique val from nums[]
        int[] frequencies = valFreq.values().stream().mapToInt(freq -> freq).toArray();
        //convert the quantity[] to quantities list and also sorted in desc order
        List<Integer> quantities = Arrays
                .stream(quantity)
                .boxed()
                .sorted((a, b) -> b - a)
                .collect(Collectors.toCollection(ArrayList::new));

        //output
        boolean isDistributionPossible = distributeRepeatingIntegers_Backtracking_Helper(
                frequencies, quantities, 0);
        System.out.println("Disribute repeating inteegrs : " + isDistributionPossible);
    }

    public void LRUCacheDesignImpl(List<String> operations, List<List<Integer>> inputs) {

        LRUCacheDesign lruObj = null;
        for (int i = 0; i < operations.size(); i++) {
            String operation = operations.get(i);
            switch (operation) {
                case "LRUCache":
                    int capacity = inputs.get(i).get(0);
                    lruObj = new LRUCacheDesign(capacity);
                    System.out.println("Object created:" + operation);
                    break;
                case "put":
                    int key = inputs.get(i).get(0);
                    int value = inputs.get(i).get(1);
                    lruObj.put(key, value);
                    System.out.println("Put: " + key + " " + value);
                    break;
                case "get":
                    key = inputs.get(i).get(0);
                    System.out.println("Get: " + lruObj.get(key));
                    break;
            }
        }
    }

    //MY AMAZON ONLINE ASSESSMENT
    public boolean robotRodeo(String command) {
        //https://leetcode.com/problems/robot-bounded-in-circle/
        //https://leetcode.com/problems/path-crossing/
        //initial state of robot
        int x = 0;
        int y = 0;
        int dir = 0; //0 = North, 1 = East, 2 = South, 3 = West (in clockwise direction of actual N-E-S-W dir)
        for (char move : command.toCharArray()) {

            if (move == 'R') {
                //for a given curr dir, R would be on +1 side in clockwise way
                //where %4 will bound our dir upto 4 actual dir(N-E-S-W dir)
                dir = (dir + 1) % 4;
            } else if (move == 'L') {
                //for a given curr dir, L would be on +3 side in clockwise way
                //where %4 will bound our dir upto 4 actual dir(N-E-S-W dir)
                dir = (dir + 3) % 4;
            } else {
                //now move = G
                if (dir == 0) {
                    //North and G, move robot to vertical up(or to north) from given (row,col)
                    y++;
                } else if (dir == 1) {
                    //East and G, move robot to horizontal right(or to east side) from given (row,col)
                    x++;
                } else if (dir == 2) {
                    //South and G, move robot to vertical down(or to south side) from given (row,col)
                    y--;
                } else { //dir == 3
                    //West and G, move robot to horizontal left(or to west side) from given (row,col)
                    x--;
                }
            }
        }

        //if the robot returned to same inital (row,col) = (0,0) after all moves in given command
        //that means there exists a cycle
        return dir != 0 || (x == 0 && y == 0);
    }

    public int swapsRequiredToSortArray(int[] arr) {

        //https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/
        int result = 0;
        Map<Integer, Integer> index = new HashMap<>();
        int[] sortedArr = arr.clone();

        for (int i = 0; i < arr.length; i++) {
            index.put(arr[i], i);
        }

        Arrays.sort(sortedArr);
        for (int i = 0; i < arr.length; i++) {

            if (arr[i] != sortedArr[i]) {
                result++;
                int init = arr[i];

                //swap
                swapIntArray(arr, i, index.get(sortedArr[i]));
                //adjust the indexes after swapping
                index.put(init, index.get(sortedArr[i]));
                index.put(sortedArr[i], i);
            }
        }

        return result;
    }

    public void checkBinaryNumberStreamIsDivisibleByN(int[] binaryStream, int N) {

        //explanation: https://www.geeksforgeeks.org/check-divisibility-binary-stream/
        //see method 2
        /*
        
         formula: 
         if bit is 1 new decimal = 2 * prevDecimal + 1
         if bit is 0 new decimal = 2 * prevDecimal
        
         Ex:
         binaryStream = [1,0,1,0,1]
         prevDecimal = 0
         binaryFormed = ""
         i = 0
         bit = 1 -> binaryFormed.append(bit) = "1" == actualDecimal(binaryFormed) = 1
         if bit == 1: prevDecimal = (2 * prevDecimal) + 1
         ---> prevDecimal = 2 * 0 + 1 = 1
        
         i = 1
         bit = 0 -> binaryFormed.append(bit) = "10" == actualDecimal(binaryFormed) = 2
         if bit == 0: prevDecimal = (2 * prevDecimal)
         ---> prevDecimal = 2 * 1 = 2
        
         i = 2
         bit = 1 -> binaryFormed.append(bit) = "101" == actualDecimal(binaryFormed) = 5
         if bit == 1: prevDecimal = (2 * prevDecimal) + 1
         ---> prevDecimal = 2 * 2 + 1= 5
        
         so on...
         */
        int remainder = 0;
        int decimal = 0;
        StringBuilder sb = new StringBuilder(); //just for output purpose, not necessary to use
        for (int bit : binaryStream) {

            if (bit == 0) {
                remainder = (2 * remainder) % N;
                decimal = 2 * decimal;
            } else if (bit == 1) {
                remainder = (2 * remainder + 1) % N;
                decimal = 2 * decimal + 1;
            }

            sb.append(bit);
            if (remainder == 0) { //another way if(decimal % N) but TLE
                System.out.println("Binary formed: " + sb.toString() + " dec(" + decimal + ") is divisible by " + N);
            } else {
                System.out.println("Binary formed: " + sb.toString() + " dec(" + decimal + ") is not divisible by " + N);
            }
        }
    }

    private String convertNumberToWords_Helper(int n, String suff) {

        // Strings at index 0 is not used, it is to make array 
        // indexing simple 
        String one[] = {"", "one ", "two ", "three ", "four ",
            "five ", "six ", "seven ", "eight ",
            "nine ", "ten ", "eleven ", "twelve ",
            "thirteen ", "fourteen ", "fifteen ",
            "sixteen ", "seventeen ", "eighteen ",
            "nineteen "};

        // Strings at index 0 and 1 are not used, they is to 
        // make array indexing simple 
        String ten[] = {"", "", "twenty ", "thirty ", "forty ",
            "fifty ", "sixty ", "seventy ", "eighty ",
            "ninety "};

        String str = "";
        // if n is more than 19, divide it 
        if (n > 19) {
            str += ten[n / 10] + one[n % 10];
        } else {
            str += one[n];
        }

        // if n is non-zero 
        if (n != 0) {
            str += suff;
        }

        return str;
    }

    public void convertNumberToWords(long n) {

        //https://www.geeksforgeeks.org/program-to-convert-a-given-number-to-words-set-2/
        StringBuilder sb = new StringBuilder();

        // handles digits at ten millions and hundred 
        // millions places (if any) 
        sb.append(convertNumberToWords_Helper((int) (n / 1000_000_0) % 100, "crore "));

        // handles digits at hundred thousands and one 
        // millions places (if any) 
        sb.append(convertNumberToWords_Helper((int) ((n / 100_000) % 100), "lakh "));

        // handles digits at thousands and tens thousands 
        // places (if any) 
        sb.append(convertNumberToWords_Helper((int) ((n / 1000) % 100), "thousand "));

        // handles digit at hundreds places (if any) 
        sb.append(convertNumberToWords_Helper((int) ((n / 100) % 10), "hundred "));

        if (n > 100 && n % 100 > 0) {
            sb.append("and ");
        }

        // handles digits at ones and tens places (if any) 
        sb.append(convertNumberToWords_Helper((int) (n % 100), ""));

        //output
        System.out.println("In words: \n" + (sb.toString().equals("") ? "zero" : sb.toString()));
    }

    public void printPascalTriangle_SimpleAddition(int rows) {
        //https://leetcode.com/problems/pascals-triangle/
        //explanation: https://youtu.be/bR7mQgwQ_o8
        List<List<Integer>> triangle = new ArrayList<>();

        if (rows == 0) {
            return;
        }

        triangle.add(new ArrayList<>());
        triangle.get(0).add(1); //base 

        for (int r = 1; r < rows; r++) {
            List<Integer> currRow = new ArrayList<>();
            List<Integer> prevRow = triangle.get(r - 1);

            currRow.add(1); //first 1 of the row
            for (int c = 1; c < r; c++) {

                currRow.add(prevRow.get(c - 1) + prevRow.get(c));
            }
            currRow.add(1); //last 1 of the row
            triangle.add(currRow);
        }

        //output
        System.out.println("Pascal tiangle: " + triangle);
    }

    public void printPascalTriangle_BinomialCoeff(int rows) {

        //https://leetcode.com/problems/pascals-triangle/
        //https://www.geeksforgeeks.org/pascal-triangle/
        List<List<Integer>> result = new ArrayList<>();

        if (rows == 0) {
            return;
        }

        for (int r = 1; r <= rows; r++) {
            int X = 1;
            result.add(new ArrayList<>());
            for (int c = 1; c <= r; c++) {
                result.get(r - 1).add(X);
                X = X * (r - c) / c;
            }
        }

        //output
        System.out.println("Pascal tiangle: " + result);
    }

    private boolean findCelebrityInNPepole_knows(int a, int b) {
        //if i knows j then its 1 else 0
        //for N * N people matrix
        int[][] whoKnowsWhom = {
            {0, 0, 1, 0},
            {0, 0, 1, 0},
            {0, 0, 0, 0},
            {0, 0, 1, 0}}; //SHOULD BE GLOBAL
        return whoKnowsWhom[a][b] == 1;
    }

    public int findCelebrityInNPepole(int N) {

        //......................T: O(N * N)
        //......................S: O(N), indegree[]
        //https://www.geeksforgeeks.org/the-celebrity-problem/
        int[] indegree = new int[N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (findCelebrityInNPepole_knows(i, j)) {
                    indegree[j]++;
                    indegree[i]--;
                }
            }
        }

        for (int i = 0; i < N; i++) {
            if (indegree[i] == N - 1) {
                return i;
            }
        }
        return -1;
    }

    public int findCelebrityInNPepole_Optimized(int N) {
        //......................T: O(N)
        //......................S: O(1)
        //https://www.geeksforgeeks.org/the-celebrity-problem/
        //OPTIMISED
        //TWO POINTER APPROACH
        int potentialCelebrityStart = 0;
        int potentialCelebrityEnd = N - 1;

        //until endPerson and startPerson becomes equal
        while (potentialCelebrityEnd > potentialCelebrityStart) {

            if (findCelebrityInNPepole_knows(potentialCelebrityStart, potentialCelebrityEnd)) {
                potentialCelebrityStart++;
            } else {
                potentialCelebrityEnd--;
            }
        }

        //startPerson == endPerson consider to be a potential celebrity
        for (int ordinaryPerson = 0; ordinaryPerson < N; ordinaryPerson++) {
            // If any person doesn't
            // know 'startPerson' or 'startPerson' doesn't
            // know any person, return -1
            if (ordinaryPerson != potentialCelebrityStart
                    && (findCelebrityInNPepole_knows(potentialCelebrityStart, ordinaryPerson) /*if celebrity know any person then he can't be celebrity*/
                    || !findCelebrityInNPepole_knows(ordinaryPerson, potentialCelebrityStart) /*if any person doesn't know celebrity then he can't be celebrity*/)) {
                return -1;
            }
        }
        return potentialCelebrityStart;
    }

    private int maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(int currX, int currY,
            int currDir, int dist, Set<String> obstacles) {

        //for col dir can either be 0 = N OR 2 = S
        if (currDir == 0) { //y + dist
            for (int i = 0; i < dist; i++) {
                currY++;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step back, and return as we can't move further
                    currY--;
                    return currY;
                }
            }
        } else { //y - dist
            for (int i = 0; i < dist; i++) {
                currY--;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step ahead, and return as we can't move further
                    currY++;
                    return currY;
                }
            }
        }
        return currY;
    }

    private int maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(int currX, int currY,
            int currDir, int dist, Set<String> obstacles) {

        //for row dir can either be 1 = E OR 3 = W
        if (currDir == 1) { //x + dist
            for (int i = 0; i < dist; i++) {
                currX++;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step back, and return as we can't move further
                    currX--;
                    return currX;
                }
            }
        } else { //x - dist
            for (int i = 0; i < dist; i++) {
                currX--;
                if (obstacles.contains(currX + "-" + currY)) {
                    //updated row-col coordinate is in obstacle
                    //take a step ahead, and return as we can't move further
                    currX++;
                    return currX;
                }
            }
        }
        return currX;
    }

    public void maximumDistanceCoveredInRobotWalkingSimulation(int[] commands, int[][] obstacles) {

        //https://leetcode.com/problems/walking-robot-simulation/
        Set<String> set = new HashSet<>();
        for (int[] obstacle : obstacles) {
            set.add(obstacle[0] + "-" + obstacle[1]);
        }

        //max distance covered in commands
        int maxDistCoveredFromOrigin = 0;

        //initial position
        int x = 0;
        int y = 0;

        //initial dir
        int dir = 0; // 0 = N, 1 = E, 2 = S, 3 = W

        for (int move : commands) {

            if (move == -1) { // -1 == TURN RIGHT
                dir = (dir + 1) % 4;
            } else if (move == -2) { // -2 == TURN LEFT
                dir = (dir + 3) % 4;
            } else { // MAKE STEPS AHEAD, BUT KEEP CHECK ON OBSTACLES
                if (dir == 0) { // NORTH col++
                    y = maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(x, y, dir, move, set);
                } else if (dir == 1) { // EAST row++
                    x = maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(x, y, dir, move, set);
                } else if (dir == 2) { // SOUTH col--
                    y = maximumDistanceCoveredInRobotWalkingSimulation_UpdateY(x, y, dir, move, set);
                } else { // WEST row--
                    x = maximumDistanceCoveredInRobotWalkingSimulation_UpdateX(x, y, dir, move, set);
                }

                //calculate distance 
                //robot's curr position(row,col) is the farthest then update maxDistCoveredFromOrigin
                maxDistCoveredFromOrigin = Math.max(maxDistCoveredFromOrigin,
                        (x * x + y * y)); //x^2 + col^2
            }
        }

        //output
        System.out.println("Max distance covered by robot from origin : " + maxDistCoveredFromOrigin);
    }

    public void brokenCalculatorMakeXEqualToY(int x, int y) {

        //............................T: O(LogY)
        //https://leetcode.com/problems/broken-calculator/
        //explanation: https://leetcode.com/problems/broken-calculator/solution/
        //Work backwards
        int res = 0;
        while (y > x) {
            res++;
            if (y % 2 == 1) {
                y++;
            } else {
                y /= 2;
            }
        }

        //output
        System.out.println("Min operations on X make equal to Y: " + (res + x - y));
    }

    public boolean rectangleOverlappingAndArea(int[] rec1, int[] rec2) {
        //explanation: https://youtu.be/zGv3hOORxh0
        //https://leetcode.com/problems/rectangle-overlap/
        //https://leetcode.com/problems/rectangle-area/
        //input format:
        //rec[4] = bottm-left coordinate(row, col) = rec[0], rec[1] & top-right coordinate(row, col) = rec[2], rec[3]

        /*
         ::::::::::R1-----------
         ::::::::::::|         |
         ::::::::::::|         |
         :::::R2----------     |
         :::::::|    |=O=|     |
         :::::::|    -----------
         :::::::|        |
         :::::::|        |
         ::::::::---------
         */
        //overlapped rectangle's bottom-left(row, col)
        int bottomLeftX = Math.max(rec1[0], rec2[0]);
        int bottomLeftY = Math.max(rec1[1], rec2[1]);

        //overlapped rectangle's top-right(row, col)
        int topRightX = Math.min(rec1[2], rec2[2]);
        int topRightY = Math.max(rec1[3], rec2[3]);

        int lengthX = topRightX - bottomLeftX;
        int lengthY = topRightY - bottomLeftY;

        //if rec1 & rec2 are not overlapping case
        if (lengthX < 0 || lengthY < 0) {
            return false;
        }
        //given 2 rectangles, if they are connected by any
        //one corner or edge they are not overlapped.
        //area = length * bredth
        int area = lengthX * lengthY;
        System.out.println("Area of overlapped rectangle: " + area);
        return area > 0;
    }

    public void addTwoNumsWithoutPlusOrMinus(int a, int b) {
        //https://leetcode.com/problems/sum-of-two-integers
        //explanation: https://youtu.be/gIlZOcZHtlQ
        //^ = XOR
        int sum = a ^ b;
        //& = AND
        int carry = a & b;
        while (carry != 0) {
            carry = carry << 1;
            int tempSum = sum ^ carry;
            int tempCarry = sum & carry;
            sum = tempSum;
            carry = tempCarry;
        }
        //output
        System.out.println("Adding two nums: " + a + " " + b + " without + or - : " + sum);
    }

    public void threeConsecutiveNumberThatSumsToGivenNumber(int num) {
        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/
        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/discuss/2164778/the-three-integers-will-be-in-arithmetic-progression
        if (num % 3 == 0) {
            int first = (num / 3) - 1;
            int second = (num / 3);
            int third = (num / 3) + 1;
            System.out.println("Three consecutive number that sums to " + num + " : "
                    + first + ", " + second + ", " + third);
            return;
        }
        System.out.println("Three consecutive number that sums to " + num + " : Not possible");
    }

    public void detectSquares(List<int[]> points, List<int[]> queryPoints) {
        //Input is little bit modified from the actual question 
        //https://leetcode.com/problems/detect-squares/
        //explanation: https://youtu.be/bahebearrDc
        //<"row,col", freq>
        Map<String, Integer> pointMap = new HashMap<>();
        for (int[] point : points) {
            int x = point[0];
            int y = point[1];
            String key = x + "," + y;
            pointMap.put(key, pointMap.getOrDefault(key, 0) + 1);
        }

        for (int[] query : queryPoints) {
            int qX = query[0];
            int qY = query[1];
            int sqauresDetectedFromCurrQueryPoint = 0;
            for (int[] point : points) {
                int x = point[0];
                int y = point[1];

                //if curr point[row, col] is not forming a diagonal with query[qX, qY]
                // or any of the curr row, col is same as qX, qY then they can't form diagnal
                //with query[qX, qY]
                boolean isDiagonal = Math.abs(x - qX) == Math.abs(y - qY);
                if (!isDiagonal || x == qX || y == qY) {
                    continue;
                }

                //otherwise now here find two coord points
                //top-left such a way that its coord [row, qY]
                //bottom-right such a way that its coord [qX, col]
                //if they exists in out pointMap in some freq that much freq
                //will form sqaures
                String topLeftKey = x + "," + qY;
                String bottomRightKey = qX + "," + y;

                sqauresDetectedFromCurrQueryPoint
                        += pointMap.getOrDefault(topLeftKey, 0) * pointMap.getOrDefault(bottomRightKey, 0);
            }
            System.out.println("Squares detected from query[qX, qY]: [" + qX + ", " + qY + "] : "
                    + sqauresDetectedFromCurrQueryPoint);
        }
    }

    public void serverAllocationToTasks(int[] servers, int[] tasks) {
        //https://leetcode.com/problems/process-tasks-using-servers
        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
        class Server {

            int index;
            int weight;
            //taskArrivalTime + taskProcessingTime
            int bookedTime;

            public Server(int index, int weight) {
                this.index = index;
                this.weight = weight;
            }
        }

        int serverLen = servers.length;
        int taskLen = tasks.length;

        int[] serverIdxAllotedPerTask = new int[taskLen];

        PriorityQueue<Server> freeServer = new PriorityQueue<>(
                //choose server with lowest weight, if weights are same
                //choose server with lowest index value
                (s1, s2) -> s1.weight == s2.weight
                        ? s1.index - s2.index
                        : s1.weight - s2.weight
        );

        PriorityQueue<Server> busyServer = new PriorityQueue<>(
                //server's booked time(booked time == taskArrivalTime + taskProcessiingTime) are same
                (s1, s2) -> s1.bookedTime == s2.bookedTime
                        //choose server with lowest weight, if weights are same
                        //choose server with lowest index value
                        ? (s1.weight == s2.weight
                                ? s1.index - s2.index
                                : s1.weight - s2.weight)
                        //if booked time was not same choose the lowest bookedtime
                        //(i.e whoose task will finish early)
                        : s1.bookedTime - s2.bookedTime
        );

        for (int idx = 0; idx < serverLen; idx++) {
            freeServer.add(new Server(idx, servers[idx]));
        }

        for (int time = 0; time < taskLen; time++) {

            int processTime = tasks[time];

            //at any time 'time' if we have some busy servers that can finish their task
            //before this 'time' that means it will get free by time 'time' comes.
            //add it back to free server heap, so that we can utilize it later
            while (!busyServer.isEmpty() && busyServer.peek().bookedTime <= time) {
                freeServer.add(busyServer.poll());
            }

            if (freeServer.isEmpty()) {
                //if there are no free servers, we have to use the most optimal
                //busy server (i.e, either that currBusyServer has lowest bookedTime
                //and if bookedTime are same then it should have
                //lowest weight and if weights are same then it should have lowest index)
                //purpose of taking the optimal busy server is, it will finish early
                //and when it will finish, we want to assign curr processTime to it.
                //that's why (currBusyServer.bookedTime += processTime) this simulates
                //this curr task[time] will be immediately be assigned to it.
                Server currBusyServer = busyServer.poll();
                currBusyServer.bookedTime += processTime;
                //add in our currBusyServer back to all busy servers
                busyServer.add(currBusyServer);
                //we need to tell that this curr task[time] is assigned
                //to which server(based on its index), so task at time 'time' is assigned
                //currBusyServer.index server
                serverIdxAllotedPerTask[time] = currBusyServer.index;
                continue;
            }

            //if we have free servers available, take the optimal currFreeServer
            //book this server's bookedTime upto total time of time + processTime
            //since we have used one free server that means it is busy now
            Server currFreeServer = freeServer.poll();
            currFreeServer.bookedTime = time + processTime;
            //so move our currFreeServer to busy server
            busyServer.add(currFreeServer);
            //as our result we need to tell which curr task[time] is assigned
            //to which server(based on its index), so task at time 'time' is assigned
            //currFreeServer.index server
            serverIdxAllotedPerTask[time] = currFreeServer.index;
        }
        //output:
        for (int i = 0; i < taskLen; i++) {
            System.out.println("For task: " + tasks[i] + " alloted server with index: " + serverIdxAllotedPerTask[i]);
        }
    }

    public void serversThatHandledMostRequests(int k, int[] arrival, int[] loads) {
        //https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/
        //based on serverAllocationToTasks()
        class Server {

            int id;
            int bookedTime;

            public Server(int id) {
                this.id = id;
            }

        }

        List<Integer> serverIdHandledMostRequest = new ArrayList<>();

        int nRequest = arrival.length;
        int[] serverUsage = new int[k];

        TreeSet<Integer> freeServerId = new TreeSet<>();
        for (int id = 0; id < k; id++) {
            freeServerId.add(id);
        }

        PriorityQueue<Server> busyServer = new PriorityQueue<>((a, b) -> a.bookedTime - b.bookedTime);

        for (int i = 0; i < nRequest; i++) {

            int time = arrival[i];
            int taskLoad = loads[i];

            while (!busyServer.isEmpty() && busyServer.peek().bookedTime <= time) {
                freeServerId.add(busyServer.poll().id);
            }

            //since a single can only handle 1 request at a time so the request
            //will get DROPPED if there is no free server to handle it.
            if (freeServerId.isEmpty()) {
                continue;
            }

            //acc to question the the curr ith request will be assigned to
            //i % k th server if in case, that is not available we will pick
            //(i + 1) % k th server and so on if that is also not available
            //ceiling(ID) will give the value greater than or equal to given ID 
            Integer nextAvailableFreeServerId = freeServerId.ceiling(i % k);
            //incase the 'next available free server' is not available ( == null)
            //that means will wrap around to the get first available free server
            //thats why first()
            nextAvailableFreeServerId = nextAvailableFreeServerId == null
                    ? freeServerId.first() : nextAvailableFreeServerId;

            //each time we get the free server id that means we make use of it
            //for our current incoming request
            serverUsage[nextAvailableFreeServerId]++;

            //now this server with nextAvailableFreeServerId is going to be busy
            //with the curr ith request
            Server createBusyServer = new Server(nextAvailableFreeServerId);
            createBusyServer.bookedTime = time + taskLoad;

            //now a free server is made busy we must remove this nextAvailableFreeServerId
            //from freeServerId
            busyServer.add(createBusyServer);
            freeServerId.remove(nextAvailableFreeServerId);
        }

        int maxUsage = 0;
        for (int usage : serverUsage) {
            maxUsage = Math.max(maxUsage, usage);
        }

        //get all those server ids that have exactly maxUasge
        for (int id = 0; id < k; id++) {
            if (maxUsage == serverUsage[id]) {
                serverIdHandledMostRequest.add(id);
            }
        }
        //output
        System.out.println("Server Ids that handled most request: " + serverIdHandledMostRequest);
    }

    public void meetingRoomsThree(int rooms, int[][] meetings) {
        //https://leetcode.com/problems/meeting-rooms-iii/
        //based on serverAllocationToTasks()
        class Room {

            int roomId;
            int endTime;
            int usage;

            public Room(int roomId) {
                this.roomId = roomId;
            }

        }
        //if just one room is given then that room is the only busiest one
        if (rooms == 1) {
            System.out.println("Busiest room no. that handled most meetings: 0");
            return;
        }

        int m = meetings.length;

        //sort the meetings array by their start times
        Arrays.sort(meetings, (a, b) -> a[0] - b[0]);

        //a free room heap, room with min room id at top
        PriorityQueue<Room> freeRooms = new PriorityQueue<>(
                (a, b) -> a.roomId - b.roomId);

        //creating all free rooms with their id
        for (int id = 0; id < rooms; id++) {
            freeRooms.add(new Room(id));
        }

        //a busy room heap
        PriorityQueue<Room> busyRooms = new PriorityQueue<>(
                //if endTimes are same, sort by smaller roomId
                //else sort by smaller endTime
                (a, b) -> a.endTime == b.endTime
                        ? a.roomId - b.roomId
                        : a.endTime - b.endTime);

        for (int i = 0; i < m; i++) {

            int startTime = meetings[i][0];
            int endTime = meetings[i][1];

            //if any previously occupied room's endTime is samller than or equal
            //to curr meetings startTime that means, this busy room will get free
            //for the curr meeting so put this busy room back to freeRooms
            while (!busyRooms.isEmpty() && busyRooms.peek().endTime <= startTime) {
                freeRooms.add(busyRooms.poll());
            }

            //if none of the occupied rooms is free
            if (freeRooms.isEmpty()) {
                //get the busy room with smaller endTime or smaller roomId
                Room currBusyRoom = busyRooms.poll();
                //calculate the delay time between the curr meeting's startTime
                //and curr busy room's endTime, why?
                //beacuse the busyRooms heap is sorting the meetings that is going
                //to end soon (min heap endTime) (in other words, a room that will
                //get free soon) but still how much time is still required for it
                //to be free, that is delay time and due to this our curr meeting
                //will get delayed by (delayedTimeForCurrMeeting + endTime) time
                int delayedTimeForCurrMeeting = currBusyRoom.endTime - startTime;
                currBusyRoom.endTime = delayedTimeForCurrMeeting + endTime;
                //since we assined the curr meeting to this busy room but delayed
                //but we still used this room, so increase the usage count
                currBusyRoom.usage++;
                //and put it back in the busyRooms
                busyRooms.add(currBusyRoom);
                continue;
            }

            //if we have some free rooms, get the room with smaller roomId
            //set the endTime for this room that is our curr meeting's endtTime
            //and also update its usage count since it is being used here
            //and put is back in busyRooms
            Room currFreeRoom = freeRooms.poll();
            currFreeRoom.endTime = endTime;
            currFreeRoom.usage++;
            busyRooms.add(currFreeRoom);
        }

        List<Room> allRooms = new ArrayList<>();
        allRooms.addAll(freeRooms);
        allRooms.addAll(busyRooms);
        //sort all the rooms by max usage if usage are same get the smaller id
        //of the max usage
        Collections.sort(allRooms, (a, b) -> a.usage == b.usage
                ? a.roomId - b.roomId
                : b.usage - a.usage);

        //output
        System.out.println("Busiest room no. that handled most meetings: " + allRooms.get(0).roomId);
    }

    public void maxPatientTreatedInGivenInAnyNRoom(int[][] patients, int totalRooms) {
        //https://leetcode.com/problems/process-tasks-using-servers
        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
        //approach simmilar to serverAllocationToTasks() & meetingRoomsThree()
        class Room {

            int roomNo;
            int patientTreated;
            int bookedTime;

            public Room(int roomNo) {
                this.roomNo = roomNo;
            }
        }

        int maxPatientTreated = 0;
        int roomNoOfMaxpatientTreated = -1;

        PriorityQueue<Room> filledRoomMinHeap = new PriorityQueue<>(
                (r1, r2) -> r1.bookedTime - r2.bookedTime);
        PriorityQueue<Room> freeRoomMinHeap = new PriorityQueue<>(
                (r1, r2) -> r1.roomNo - r2.roomNo);

        for (int roomNo = 1; roomNo <= totalRooms; roomNo++) {
            freeRoomMinHeap.add(new Room(roomNo));
        }

        for (int[] patient : patients) {

            int entry = patient[0];
            int duration = patient[1];

            while (!filledRoomMinHeap.isEmpty() && filledRoomMinHeap.peek().bookedTime < entry) {
                freeRoomMinHeap.add(filledRoomMinHeap.poll());
            }

            if (freeRoomMinHeap.isEmpty()) {
                continue;
            }

            Room currFreeRoom = freeRoomMinHeap.poll();
            currFreeRoom.patientTreated++;
            currFreeRoom.bookedTime = entry + duration;

            filledRoomMinHeap.add(currFreeRoom);

            if (currFreeRoom.patientTreated > maxPatientTreated) {
                maxPatientTreated = currFreeRoom.patientTreated;
                roomNoOfMaxpatientTreated = currFreeRoom.roomNo;
            }
        }
        //output
        System.out.println("Room no in which max patient treated : "
                + roomNoOfMaxpatientTreated + " max patient : " + maxPatientTreated);
    }

    class SkylineProblemBuildingCoord {

        int x;
        int height;

        public SkylineProblemBuildingCoord(int x, int height) {
            this.x = x;
            this.height = height;
        }

    }

    private List<SkylineProblemBuildingCoord> skylineProblem_BreakBuildingInCoords(
            int[][] buildings) {

        List<SkylineProblemBuildingCoord> coords = new ArrayList<>();
        for (int[] building : buildings) {
            //for start points of building
            int start = building[0]; //x
            int height = building[2]; //height
            //all start points have height -ve
            coords.add(new SkylineProblemBuildingCoord(start, -height));

            //for end points of building
            int end = building[1]; //x
            height = building[2]; //height
            //all end points have height +ve
            coords.add(new SkylineProblemBuildingCoord(end, height));
        }

        Collections.sort(coords, (c1, c2) -> c1.x == c2.x
                ? c1.height - c2.height
                : c1.x - c2.x);
        return coords;
    }

    public void skylineProblem(int[][] buildings) {
        //https://leetcode.com/problems/the-skyline-problem/
        //https://leetcode.com/problems/the-skyline-problem/discuss/2257654/With-Algorithm-Java-Solution-O(NlogN)
        //explanation: https://youtu.be/GSBLe8cKu0s
        List<List<Integer>> skylinePoints = new ArrayList<>();
        List<SkylineProblemBuildingCoord> coords = skylineProblem_BreakBuildingInCoords(buildings);

        PriorityQueue<Integer> maxHeapHeights = new PriorityQueue<>(Collections.reverseOrder());
        maxHeapHeights.add(0); // default building height

        int prevMaxHeight = 0;

        for (SkylineProblemBuildingCoord coord : coords) {
            //System.out.println(coord.row + " " + coord.height + " " + maxHeapHeights.peek());
            //if curr height is -ve that means its a start point
            //so put that height in maxHeap heights as original == abs(height)
            if (coord.height < 0) {
                //height of building start point which we made -ve
                maxHeapHeights.add(Math.abs(coord.height));
            } else {
                //removing object from PriorityQueue
                //takes O(N) time as it search for the object first
                //if the height is here that means its a end point
                //any time we reach the end point we will remove the height
                //associated with this end point
                maxHeapHeights.remove(coord.height);
            }
            //after adding or removing the heights from maxHeap heights
            //we will have a new max height
            int currMaxHeight = maxHeapHeights.peek();

            if (currMaxHeight == prevMaxHeight) {
                continue;
            }

            skylinePoints.add(Arrays.asList(coord.x, currMaxHeight));
            prevMaxHeight = currMaxHeight;
        }
        //output;
        System.out.println("Skyline coordinates of the given buildings: " + skylinePoints);
    }

    public void skylineProblem_TreeMap(int[][] buildings) {
        //..........................T: O(LogN), as treemap supports all operations in LogN time
        //OPTIMIZED much faster as compared to above priority queue approach,
        //as priority queue remove operation is O(N) time
        //https://leetcode.com/problems/the-skyline-problem/
        //https://leetcode.com/problems/the-skyline-problem/discuss/2257654/With-Algorithm-Java-Solution-O(NlogN)
        //explanation: https://youtu.be/GSBLe8cKu0s
        List<List<Integer>> skylinePoints = new ArrayList<>();
        List<SkylineProblemBuildingCoord> coords = skylineProblem_BreakBuildingInCoords(buildings);

        //<height, freq> = will store keys in maxHeap way, that means max heights on root
        //freq is required because there may be multiple buildings with same height
        TreeMap<Integer, Integer> maxHeapHeights = new TreeMap<>(Collections.reverseOrder());
        maxHeapHeights.put(0, 1); // default building height and its freq

        int prevMaxHeight = 0;

        for (SkylineProblemBuildingCoord coord : coords) {
            //System.out.println(coord.row + " " + coord.height + " " + maxHeapHeights.firstKey());
            //if curr height is -ve that means its a start point
            //so put that height in maxHeap heights as original == abs(height)
            if (coord.height < 0) {
                //height of building start point which we made -ve
                int startHeight = Math.abs(coord.height);
                //each time we see same height just increase freq if already exist
                maxHeapHeights.put(startHeight, maxHeapHeights.getOrDefault(startHeight, 0) + 1);
            } else {
                //if the height is here that means its a end point
                //any time we reach the end point we will remove the height
                //associated with this end point
                maxHeapHeights.put(coord.height, maxHeapHeights.getOrDefault(coord.height, 0) - 1);
                if (maxHeapHeights.get(coord.height) <= 0) {
                    maxHeapHeights.remove(coord.height);
                }
            }
            //after adding or removing the heights from maxHeap heights
            //we will have a new max height
            int currMaxHeight = maxHeapHeights.firstKey();

            if (currMaxHeight == prevMaxHeight) {
                continue;
            }

            skylinePoints.add(Arrays.asList(coord.x, currMaxHeight));
            prevMaxHeight = currMaxHeight;
        }
        //output;
        System.out.println("Skyline coordinates of the given buildings: " + skylinePoints);
    }

    public void minAngleBetweeHourAndMinuteHands(int hour, int min) {
        //https://leetcode.com/problems/angle-between-hands-of-a-clock/
        /*
         In 12 hour, hour hand make 360deg
         12hr = 360deg
         1hr = 360/12deg = 30deg
         1hr = 60min
         60min = 30deg
         1min = 30/60deg = 0.5deg
         ..........
         To complete 1hr, min hand makes 360deg
         1hr = 60min = 360deg
         1min = 360/60deg = 6deg
         */

        double hourAngle = (30 * hour) + (0.5 * min);
        double minuteAngle = (0 * hour) + (6 * min);
        double angle = Math.abs(hourAngle - minuteAngle);
        double minAngle = angle < 180 ? angle : 360.0 - angle;
        //output
        System.out.println("Min angle between hour and min hands: " + minAngle);
    }

    class ColorNumber {

        String color;
        int number;

        public ColorNumber(String color, int number) {
            this.color = color;
            this.number = number;
        }
    }

    public boolean cardOf12_Helper(List<ColorNumber> colorNumbers) {
        Map<String, List<Integer>> allNumbersOfSameCardMap = new HashMap<>();

        for (ColorNumber colorNumber : colorNumbers) {

            String color = colorNumber.color;
            int cardNum = colorNumber.number;
            allNumbersOfSameCardMap.putIfAbsent(color, new ArrayList<>());
            allNumbersOfSameCardMap.get(color).add(cardNum);
        }

        for (String color : allNumbersOfSameCardMap.keySet()) {
            if (allNumbersOfSameCardMap.get(color).size() % 3 != 0) {
                return false;
            }
            Collections.sort(allNumbersOfSameCardMap.get(color));
        }

        for (String color : allNumbersOfSameCardMap.keySet()) {
            List<Integer> cards = allNumbersOfSameCardMap.get(color);
            for (int i = 0; i < cards.size(); i += 3) {
                int cardNum1 = cards.get(i);
                int cardNum2 = cards.get(i + 1);
                int cardNum3 = cards.get(i + 2);

                //either 3 cards that picked up
                //1. of same num i.e, 1,1,1
                //OR 2. are consecutive (1,2,3)
                //cNum1 + 1 == cNum2 ==> 1 + 1 == 2 && cNum1 + 2 == cNum3 ==> 1 + 2 == 3
                boolean hasPassed = (cardNum1 == cardNum2 && cardNum2 == cardNum3)
                        || (cardNum1 + 1 == cardNum2 && cardNum1 + 2 == cardNum3);
                if (!hasPassed) {
                    return false;
                }
            }
        }
        return true;
    }

    public void cardOf12() {
        //https://leetcode.com/discuss/interview-experience/2279548/Google-or-Phone-Screen-or-Question-or-India
        //generating input to the question here
        List<ColorNumber> colorNumbers = Arrays.asList(
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 2),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4),
                new ColorNumber("GREEN", 4)
        );

        System.out.println("3 group of cards possible from given 12 cards: "
                + cardOf12_Helper(colorNumbers));

        colorNumbers = Arrays.asList(
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 1),
                new ColorNumber("RED", 2),
                new ColorNumber("RED", 2),
                new ColorNumber("RED", 2),
                new ColorNumber("BLUE", 1),
                new ColorNumber("BLUE", 2),
                new ColorNumber("BLUE", 3),
                new ColorNumber("GREEN", 5),
                new ColorNumber("GREEN", 5),
                new ColorNumber("GREEN", 5)
        );

        System.out.println("3 group of cards possible from given 12 cards: "
                + cardOf12_Helper(colorNumbers));
    }

    public void implementIncreamentalStack() {
        //explanation: https://youtu.be/L8tY9gSfHz4
        ImplementIncreamentalStack stack = new ImplementIncreamentalStack();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        stack.push(4);
        stack.print();
        System.out.println("POP: " + stack.pop());
        System.out.println("PEEK: " + stack.peek());
        stack.print();
        stack.increament(2, 10);
        stack.push(5);
        stack.push(6);
        stack.push(7);
        stack.increament(5, 100);
        stack.print();
        while (!stack.isEmpty()) {
            System.out.println("POP: " + stack.pop());
        }
        stack.print();
    }

    public void minPathCostRobotMovingStartToHomePos(int[] startPos, int[] homePos, int[] rowCosts, int[] colCosts) {
        //https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/
        int minPathCost = 0;

        int startRow = startPos[0];
        int startCol = startPos[1];

        int destRow = homePos[0];
        int destCol = homePos[1];

        int minRowFrom = Math.min(startRow, destRow);
        int maxRowTo = Math.max(startRow, destRow);

        for (int i = minRowFrom + 1; i < maxRowTo; i++) {
            minPathCost += rowCosts[i];
        }

        int minColFrom = Math.min(startCol, destCol);
        int maxColTo = Math.max(startCol, destCol);

        for (int i = minColFrom + 1; i < maxColTo; i++) {
            minPathCost += colCosts[i];
        }

        if (startRow != destRow) {
            minPathCost += rowCosts[destRow];
        }

        if (startCol != destCol) {
            minPathCost += colCosts[destCol];
        }

        //output
        System.out.println("Min path cost for robot moving from startPos to homePos: " + minPathCost);
    }

    private boolean kThSmallestNumberInMultiplicationTable_Enough(int x, int m, int n, int k) {
        int count = 0;
        for (int i = 1; i <= m; i++) {
            count += Math.min(x / i, n);
        }
        return count >= k;
    }

    public void kThSmallestNumberInMultiplicationTable(int m, int n, int k) {
        //https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/
        int start = 1;
        int end = m * n;
        while (end > start) {
            int mid = start + (end - start) / 2;
            if (kThSmallestNumberInMultiplicationTable_Enough(mid, m, n, k)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        System.out.println("kTh smallest number in multiplication table: " + start);
    }

    public int maxLineToRepresentLineChart(int[][] points) {
        //https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/
        //https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/
        int n = points.length;
        int X = 0;
        int Y = 1;
        if (n == 1) {
            return 0;
        }
        //sort the points[] on X axis
        Arrays.sort(points, (a, b) -> a[X] - b[X]);
        int lines = 1;
        int lastDy = points[1][Y] - points[0][Y];
        int lastDx = points[1][X] - points[0][X];

        for (int i = 2; i < n; i++) {
            int currDy = points[i][Y] - points[i - 1][Y];
            int currDx = points[i][X] - points[i - 1][X];

            //if any points lie in same line, then they must have the same slope
            //value which is (slope: (y2 - y1) / (x2 - x1)). If pointA, pointB, pointC
            //lie in same line then slopeAB == slopeBC, if they are not same then
            //there separate lines passing through these points hence lines++
            //slopeAB ==> (yB - yA) / (xB - xA) in our case one slope
            //is lastDy / lastDx
            //slopeBC ==> (yC - yB) / (xC - xB) in our case one slope
            //is currDy / currDx
            //hence (lastDy / lastDx) == (currDy / currDx) simplify
            //currDx * lastDy == lastDx * currDy, if these slopes are not same they
            //are separate lines
            if (currDx * lastDy != lastDx * currDy) {
                lines++;
                lastDy = currDy;
                lastDx = currDx;
            }
        }
        return lines;
    }

    private double maxPointsOnLine_CalculateSlope(int[] point1, int[] point2) {
        double x1 = point1[0];
        double y1 = point1[1];

        double x2 = point2[0];
        double y2 = point2[1];

        //if two points lie on same row coord p1=[1, 3], p2=[1,6], then the slope
        //between these two points will be perpendicular to X-Axis and is infinity
        if (x1 == x2) {
            return Double.MAX_VALUE;
        }

        //if two points have on same col coord p1=[1, 3], p2=[2,3], then these points
        //are parallel to each other and hence the slope between these two points are 0
        if (y1 == y2) {
            return 0.0;
        }

        return (y2 - y1) / (x2 - x1);
    }

    public void maxPointsOnLine(int[][] points) {
        //https://leetcode.com/problems/max-points-on-a-line/description/
        int n = points.length;

        if (n == 1) {
            System.out.println("Max points on line: " + 1);
            return;
        }

        int maxPointsInLine = 0;
        for (int i = 0; i < n; i++) {

            Map<Double, Integer> slopes = new HashMap<>();

            for (int j = i + 1; j < n; j++) {

                double slope = maxPointsOnLine_CalculateSlope(points[i], points[j]);

                slopes.put(slope, slopes.getOrDefault(slope, 0) + 1);

                maxPointsInLine = Math.max(maxPointsInLine, slopes.get(slope));
            }
        }
        //output
        System.out.println("Max points on line: " + maxPointsInLine);
    }

    public void countPrimes(int n) {
        //https://leetcode.com/problems/count-primes/
        //explanation: https://www.geeksforgeeks.org/sieve-of-eratosthenes/
        boolean[] primes = new boolean[n];
        //initially considering all 0 to n - 1 nums to be prime, then we will
        //filter out what all num are not primes
        Arrays.fill(primes, true);
        //since we are trying out all the num under n whose sqr is there in primes[]
        //why? because a prime num is someone who is not divisible by any other num
        //but sqr(num) is divisible 
        for (int num = 2; num * num < n; num++) {
            if (primes[num]) {
                //all sqrs of num(basically multiple of primes num)
                //ex num = 2 is prime but 2 * 2 = 4; i += num = 2 + 2 = 4
                for (int i = num * num; i < n; i += num) {
                    primes[i] = false;
                }
            }
        }
        int totalPrimes = 0;
        for (int num = 2; num < n; num++) {
            if (primes[num]) {
                System.out.print(num + " ");
                totalPrimes++;
            }
        }
        //output
        System.out.println("Count primes: " + totalPrimes);
    }

    public void myCalendarOne() {
        //https://leetcode.com/problems/my-calendar-i/
        //based on SEGMENT TREES BUT modifed it to use TREEMAP behaving as SEGMENT TREE
        //somewhat similar to amountToPaintTheArea()
        class MyCalendarOne {

            TreeMap<Integer, Integer> timeRange;

            public MyCalendarOne() {
                timeRange = new TreeMap<>();
            }

            public boolean book(int start, int end) {

                //here end - 1 being used because acc to question end time is
                //non-inclusive
                //floorKey(KEY) will give a key which will be
                //less than or equal to our KEY if not present then null
                //thats why using Integer beacuse primitive int can't store null
                //here it will return first lower start time than given start key
                Integer firstLowerTime = timeRange.floorKey(start);
                //higherKey(KEY) will give a key which will be
                //greater than or equal to our KEY if not present then null
                //thats why using Integer beacuse primitive int can't store null
                //here it will return first higher start time than given start key
                Integer firstHigherTime = timeRange.higherKey(start);

                if (firstLowerTime != null) {
                    //ex: [15, 20], [15, 17]
                    if (firstLowerTime == start) {
                        return false;
                    }
                    //ex: [10, 20], [15, 17] ==> 15 lying in range of [10 to 20 - 1]
                    if (start <= timeRange.get(firstLowerTime)) {
                        return false;
                    }
                }

                if (firstHigherTime != null) {
                    //ex: [15, 20], [15, 17]
                    if (firstHigherTime == start) {
                        return false;
                    }
                    //ex: [17, 25], [15, 18] ==> 15's end that is 18 lying beyond
                    //firstHigherTime range's start time that it 17
                    if (end - 1 >= firstHigherTime) {
                        return false;
                    }
                }

                timeRange.put(start, end - 1);
                return true;
            }
        }

        //input 1
        System.out.println("Input 1");
        MyCalendarOne calendar = new MyCalendarOne();
        int[][] bookings = new int[][]{{10, 20}, {50, 60}, {10, 40}, {5, 15}, {5, 10}, {25, 55}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }

        //input 2
        System.out.println("Input 2");
        calendar = new MyCalendarOne();
        bookings = new int[][]{{10, 20}, {15, 25}, {20, 30}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }
    }

    public void myCalendarThree() {
        //https://leetcode.com/problems/my-calendar-iii/
        class MyCalendarThree {

            TreeMap<Integer, Integer> diffs;

            public MyCalendarThree() {
                diffs = new TreeMap<>();
            }

            public int book(int start, int end) {
                diffs.put(start, diffs.getOrDefault(start, 0) + 1);
                diffs.put(end, diffs.getOrDefault(end, 0) - 1);
                int result = 0;
                int curr = 0;
                for (int diff : diffs.values()) {
                    curr += diff;
                    result = Math.max(result, curr);
                }

                return result;
            }
        }

        //input 1
        System.out.println("Input 1");
        MyCalendarThree calendar = new MyCalendarThree();
        int[][] bookings = new int[][]{{10, 20}, {50, 60}, {10, 40}, {5, 15}, {5, 10}, {25, 55}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }

        //input 2
        System.out.println("Input 2");
        calendar = new MyCalendarThree();
        bookings = new int[][]{{10, 20}, {15, 25}, {20, 30}};

        for (int[] timeRange : bookings) {
            System.out.println("Can book an event between [" + timeRange[0] + ", " + timeRange[1] + ") : "
                    + calendar.book(timeRange[0], timeRange[1]));
        }
    }

    public void implementMaxFreqStack() {
        //https://leetcode.com/problems/maximum-frequency-stack/
        //https://leetcode.com/problems/maximum-frequency-stack/solution/
        ImplementMaxFreqStack stack = new ImplementMaxFreqStack();
        stack.push(5);
        stack.push(7);
        stack.push(5);
        stack.push(7);
        stack.push(4);
        stack.push(5);
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
        System.out.println("POP: " + stack.pop());
    }

    public void executionOfAllInstructionsStayingInGrid(int n, int[] startPos, String commands) {
        //https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/description/
        //based on simulation
        class Helper {

            boolean isOutOfBounds(int row, int col, int n) {
                return row < 0 || row >= n || col < 0 || col >= n;
            }

            int helperSimulateCommands(int n, int[] startPos, String commands) {

                int len = commands.length();
                int row = startPos[0];
                int col = startPos[1];
                int steps = 0;
                int index = 0;

                while (index < len) {

                    char command = commands.charAt(index++);
                    steps++;

                    switch (command) {
                        case 'U':
                            row--;
                            break;
                        case 'D':
                            row++;
                            break;
                        case 'R':
                            col++;
                            break;
                        case 'L':
                            col--;
                            break;
                    }

                    //if the row & col going 'isOutOfBounds' then take a step back
                    //(==> step - 1) and return
                    if (isOutOfBounds(row, col, n)) {
                        return steps - 1;
                    }

                }
                return steps;
            }
        }

        Helper helper = new Helper();

        int len = commands.length();
        int[] result = new int[len];

        for (int i = 0; i < len; i++) {
            String command = commands.substring(i);
            result[i] = helper.helperSimulateCommands(n, startPos, command);
        }
        //output
        System.out.println("Execute instructions for staying in grid : " + Arrays.toString(result));
    }

    public static void main(String[] args) {

        //Object to access method
        DSA450Questions obj = new DSA450Questions();

        //......................................................................
//        Row: 6
//        System.out.println("Reverse array");
//        int[] a1 = {1, 2, 3, 4, 5};
//        obj.reverseArray(a1);
//        int[] a2 = {1, 2, 3, 4};
//        obj.reverseArray(a2);
        //......................................................................
//        Row: 56
//        System.out.println("Reverse string");
//        String str1 = "Sangeet";
//        obj.reverseString(str1);
//        String str2 = "ABCD";
//        obj.reverseString(str2);
        //......................................................................
//        Row: 57 
//        System.out.println("Is string pallindrome");
//        String str3 = "Sangeet";
//        System.out.println(str3+" "+obj.isStringPallindrome(str3));
//        System.out.println(str3+": is pallindrome by two pointer: "+obj.isStringPallindrome(str3, 0, str3.length() - 1));
//        String str4 = "ABBA";
//        System.out.println(str4+" "+obj.isStringPallindrome(str4));
//        System.out.println(str4+": is pallindrome by two pointer: "+obj.isStringPallindrome(str4, 0, str4.length() - 1));
        //......................................................................
//        Row: 58
//        System.out.println("Print duplicates char in string");
//        String str5 = "AABBCDD";
//        obj.printDuplicatesCharInString(str5);
//        String str6 = "XYZPQRS";
//        obj.printDuplicatesCharInString(str6);
        //......................................................................
//        Row: 139
//        System.out.println("Reverse a linked list iterative/recursive");
//        Node<Integer> node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        obj.reverseLinkedList_Iterative(node1);
//        Node<Integer> node2 = new Node<>(1);
//        node2.setNext(new Node<>(2));
//        node2.getNext().setNext(new Node<>(3));
//        node2.getNext().getNext().setNext(new Node<>(4));
//        node2.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.reverseLinkedList_Recursive(node2);
        //......................................................................
//        Row: 177
//        System.out.println("Level order traversal of tree iterative & recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.levelOrderTraversal_Iterative(root1);
//        obj.levelOrderTraversal_Iterative2(root1); //size based approach
//        obj.levelOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 179
//        System.out.println("Height of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        System.out.println(obj.heightOfTree(root1));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode(2));
//        System.out.println(obj.heightOfTree(root2));
        //......................................................................
//        Row: 181
//        System.out.println("Invert/mirror of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        obj.mirrorOfTree(root1);
//        System.out.println();
//        //output
//        bt = new BinaryTree<>(root1);
//        bt.treeBFS();
        //......................................................................
//        Row: 299
//        System.out.println("Middle element in the stack");
//        Stack<Integer> stack = new Stack<>();
//        stack.addAll(Arrays.asList(1, 2, 3, 4, 5, 6, 7));
//        obj.middleElementInStack(stack);
//        stack.clear();
//        stack.addAll(Arrays.asList(1, 2, 3, 4));
//        obj.middleElementInStack(stack);
//        stack.clear();
//        //empty stack!!
//        obj.middleElementInStack(stack);
        //......................................................................
//        Row: 182
//        System.out.println("Inorder traversal of tree Iterative/recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.inOrderTraversal_Iterative(root1);
//        obj.inOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 183
//        System.out.println("Preorder traversal of tree Iterative/recursive");
//        //https://leetcode.com/problems/binary-tree-preorder-traversal/description/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.preOrderTraversal_Iterative(root1);
//        obj.preOrderTraversal_Iterative2(root1);
//        obj.preOrderTraversal_Recursive(root1);
        //......................................................................
//        Row: 184
//        System.out.println("Postsorder traversal of tree Iterative/recursive");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        //actual
//        BinaryTree bt = new BinaryTree<>(root1);
//        bt.treeBFS();
//        System.out.println();
//        obj.postOrderTraversal_Iterative(root1);
//        obj.postOrderTraversal_recursive(root1);
        //......................................................................
//        Row: 148
//        System.out.println("Add two numbers represented by linked list");
//        Node<Integer> n1 = new Node<>(4);
//        n1.setNext(new Node<>(5));
//        Node<Integer> n2 = new Node<>(3);
//        n2.setNext(new Node<>(4));
//        n2.getNext().setNext(new Node<>(5));
//        obj.sumOfNumbersAsLinkedList_ByStack(n1, n2);
//        obj.sumOfNumbersAsLinkedList_ByReversingList(n1, n2);
        //......................................................................
//        Row: 178
//        System.out.println("Reverse level order traversal");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.reverseLevelOrderTraversal(root1);
        //......................................................................
//        Row: 185
//        System.out.println("Left view of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.leftViewOfTree(root1);
//        obj.leftViewOfTreeWithoutExtraSpace(root1);
        //......................................................................
//        Row: 186
//        System.out.println("Right view of tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.rightViewOfTree(root1);
//        obj.rightViewOfTreeWithoutExtraSpace(root1);
        //......................................................................
//        Row: 187
//        System.out.println("Top view of tree/ Vertical order traversal of tree");
//        //https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.topViewOfTree(root1);
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.verticalOrderTraversalOfBinaryTree(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode(1));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(2));
//        root1.setRight(new TreeNode(4));
//        root1.getRight().setLeft(new TreeNode(2));
//        obj.verticalOrderTraversalOfBinaryTree(root1);
        //......................................................................
//        Row: 188
//        System.out.println("Bottom view of tree");
//        //https://practice.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1
//        TreeNode<Integer> root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.bottomViewOfTree(root1);
        //......................................................................
//        Row: 189
//        System.out.println("Zig zag traversal of tree");
//        //https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.zigZagTreeTraversal(root1, true);
//        root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.zigZagTreeTraversal(root1, false);
        //......................................................................
//        Row: 30
//        System.out.println("All the element from array[N] and given K that occurs more than N/K times");
//        obj.arrayElementMoreThan_NDivK(new int[]{3, 1, 2, 2, 1, 2, 3, 3}, 4);
        //......................................................................
//        Row: 81
//        System.out.println("Roman numeral string to decimal");
//        //https://leetcode.com/problems/roman-to-integer/
//        obj.romanStringToDecimal("III");
//        obj.romanStringToDecimal("CI");
//        obj.romanStringToDecimal("IM");
//        obj.romanStringToDecimal("V");
//        obj.romanStringToDecimal("XI");
//        obj.romanStringToDecimal("IX");
//        obj.romanStringToDecimal("IV");
//        obj.integerToRomanString(100);
//        obj.integerToRomanString(101);
//        obj.integerToRomanString(4999);
        //......................................................................
//        Row: 86
//        System.out.println("Longest common subsequence");
//        obj.longestCommonSubsequence("ababcba", "ababcba");
//        obj.longestCommonSubsequence("abxayzbcpqba", "kgxyhgtzpnlerq");
//        obj.longestCommonSubsequence("abcd", "pqrs");
//        obj.longestCommonSubsequence("abcd", "");
//        obj.longestCommonSubsequence("", "pqrs");
        //......................................................................
//        Row: 144
//        System.out.println("Remove duplicates from sorted linked list");
//        Node<Integer> node1 = new Node<>(1);
//        node1.setNext(new Node<>(1));
//        node1.getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.removeDuplicateFromSortedLinkedList(node1);
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(2));
//        node1.getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.removeDuplicateFromSortedLinkedList(node1);
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().setNext(new Node<>(4));
//        node1.getNext().getNext().getNext().setNext(new Node<>(5));
//        node1.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicateFromSortedLinkedList(node1);
        //......................................................................
//        Row: 194
//        System.out.println("Convert tree to doubly linked list");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.treeToDoublyLinkedList(root1);
//        root1 = new TreeNode<>(20);
//        root1.setLeft(new TreeNode(8));
//        root1.getLeft().setLeft(new TreeNode(5));
//        root1.getLeft().setRight(new TreeNode(3));
//        root1.getLeft().getRight().setLeft(new TreeNode(10));
//        root1.setRight(new TreeNode(22));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().setRight(new TreeNode(25));
//        root1.getRight().getLeft().setRight(new TreeNode(14));
//        obj.treeToDoublyLinkedList(root1);
        //......................................................................
//        Row: 199
//        System.out.println("Check if all the leaf nodes of tree are at same level");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.checkIfAllLeafNodeOfTreeAtSameLevel(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(2));
//        root1.setRight(new TreeNode(3));
//        obj.checkIfAllLeafNodeOfTreeAtSameLevel(root1);
        //......................................................................
//        Row: 216
//        System.out.println("Min & max in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.minAndMaxInBST(root1);
        //......................................................................
//        Row: 218
//        System.out.println("Check if a tree is BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeBST(root1);
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(10)); //BST break cond.
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeBST(root1);
        //......................................................................
//        Row: 225
//        System.out.println("Kth largest node in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.kTHLargestNodeInBST(root1, 4);
//        obj.kTHLargestNodeInBSTWithoutHeap(root1, 4);
//        obj.kTHLargestNodeInBST(root1, 21);
//        obj.kTHLargestNodeInBSTWithoutHeap(root1, 21);
        //......................................................................
//        Row: 226
//        System.out.println("Kth smallest node in the BST");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.kTHSmallestNodeInBST(root1, 4);
//        obj.kTHSmallestNodeInBST(root1, 1);
//        obj.kTHSmallestNodeInBST(root1, 21);
        //......................................................................
//        Row: 169
//        System.out.println("Merge K sorted linked lists");
//        //https://leetcode.com/problems/merge-k-sorted-lists/
//        Node<Integer> n1 = new Node<>(1);
//        n1.setNext(new Node<>(2));
//        n1.getNext().setNext(new Node<>(3));
//        Node<Integer> n2 = new Node<>(4);
//        n2.setNext(new Node<>(10));
//        n2.getNext().setNext(new Node<>(15));
//        Node<Integer> n3 = new Node<>(3);
//        n3.setNext(new Node<>(9));
//        n3.getNext().setNext(new Node<>(27));
//        int K = 3;
//        Node<Integer>[] nodes = new Node[K];
//        nodes[0] = n1;
//        nodes[1] = n2;
//        nodes[2] = n3;
//        obj.mergeKSortedLinkedList(nodes);
        //......................................................................
//        Row: 173
//        System.out.println("Print the Kth node from the end of a linked list 3 approaches");
//        //https://leetcode.com/problems/remove-nth-node-from-end-of-list/
//        //https://www.geeksforgeeks.org/nth-node-from-the-end-of-a-linked-list/
//        //https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
//        Node<Integer> n1 = new Node<>(1);
//        n1.setNext(new Node<>(2));
//        n1.getNext().setNext(new Node<>(3));
//        n1.getNext().getNext().setNext(new Node<>(5));
//        n1.getNext().getNext().getNext().setNext(new Node<>(9));
//        n1.getNext().getNext().getNext().getNext().setNext(new Node<>(15));
//        obj.kThNodeFromEndOfLinkedList_1(n1, 3);
//        obj.kThNodeFromEndOfLinkedList_2(n1, 3);
//        obj.kThNodeFromEndOfLinkedList_3(n1, 3); //OPTIMISED O(N)
//        obj.kThNodeFromEndOfLinkedList_3(n1, 6); //OPTIMISED O(N)
//        obj.kThNodeFromEndOfLinkedList_3(n1, 8); //OPTIMISED O(N)
        //......................................................................
//        Row: 190
//        System.out.println("Check if a tree is height balanced or not");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.isTreeHeightBalanced(root1);
//        root1 = new TreeNode<>(1); //SKEWED TREE
//        root1.setLeft(new TreeNode(10));
//        root1.getLeft().setLeft(new TreeNode(15));
//        obj.isTreeHeightBalanced(root1);
        //......................................................................
//        Row: 201
//        System.out.println("Check if 2 trees are mirror or not");
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        System.out.println("2 tree are mirror: "+obj.checkTwoTreeAreMirror(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(2)); //SAME 
//        root2.setRight(new TreeNode<>(3)); //SAME
//        System.out.println("2 tree are mirror: "+obj.checkTwoTreeAreMirror(root1, root2));
        //......................................................................
//        Row: 333
//        System.out.println("Next smaller element to right / left in array");
//        obj.nextSmallerElementToRightInArray(new int[]{4, 8, 5, 2, 25});
//        obj.nextSmallerElementToLeftInArray(new int[]{4, 8, 5, 2, 25});
        //......................................................................
//        Row: 304
//        System.out.println("Next greater element to right / left in array");
//        obj.nextGreaterElementToRightInArray(new int[]{1,3,2,4});
//        obj.nextGreaterElementToRightInArray(new int[]{1,2,3,4,5}); //STACK WILL HOLD N ELEMENT S: O(N)
//        obj.nextGreaterElementToRightInArray(new int[]{5,4,3,2,1}); //STACK WILL NOT HOLD N ELEMENT S: O(1)
//        obj.nextGreaterElementToLeftInArray(new int[]{1,3,2,4});
//        obj.nextGreaterElementToLeftInArray(new int[]{1,2,3,4,5});
//        obj.nextGreaterElementToLeftInArray(new int[]{5,4,3,2,1});
        //......................................................................
//        Row: 309
//        System.out.println("Reverse a stack using recursion");
//        Stack<Integer> stack = new Stack<>();
//        stack.addAll(Arrays.asList(1, 2, 3, 4, 5));
//        obj.reverseStack(stack);
        //......................................................................
//        Row: 7
//        System.out.println("Min & max in array");
//        obj.minMaxInArray_1(new int[]{1000, 11, 445, 1, 330, 3000});
//        obj.minMaxInArray_2(new int[]{1000, 11, 445, 1, 330, 3000});
        //......................................................................
//        Row: 8
//        System.out.println("Kth smallest and largest element in array");
//        //https://leetcode.com/problems/query-kth-smallest-trimmed-number/
//        obj.kThSmallestElementInArray(new int[]{7, 10, 4, 3, 20, 15}, 3);
//        obj.kThSmallestTrimmedNumber(new String[]{"102", "473", "251", "814"},
//                new int[][]{{1, 1}, {2, 3}, {4, 2}, {1, 2}});
//        obj.kThLargestElementInArray(new int[]{7, 10, 4, 3, 20, 15}, 3);
        //......................................................................
//        Row: 9
//        System.out.println("Sort the array containing elements 0, 1, 2");
//        //https://leetcode.com/problems/sort-colors/
//        obj.sortArrayOf012_1(new int[]{0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1});
//        obj.sortArrayOf012_2(new int[]{0, 1, 1, 0, 1, 2, 1, 2, 0, 0, 0, 1}); //DUTCH NATIONAL FLAG ALGO
        //......................................................................
//        Row: 51
//        System.out.println("Rotate a matrix 90 degrees clockwise/anticlockwise");
//        //https://leetcode.com/problems/rotate-image
//        int[][] mat = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
//        obj.rotateMatrixClockWise90Deg(mat);
//        mat = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
//        obj.rotateMatrixAntiClockWise90Deg(mat);
        //......................................................................
//        Row: 62
//        System.out.println("Count and say");
//        //https://leetcode.com/problems/count-and-say/
//        obj.countAndSay(1);
//        obj.countAndSay(2);
//        obj.countAndSay(3);
//        obj.countAndSay(10);
        //......................................................................
//        Row: 93
//        System.out.println("Remove consecutive duplicate char in string");
//        obj.removeConsecutiveDuplicateInString("aababbccd");
//        obj.removeConsecutiveDuplicateInString("aaabbbcccbbbbaaaa");
//        obj.removeConsecutiveDuplicateInString("xyzpqrs");
//        obj.removeConsecutiveDuplicateInString("abcppqrspplmn");
//        obj.removeConsecutiveDuplicateInString("abcdlllllmmmmm");
//        obj.removeConsecutiveDuplicateInString("aaaaaaaaaaaa");
        //......................................................................
//        Row: 108
//        System.out.println("Majority Element");
//        //https://leetcode.com/problems/majority-element/
//        //https://leetcode.com/problems/majority-element-ii/
//        obj.majorityElement_1(new int[] { 1, 3, 3, 1, 2 });
//        obj.majorityElement_1(new int[] { 1, 3, 3, 3, 2 });
//        obj.majorityElement_2(new int[] { 1, 3, 3, 1, 2 }); //MOORE'S VOTING ALGO
//        obj.majorityElement_2(new int[] { 1, 3, 3, 3, 2 }); //MOORE'S VOTING ALGO
        //......................................................................
//        Row: 195
//        System.out.println("Convert tree to its sum tree");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.convertTreeToSumTree(root1); //EXTRA QUEUE SPACE IS USED
//        //reset root
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.convertTreeToSumTree_Recursion(root1); //NO EXTRA QUEUE SPACE IS USED - OPTIMISED
        //......................................................................
//        Row: 206
//        System.out.println("K sum path from any node top to down");
//        //https://leetcode.com/problems/path-sum-iii/
//        //https://leetcode.com/problems/path-sum-ii/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(3));
//        root1.getLeft().setLeft(new TreeNode(2));
//        root1.getLeft().setRight(new TreeNode(1));
//        root1.getLeft().getRight().setLeft(new TreeNode(1));
//        root1.setRight(new TreeNode(-1));
//        root1.getRight().setLeft(new TreeNode(4));
//        root1.getRight().getLeft().setLeft(new TreeNode(1));
//        root1.getRight().getLeft().setRight(new TreeNode(2));
//        root1.getRight().setRight(new TreeNode(5));
//        root1.getRight().getRight().setRight(new TreeNode(6));
//        obj.printKSumPathAnyNodeTopToDown(root1, 5);
        //......................................................................
//        Row: 349, 269
//        System.out.println("Min cost to combine ropes of diff lengths into one big rope");
//        obj.minCostOfRope(new int[]{4, 3, 2, 6});
        //......................................................................
//        Row: 344, 89, 271
//        System.out.println("Reorganise string");
//        //https://leetcode.com/problems/reorganize-string/
//        System.out.println("Reorganise string output: "+obj.reorganizeString("aab"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("aaab"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("bbbbb"));
//        System.out.println("Reorganise string output: "+obj.reorganizeString("geeksforgeeks"));
        //......................................................................
//        Row: 98
//        System.out.println("Print all sentences that can be formed from list/array of words");
//        String[][] arr = {{"you", "we", ""},
//        {"have", "are", ""},
//        {"sleep", "eat", "drink"}};
//        obj.printSentencesFromCollectionOfWords(arr); //GRAPH LIKE DFS
        //......................................................................
//        Row: 74
//        System.out.println("KMP pattern matching algo");
//        //https://leetcode.com/problems/implement-strstr/
//        obj.KMP_PatternMatching_Algorithm("ABABDABACDABABCABAB", "ABABCABAB");
//        obj.KMP_PatternMatching_Algorithm("sangeeangt", "ang");
//        obj.KMP_PatternMatching_Algorithm("sangeeangt", "xyz");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("abab");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("aaaa");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("aabcavefaabca");
//        obj.longestPrefixAlsoSuffixInString_KMPAlgo("abcdef");
        //......................................................................
//        Row: 82
//        System.out.println("Longest common prefix in list of strings");
//        //https://leetcode.com/problems/longest-common-prefix/
//        obj.longestCommonPrefix(new String[]{"flower", "flow", "flight"});
//        obj.longestCommonPrefix(new String[]{"flower", "flower", "flower"});
//        obj.longestCommonPrefix(new String[]{"dog", "racecar", "car"});
//        obj.longestCommonPrefix(new String[]{"a"});
//        obj.longestCommonPrefix(new String[]{"abc", "abcdef", "abcdlmno"});
        //......................................................................
//        Row: 114
//        System.out.println("Merge 2 sorted arrays without using extra space");
//        int arr1[] = new int[]{1, 5, 9, 10, 15, 20};
//        int arr2[] = new int[]{2, 3, 8, 13};
//        obj.mergeTwoSortedArraysWithoutExtraSpace(arr1, arr2, arr1.length, arr2.length);
        //......................................................................
//        Row: 140
//        System.out.println("Swap Linked List Nodes In Pairs");
//        //https://leetcode.com/problems/swap-nodes-in-pairs/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<>(obj.swapLinkedListNodesInPair(node)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(8));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        new LinkedListUtil<>(obj.swapLinkedListNodesInPair(node)).print();
        //......................................................................
//        Row: 140
//        System.out.println("Reverse a linked list in K groups");
//        //https://leetcode.com/problems/reverse-nodes-in-k-group/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<>(obj.reverseLinkedListInKGroups(node, 3)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(8));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        new LinkedListUtil<>(obj.reverseLinkedListInKGroups(node, 4)).print();
        //......................................................................
//        Row: 207, 220
//        System.out.println("Lowest common ancestor of two given node/ node values for binary tree and binary search tree both");
//        TreeNode<Integer> root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        obj.lowestCommonAncestorOfTree(root1, 3, 4);
//        root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(6));
//        obj.lowestCommonAncestorOfTree(root1, 3, 6);
//        //CASE OF BST
//        root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.lowestCommonAncestorOfTree(root1, 0, 5);
//        root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode(4));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode(6));
//        root1.getRight().setRight(new TreeNode(7));
//        root1.getRight().getRight().setRight(new TreeNode(8));
//        obj.lowestCommonAncestorOfTree(root1, 7, 8);
        //......................................................................
//        Row: 69, 416
//        System.out.println("Edit distance recursion/ DP memoization");
//        //https://leetcode.com/problems/edit-distance/description/
//        String s1 = "sunday";
//        String s2 = "saturday";
//        System.out.println("Edit distance recursion: "+obj.editDistance_Recursion(s1, s2, s1.length(), s2.length()));
//        System.out.println("Edit distance dp memoization: "+obj.editDistance_DP_Memoization(s1, s2));
        //......................................................................
//        Row: 84
//        System.out.println("Second most occuring word in list");
//        obj.secondMostOccuringWordInStringList(new String[]{"aaa", "bbb", "ccc", "bbb", "aaa", "aaa"});
        //......................................................................
//        Row: 101
//        System.out.println("Find first and last occurence of K in sorted array");
//        //https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/
//        //https://leetcode.com/problems/find-target-indices-after-sorting-array/
//        //https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/
//        obj.findFirstAndLastOccurenceOfKInSortedArray(new int[]{1, 3, 5, 5, 5, 5, 67, 123, 125}, 5);
//        obj.findFirstAndLastOccurenceOfKInSortedArray(new int[]{1, 3, 5, 5, 5, 5, 67, 123, 125}, 9);
//        obj.findFirstAndLastOccurenceOfKInSortedArray(new int[]{1, 3, 5, 67, 123, 125}, 5);
        //......................................................................
//        Row: 141, 143
//        System.out.println("Detect and print starting node of a loop cycle in linked list 2 approaches");
//        //https://leetcode.com/problems/linked-list-cycle/description/
//        //https://leetcode.com/problems/happy-number/
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_HashBased(node));
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_Iterative(node)); //T: O(N), S: O(1) //OPTIMISED
//        node = new Node<>(3);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(-4));
//        node.getNext().getNext().getNext().setNext(node.getNext());
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_HashBased(node));
//        System.out.println("Is there a loop in linked list: "+obj.detectLoopCycleInLinkedList_Iterative(node)); //T: O(N), S: O(1) //OPTIMISED
        //......................................................................
//        Row: 142
//        System.out.println("Detect and remove loop cycle in linked list 2 approaches");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        obj.detectAndRemoveLoopCycleInLinkedList_HashBased(node);
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(node.getNext().getNext()); //Node 5 connects to Node 3
//        obj.detectAndRemoveLoopCycleInLinkedList_Iterative(node); //OPTIMISED
        //......................................................................
//        Row: 145
//        System.out.println("Remove duplicates element in unsorted linked list 2 different outputs");
//        Node<Integer> node = new Node<>(3);
//        node.setNext(new Node<>(4));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicatesFromUnSortedLinkedListOnlyConsecutive(node);
//        node = new Node<>(3);
//        node.setNext(new Node<>(4));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.removeDuplicatesFromUnSortedLinkedListAllExtraOccuernce(node);
        //......................................................................
//        Row: 153
//        System.out.println("Find the middle element of the linked list");
//        Node<Integer> node = new Node<>(3);
//        node.setNext(new Node<>(5));
//        node.getNext().setNext(new Node<>(2));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        System.out.println("Middle element: "+obj.findMiddleNodeOfLinkedList(node).getData());
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        System.out.println("Middle element: "+obj.findMiddleNodeOfLinkedList(node).getData());
        //......................................................................
//        Row: 151
//        System.out.println("Sort linked list using merge sort");
//        //https://leetcode.com/problems/sort-an-array/description/
//        Node<Integer> node = new Node<>(3);
//        node.setNext(new Node<>(5));
//        node.getNext().setNext(new Node<>(2));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        new LinkedListUtil<Integer>(obj.mergeSortDivideAndMerge(node)).print();
//        node = new Node<>(3);
//        node.setNext(new Node<>(3));
//        node.getNext().setNext(new Node<>(7));
//        node.getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        new LinkedListUtil<Integer>(obj.mergeSortDivideAndMerge(node)).print();
        //......................................................................
//        Row: 198
//        System.out.println("Check if a tree is sum tree");
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(20));
//        root.getLeft().setLeft(new TreeNode<>(10));
//        root.getLeft().setRight(new TreeNode<>(10));
//        root.setRight(new TreeNode<>(30)); //NOT A SUM TREE
//        obj.checkTreeIsSumTree(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(1)); //SUM TREE
//        obj.checkTreeIsSumTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Coin Change/ Min number of coins to make change in unlimited supply of coins");
//        //https://leetcode.com/problems/coin-change/description/
//        //https://practice.geeksforgeeks.org/problems/number-of-coins1824/1
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{25, 10, 5}, 30);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{1, 2, 5}, 11);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{2}, 3);
//        obj.minCoinsRequiredToMakeChangeInUnlimitedSupplyOfCoins_DP_Memoization(new int[]{1}, 0);
//        obj.coinChange_DP_Memoization(new int[]{25, 10, 5}, 30);
//        obj.coinChange_DP_Memoization(new int[]{1, 2, 5}, 11);
//        obj.coinChange_DP_Memoization(new int[]{2}, 3);
//        obj.coinChange_DP_Memoization(new int[]{1}, 0);
        //......................................................................
//        Row: 410
//        System.out.println("Coin change with infinite supply of coins");
//        //https://leetcode.com/problems/coin-change-2/
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{1, 2, 5}, 5);
//        obj.coinChangeTwo_DP_Memoization(new int[]{1, 2, 5}, 5);
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{2}, 3);
//        obj.coinChangeTwo_DP_Memoization(new int[]{2}, 3);
//        obj.coinChangeTwo_Recursive_Memoization(new int[]{1, 2, 3}, 9);
//        obj.coinChangeTwo_DP_Memoization(new int[]{1, 2, 3}, 9);
        //......................................................................
//        Row: 411
//        System.out.println("0-1 knap sack");
//        obj.knapSack01_Recursive_Memoization(new int[]{4, 5, 1}, new int[]{1, 2, 3}, 4);
//        obj.knapSack01_DP_Memoization(new int[]{4, 5, 1}, new int[]{1, 2, 3}, 4);
//        obj.knapSack01_Recursive_Memoization(new int[]{4, 5, 6}, new int[]{1, 2, 3}, 3);
//        obj.knapSack01_DP_Memoization(new int[]{4, 5, 6}, new int[]{1, 2, 3}, 3);
        //......................................................................
//        Row: 417, 282
//        System.out.println("Subset sum");
//        obj.subsetSum_Recursive_Memoization(new int[]{1, 5, 5, 11}, 11);
//        obj.subsetSum_Recursive_Memoization(new int[]{1, 5, 5, 12}, 14);
//        obj.subsetSum_DP_Memoization(new int[]{1, 5, 5, 11}, 11);
//        obj.subsetSum_DP_Memoization(new int[]{1, 5, 5, 12}, 14);
//        System.out.println("Partition Equal Subset Sum");
//        //https://leetcode.com/problems/partition-equal-subset-sum/
//        obj.equalsSumPartition_SubsetSum(new int[]{1, 5, 5, 11});
//        obj.equalsSumPartition_SubsetSum(new int[]{1, 5, 5, 12});
        //......................................................................
//        Row: 423
//        System.out.println("Longest common sub sequence of 2 strings DP problem");
//        //https://leetcode.com/problems/longest-common-subsequence
//        String s1 = "ABCDGH";
//        String s2 = "AEDFHR";
//        System.out.println("The longest common sub sequence length for the given 2 strings: "+obj.longestCommonSubsequence_Recursion(s1, s2, s1.length(), s2.length()));
//        obj.longestCommonSubsequence_DP_Memoization(s1, s2, s1.length(), s2.length());
//        s1 = "ABCDGH";
//        s2 = "";
//        System.out.println("The longest common sub sequence length for the given 2 strings: "+obj.longestCommonSubsequence_Recursion(s1, s2, s1.length(), s2.length()));
//        obj.longestCommonSubsequence_DP_Memoization(s1, s2, s1.length(), s2.length());
//        System.out.println("Uncrossed Lines / Longest common sub sequence of 2 int arrays DP problem");
//        //https://leetcode.com/problems/uncrossed-lines/
//        obj.uncrossedLines_DP_Memoization(new int[]{1,4,2}, new int[]{1,2,4});
//        obj.uncrossedLines_DP_Memoization(new int[]{2,5,1,2,5}, new int[]{10,5,2,1,5,2});
//        obj.uncrossedLines_DP_Memoization(new int[]{1,3,7,1,7,5}, new int[]{1,9,2,5,1});
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Longest Pallindromic Subsequence DP problem");
//        //https://leetcode.com/problems/longest-palindromic-subsequence
//        obj.longestPallindromicSubsequence_Recursive_Memoization("bbbab");
//        obj.longestPallindromicSubsequence_Recursive_Memoization("cbbs");
//        obj.longestPallindromicSubsequence_DP_Memoization("bbbab");
//        obj.longestPallindromicSubsequence_DP_Memoization("cbbs");
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Maximize Palindrome Length From Subsequences");
//        //https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/description/
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("cacb", "cbba");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("ab", "ab");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("aa", "bb");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("xyz", "cbba");
//        obj.maximizePallindromLengthFromSubsequence_DP_Memoization("cfe", "ef");
        //......................................................................
//        Row: SEPARATE IMPORTANT QUESTION
//        System.out.println("Delete Operation for Two Strings DP problem");
//        //https://leetcode.com/problems/delete-operation-for-two-strings/
//        // delete s from sea ==> "ea" insert t to "ea"  ==> eat
//        obj.deleteOperationOfTwoStrings_DP_Memoization("sea", "eat"); 
//        obj.deleteOperationOfTwoStrings_DP_Memoization("leetcode", "etco");
        //......................................................................
//        Row: 97
//        System.out.println("Check two strings are isomorphic or not");
//        //https://leetcode.com/problems/word-pattern/
//        //https://leetcode.com/problems/find-and-replace-pattern/
//        //https://www.geeksforgeeks.org/check-if-two-given-strings-are-isomorphic-to-each-other/
//        String s1 = "aab";
//        String s2 = "xxy";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
//        s1 = "aab";
//        s2 = "xyz";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
//        s1 = "13";
//        s2 = "42";
//        System.out.println("Is isomorphic strings 1: "+obj.checkIsomorphicStrings_1(s1, s2));
//        System.out.println("Is isomorphic strings 2: "+obj.checkIsomorphicStrings_2(s1, s2));
        //......................................................................
//        Row: 96
//        System.out.println("Transform one string to another with min given no of operations");
//        //https://www.geeksforgeeks.org/transform-one-string-to-another-using-minimum-number-of-given-operation/
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACBD", "EABCD"));
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACBD", "EACBD"));
//        System.out.println("Transform operations required: " + obj.transformOneStringToAnotherWithMinOprn("EACCD", "EABCD"));
        //......................................................................
//        Row: 154
//        System.out.println("Check if a linked list is circular linked list");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(node); //CIRCULAR 6 -> 1
//        System.out.println("Check if given linked list is circular linked list: " + obj.checkIfLinkedListIsCircularLinkedList(node));
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6)); //NOT CIRCULAR 6 -> NULL
//        System.out.println("Check if given linked list is circular linked list: " + obj.checkIfLinkedListIsCircularLinkedList(node));
        //......................................................................
//        Row: 152
//        System.out.println("Quick sort in linked list");
//        //https://www.geeksforgeeks.org/quick-sort/
//        Node<Integer> node = new Node<>(10);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(5));
//        node.getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().setNext(new Node<>(3));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.quickSortInLinkedList(node);
        //......................................................................
//        Row: 339
//        System.out.println("K-th largest element in array");
//        obj.kLargestElementInArray(new int[]{12, 5, 787, 1, 23}, 2);
//        obj.kLargestElementInArray(new int[]{1, 23, 12, 9, 30, 2, 50}, 3);
//        System.out.println("Find the Kth Largest Integer in the String Nums Array");
//        //https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/description/
//        obj.kLargestElementInStringNumsArray(new String[]{"3", "6", "7", "10"}, 4);
//        obj.kLargestElementInStringNumsArray(new String[]{"2", "21", "12", "1"}, 3);
//        obj.kLargestElementInStringNumsArray(new String[]{"0", "0"}, 2);
//        obj.kLargestElementInStringNumsArray(new String[]{"300", "601", "70", "1"}, 4);
//        obj.kLargestElementInStringNumsArray(new String[]{"301", "302", "303", "300", "0", "0"}, 3);
        //......................................................................
//        Row: 20, 70
//        System.out.println("Next permutation");
//        //https://leetcode.com/problems/next-permutation
//        obj.nextPermutation(new int[]{1,2,3});
//        obj.nextPermutation(new int[]{4,3,2,1});
//        obj.nextPermutation(new int[]{1,3,1,4,7,6,2});
//        obj.nextPermutation(new int[]{2,7,4,3,2});
//        obj.nextPermutation(new int[]{1, 2, 3, 6, 5, 4});
        //......................................................................
//        Row: 27
//        System.out.println("Factorial of large number");
//        //https://www.geeksforgeeks.org/factorial-large-number/
//        obj.factorialLargeNumber(1);
//        obj.factorialLargeNumber(5);
//        obj.factorialLargeNumber(10);
//        obj.factorialLargeNumber(897);
        //......................................................................
//        Row: 103
//        System.out.println("Search in rotated sorted array");
//        //https://leetcode.com/problems/search-in-rotated-sorted-array
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 0));
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 4));
//        System.out.println("The target is found at location: "+ obj.searchInRotatedSortedArray(new int[]{4,5,6,7,0,1,2}, 3));
//        //https://leetcode.com/problems/search-in-rotated-sorted-array-ii/
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{1,0,1,1,1}, 0));
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{2,5,6,0,0,1,2}, 0));
//        System.out.println("The target is found at location in arr with duplicate elements: "
//                + obj.searchInRotatedSortedArrayWithDuplicateArrayElement(new int[]{2,5,6,0,0,1,2}, 3));
        //......................................................................
//        Row: 146
//        System.out.println("Move last node of linked list to front");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.moveLastNodeToFrontOfLinkedList(node);
        //......................................................................
//        Row: 147
//        System.out.println("Add 1 to linked list");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        obj.addOneToLinkedList(node);
//        node = new Node<>(9); //COND WHEN METHOD WILL CREATE NEWHEAD TO STORE EXTRA CARRY IN THE SUM RECURSION
//        node.setNext(new Node<>(9));
//        node.getNext().setNext(new Node<>(9));
//        node.getNext().getNext().setNext(new Node<>(9));
//        obj.addOneToLinkedList(node);
        //......................................................................
//        Row: 167
//        System.out.println("Sort linked list of 0s, 1s, 2s using 2 approaches");
//        //https://www.geeksforgeeks.org/sort-a-linked-list-of-0s-1s-or-2s/
//        Node<Integer> node = new Node<>(0);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        new LinkedListUtil<>(obj.mergeSortDivideAndMerge(node)).print(); //SIMPLE MERGE SORT APPROACH T: O(N.LogN)
//        node = new Node<>(0);
//        node.setNext(new Node<>(1));
//        node.getNext().setNext(new Node<>(0));
//        node.getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        node.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        obj.sortLinkedListOf012_2(node); //SIMPLE MANIPULATION OF NODE T: O(N)
        //......................................................................
//        Row: 202
//        System.out.println("Sum of node on the longest path of tree from root to leaf");
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.getLeft().getRight().setLeft(new TreeNode<>(6)); //LONGEST PATH
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(3));
//        obj.longestPathNodeSum(root);
        //......................................................................
//        Row: 34
//        System.out.println("Rain water trapping 2 approaches");
//        //https://leetcode.com/problems/trapping-rain-water/
//        obj.rainWaterTrappingUsingStack(new int[]{3,0,0,2,0,4});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{3,0,0,2,0,4});
//        obj.rainWaterTrappingUsingStack(new int[]{6,9,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{6,9,9});
//        obj.rainWaterTrappingUsingStack(new int[]{7,4,0,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{7,4,0,9});
//        obj.rainWaterTrappingUsingTwoPointers(new int[]{3,4,1});
        //......................................................................
//        Row: 28
//        System.out.println("Find maximum product subarray");
//        //https://leetcode.com/problems/maximum-product-subarray/
//        obj.findMaximumProductSubarray(new int[]{2,3,-2,4});
//        obj.findMaximumProductSubarray(new int[]{-2,0,-1});
//        obj.findMaximumProductSubarray(new int[]{-1,8});
//        obj.findMaximumProductSubarray(new int[]{-1,-8});
        //......................................................................
//        Row: 217
//        System.out.println("Find predecessor and successor of given node in BST");
//        //https://www.geeksforgeeks.org/inorder-predecessor-successor-given-key-bst/
//        //predecessors and successor can be found when we do the inorder traversal of tree
//        //inorder traversal of BST is sorted list of node data
//        //for below BST inorder list [0,2,3,4,5,6,7,8,9]
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.findPredecessorAndSuccessorInBST(root1, 6);
//        obj.findPredecessorAndSuccessorInBST(root1, 2);
//        obj.findPredecessorAndSuccessorInBST(root1, 5);
//        obj.findPredecessorAndSuccessorInBST(root1, 10); //ONLY PREDECESSOR IS POSSIBLE
//        obj.findPredecessorAndSuccessorInBST(root1, -1); //ONLY SUCCESSOR IS POSSIBLE
        //......................................................................
//        Row: 424, 64
//        System.out.println("Longest Repeating Subsequence DP problem");
//        System.out.println("Longest repeating subsequence: "+obj.longestRepeatingSubsequence_Recursion("axxxy", 5)); //xx, xx
//        obj.longestRepeatingSubsequence_DP_Memoization("axxxy"); //xx, xx
        //......................................................................
//        Row: 441
//        System.out.println("Longest common substring DP problem");
//        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
//        obj.longestCommonSubstring_DP_Memoization("ABCDGH", "ACDGHR");
        //......................................................................
//        Row: 441
//        System.out.println("Maximum length of pair chain 2 approaches");
//        //https://leetcode.com/problems/maximum-length-of-pair-chain/
//        System.out.println("maximum length of pair chain DP approach: "+
//                obj.maximumLengthOfPairChain_DP_Approach(new int[][]{
//                    {1,2},
//                    {3,4},
//                    {2,3}}));
//        System.out.println("maximum length of pair chain Greedy approach: "+
//                obj.maximumLengthOfPairChain_Greedy_Approach(new int[][]{
//                    {1,2},
//                    {3,4},
//                    {2,3}}));
        //......................................................................
//        Row: 412
//        System.out.println("Binomial coefficient DP problem");
//        //https://www.geeksforgeeks.org/binomial-coefficient-dp-9/
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 2));
//        obj.findBinomialCoefficient_DP_Memoization(5, 2);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 6));
//        obj.findBinomialCoefficient_DP_Memoization(5, 6);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 5));
//        obj.findBinomialCoefficient_DP_Memoization(5, 5);
//        System.out.println("Binomial coefficient recursive way: "+obj.findBinomialCoefficient_Recursion(5, 0));
//        obj.findBinomialCoefficient_DP_Memoization(5, 0);
        //......................................................................
//        Row: 229
//        System.out.println("Count BST nodes that lie in the given range");
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.countNodesThatLieInGivenRange(root1, 1, 4);
//        obj.countNodesThatLieInGivenRange(root1, 6, 9);
        //......................................................................
//        Row: 235
//        System.out.println("Flatten BST to linked list (skewed tree)");
//        //https://leetcode.com/problems/flatten-binary-tree-to-linked-list/
//        //https://leetcode.com/problems/flatten-a-multilevel-doubly-linked-list/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.flattenBSTToLinkedList(root1);
//        //obj.flattenBSTToLinkedList_Recursion(root1);
        //......................................................................
//        Row: 158
//        System.out.println("Reverse a doubly linked list");
//        Node<Integer> node = new Node<>(3);
//        Node<Integer> next = new Node<>(4);
//        node.setNext(next);
//        next.setPrevious(node);
//        Node<Integer> nextToNext = new Node<>(5);
//        next.setNext(nextToNext);
//        nextToNext.setPrevious(next);
//        obj.reverseDoublyLinkedList(node);
        //......................................................................
//        Row: 18, 13
//        System.out.println("Kaden's algorithm approaches");
//        //https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
//        int[] a = new int[]{-2, -3, 4, -1, -2, 1, 5, -3};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{-1, -2, -3, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{-1, -2, 0, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
//        a = new int[]{1, 2, -3, -4};
//        System.out.println("Maximum sum subarray: "+ obj.kadaneAlgorithm(a));
//        obj.kadaneAlgorithm_PointingIndexes(a);
        //......................................................................
//        Row: 10
//        System.out.println("Move all negative elements to one side of array");
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-12, 11, -13, -5, 6, -7, 5, -3, -6});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-1, 2, -3, 4, 5, 6, -7, 8, 9});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{-1, -2, -3, -1, -10, -7});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{1, 2, 3, 1, 10, 7});
//        obj.moveNegativeElementsToOneSideOfArray(new int[]{1, -2, -3, -1, -10, -7});
        //......................................................................
//        Row: 11
//        System.out.println("Find union and intersection of two arrays");
//        obj.findUnionAndIntersectionOfTwoArrays(new int[]{1,2,3,4,5}, new int[]{1,2,3});
//        obj.findUnionAndIntersectionOfTwoArrays(new int[]{4,9,5}, new int[]{9,4,9,8,4});
        //......................................................................
//        Row: 12
//        System.out.println("Cyclically rotate element in array by 1");
//        //https://leetcode.com/problems/rotate-array/
//        obj.rotateArrayByK_BruteForce(new int[]{1, 2, 3, 4, 5}, 1);
//        obj.rotateArrayByK_BruteForce(new int[]{1, 2, 3, 4, 5}, 4);
//        obj.rotateArrayByK(new int[]{1, 2, 3, 4, 5}, 1);
//        obj.rotateArrayByK(new int[]{1, 2, 3, 4, 5}, 4);
        //......................................................................
//        Row: 14
//        System.out.println("Minimize the difference between the heights");
//        //https://www.geeksforgeeks.org/minimize-the-maximum-difference-between-the-heights/
//        obj.minimizeDifferenceBetweenHeights(new int[]{1, 5, 8, 10}, 2);
//        obj.minimizeDifferenceBetweenHeights(new int[]{4, 6}, 10);
        //......................................................................
//        Row: 191
//        System.out.println("Diagonal traversal of tree");
//        //https://www.geeksforgeeks.org/diagonal-traversal-of-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.diagonalTraversalOfTree(root1);
        //......................................................................
//        Row: 180
//        System.out.println("Diameter of tree DP on tree problem");
//        //https://leetcode.com/problems/diameter-of-binary-tree/
//        //https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/
//        //https://practice.geeksforgeeks.org/problems/diameter-of-binary-tree/1/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode(0));
//        root1.getLeft().setRight(new TreeNode(4));
//        root1.getLeft().getRight().setLeft(new TreeNode(3));
//        root1.getLeft().getRight().setRight(new TreeNode(5));
//        root1.setRight(new TreeNode(8));
//        root1.getRight().setLeft(new TreeNode(7));
//        root1.getRight().setRight(new TreeNode(9));
//        obj.diameterOfTree(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.getLeft().getRight().setRight(new TreeNode<>(5));
//        obj.diameterOfTree(root1);
        //......................................................................
//        Row: 238, 251
//        System.out.println("N meeting in a room/ Activity selection");
//        //https://practice.geeksforgeeks.org/problems/n-meetings-in-one-room-1587115620/1
//        int[] startTime = {1, 3, 0, 5, 8, 5};
//        int[] finishTime = {2, 4, 6, 7, 9, 9};
//        obj.nMeetingRooms_Greedy(startTime, finishTime);
        //......................................................................
//        Row: 357, 358
//        System.out.println("BFS/DFS directed graph");
//        //https://leetcode.com/problems/employee-importance/
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList());
//        adjList.add(2, Arrays.asList(4));
//        adjList.add(3, Arrays.asList());
//        adjList.add(4, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(5));
//        adjList.add(2, Arrays.asList(4));
//        adjList.add(3, Arrays.asList());
//        adjList.add(4, Arrays.asList(3));
//        adjList.add(5, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList(3));
//        adjList.add(3, Arrays.asList(4));
//        adjList.add(4, Arrays.asList(5));
//        adjList.add(5, Arrays.asList());
//        obj.graphBFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphBFSLevelOrderAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Graph(adjList.size(), adjList);
//        obj.graphDFSAdjList_Recursive_Graph(adjList.size(), adjList);
        //......................................................................
//        Row: 361, 275
//        System.out.println("Search in maze");
//        int[][] maze = new int[][]{
//            {1, 0, 0, 0},
//            {1, 1, 0, 1},
//            {1, 1, 0, 0},
//            {0, 1, 1, 1}
//        };
//        obj.findPathRatInMaze_Graph(maze, maze.length);
//        maze = new int[][]{
//            {1, 0, 0, 0},
//            {1, 1, 0, 1},
//            {1, 1, 0, 0},
//            {0, 1, 1, 0}
//        };
//        obj.findPathRatInMaze_Graph(maze, maze.length);
        //......................................................................
//        Row: 371
//        System.out.println("No. of Island");
//        //https://leetcode.com/problems/number-of-islands
//        //https://leetcode.com/problems/battleships-in-a-board/
//        //https://leetcode.com/problems/max-area-of-island/
//        //https://leetcode.com/problems/number-of-enclaves/
//        int[][] grid = {
//            {0, 1, 1, 1, 0, 0, 0},
//            {0, 0, 1, 1, 0, 1, 0}};
//        obj.numberOfIslands_Graph(grid);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Closed Islands");
//        //https://leetcode.com/problems/number-of-closed-islands/description/
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {1, 1, 1, 1, 1, 1, 1, 0},
//            {1, 0, 0, 0, 0, 1, 1, 0},
//            {1, 0, 1, 0, 1, 1, 1, 0},
//            {1, 0, 0, 0, 0, 1, 0, 1},
//            {1, 1, 1, 1, 1, 1, 1, 0}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {0, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 1, 1, 1, 0}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {1, 1, 1, 1, 1, 1, 1},
//            {1, 0, 0, 0, 0, 0, 1},
//            {1, 0, 1, 1, 1, 0, 1},
//            {1, 0, 1, 0, 1, 0, 1},
//            {1, 0, 1, 1, 1, 0, 1},
//            {1, 0, 0, 0, 0, 0, 1},
//            {1, 1, 1, 1, 1, 1, 1}});
//        obj.numberOfClosedIslands_Graph(new int[][]{
//            {0, 1, 1, 1, 1, 1, 1, 1},
//            {1, 0, 1, 0, 0, 0, 0, 1},
//            {1, 0, 0, 0, 0, 1, 0, 1},
//            {0, 1, 0, 0, 0, 1, 0, 1},
//            {1, 0, 0, 1, 0, 1, 0, 1},
//            {1, 1, 1, 1, 0, 0, 1, 1},
//            {1, 0, 0, 0, 0, 0, 1, 1},
//            {0, 1, 1, 1, 1, 1, 1, 1}});
        //......................................................................
//        Row: 348
//        System.out.println("Check if binary tree is heap (max heap)");
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(4));
//        obj.checkIfBinaryTreeIsMaxHeap(root);
//        root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(9)); 
//        obj.checkIfBinaryTreeIsMaxHeap(root);
//        root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(6));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(4)); 
//        root.getRight().setRight(new TreeNode<>(3)); 
//        obj.checkIfBinaryTreeIsMaxHeap(root);
        //......................................................................
//        Row: 91
//        System.out.println("Arrange all anagrams together");
//        obj.arrangeAllWordsAsTheirAnagrams(Arrays.asList("act", "god", "cat", "dog", "tac"));
        //......................................................................
//        Row: 90
//        System.out.println("Minimum character added at front of string to make it pallindrome/ Shortest pallindrome");
//        //https://leetcode.com/problems/shortest-palindrome
//        //https://leetcode.com/problems/longest-happy-prefix/
//        obj.characterAddedAtFrontToMakeStringPallindrome("ABC"); // 2 char = B,C (ex CBABC)
//        obj.characterAddedAtFrontToMakeStringPallindrome("ABA"); // 0 char already pallindrome
//        obj.shortestPallindrome("a");
//        obj.shortestPallindrome("aacecaaa");
//        obj.shortestPallindrome("abcd");
//        obj.shortestPallindrome("aaaa");
        //......................................................................
//        Row: 360
//        System.out.println("Detect cycle in undirected graph DFS");
//        //https://www.geeksforgeeks.org/detect-cycle-undirected-graph/
//        List<List<Integer>> adjList = new ArrayList<>(); //CYCLE //0 <--> 1 <--> 2 <--> 0
//        adjList.add(0, Arrays.asList(1, 2));
//        adjList.add(1, Arrays.asList(0, 2));
//        adjList.add(2, Arrays.asList(0, 1));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //NO CYCLE 0 <--> 1 <--> 2
//        adjList.add(0, Arrays.asList(1));       
//        adjList.add(1, Arrays.asList(0, 2));
//        adjList.add(2, Arrays.asList(1));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE //FAIL CASE // 0 <--> 1 //CASE OF DIRECTED GRAPH
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(0));
//        System.out.println("Is there a cycle in undirected graph: " + obj.detectCycleInUndirectedGraphDFS_Graph(adjList.size(), adjList));
        //......................................................................
//        Row: 368
//        System.out.println("Topological sort graph");    
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList());
//        adjList.add(1, Arrays.asList());
//        adjList.add(2, Arrays.asList(3));
//        adjList.add(3, Arrays.asList(1));
//        adjList.add(4, Arrays.asList(0,1));
//        adjList.add(5, Arrays.asList(0,2));
//        obj.topologicalSort_Graph(adjList.size(), adjList);
        //......................................................................
//        Row: 439
//        System.out.println("Minimum cost to fill the given bag");
//        //https://www.geeksforgeeks.org/minimum-cost-to-fill-given-weight-in-a-bag/
//        obj.minimumCostToFillGivenBag_DP_Memoization(new int[]{20, 10, 4, 50, 100}, 5);
//        obj.minimumCostToFillGivenBag_DP_Memoization(new int[]{-1, -1, 4, 3, -1}, 5);
        //......................................................................
//        Row: 22
//        System.out.println("Best time to buy and sell stock");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
//        obj.bestProfitToBuySellStock(new int[]{7,1,5,3,6,4});
//        obj.bestProfitToBuySellStock(new int[]{7,6,4,3,1});
        //......................................................................
//        System.out.println("Maximum profit by buying seling stocks,"
//                + "can hold stock atmost one but can buy/sell same stock in same day");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{2, 30, 15, 10, 8, 25, 80});
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{2, 30, 80, 10, 8, 25, 60});
//        obj.bestProfitToBuySellStockCanHoldAtmostOneStock(new int[]{3, 3, 5, 0, 0, 3, 1, 4});
        //......................................................................
//        Row: 31
//        System.out.println("Maximum profit by buying seling stocks atmost twice");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{2, 30, 15, 10, 8, 25, 80});
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{2, 30, 80, 10, 8, 25, 60});
//        obj.bestProfitToBuySellStockAtMostTwice(new int[]{3, 3, 5, 0, 0, 3, 1, 4});
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock IV");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
//        obj.buyAndSellStocksAtMostkTimes_Recursive_Memoization(new int[]{2, 4, 1}, 2);
//        obj.buyAndSellStocksAtMostkTimes_Recursive_Memoization(new int[]{3, 2, 6, 5, 0, 3}, 2);
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock with Cooldown");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/
//        obj.buySellStocksWithCooldown_Recursive_Memoization(new int[]{1, 2, 3, 0, 2});
//        obj.buySellStocksWithCooldown_Recursive_Memoization(new int[]{1});
        //......................................................................
//        Row: 31
//        System.out.println("Best Time to Buy and Sell Stock with Transaction Fee");
//        //https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/
//        obj.buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(new int[]{1, 3, 2, 8, 4, 9}, 2);
//        obj.buySellStocksWithTransactionFeeOnSell_Recursive_Memoization(new int[]{1, 3, 7, 5, 10, 3}, 3);
        //......................................................................
//        Row: 23
//        System.out.println("Find all pairs in array whose sum is given to K");
//        //https://www.geeksforgeeks.org/count-pairs-with-given-sum/
//        obj.countAllPairsInArrayThatSumIsK(new int[]{1, 5, 7, 1}, 6);
//        obj.countAllPairsInArrayThatSumIsK(new int[]{1, 1, 1, 1}, 2);
        //......................................................................
//        Row: 60
//        System.out.println("Check if one string is rotation of other string");
//        //https://www.geeksforgeeks.org/a-program-to-check-if-strings-are-rotations-of-each-other/
//        System.out.println("Check if one string is rotation: "+obj.checkIfOneStringRotationOfOtherString("AACD", "ACDA"));
        //......................................................................
//        Row: 312
//        System.out.println("Largest area of histogram");
//        //https://leetcode.com/problems/largest-rectangle-in-histogram
//        //https://www.geeksforgeeks.org/largest-rectangle-under-histogram/
//        obj.largestAreaInHistogram(new int[]{6, 2, 5, 4, 5, 1, 6});
//        obj.largestAreaInHistogram(new int[]{6,9,8});
        //......................................................................
//        Row: 418
//        System.out.println("Friends pairing DP problem");
//        //https://www.geeksforgeeks.org/friends-pairing-problem/
//        System.out.println("No. of ways friends can be paired recursion: "+obj.friendsPairingProblem_Recursion(4));
//        obj.friendsPairingProblem_DP_Memoization(4);
//        obj.friendsPairingProblem(4);
        //......................................................................
//        Row: 341
//        System.out.println("Merge k sorted arrays (heap)");
//        int[][] arr = new int[][]{
//            {1,2,3},
//            {4,5,6},
//            {7,8,9}
//        };
//        obj.mergeKSortedArrays_1(arr);
//        obj.mergeKSortedArrays_2(arr);
        //......................................................................
//        Row: 343
//        System.out.println("Kth largest sum from contigous subarray");
//        //https://www.geeksforgeeks.org/k-th-largest-sum-contiguous-subarray/
//        obj.kThLargestSumFromContigousSubarray(new int[]{10, -10, 20, -40}, 6);
//        obj.kThLargestSumFromContigousSubarray(new int[]{20, -5, -1}, 3);
        //......................................................................
//        Row: 329
//        System.out.println("Check if all levels in two trees are anagrams of each other");
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(7));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setLeft(new TreeNode<>(5));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(5));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(2));
//        root2.setRight(new TreeNode<>(3));
//        root2.getRight().setLeft(new TreeNode<>(4));
//        root2.getRight().setRight(new TreeNode<>(5));
//        root2.getRight().getRight().setLeft(new TreeNode<>(6));
//        root2.getRight().getRight().setRight(new TreeNode<>(7));
//        System.out.println("Check if all levels of two trees are anagrams 1: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_1(root1, root2));
//        System.out.println("Check if all levels of two trees are anagrams 2: "+
//                obj.checkIfAllLevelsOfTwoTreesAreAnagrams_2(root1, root2));
        //......................................................................
//        Row: 78
//        System.out.println("Count the presence of given string in char array");
//        //https://leetcode.com/problems/word-search/
//        char[][] charArr = new char[][]{
//            {'D','D','D','G','D','D'},
//            {'B','B','D','E','B','S'},
//            {'B','S','K','E','B','K'},
//            {'D','D','D','D','D','E'},
//            {'D','D','D','D','D','E'},
//            {'D','D','D','D','D','G'}
//           };
//        String str= "GEEKS";
//        obj.countOccurenceOfGivenStringInCharArray(charArr, str);
//        charArr = new char[][]{
//            {'B','B','M','B','B','B'},
//            {'C','B','A','B','B','B'},
//            {'I','B','G','B','B','B'},
//            {'G','B','I','B','B','B'},
//            {'A','B','C','B','B','B'},
//            {'M','C','I','G','A','M'}
//           };
//        str= "MAGIC";
//        obj.countOccurenceOfGivenStringInCharArray(charArr, str);
        //......................................................................
//        Row: 149
//        System.out.println("Intersection of two sorted linked list");
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        node.getNext().getNext().setNext(new Node<>(4));
//        node.getNext().getNext().getNext().setNext(new Node<>(5));
//        node.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        Node<Integer> node2 = new Node<>(2);
//        node2.setNext(new Node<>(4));
//        node2.getNext().setNext(new Node<>(4));
//        node2.getNext().getNext().setNext(new Node<>(6));
//        node2.getNext().getNext().getNext().setNext(new Node<>(7));
//        obj.intersectionOfTwoSortedLinkedList(node, node2);
        //......................................................................
//        Row: 26
//        System.out.println("Check if any sub array with sum 0 is present or not");
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{4, 2, -3, 1, 6}));
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{2, -3, 1}));
//        System.out.println("Is there with subarray sum 0 "+obj.checkIfSubarrayWithSum0(new int[]{4, 2, 0, -1}));
        //......................................................................
//        Row: 107, 16
//        System.out.println("Find repeating and missing in unsorted array");
//        //https://leetcode.com/problems/set-mismatch/
//        //https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/
//        //https://www.geeksforgeeks.org/find-a-repeating-and-a-missing-number/
//        obj.findRepeatingAndMissingInUnsortedArray_1(new int[]{7, 3, 4, 5, 5, 6, 2 });
//        obj.findRepeatingAndMissingInUnsortedArray_1(new int[]{3,1,3});
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{7, 3, 4, 5, 5, 6, 2 });
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{3,1,3});
//        obj.findRepeatingAndMissingInUnsortedArray_2(new int[]{4,3,2,7,8,2,3,1});
        //......................................................................
//        Row: 110
//        System.out.println("Check if any pair possible in an array having given difference");
//        System.out.println("Check if any pair is possible in the array having given diff: "+
//                obj.checkIfPairPossibleInArrayHavingGivenDiff(new int[]{5, 20, 3, 2, 5, 80}, 78));
//        System.out.println("Check if any pair is possible in the array having given diff: "+
//                obj.checkIfPairPossibleInArrayHavingGivenDiff(new int[]{90, 70, 20, 80, 50}, 45));
        //......................................................................
//        Row: 150
//        System.out.println("Intersection point in two given linked list (by ref linkage) 2 approach");
//        //https://leetcode.com/problems/intersection-of-two-linked-lists
//        Node<Integer> common = new Node<>(15);
//        common.setNext(new Node<>(30));
//        Node<Integer> node1 = new Node<>(3);
//        node1.setNext(new Node<>(9));
//        node1.getNext().setNext(new Node<>(6));
//        node1.getNext().getNext().setNext(common);
//        Node<Integer> node2 = new Node<>(10);
//        node2.setNext(common);
//        obj.intersectionPointOfTwoLinkedListByRef(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_HashBased(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_Iterative(node1, node2);
//        common = new Node<>(4);
//        common.setNext(new Node<>(5));
//        common.getNext().setNext(new Node<>(6));
//        node1 = new Node<>(1);
//        node1.setNext(new Node<>(2));
//        node1.getNext().setNext(new Node<>(3));
//        node1.getNext().getNext().setNext(common);
//        node2 = new Node<>(10);
//        node2.setNext(new Node<>(20));
//        node2.getNext().setNext(common);
//        obj.intersectionPointOfTwoLinkedListByRef(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_HashBased(node1, node2);
//        obj.intersectionPointOfTwoLinkedListByRef_Iterative(node1, node2);
        //......................................................................
//        Row: 359
//        System.out.println("Detect cycle in directed graph using DFS");
//        //https://www.geeksforgeeks.org/detect-cycle-in-a-graph/
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1)); //CYCLE 0 --> 1 --> 2 --> 0
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList(0));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //NO CYCLE // 0 --> 1 --> 2
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList());
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE // 0 --> 1 --> 0
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(0));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
//        adjList = new ArrayList<>(); //CYCLE // disjoint graph 0 --> 1 --> 2 | 3 --> 4 --> 5 --> 3
//        adjList.add(0, Arrays.asList(1));
//        adjList.add(1, Arrays.asList(2));
//        adjList.add(2, Arrays.asList());
//        adjList.add(3, Arrays.asList(4));
//        adjList.add(4, Arrays.asList(5));
//        adjList.add(5, Arrays.asList(3));
//        System.out.println("Is there a cycle in directed graph: " + obj.detectCycleInDirectedGraphDFS_Graph(adjList.size(), adjList));
        //......................................................................
//        Row: 363
//        System.out.println("Flood fill");
//        //https://leetcode.com/problems/flood-fill/
//        int[][] image = new int[][]{
//            {1,1,1},
//            {1,1,0},
//            {1,0,1}
//        };
//        obj.floodFill(image, 1, 1, 2);
//        image = new int[][]{
//            {0,0,0},
//            {0,0,0}
//        };
//        obj.floodFill(image, 0, 0, 2);
//        image = new int[][]{
//            {0,0,0,0,0},
//            {0,1,1,1,0},
//            {0,1,1,1,0},
//            {0,1,1,1,0},
//            {0,0,0,0,0},
//        };
//        obj.floodFill(image, 2, 2, 3);
//        image = new int[][]{
//            {0,0,0},
//            {0,1,1},
//        };
//        obj.floodFill(image, 1, 1, 1); //Edge case could have caused StackOverflowError, visited[][] helped
        //......................................................................
//        Row: 49
//        System.out.println("Maximum size of rectangle in binary matrix");
//        //https://leetcode.com/problems/maximal-rectangle
//        int[][] mat = new int[][]{
//            {0, 1, 1, 0},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 0, 0},};
//        obj.maxAreaOfRectangleInBinaryMatrix(mat);
//        mat = new int[][]{
//            {0, 0, 0, 0},
//            {0, 1, 1, 0},
//            {0, 1, 1, 0},
//            {0, 0, 0, 0},};
//        obj.maxAreaOfRectangleInBinaryMatrix(mat);
        //......................................................................
//        Row: 19
//        System.out.println("Merge intervals");
//        //https://leetcode.com/problems/merge-intervals/
//        //https://leetcode.com/problems/non-overlapping-intervals/
//        int[][] intervals = new int[][]{
//            {1, 3}, {2, 6}, {8, 10}, {15, 18}
//        };
//        obj.mergeIntervals_1(intervals);
//        obj.mergeIntervals_2(intervals);
//        intervals = new int[][]{
//            {1, 4}, {4, 5}
//        };
//        obj.mergeIntervals_1(intervals);
//        obj.mergeIntervals_2(intervals);
//        intervals = new int[][]{
//            {1, 4}, {0, 4}
//        };
//        obj.mergeIntervals_1(intervals);
//        obj.mergeIntervals_2(intervals);
//        intervals = new int[][]{
//            {1, 7}, {2, 5}
//        };
//        obj.mergeIntervals_1(intervals);
//        obj.mergeIntervals_2(intervals);
        //......................................................................
//        Row: 47
//        System.out.println("Row with maximum 1s in the matrix");
//        //https://www.geeksforgeeks.org/find-the-row-with-maximum-number-1s/
//        int[][] mat = new int[][]{
//            {0, 1, 1, 1},
//            {0, 0, 1, 1},
//            {1, 1, 1, 1},
//            {0, 0, 0, 0}
//        };
//        obj.maximumOnesInRowOfABinarySortedMatrix_1(mat);
//        obj.maximumOnesInRowOfABinarySortedMatrix_2(mat); //OPTIMISED
//        mat = new int[][]{
//            {0, 0, 0, 0}
//        };
//        obj.maximumOnesInRowOfABinarySortedMatrix_1(mat);
//        obj.maximumOnesInRowOfABinarySortedMatrix_2(mat); //OPTIMISED
        //......................................................................
//        Row: 45
//        System.out.println("Find a value in row wise sorted matrix");
//        //https://leetcode.com/problems/search-a-2d-matrix-ii/
//        int[][] mat = new int[][]{
//            {1, 3, 5, 7}, 
//            {10, 11, 16, 20}, 
//            {23, 30, 34, 60}
//        };
//        obj.findAValueInRowWiseSortedMatrix(mat, 13);
//        mat = new int[][]{
//            {1, 3, 5, 7}, 
//            {10, 11, 16, 20}, 
//            {23, 30, 34, 60}
//        };
//        obj.findAValueInRowWiseSortedMatrix(mat, 11);
        //......................................................................
//        Row: 65
//        System.out.println("Print all subsequences of the given string");
//        //https://www.geeksforgeeks.org/print-subsequences-string/
//        obj.printAllSubSequencesOfAString("abc");
//        obj.printAllSubSequencesOfAString("aaaa");
        //......................................................................
//        Row: 44
//        System.out.println("Spiral matrix traversal");
//        //https://leetcode.com/problems/spiral-matrix/description/
//        //https://leetcode.com/problems/spiral-matrix-ii/description/
//        //https://leetcode.com/problems/spiral-matrix-iv/description/
//        int[][] mat = new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12},
//            {13, 14, 15, 16}
//        };
//        obj.spiralMatrixTraversal(mat);
//        mat = new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12}
//        };
//        obj.spiralMatrixTraversal(mat);
//        System.out.println("Spiral matrix traversal three");
//        //https://leetcode.com/problems/spiral-matrix-iii/description/
//        obj.spriralMatrixTraversalThree(1, 4, 0, 0);
//        obj.spriralMatrixTraversalThree(5, 6, 1, 4);
        //......................................................................
//        Row: 156
//        System.out.println("Check singly linked list is pallindrome or not");
//        //https://leetcode.com/problems/palindrome-linked-list
//        Node<Integer> node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(1));
//        System.out.println("Is linked list pallindrome: "+obj.checkIfLinkedListPallindrome_1(node));
//        System.out.println("Is linked list pallindrome OPTIMISED: "+obj.checkIfLinkedListPallindrome_2(node));
//        node = new Node<>(1);
//        node.setNext(new Node<>(2));
//        node.getNext().setNext(new Node<>(3));
//        System.out.println("Is linked list pallindrome: "+obj.checkIfLinkedListPallindrome_1(node));
//        System.out.println("Is linked list pallindrome OPTIMISED: "+obj.checkIfLinkedListPallindrome_2(node));
        //......................................................................
//        Row: 71, 301
//        System.out.println("Balanced parenthesis evaluation");
//        //https://leetcode.com/problems/valid-parentheses/
//        System.out.println(obj.balancedParenthesisEvaluation("()"));
//        System.out.println(obj.balancedParenthesisEvaluation("({[]})"));
//        System.out.println(obj.balancedParenthesisEvaluation(")}]"));
//        System.out.println(obj.balancedParenthesisEvaluation("({)}"));
        //......................................................................
//        Row: 104
//        System.out.println("Square root of a number");
//        //https://leetcode.com/problems/sqrtx/
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(4));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(1));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(3));
//        System.out.println("Square root of a number precise double value: "+obj.squareRootOfANumber_PreciseDoubleValue(1.5));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(4));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(1));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(3));
//        System.out.println("Square root of a number rounded to int value: "+obj.squareRootOfANumber_RoundedIntValue(2));
        //......................................................................
//        Row: 211
//        System.out.println("Tree isomorphic (Flip Equivalent Binary Trees)");
//        //https://leetcode.com/problems/flip-equivalent-binary-trees/
//        //https://www.geeksforgeeks.org/tree-isomorphism-problem/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        TreeNode<Integer> root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.getLeft().setLeft(new TreeNode<>(4));
//        root2.setRight(new TreeNode<>(2));
//        System.out.println("Are two tres isomorphic: "+obj.areTwoTreeIsoMorphic(root1, root2));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root2 = new TreeNode<>(1);
//        root2.setLeft(new TreeNode<>(3));
//        root2.setRight(new TreeNode<>(2));
//        root2.getRight().setRight(new TreeNode<>(4));
//        System.out.println("Are two tres isomorphic: "+obj.areTwoTreeIsoMorphic(root1, root2));
        //......................................................................
//        Row: 210
//        System.out.println("Duplicate subtrees in a tree");
//        //https://leetcode.com/problems/find-duplicate-subtrees
//        //https://leetcode.com/problems/construct-string-from-binary-tree/
//        //https://www.geeksforgeeks.org/find-duplicate-subtrees/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(4));
//        root1.getRight().setRight(new TreeNode<>(4));
//        obj.findDuplicateSubtreeInAGivenTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all the nodes that are at K distance from the target node");
//        //https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(5));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setLeft(new TreeNode<>(0));
//        root1.getRight().setRight(new TreeNode<>(8));
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 5, 2);
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 3, 3);
//        obj.printAllTheNodesAtKDistanceFromTargetNode(root1, 6, 3);
        //......................................................................
//        Row: 39
//        System.out.println("Minimum no of operations required to make an array pallindrome");
//        obj.minOperationsToMakeArrayPallindrome(new int[]{10, 15, 10});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 4, 5, 9, 1});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 2, 3, 4});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1});
//        obj.minOperationsToMakeArrayPallindrome(new int[]{1, 2});
        //......................................................................
//        Row: 112
//        System.out.println("maximum sum such that no 2 elements are adjacent / Stickler thief DP problem");
//        //https://leetcode.com/problems/house-robber
//        int[] houses = new int[]{5, 5, 10, 100, 10, 5};
//        System.out.println("The maximum amount stickler thief can pick from alternate houses: " + obj.sticklerThief_Recursion(houses, houses.length));
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        houses = new int[]{1, 2, 3};
//        System.out.println("The maximum amount stickler thief can pick from alternate houses: " + obj.sticklerThief_Recursion(houses, houses.length));
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        houses = new int[]{5};
//        System.out.println("The maximum amount stickler thief can pick from alternate houses: " + obj.sticklerThief_Recursion(houses, houses.length));
//        System.out.println("The maximum amount stickler thief can pick from alternate houses (DP): "
//                + obj.sticklerThief_DP_Memoization(houses));
//        //https://leetcode.com/problems/house-robber-ii
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{2, 3, 2});
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{1, 2, 3});
//        obj.sticklerThiefTwo_DP_Memoization(new int[]{1, 2, 3, 1});
//        //https://leetcode.com/problems/house-robber-iii/
//        TreeNode<Integer> root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(1));
//        obj.sticklerThiefThree_DP_Memoization(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(1));
//        obj.sticklerThiefThree_DP_Memoization(root);
        //......................................................................
//        Row: 203
//        System.out.println("Check if given undirected graph is a binary tree or not");
//        //https://www.geeksforgeeks.org/check-given-graph-tree/#:~:text=Since%20the%20graph%20is%20undirected,graph%20is%20connected%2C%20otherwise%20not.
//        List<List<Integer>> adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0, 2)); // CYCLE 0 <--> 1 <--> 2
//        adjList.add(2, Arrays.asList(0, 1));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0, 4));
//        adjList.add(4, Arrays.asList(3, 5, 6)); // CYCLE 4 <--> 5 <--> 6 but not starting with 0
//        adjList.add(5, Arrays.asList(4, 6));
//        adjList.add(6, Arrays.asList(4, 5));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0));
//        adjList.add(4, Arrays.asList(5, 6)); // CYCLE 4 <--> 5 <--> 6 but 3 <--> 4 not connected
//        adjList.add(5, Arrays.asList(4, 6));
//        adjList.add(6, Arrays.asList(4, 5));
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
//        adjList = new ArrayList<>();
//        adjList.add(0, Arrays.asList(1, 2, 3));
//        adjList.add(1, Arrays.asList(0));
//        adjList.add(2, Arrays.asList(0));
//        adjList.add(3, Arrays.asList(0));
//        adjList.add(4, Arrays.asList()); // vertex 4 is not connected(3 <--> 4 not connected)
//        System.out.println("Is graph is binary tree: " + obj.checkIfGivenUndirectedGraphIsBinaryTree(adjList.size(), adjList));
        //......................................................................
//        Row: 174
//        System.out.println("First non repeating character from the stream of character");
//        obj.firstNonRepeatingCharacterFromStream("geeksforgeeksandgeeksquizfor");
//        obj.firstNonRepeatingCharacterFromStream("aaaaa");
//        obj.firstNonRepeatingCharacterFromStream("abcd");
//        obj.firstNonRepeatingCharacterFromStream("aabbccdd");
        //......................................................................
//        Row: 425
//        System.out.println("Longest increasing subsequence");
//        //https://leetcode.com/problems/longest-increasing-subsequence
//        //https://leetcode.com/problems/number-of-longest-increasing-subsequence
//        //https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/
//        int[] arr = new int[]{10, 22, 9, 33, 21, 50, 41, 60}; //LONGEST INC SEQ 10, 22, 33, 50, 60: length = 5
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        arr = new int[]{3, 10, 2, 1, 20};
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        arr = new int[]{3, 2};
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        arr = new int[]{0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15}; //LONGEST INC SEQ 0, 2, 6, 9, 13, 15: length 6
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        arr = new int[]{5,8,7,1,9}; //LONGEST INC SEQ 5,8,9 or 5,7,9
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
//        arr = new int[]{5}; 
//        System.out.println("Recursion Longest increasing subsequnec in the givve array: " + obj.longestIncreasingSubsequence_Recursion(arr, arr.length));
//        obj.longestIncreasingSubsequence_DP_Memoization(arr, arr.length);
        //......................................................................
//        Row: 425
//        System.out.println("Maximum sum increasing subsequence");
//        //https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/
//        //Max sum & also Incr subseq: [1,2,4,100] = 106
//        obj.maxSumIncreasingSubsequence_DP_Memoization(new int[]{1, 101, 2, 3, 100, 4, 5});
//        //Max sum & also Incr subseq: [3,10,20] = 33
//        obj.maxSumIncreasingSubsequence_DP_Memoization(new int[]{3, 10, 2, 1, 20});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pair of movie watching during a flight");
//        //problem: https://www.geeksforgeeks.org/amazon-interview-experience-sde-2-10/
//        //solution: https://leetcode.com/discuss/interview-question/313719/Amazon-Online-Assessment-2019-Tho-sum-closest/291502
//        obj.pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(new int[]{90, 85, 75, 60, 120, 150, 125}, 250);
//        obj.pairsOfMoviesCanBeWatchedDuringFlightDurationK_Greedy(new int[]{27, 1,10, 39, 12, 52, 32, 67, 76}, 77);
        //......................................................................
//        Row: 261
//        System.out.println("Choclate distributions");
//        //https://www.geeksforgeeks.org/chocolate-distribution-problem/
//        System.out.println("Min diff in distribution of choclates among the students: "
//                +obj.choclateDistribution_Greedy(new int[]{12, 4, 7, 9, 2, 23,
//                    25, 41, 30, 40, 28,
//                    42, 30, 44, 48, 43,
//                   50}, 7));
//        System.out.println("Min diff in distribution of choclates among the students: "
//                +obj.choclateDistribution_Greedy(new int[]{7, 3, 2, 4, 9, 12, 56}, 3));
        //......................................................................
//        Row: 123
//        System.out.println("Kth element in 2 sorted array 2 approaches");
//        //https://www.geeksforgeeks.org/k-th-element-two-sorted-arrays/
//        obj.kThElementInTwoSortedArrays_1(new int[]{2, 3, 6, 7, 9 }, new int[]{1, 4, 8, 10}, 5);
//        obj.kThElementInTwoSortedArrays_2(new int[]{2, 3, 6, 7, 9 }, new int[]{1, 4, 8, 10}, 5); //OPTIMISED
        //......................................................................
//        Row: 72
//        System.out.println("Word break 1 and 2");
//        //https://leetcode.com/problems/word-break/
//        Set<String> set = new HashSet<>();
//        set.addAll(Arrays.asList("mobile","samsung","sam","sung","man","mango","icecream","and",  
//                            "go","i","like","ice","cream"));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilikesamsung", set)); 
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilike", set));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("ilikedhokhla", set));
//        System.out.println("Word break possible recursive: "+obj.wordBreak_Recursive("andicecreamhill", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilikesamsung", set)); 
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilike", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("ilikedhokhla", set));
//        System.out.println("Word break possible dp: "+obj.wordBreak_DP_Problem("andicecreamhill", set));
//        //https://leetcode.com/problems/word-break-ii/
//        obj.wordBreakTwo_Backtracking("catsanddog", new String[]{"cat","cats","and","sand","dog"});
//        //one 'd' is missing here 
//        obj.wordBreakTwo_Backtracking("catsandog", new String[]{"cats","dog","sand","and","cat"});
//        obj.wordBreakTwo_Backtracking("aaaaaaa", new String[]{"aaaa","aa","a"});
        //......................................................................
//        Row: 245
//        System.out.println("Minimum platform needed");
//        //https://www.geeksforgeeks.org/minimum-number-platforms-required-railwaybus-station/
//        obj.minimumPlatformNeeded_BruteForce(new int[]{900, 940, 950, 1100, 1500, 1800}, 
//                new int[]{910, 1200, 1120, 1130, 1900, 2000});
//        obj.minimumPlatformNeeded_Greedy(new int[]{900, 940, 950, 1100, 1500, 1800}, 
//                new int[]{910, 1200, 1120, 1130, 1900, 2000});
        //......................................................................
//        Row: 242
//        System.out.println("Fractional knapsack");
//        //https://www.geeksforgeeks.org/fractional-knapsack-problem/
//        obj.fractionalKnapsack(new int[]{10,20,30}, new int[]{60, 100, 120}, 50);
//        obj.fractionalKnapsack(new int[]{10,20}, new int[]{60, 100}, 50);
//        obj.fractionalKnapsack(new int[]{60,70}, new int[]{60, 100}, 50);
        //......................................................................
//        Row: 326
//        System.out.println("Rotten oranges");
//        //https://leetcode.com/problems/rotting-oranges/
//        //Hash BASED: this approach rot all those oranges that are adjacent to a rotten orange in 1 unit of time
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {2, 1, 1}, {1, 1, 0}, {0, 1, 1}}));
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {2, 1, 1}, {0, 1, 1}, {1, 0, 1}}));
//        System.out.println("Rottening all the fresh oranges are possile in time: "
//                + obj.rottenOranges_HashBased(new int[][]{
//                    {0, 2}}));
//        //DFS BASED: this approach rot all the oranges that are connected to a rotten orange
//        //this follows flood fill way
//        obj.rottenOranges_DFS(new int[][]{
//            {2, 1, 1}, {1, 1, 0}, {0, 1, 1}});
//        obj.rottenOranges_DFS(new int[][]{
//            {2, 1, 1}, {0, 1, 1}, {1, 0, 1}});
//        obj.rottenOranges_DFS(new int[][]{
//            {0, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT : MY AMAZON ONLINE ASSESSMENT
//        System.out.println("Robot rodeo/ Robot bounded in the circle");
//        //https://leetcode.com/problems/robot-bounded-in-circle/
//        //https://leetcode.com/problems/path-crossing/
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GGLLGG"));
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GG"));
//        System.out.println("Is robot moving in circle: " + obj.robotRodeo("GL"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT : MY AMAZON ONLINE ASSESSMENT
//        System.out.println("Swaps required to sort the array");
//        //https://leetcode.com/discuss/interview-question/346621/Google-or-Phone-Screen-or-Min-swaps-to-sort-array
//        //https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{1, 5, 4, 3, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{7, 1, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{5, 1, 3, 2}));
//        System.out.println("Min swaps: " + obj.swapsRequiredToSortArray(new int[]{1, 2, 3, 4}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All path from source to target in directed acyclic graph");
//        //https://leetcode.com/problems/all-paths-from-source-to-target/
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {1, 2}, {3}, {3}, {}});
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {4, 3, 1}, {3, 2, 4}, {3}, {4}, {}});
//        obj.allPathFromSourceToTargetInDirectedAcyclicGraph(new int[][]{
//            {2}, {}, {1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest substring without repeating characters");
//        //https://leetcode.com/problems/longest-substring-without-repeating-characters/
//        obj.longestSubstringWithoutRepeatingChar("abcabcbb");
//        obj.longestSubstringWithoutRepeatingChar("bbbbb");
//        obj.longestSubstringWithoutRepeatingChar("pwwkew");
//        obj.longestSubstringWithoutRepeatingChar("");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum window substring containing all the character of string t in string s");
//        //https://leetcode.com/problems/minimum-window-substring/
//        obj.minimumWindowSubstring("", "");
//        obj.minimumWindowSubstring("ADOBECODEBANC", "ABC");
//        obj.minimumWindowSubstring("a", "a");
//        obj.minimumWindowSubstring("aa", "aa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete tree nodes and return forest");
//        //https://leetcode.com/problems/delete-nodes-and-return-forest/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().setRight(new TreeNode<>(4));
//        obj.deleteTreeNodesAndReturnForest(root1, new int[]{8, 1, 6});
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        obj.deleteTreeNodesAndReturnForest(root1, new int[]{3, 2});
        //......................................................................
//        Row: 321
//        System.out.println("LRU cache design");
//        List<String> operations = Arrays.asList("LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get");
//        List<List<Integer>> inputs = Arrays.asList(
//                Arrays.asList(2),
//                Arrays.asList(1, 1),
//                Arrays.asList(2, 2),
//                Arrays.asList(1),
//                Arrays.asList(3, 3),
//                Arrays.asList(2),
//                Arrays.asList(4, 4),
//                Arrays.asList(1),
//                Arrays.asList(3),
//                Arrays.asList(4)
//        );
//        obj.LRUCacheDesignImpl(operations, inputs);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Product of array excluding element itself");
//        obj.productOfArrayExcludingElementItself_BruteForce(new int[]{1, 2, 3, 4});
//        obj.productOfArrayExcludingElementItself_Optimised1(new int[]{1, 2, 3, 4});
//        obj.productOfArrayExcludingElementItself_Optimised2(new int[]{1, 2, 3, 4}); //TIME & SPACE OPTIMISED
        //......................................................................
//        Row: 196
//        System.out.println("Construct binary tree from inorder and preorder/ postorder");
//        //https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
//        //https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
//        obj.constructBinaryTreeFromInorderPreorderArray(new int[]{9, 3, 15, 20, 7}, new int[]{3, 9, 20, 15, 7});
//        obj.constructBinaryTreeFromInorderPostorderArray(new int[]{9, 3, 15, 20, 7}, new int[]{9,15,7,20,3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Construct BST from given preorder/postorder array");
//        //https://practice.geeksforgeeks.org/problems/preorder-to-postorder4423/1/
//        //PREORDER ARRAY
//        obj.constructBinarySearchTreeFromPreorderArray(new int[]{40, 30, 35, 80, 100});
//        obj.constructBinarySearchTreeFromPreorderArray(new int[]{40, 30, 32, 35, 80, 90, 100, 120});
//        //POSTORDER ARRAY
//        obj.constructBinarySearchTreeFromPostorderArray(new int[]{35, 30, 100, 80, 40});
//        obj.constructBinarySearchTreeFromPostorderArray(new int[]{35, 32, 30, 120, 100, 90, 80, 40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count all the occurences of anagrams of given pattern in the text SLIDING WINDOW");
//        //https://www.geeksforgeeks.org/amazon-interview-experience-set-324-sde2/
//        //https://leetcode.com/problems/permutation-in-string/
//        //https://leetcode.com/problems/find-all-anagrams-in-a-string/description/
//        obj.countAllOccurencesOfPatternInGivenString("forxxorfxdofr", "for");
//        obj.countAllOccurencesOfPatternInGivenString("foorxxorfxdofr", "for");
//        obj.countAllOccurencesOfPatternInGivenString("aabaabaa", "aaba");
//        obj.countAllOccurencesOfPatternInGivenString("aabaabaa", "xyz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert all the leaves of tree to DLL and remove leaves from tree");
//        //https://practice.geeksforgeeks.org/problems/leaves-to-dll/1/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
//        root = new TreeNode<>(1); //EDGE CASE
//        obj.leavesOfTreeToDoublyLinkedListAndRemoveLeaves(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum of all subarray in size of K");
//        //https://leetcode.com/problems/sliding-window-maximum/
//        //https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k/
//        //https://practice.geeksforgeeks.org/problems/maximum-of-all-subarrays-of-size-k3101/1/
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{1, 2, 3, 1, 4, 5, 2, 3, 6}, 3);
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{8, 5, 10, 7, 9, 4, 15, 12, 90, 13}, 4);
//        obj.maximumOfAllSubArrayOfSizeK(new int[]{1, 3, 1, 2, 0, 5}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check two N-ary trees are mirror image of each other");
//        //https://youtu.be/UGzXSDZv-SY
//        List<List<Integer>> tree1 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        List<List<Integer>> tree2 = Arrays.asList(
//                Arrays.asList(4, 3, 2, 1), //0
//                Arrays.asList(6, 5), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        System.out.println("Check if two N-ary trees are mirror of each other: "
//                + obj.checkIfTwoNAryTreeAreMirror(tree1, tree2));
//        tree1 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        //BOTH TREE ARE SAME NOW THIS SHOULD GIVE FALSE
//        tree2 = Arrays.asList(
//                Arrays.asList(1, 2, 3, 4), //0
//                Arrays.asList(5, 6), //1
//                Arrays.asList(7), //2
//                Arrays.asList(), //3
//                Arrays.asList(), //4
//                Arrays.asList(), //5
//                Arrays.asList(), //6
//                Arrays.asList() //7
//        );
//        System.out.println("Check if two N-ary trees are mirror of each other: "
//                + obj.checkIfTwoNAryTreeAreMirror(tree1, tree2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find minimum in rotated sorted array I/ II");
//        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{3, 4, 5, 1, 2}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{0, 1, 2, 3, 4, 5}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{4, 6, 8, 10, 1, 3}));
//        System.out.println("Find min in rotated sorted array : "
//                + obj.findMinimumInRotatedSortedArray(new int[]{5, 4, 3, 2, 1}));
//        //https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{1, 3, 5}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{2, 2, 2, 0, 1}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{3, 3, 1, 3}));
//        System.out.println("Find min in rotated sorted array two : "
//                + obj.findMinimumInRotatedSortedArrayTwo(new int[]{
//            3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 2, 2, 2, 2}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Deepest leaves sum in the tree");
//        //https://leetcode.com/problems/deepest-leaves-sum/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(6));
//        root.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.deepestLeavesSumOfTree_Iterative(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Average waiting time");
//        //https://leetcode.com/problems/average-waiting-time/
//        obj.averageWaitingTime(new int[][]{{1, 2}, {2, 5}, {4, 3}});
//        obj.averageWaitingTime(new int[][]{{5, 2}, {5, 4}, {10, 3}, {20, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition labels");
//        //https://leetcode.com/problems/partition-labels/
//        obj.partitionLabels("ababcbacadefegdehijhklij");
//        obj.partitionLabels("aabbaaccddcc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest repeating character replacement (SLIDING WINDOW)");
//        //https://leetcode.com/problems/longest-repeating-character-replacement/
//        obj.longestRepeatingCharacterByKReplacement("ABAB", 2);
//        obj.longestRepeatingCharacterByKReplacement("AABABBA", 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Recolors to Get K Consecutive Black Blocks");
//        //https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBBWWBBWBW", 7);
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBWBBBW", 2);
//        obj.minWhiteBlockChangeToBlackBlockInKLength("WBWW", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize the Confusion of an Exam");
//        //https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/
//        obj.maximizeConfusionInExam("TTFF", 2);
//        obj.maximizeConfusionInExam("TFFT", 1);
//        obj.maximizeConfusionInExam("TTFTTFTT", 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum time differenec");
//        //https://leetcode.com/problems/minimum-time-difference/
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("23:59","00:00")));
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("15:45","16:00")));
//        System.out.println("Min time difference: "+obj.minimumTimeDifference(Arrays.asList("00:00","23:59","00:00")));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Length of contigous array (subarray with equal no of 0 and 1)");
//        //https://leetcode.com/problems/contiguous-array/
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{0,1});
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{0,1,0,1,0});
//        obj.contigousArrayWithEqualZeroAndOne(new int[]{1,0,0,1,0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Generate balanced parenthesis");
//        //https://www.geeksforgeeks.org/print-all-combinations-of-balanced-parentheses/
//        //https://leetcode.com/problems/generate-parentheses/
//        obj.generateBalancedParenthesis(1);
//        obj.generateBalancedParenthesis(2);
//        obj.generateBalancedParenthesis(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find whether path exists");
//        //https://practice.geeksforgeeks.org/problems/find-whether-path-exist5238/1
//        System.out.println("Path exists: " + obj.checkIfPathExistsFromSourceToDestination(new int[][]{
//            {1, 3},
//            {3, 2}
//        }));
//        System.out.println("Path exists: " + obj.checkIfPathExistsFromSourceToDestination(new int[][]{
//            {3, 0, 3, 0, 0}, {3, 0, 0, 0, 3}, {3, 3, 3, 3, 3}, {0, 2, 3, 0, 0}, {3, 0, 0, 1, 3}
//        }));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Linked list in K groups alternatively");
//        //https://www.interviewbit.com/problems/reverse-alternate-k-nodes/
//        Node<Integer> head = new Node<>(3);
//        head.setNext(new Node<>(4));
//        head.getNext().setNext(new Node<>(7));
//        head.getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(15));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(61));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(16));
//        new LinkedListUtil<Integer>(obj.reverseLinkedListInKGroupsAlternatively(head, 3)).print();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest String in a tree starting from leaf to root");
//        //https://leetcode.com/problems/smallest-string-starting-from-leaf/
//        TreeNode<Integer> root = new TreeNode<>(0);
//        root.setLeft(new TreeNode<>(1));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.smallestStringInTreeFromLeafToRoot(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print the sum where each root-to-leaf path of tree represent a number");
//        //https://leetcode.com/problems/sum-root-to-leaf-numbers/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        obj.printSumWhereRootToLeafPathIsANumber(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(6));
//        root.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.printSumWhereRootToLeafPathIsANumber(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max sum path in two sorted arrays");
//        //https://www.geeksforgeeks.org/maximum-sum-path-across-two-arrays/
//        obj.maxSumPathInTwoSortedArrays(new int[]{2, 3, 7, 10, 12}, new int[]{1, 5, 7, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Asteroid collision");
//        //https://leetcode.com/problems/asteroid-collision/
//        obj.asteroidCollision(new int[] {5,10,-5});
//        obj.asteroidCollision(new int[] {8, -8});
//        obj.asteroidCollision(new int[] {10,2,-5});
//        obj.asteroidCollision(new int[] {3,2,1,-10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest pallindromic substring");
//        //https://leetcode.com/problems/longest-palindromic-substring/
//        //https://leetcode.com/problems/palindromic-substrings/
//        obj.longestPallindromicSubstring("racecar");
//        obj.longestPallindromicSubstring("babccaa");
//        obj.longestPallindromicSubstring("aabbaa");
//        obj.longestPallindromicSubstring("cbb");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Next greater element 2 (consider array to cyclic)");
//        //https://leetcode.com/problems/next-greater-element-ii/
//        obj.nextGreaterElement2_CyclicArray(new int[]{1, 2, 1});
//        obj.nextGreaterElement2_CyclicArray(new int[]{5, 4, 3, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Valid sudoku");
//        //https://leetcode.com/problems/valid-sudoku/
//        //https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/
//        obj.validSudoku(new String[][]{
//            {"5", "3", ".", ".", "7", ".", ".", ".", "."}, 
//            {"6", ".", ".", "1", "9", "5", ".", ".", "."}, 
//            {".", "9", "8", ".", ".", ".", ".", "6", "."}, 
//            {"8", ".", ".", ".", "6", ".", ".", ".", "3"}, 
//            {"4", ".", ".", "8", ".", "3", ".", ".", "1"}, 
//            {"7", ".", ".", ".", "2", ".", ".", ".", "6"}, 
//            {".", "6", ".", ".", ".", ".", "2", "8", "."}, 
//            {".", ".", ".", "4", "1", "9", ".", ".", "5"}, 
//            {".", ".", ".", ".", "8", ".", ".", "7", "9"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Diagonal matrix traversal");
//        //https://www.geeksforgeeks.org/print-matrix-diagonal-pattern/
//        obj.diagonalMatrixTraversal(new int[][]{
//            {1, 2, 3},
//            {4, 5, 6},
//            {7, 8, 9}});
//        obj.diagonalMatrixTraversal(new int[][]{
//            {1, 2, 3},
//            {4, 5, 6}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Score of parenthesis");
//        //https://leetcode.com/problems/score-of-parentheses
//        obj.scoreOfParenthesis("()");
//        obj.scoreOfParenthesis("()()");
//        obj.scoreOfParenthesis("(())");
//        obj.scoreOfParenthesis("(()())");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("minimun remove of character to make valid parenthesis");
//        //https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
//        obj.minimumCharRemovalToMakeValidParenthesis("lee(t(c)o)de)");
//        obj.minimumCharRemovalToMakeValidParenthesis("a)b(c)d");
//        obj.minimumCharRemovalToMakeValidParenthesis(")))(((");
//        obj.minimumCharRemovalToMakeValidParenthesis("()()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Repeated substring pattern");
//        //https://leetcode.com/problems/repeated-substring-pattern/
//        System.out.println("Repeated substring pattern possible: "+obj.repeatedSubstringPattern("abab"));
//        System.out.println("Repeated substring pattern possible: "+obj.repeatedSubstringPattern("aba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find median in data stream");
//        //https://leetcode.com/problems/find-median-from-data-stream/
//        obj.findMedianInDataStream(new int[] {5, 15, 1, 3, 2, 8, 7, 9, 10, 6, 11, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Median of Two Sorted Arrays");
//        //https://leetcode.com/problems/median-of-two-sorted-arrays/
//        obj.medianOfTwoSortedArrays(new int[]{1,3}, new int[]{2});
//        obj.medianOfTwoSortedArrays(new int[]{1,3}, new int[]{2,4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pairs of Songs With Total Durations Divisible by 60");
//        //https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
//        obj.numPairsDivisibleBy60(new int[]{30,20,150,100,40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count inversion in the arrays (using modified merge sort)");
//        obj.countInversion(new int[]{1, 20, 6, 4, 5});
//        obj.countInversion(new int[]{1, 3, 2}); 
//        obj.countInversion(new int[]{7,1,2});
//        obj.countInversion(new int[]{5,3,2,4,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum window length where subarray is greater OR equal to target sum");
//        //https://leetcode.com/problems/minimum-size-subarray-sum/
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {2,3,1,2,4,3}, 7);
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {1,4,4}, 4);
//        obj.minimumWindowSubarrayForTargetSumK(new int[] {1,1,1,1,1,1,1,1}, 11);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length of repeated subarray (DP PROBLEM)");
//        //https://leetcode.com/problems/maximum-length-of-repeated-subarray/
//        obj.maximumLengthOfRepeatedSubarray_DP_Memoization(new int[]{1,2,3,2,1}, new int[]{3,2,1,4,7});
//        obj.maximumLengthOfRepeatedSubarray_DP_Memoization(new int[]{0,1,1,1,1,1}, new int[]{0,1,0,1,0,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fix two swapped nodes of the BST");
//        //https://www.geeksforgeeks.org/fix-two-swapped-nodes-of-bst/
//        //https://leetcode.com/problems/recover-binary-search-tree/
//        TreeNode<Integer> root = new TreeNode<>(10);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(20)); //FIRST
//        root.setRight(new TreeNode<>(8)); //LAST
//        obj.fixTwoSwappedNodesInBST(root);
//        root = new TreeNode<>(3); //MID
//        root.setLeft(new TreeNode<>(5)); //FIRST
//        obj.fixTwoSwappedNodesInBST(root);
//        root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(5)); //FIRST
//        root.setRight(new TreeNode<>(1)); //LAST
//        obj.fixTwoSwappedNodesInBST(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge two binary trees");
//        //https://leetcode.com/problems/merge-two-binary-trees/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(2));
//        TreeNode<Integer> root2 = new TreeNode<>(2);
//        root2.setLeft(new TreeNode<>(1));
//        root2.getLeft().setRight(new TreeNode<>(4));
//        root2.setRight(new TreeNode<>(3));
//        root2.getRight().setRight(new TreeNode<>(7));
//        obj.mergeTwoBinaryTree(root1, root2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Flip M 0s in binary array and find maximum length of consecutive 1s");
//        //https://leetcode.com/problems/max-consecutive-ones-iii/
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{1, 0, 1}, 1);
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{1, 0, 0, 1, 1, 0, 1, 0, 1, 1}, 3);
//        obj.flipMZerosFindMaxLengthOfConsecutiveOnes(new int[]{0,0,0,}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Local minima and local maxima(Peak element) (BINARY SEARCH)");
//        //https://www.geeksforgeeks.org/find-local-minima-array/
//        //https://leetcode.com/problems/find-peak-element/        
//        obj.findLocalMinima(new int[]{1, 2, 3});
//        obj.findLocalMinima(new int[]{23, 8, 15, 2, 3});
//        obj.findLocalMinima(new int[]{9, 6, 3, 14, 5, 7, 4});
//        obj.findLocalMinima(new int[]{3, 2, 1});
//        //MAXIMA OR PEAK ELEMENT
//        obj.findLocalMaxima(new int[]{3, 2, 1});
//        obj.findLocalMaxima(new int[]{1, 2, 3});
//        obj.findLocalMaxima(new int[]{9, 6, 3, 14, 5, 7, 4});
//        obj.findLocalMaxima(new int[]{23, 8, 15, 2, 3});
//        obj.findLocalMaxima(new int[]{23, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reorder linked list");
//        //https://leetcode.com/problems/reorder-list/
//        Node<Integer> head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.reorderLinkedList(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove K digits and create the smallest num");
//        //https://leetcode.com/problems/remove-k-digits/
//        obj.removeKDigitsToCreateSmallestNumber("1432219", 3);
//        obj.removeKDigitsToCreateSmallestNumber("10", 2);
//        obj.removeKDigitsToCreateSmallestNumber("10200", 1);
//        obj.removeKDigitsToCreateSmallestNumber("4321", 2);
//        obj.removeKDigitsToCreateSmallestNumber("1234", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the most competetive subsequence of length K in the given array");
//        //https://leetcode.com/problems/find-the-most-competitive-subsequence/
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{3,5,2,6}, 2);
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{2,4,3,3,5,4,9,6}, 4);
//        obj.findTheMostCompetetiveSubsequenceOfSizeKFromArray(new int[]{5,4,3,2,1}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Odd even linked list");
//        //https://leetcode.com/problems/odd-even-linked-list/
//        Node<Integer> head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(head);
//        head = new Node<Integer>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.rearrangeLinkedListAsOddIndexFirstAndEvenIndexAtEnd(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of ways to create BST and BT with given N (req info: Catalan number series)");
//        //https://leetcode.com/problems/unique-binary-search-trees/
//        //https://www.geeksforgeeks.org/total-number-of-possible-binary-search-trees-with-n-keys/#
//        obj.numberOfWaysToCreateBSTAndBTWithGivenN(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if binary tree is complete binary tree or not");
//        //https://leetcode.com/problems/check-completeness-of-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6)); //COMPLETE BINARY TREE
//        System.out.println("Is tree complete binary tree: "+obj.checkIfBinaryTreeIsCompleteOrNot(root1));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(7)); //NOT-COMPLETE BINARY TREE
//        System.out.println("Is tree complete binary tree: "+obj.checkIfBinaryTreeIsCompleteOrNot(root1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("maximum width of binary tree");
//        //https://leetcode.com/problems/maximum-width-of-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.getLeft().setRight(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setRight(new TreeNode<>(9));
//        obj.maximumWidthOfBinaryTree(root1);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(5));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(6));
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setRight(new TreeNode<>(9));
//        root1.getRight().getRight().setRight(new TreeNode<>(7));
//        obj.maximumWidthOfBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of elements in matrix except given row and col");
//        //https://www.geeksforgeeks.org/find-sum-of-all-elements-in-a-matrix-except-the-elements-in-given-row-andor-column-2/
//        int[][] rowAndCol = new int[][]{
//            {0, 0},
//            {1, 1},
//            {0, 1}
//        };
//        int[][] matrix = new int[][]{
//            {1, 1, 2},
//            {3, 4, 6},
//            {5, 3, 2}
//        };
//        obj.sumOfElementsInMatrixExceptGivenRowAndCol(matrix, rowAndCol);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count number elements from second array less than or equal to element in first array");
//        //https://www.geeksforgeeks.org/element-1st-array-count-elements-less-equal-2nd-array/
//        obj.countElementsFromSecondArrayLessOrEqualToElementInFirstArray(
//                new int[]{1, 2, 3, 4, 7, 9},
//                new int[]{0, 1, 2, 1, 1, 4});
//        obj.countElementsFromSecondArrayLessOrEqualToElementInFirstArray(
//                new int[]{5, 10, 2, 6, 1, 8, 6, 12},
//                new int[]{6, 5, 11, 4, 2, 3, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if input binary number stream is divisible by N");
//        //https://leetcode.com/problems/binary-prefix-divisible-by-5/
//        //https://www.geeksforgeeks.org/check-divisibility-binary-stream/
//        obj.checkBinaryNumberStreamIsDivisibleByN(new int[]{1,0,1,0,1}, 3);
//        obj.checkBinaryNumberStreamIsDivisibleByN(new int[]{1,0,1}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert number to words");
//        //https://www.geeksforgeeks.org/program-to-convert-a-given-number-to-words-set-2/
//        obj.convertNumberToWords(438237764);
//        obj.convertNumberToWords(0);
//        obj.convertNumberToWords(101);
//        obj.convertNumberToWords(1000);
//        obj.convertNumberToWords(222);
//        obj.convertNumberToWords(999999999);
//        obj.convertNumberToWords(1234567891);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum swaps to form greater number by swaping 2 digit atmost ");
//        //https://leetcode.com/problems/maximum-swap/
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(2736);
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(9973);
//        obj.swapTwoDigitAtMostToFormAGreaterNumber_Greedy(1002);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String comparision after processing backspace character");
//        //https://leetcode.com/problems/backspace-string-compare/
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("ab#c", "ad#c"));
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("a#c", "b"));
//        System.out.println("Are two strings same after processing backspace char: "+
//                obj.stringComparisionAfterProcessingBackspaceChar("a#", "b#"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find negative number in window size of K from the array");
//        //https://practice.geeksforgeeks.org/problems/first-negative-integer-in-every-window-of-size-k/0
//        obj.firstNegativeNumberInWindowKFromArray(new int[]{-8, 2, 3, -6, 10}, 2);
//        obj.firstNegativeNumberInWindowKFromArray(new int[]{12, -1, -7, 8, -15, 30, 16, 28}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String zig zag");
//        //https://leetcode.com/problems/zigzag-conversion/
//        obj.stringZigZag("PAYPALISHIRING", 3);
//        obj.stringZigZag("PAYPALISHIRING", 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Can we divide the given array into consecutive sequence of length W");
//        //https://leetcode.com/problems/hand-of-straights/
//        //https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers
//        System.out.println("Given array can be divided into consecutive groups of length W: "
//                +obj.handOfStraight(new int[]{1,2,3,6,2,3,4,7,8}, 3));
//        System.out.println("Given array can be divided into consecutive groups of length W: "
//                + obj.handOfStraight(new int[]{1,2,3,4,5}, 4));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Can we visit all the rooms");
//        //https://leetcode.com/problems/keys-and-rooms/
//        List<List<Integer>> rooms = Arrays.asList(
//                Arrays.asList(1),
//                Arrays.asList(2),
//                Arrays.asList(3),
//                Arrays.asList()
//        );
//        System.out.println("Can we visit all the rooms: "+obj.canWeVisitAllTheRooms_Graph(rooms));
//        rooms = Arrays.asList(
//                Arrays.asList(1, 3),
//                Arrays.asList(3, 0, 1),
//                Arrays.asList(2),
//                Arrays.asList(0)
//        );
//        System.out.println("Can we visit all the rooms: "+obj.canWeVisitAllTheRooms_Graph(rooms));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("number of Steps taken to Open the lock");
//        //https://leetcode.com/problems/open-the-lock/
//        String[] deadends = new String[]{"0201", "0101", "0102", "1212", "2002"};
//        String target = "0202";
//        System.out.println("Steps required: " + obj.stepsToOpenTheLock(deadends, target));
//        deadends = new String[]{"8887", "8889", "8878", "8898", "8788", "8988", "7888", "9888"};
//        target = "8888";
//        System.out.println("Steps required: " + obj.stepsToOpenTheLock(deadends, target));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Squares of sorted array");
//        //https://leetcode.com/problems/squares-of-a-sorted-array/
//        obj.sortedSquaresOfSortedArray_1(new int[]{-4, -1, 0, 3, 10});
//        obj.sortedSquaresOfSortedArray_2(new int[]{-4, -1, 0, 3, 10}); //OPTIMISED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Move zeros to end");
//        //https://leetcode.com/problems/move-zeroes/
//        obj.moveZeroesToEnd(new int[]{0, 1, 0, 3, 12});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distribute coins in binary tree");
//        //https://leetcode.com/problems/distribute-coins-in-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(3);
//        root.setLeft(new TreeNode<>(0));
//        root.setRight(new TreeNode<>(0));
//        obj.distributeCoinsInBinaryTree(root);
//        root = new TreeNode<>(0);
//        root.setLeft(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(0));
//        obj.distributeCoinsInBinaryTree(root);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(0));
//        root.setRight(new TreeNode<>(2));
//        obj.distributeCoinsInBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Container with most water");
//        //https://leetcode.com/problems/container-with-most-water/
//        obj.containerWithMostWater(new int[]{1,8,6,2,5,4,8,3,7});
//        obj.containerWithMostWater(new int[]{5,6,8,9,8,6,5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if binary tree is odd-even binary tree");
//        //https://leetcode.com/problems/even-odd-tree
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(10));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(7));
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(11)); //LEVEL - 1 (ODD) data == ODD which is FALSE
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(7));
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(10)); 
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(12));
//        root.getLeft().getLeft().setRight(new TreeNode<>(8));
//        root.setRight(new TreeNode<>(4));
//        root.getRight().setLeft(new TreeNode<>(3)); //LEVEL - 2 (EVEN) nodes at this level should be strictly incr but level 2[3,3, 9] FALSE
//        root.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(9));
//        root.getRight().getRight().setRight(new TreeNode<>(2));
//        System.out.println("Check is binary tree is odd-even tree: "+obj.checkIfBinaryTreeIsOddEvenTree(root));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Substring With K Unique Characters (SLIDING WINDOW)");
//        //https://practice.geeksforgeeks.org/problems/longest-k-unique-characters-substring0853/1
//        obj.longestSubstringWithKUniqueCharacter("aabacbebebe", 3);
//        obj.longestSubstringWithKUniqueCharacter("aabcaccbeb", 3);
//        obj.longestSubstringWithKUniqueCharacter("aaaa", 2);
//        obj.longestSubstringWithKUniqueCharacter("hq", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest Substring With K Unique Characters (SLIDING WINDOW)");
//        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
//        obj.smallestSubstringWithKUniqueCharacter("aabacbebebe", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aabcaccbeb", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aaaa", 2);
//        obj.smallestSubstringWithKUniqueCharacter("hq", 2);
//        obj.smallestSubstringWithKUniqueCharacter("aabab", 3);
//        obj.smallestSubstringWithKUniqueCharacter("aaabbbccc", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest Subarray With K Distinct Elements (SLIDING WINDOW)");
//        //https://www.codingninjas.com/codestudio/problems/smallest-subarray-with-k-distinct-elements_630523?leftPanelTab=0
//        obj.smallestSubarrayWithKDistinctElements(new int[]{1, 1, 2, 1, 2}, 3);
//        obj.smallestSubarrayWithKDistinctElements(new int[]{4, 2, 2, 2, 3, 4, 4, 3}, 3);
//        obj.smallestSubarrayWithKDistinctElements(new int[]{1,1,1,2,2,2,3,3,3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest missing positive missing number");
//        //https://practice.geeksforgeeks.org/problems/smallest-positive-missing-number-1587115621/1#
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{1, 2, 3, 4, 5}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{0, -10, 1, 3, -20}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{}));
//        System.out.println("Smallest missing positive number: " + obj.smallestMissingPositiveNumber(new int[]{-2,2,7,1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sort the matrix diaonally");
//        //https://leetcode.com/problems/sort-the-matrix-diagonally
//        int[][] mat = new int[][]{{3, 3, 1, 1}, {2, 2, 1, 2}, {1, 1, 1, 2}};
//        obj.sortTheMatrixDiagonally(mat);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray sum equals K");
//        //https://leetcode.com/problems/subarray-sum-equals-k/
//        obj.subarraySumEqualsK(new int[]{1, 1, 1}, 2);
//        obj.subarraySumEqualsK(new int[]{1, 2, 3}, 3);
//        obj.subarraySumEqualsK(new int[]{1}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Sub-Array with Sum K");
//        //https://www.geeksforgeeks.org/longest-sub-array-sum-k/
//        //https://practice.geeksforgeeks.org/problems/longest-sub-array-with-sum-k0809/1
//        obj.longestSubarrayWithSumEqualsK(new int[]{10, 5, 2, 7, 1, 9}, 15);
//        obj.longestSubarrayWithSumEqualsK(new int[]{-1, 2, 3}, 6);
//        obj.longestSubarrayWithSumEqualsK(new int[]{-13, 0, 6, 15, 16, 2, 15, -12, 17, -16, 0, -3, 19, -3, 2, -9, -6}, 15);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Continuous Subarray Sum");
//        //https://leetcode.com/problems/continuous-subarray-sum/
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 4, 6, 7}, 6));
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 6, 4, 7}, 6));
//        System.out.println("Continous subarray sum of size atleast 2 divisible by k: "
//                + obj.continousSubarraySum(new int[]{23, 2, 6, 4, 7}, 13));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Nice Pairs in an Array");
//        //https://leetcode.com/problems/count-nice-pairs-in-an-array/
//        obj.countNicePairsInArray(new int[]{42, 11, 1, 97});
//        obj.countNicePairsInArray(new int[]{13, 10, 35, 24, 76});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Bad Pairs");
//        //https://leetcode.com/problems/count-number-of-bad-pairs/
//        obj.countNumberOfBadPairs(new int[]{4, 1, 3, 3});
//        obj.countNumberOfBadPairs(new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Pairs of Interchangeable Rectangles");
//        //https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/
//        obj.numberOfPairsOfInterchangeableRectangles(new int[][]{{4, 8}, {3, 6}, {10, 20}, {15, 30}});
//        obj.numberOfPairsOfInterchangeableRectangles(new int[][]{{4, 5}, {7, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Nice Subarrays");
//        //https://leetcode.com/problems/count-number-of-nice-subarrays/
//        obj.numberOfSubarraysWithKOddNums(new int[]{1, 1, 2, 1, 1}, 3);
//        obj.numberOfSubarraysWithKOddNums(new int[]{2, 4, 6}, 1);
//        obj.numberOfSubarraysWithKOddNums(new int[]{2, 2, 2, 1, 2, 2, 1, 2, 2, 2}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray sum divisible by K");
//        //https://leetcode.com/problems/subarray-sums-divisible-by-k/
//        obj.subarraySumDivisibleByK(new int[]{4, 5, 0, -2, -3, 1}, 5);
//        obj.subarraySumDivisibleByK(new int[]{-1,2,9}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest subarray with sum divisible by K");
//        //https://practice.geeksforgeeks.org/problems/longest-subarray-with-sum-divisible-by-k1259/1?utm_source=gfg&utm_medium=article&utm_campaign=bottom_sticky_on_article
//        obj.longestSubarraySumDivisibleByK(new int[]{2, 7, 6, 1, 4, 5}, 3);
//        obj.longestSubarraySumDivisibleByK(new int[]{-2, 2, -5, 12, -11, -1, 7}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Subarray product less than K (SLIDING WINDOW)");
//        //https://leetcode.com/problems/subarray-product-less-than-k/
//        obj.subarrayProductLessThanK(new int[]{10, 5, 2, 6}, 100);
//        obj.subarrayProductLessThanK(new int[]{1, 2, 3}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Make Sum Divisible by k");
//        //https://leetcode.com/problems/make-sum-divisible-by-p/description/
//        obj.makeSumDivisibleByK(new int[]{3, 1, 4, 2}, 6);
//        obj.makeSumDivisibleByK(new int[]{6, 3, 5, 2}, 9);
//        obj.makeSumDivisibleByK(new int[]{1, 2, 3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked list component");
//        //https://leetcode.com/problems/linked-list-components/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        head.getNext().getNext().setNext(new Node<>(3));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.linkedListComponent(head, new int[]{0,3,1,4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked list partition list");
//        //https://leetcode.com/problems/partition-list
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(4));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        obj.partitionList(head, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max sum in any path of the tree");
//        //https://leetcode.com/problems/binary-tree-maximum-path-sum/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        obj.maxSumInAnyPathOfTree(root);
//        root = new TreeNode<>(42);
//        root.setLeft(new TreeNode<>(-2));
//        root.setRight(new TreeNode<>(2));
//        obj.maxSumInAnyPathOfTree(root);
//        root = new TreeNode<>(-10);
//        root.setLeft(new TreeNode<>(9));
//        root.setRight(new TreeNode<>(20));
//        root.getRight().setLeft(new TreeNode<>(15));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.maxSumInAnyPathOfTree(root); //MAX SUM accross path: 15<->20<->7
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("longest length of edge between tree nodes having same values");
//        //https://leetcode.com/problems/longest-univalue-path/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(5));
//        obj.longestEdgeLengthBetweenTreeNodesWithSameValue(root); //EDGE b/w 4<->4<->4
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Global and local inversions");
//        //https://leetcode.com/problems/global-and-local-inversions/
//        System.out.println("Are counts for global and local inversion are equal: "
//                + obj.globalAndLocalInversionCountAreEqual(new int[]{1, 0, 2}));
//        System.out.println("Are counts for global and local inversion are equal: "
//                + obj.globalAndLocalInversionCountAreEqual(new int[]{1, 2, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pascal triangle");
//        //https://leetcode.com/problems/pascals-triangle/
//        obj.printPascalTriangle_SimpleAddition(6);
//        obj.printPascalTriangle_BinomialCoeff(6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest number from the given set of number/ Smallest Value of the Rearranged Number");
//        //https://leetcode.com/problems/largest-number/
//        obj.largestNumberFromSetOfNumbers(new String[]{"3", "30", "34", "5", "9"});
//        obj.largestNumberFromSetOfNumbers(new String[]{"54", "546", "548", "60"});
//        obj.largestNumberFromSetOfNumbers(new String[]{"0", "0"});
//        //https://leetcode.com/problems/smallest-value-of-the-rearranged-number
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(310));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(-7650));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(-12345));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(54321));
//        System.out.println("Smallest number from the given num: " + obj.smallestNumber(54321000));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("String compression");
//        //https://leetcode.com/problems/string-compression/
//        obj.stringCompression(new char[]{'a', 'a', 'b', 'b', 'c', 'c'});
//        obj.stringCompression(new char[]{'a'});
//        obj.stringCompression(new char[]{'a', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'b'});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rotate linked list K times");
//        //https://leetcode.com/problems/rotate-list/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        obj.rotateLinkedListKTimes(head, 4);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rotateLinkedListKTimes(head, 2);
//        //same linked list approach 2
//        head = new Node<>(0);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        obj.rotateLinkedListKTimes2(head, 4);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        obj.rotateLinkedListKTimes2(head, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sort the linked list in relative order of the given arr");
//        //https://leetcode.com/problems/relative-sort-array/
//        //https://www.geeksforgeeks.org/sort-linked-list-order-elements-appearing-array/
//        Node<Integer> head = new Node<>(3);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(5));
//        head.getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        obj.sortLinkedListInRelativeOrderOfArr(head, new int[]{5, 1, 3, 2, 8});
//        head = new Node<>(3);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(5));
//        head.getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(1));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(19)); //EXTRA NOT IN arr[]
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(7)); //EXTRA NOT IN arr[]
//        obj.sortLinkedListInRelativeOrderOfArr(head, new int[]{5, 1, 3, 2, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count nodes in complete binary tree");
//        //https://leetcode.com/problems/count-complete-tree-nodes/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Nnumber of nodes in complete binary tree: " + obj.countNodesInCompleteBinaryTree(root1));
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        System.out.println("Nnumber of nodes in complete binary tree: " + obj.countNodesInCompleteBinaryTree(root1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All source to destination path with weight sum in N-Ary tree ");
//        //https://www.geeksforgeeks.org/amazon-interview-experience-set-424-sde-2/
//        List<List<VertexWithWeight>> adjList = Arrays.asList(
//                /*0*/Arrays.asList(new VertexWithWeight(1, 10),
//                        new VertexWithWeight(2, 50),
//                        new VertexWithWeight(3, 20)),
//                /*1*/ Arrays.asList(new VertexWithWeight(0, 10),
//                        new VertexWithWeight(4, 30),
//                        new VertexWithWeight(5, 40)),
//                /*2*/ Arrays.asList(new VertexWithWeight(0, 50)),
//                /*3*/ Arrays.asList(new VertexWithWeight(0, 20)),
//                /*4*/ Arrays.asList(new VertexWithWeight(1, 30)),
//                /*5*/ Arrays.asList(new VertexWithWeight(1, 40))
//        );
//        obj.vertexWithWeightAllSourceToDestinationPath(adjList);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count good nodes in binary tree");
//        //https://leetcode.com/problems/count-good-nodes-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().setRight(new TreeNode<>(5));
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
//        root1 = new TreeNode<>(1);
//        System.out.println("Good nodes counts in tree approach 1: "+obj.countGoodNodesInBinaryTree_1(root1, Integer.MIN_VALUE));
//        obj.countGoodNodesInBinaryTree_2(root1); //EASIER APPROACH
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min distance between 2 nodes in given binary tree");
//        //https://www.geeksforgeeks.org/find-distance-between-two-nodes-of-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 2, 3);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 3, 3);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().setRight(new TreeNode<>(7));
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 4, 5);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 4, 6);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 3, 4);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 2, 4);
//        obj.minDistanceBetweenGivenTwoNodesInBinaryTree(root1, 8, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Celebrity problem");
//        //https://www.geeksforgeeks.org/the-celebrity-problem/
//        System.out.println("Id of celebrity person: " + obj.findCelebrityInNPepole(4));
//        System.out.println("Id of celebrity person: " + obj.findCelebrityInNPepole_Optimized(4));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max product in splitted binary tree");
//        //https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        obj.maxProductIfBinaryTreeIsSplitIntoTwo(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest consecutive sequenece");
//        //https://leetcode.com/problems/longest-consecutive-sequence/
//        //https://practice.geeksforgeeks.org/problems/longest-consecutive-subsequence2449/1
//        System.out.println("Longest consecutive seq: " + obj.longestConsecutiveSequence(new int[]{2, 6, 1, 9, 4, 5, 3}));
//        System.out.println("Longest consecutive seq: "
//                + obj.longestConsecutiveSequence(new int[]{2, 2, 4, 5, 1, 1, 1, 3, 4, 5, 6, 7, 8, 9, 9}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max difference of indexes");
//        //https://www.geeksforgeeks.org/given-an-array-arr-find-the-maximum-j-i-such-that-arrj-arri/
//        obj.maxDifferenceOfIndexes(new int[]{34, 8, 10, 3, 2, 80, 30, 33, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete nodes from binary search tree");
//        //https://leetcode.com/problems/delete-node-in-a-bst/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 3)).treeBFS(); //DELETE ROOT OF TREE
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 1)).treeBFS(); //DELETE LEAF
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 0)).treeBFS(); //DELETE ROOT HAS ONE CHILD (RIGHT)
//        new BinaryTree<Integer>(obj.deleteTreeNodeFromBinarySearchTree(root1, 2)).treeBFS(); //DELETE ROOT HAS ONE CHILD (LEFT)
//        System.out.println();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete nodes from binary search tree that are not in range");
//        //https://leetcode.com/problems/trim-a-binary-search-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        obj.deleteTreeNodeFromBinarySearchTreeNotInRange(root1, 1, 3);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(4));
//        obj.deleteTreeNodeFromBinarySearchTreeNotInRange(root1, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rearrange array elements");
//        //https://www.geeksforgeeks.org/rearrange-given-array-place/
//        obj.rearrangeArrayElements(new int[]{4, 0, 2, 1, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum range that contains atleast one element from K sorted List");
//        //https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/
//        //https://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/
//        obj.minimumRangeContainingAtleastOneElementFromKSortedList(new int[][]{
//            {1, 3, 5, 7, 9},
//            {0, 2, 4, 6, 8},
//            {2, 3, 5, 7, 11}
//        });
//        obj.minimumRangeContainingAtleastOneElementFromKSortedList(new int[][]{
//            {1, 2, 3, 4},
//            {5, 6, 7, 8},
//            {9, 10, 11, 12}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Tuples with same product");
//        //https://leetcode.com/problems/tuple-with-same-product/
//        obj.tupleWithSameProduct(new int[]{2, 3, 4, 6});
//        obj.tupleWithSameProduct(new int[]{2, 3, 5, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if two nodes are cousin of each other");
//        //https://leetcode.com/problems/cousins-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        obj.checkIfTwoTreeNodesAreCousin(root1, 4, 3);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 3);
//        root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(5));
//        obj.checkIfTwoTreeNodesAreCousin(root1, 4, 5);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 5);
//        obj.checkIfTwoTreeNodesAreCousin(root1, 2, 6); //6 don't exist
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cousins in Binary Tree II");
//        //https://leetcode.com/problems/cousins-in-binary-tree-ii/description/
//        TreeNode<Integer> root1 = new TreeNode<>(5);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setLeft(new TreeNode<>(1));
//        root1.getLeft().setRight(new TreeNode<>(10));
//        root1.setRight(new TreeNode<>(9));
//        root1.getRight().setRight(new TreeNode<>(7));
//        obj.cousinsInBinaryTreeTwo(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(2));
//        obj.cousinsInBinaryTreeTwo(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Closest Strings distance");
//        //https://practice.geeksforgeeks.org/problems/closest-strings0611/1#
//        System.out.println("Closest string distance: " + obj.closestStringDistance(
//                Arrays.asList("geeks", "for", "geeks", "contribute", "practice"), "geeks", "practice"));
//        System.out.println("Closest string distance: " + obj.closestStringDistance(
//                Arrays.asList("geeks", "for", "geeks", "contribute", "practice"), "geeks", "geeks"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Connect all nodes at same level in a tree by the random pointer (Recursive/ Iterative)");
//        //https://leetcode.com/problems/populating-next-right-pointers-in-each-node/
//        //https://practice.geeksforgeeks.org/problems/connect-nodes-at-same-level/1#
//        TreeNode<Integer> root1 = new TreeNode<>(10);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(5));
//        root1.getRight().setRight(new TreeNode<>(2));
//        obj.connectTreeNodesAtSameLevel_Recursive(root1);
//        obj.connectTreeNodesAtSameLevel_Iterative(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K - diff pairs in array");
//        //https://leetcode.com/problems/k-diff-pairs-in-an-array/
//        //https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/
//        obj.kDiffPairsInArray(new int[]{3, 1, 4, 1, 5}, 2);
//        obj.kDiffPairsInArray(new int[]{-1, -2, -3}, 1);
//        obj.kDiffPairsInArray(new int[]{1, 3, 1, 5, 4}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Least number of unique integers left after K removals");
//        //https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{5, 5, 4}, 1);
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{4, 3, 1, 1, 3, 3, 2}, 3);
//        obj.leastNumberOfUniqueIntegersLeftAfterKRemoval(new int[]{4, 3, 1, 1, 3, 3, 2}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Long pressed names");
//        //https://leetcode.com/problems/long-pressed-name/
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("alex", "aaleex"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("laex", "aaleex"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("saeed", "ssaaedd"));
//        System.out.println("Both actual name and typed name supposed to equal: " + obj.longPressedNames("leelee", "lgeelege"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary search tree to greater sum tree");
//        //https://leetcode.com/problems/convert-bst-to-greater-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(4);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setRight(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(6));
//        root1.getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().setRight(new TreeNode<>(7));
//        root1.getRight().getRight().setRight(new TreeNode<>(8));
//        obj.binarySearchTreeToGreaterSumTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all interleavings of given two strings");
//        //https://www.geeksforgeeks.org/print-all-interleavings-of-given-two-strings/
//        obj.interleavingOfTwoStrings("AB", "CD");
//        obj.interleavingOfTwoStrings("ABC", "DEF");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if String C is interleaving of String A & B");
//        //https://leetcode.com/problems/interleaving-string/
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "ACBG"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "ACDB"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("AB", "CD", "AC"));
//        System.out.println("Third string is interleaving of other two (Recursive Memoization): "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_Recursive_Memoization("aabcc", "dbbca", "aadbbcbcac"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "ACBG"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "ACDB"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("AB", "CD", "AC"));
//        System.out.println("Third string is interleaving of other two: "
//                + obj.checkIfStringCIsInterleavingOfStringAAndB_DP_Memoization("aabcc", "dbbca", "aadbbcbcac"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all permutation of distinct char in string");
//        //https://leetcode.com/problems/permutations/
//        //https://leetcode.com/problems/permutations-ii/
//        obj.printAllPermutationOfDistinctCharInString("ABC");
//        obj.printAllPermutationOfDistinctCharInString("ABCD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print all permutation of a distinct integer");
//        //https://leetcode.com/problems/permutations/
//        //https://leetcode.com/problems/permutations-ii/
//        obj.printAllPermutationOfDistinctIntegerArray(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max distance covered by robot walking simulation");
//        //https://leetcode.com/problems/walking-robot-simulation/
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{4, -1, 4, -2, 4},
//                new int[][]{{2, 4}});
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{4, -1, 3},
//                new int[][]{});
//        obj.maximumDistanceCoveredInRobotWalkingSimulation(new int[]{2, -1, 2 - 1, 2},
//                new int[][]{});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest substring having all vowels in order");
//        //https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/
//        obj.longestSubstringHavingAllVowelsInOrder("aeiaaioaaaaeiiiiouuuooaauuaeiu");
//        obj.longestSubstringHavingAllVowelsInOrder("aeeeiiiioooauuuaeiou");
//        obj.longestSubstringHavingAllVowelsInOrder("a");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Evaluate arithematic expression(Basic calculator)");
//        //https://leetcode.com/problems/basic-calculator-ii/
//        obj.arithematicExpressionEvaluationBasicCalculator(" 3/2 ");
//        obj.arithematicExpressionEvaluationBasicCalculator(" 35 + 5 / 4 ");
//        obj.arithematicExpressionEvaluationBasicCalculator(" 3 + 5 / 4*2");
//        //https://leetcode.com/problems/basic-calculator/
//        obj.basicCalculator("1 + 1");
//        obj.basicCalculator(" 2-1 + 2 ");
//        obj.basicCalculator("(1+(4+5+2)-3)+(6+8)");
//        obj.basicCalculator("1 + (1 + 1) - (1 - 3)");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Single threaded CPU Greedy");
//        //https://leetcode.com/problems/single-threaded-cpu/
//        obj.singleThreadedCPU_Greedy(new int[][]{
//            {1, 2}, {2, 4}, {3, 2}, {4, 1}
//        });
//        obj.singleThreadedCPU_Greedy(new int[][]{
//            {7, 10}, {7, 12}, {7, 5}, {7, 4}, {7, 2}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Replace bracket pattern with given value in list");
//        //https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/
//        List<List<String>> keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("name", "bob"));
//        keyReplacement.add(Arrays.asList("age", "two"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("(name)is(age)yearsold",
//                keyReplacement);
//        keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("a", "b"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("hi(name)",
//                keyReplacement);
//        keyReplacement = new ArrayList<>();
//        keyReplacement.add(Arrays.asList("a", "yes"));
//        obj.evaluateBracketPatternAndReplaceWithGivenWord("(a)(a)(a)aaa",
//                keyReplacement);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All phone digits letter combinations");
//        //https://leetcode.com/problems/letter-combinations-of-a-phone-number
//        obj.allPhoneDigitLetterCombinations("2");
//        obj.allPhoneDigitLetterCombinations("23");
//        obj.allPhoneDigitLetterCombinations("7979");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Combination sum 1 and 3");
//        //https://leetcode.com/problems/combination-sum
//        //https://leetcode.com/problems/combinations/
//        obj.combinationSum_1(new int[]{1}, 2);
//        obj.combinationSum_1(new int[]{2}, 1); //No Combinations Possible
//        obj.combinationSum_1(new int[]{2, 3, 5}, 8);
//        //https://leetcode.com/problems/combination-sum-iii/
//        obj.combinationSum_3(3, 7);
//        obj.combinationSum_3(3, 9);
//        obj.combinationSum_3(4, 1);
//        obj.combinationSum_3(9, 60);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Combination sum-2");
//        //https://leetcode.com/problems/combination-sum-ii/
//        obj.combinationSum_2(new int[]{10, 1, 2, 7, 6, 1, 5}, 8);
//        obj.combinationSum_2(new int[]{2, 5, 2, 1, 2}, 5);
//        obj.combinationSum_2(new int[]{1}, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest unsorted contigous subarray");
//        //https://leetcode.com/problems/shortest-unsorted-continuous-subarray
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{2, 6, 4, 8, 10, 9, 15}));
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{1, 2, 3, 4})); //ALREADY SORTED
//        System.out.println("Length of shortest unsorted contigous subarray "
//                + obj.shortestUnsortedContigousSubarray(new int[]{4})); //ALREADY SORTED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum operations to make array increasing");
//        //https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
//        obj.minimumOperationsToMakeArrayStrictlyIncr(new int[]{1, 1, 1});
//        obj.minimumOperationsToMakeArrayStrictlyIncr(new int[]{4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Broken calculator (make X equal to Y with decreament Or Multiplication oprn on X)");
//        //https://leetcode.com/problems/broken-calculator/
//        obj.brokenCalculatorMakeXEqualToY(2, 3);
//        obj.brokenCalculatorMakeXEqualToY(3, 10);
//        obj.brokenCalculatorMakeXEqualToY(1024, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Vertices to Reach All Nodes");
//        //https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
//        obj.vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(6, new int[][]{
//            {0, 1}, {0, 2}, {2, 5}, {3, 4}, {4, 2}
//        });
//        obj.vertexThroughAllOtherVertexCanBeReachedInDirectedAcyclicGraph_Graph(5, new int[][]{
//            {0, 1}, {2, 1}, {3, 1}, {4, 1}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if atmost one char swap make strings equal");
//        //https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("bank", "kanb"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("kelb", "kelb"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("abcd", "dcba"));
//        System.out.println("String are equal with atmost one char swap: "
//                + obj.checkIfOneCharSwapMakeStringEqual("attack", "defend"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Substring Between Two Equal Characters");
//        //https://leetcode.com/problems/largest-substring-between-two-equal-characters/
//        obj.largestSubstringBetweenTwoSameChar("aa");
//        obj.largestSubstringBetweenTwoSameChar("cbzxy");
//        obj.largestSubstringBetweenTwoSameChar("cabbac");
//        obj.largestSubstringBetweenTwoSameChar("abca");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest subtree with all the deepest nodes in a tree");
//        //https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
//        //https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/
//        TreeNode<Integer> root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(5));
//        root1.getLeft().setLeft(new TreeNode<>(6));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(4));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setLeft(new TreeNode<>(0));
//        root1.getRight().setRight(new TreeNode<>(8));
//        obj.subtreeWithAllDeepestNodes(root1); //DEEP LEAF = 7,4 subtree = [2,7,4]
//        root1 = new TreeNode<>(0);
//        root1.setLeft(new TreeNode<>(1));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.setRight(new TreeNode<>(3));
//        obj.subtreeWithAllDeepestNodes(root1); //DEEP LEAF = 2 subtree = [2]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Determine if two strings are close");
//        //https://leetcode.com/problems/determine-if-two-strings-are-close/
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("a", "aa"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("abc", "cba"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("cabbba", "abbccc"));
//        System.out.println(obj.determineIfTwoStringCanBeMadeClose("cabbba", "aabbss"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum char required to make string t anagram of string s");
//        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/
//        //https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("bab", "aba");
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("leetcode", "practice");
//        obj.minCharacterRequiredToMakeStringTAnagramOfS("xxyyzz", "xxyyzz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum char removed to make string t & s anagram");
//        //https://practice.geeksforgeeks.org/problems/anagram-of-string
//        //https://www.geeksforgeeks.org/remove-minimum-number-characters-two-strings-become-anagram/
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("bcadeh", "hea"); //remove b,c,d from S
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("bcadeh", "heaz"); //remove b,c,d from S, z from T
//        obj.minCharacterRemovedToMakeStringTAndSAnagrams("cddgk", "gcd"); //remove k,d from S
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if graph is bipartite");
//        //https://leetcode.com/problems/is-graph-bipartite/
//        System.out.println("Graph is bipartite: "
//                + obj.checkIfGraphIsBipartite_Graph(new int[][]{{1, 3}, {0, 2}, {1, 3}, {0, 2}}));
//        System.out.println("Graph is bipartite: "
//                + obj.checkIfGraphIsBipartite_Graph(new int[][]{{1, 2, 3}, {0, 2}, {0, 1, 3}, {0, 2}}));
//        System.out.println("Possible Bipartition");
//        //https://leetcode.com/problems/possible-bipartition/description/
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(4, new int[][]{{1, 2}, {1, 3}, {2, 4}}));
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(3, new int[][]{{1, 2}, {1, 3}, {2, 3}}));
//        System.out.println("Graph is bipartite: "
//                + obj.possibleBipartition_Graph(5, new int[][]{{1, 2}, {2, 3}, {3, 4}, {4, 5}, {1, 5}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pseudo-Palindromic Paths in a Binary Tree");
//        //https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(2);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().setRight(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(1));
//        root1.getRight().setRight(new TreeNode<>(1));
//        obj.pseudoPallindromicPathInBinaryTree(root1);
//        root1 = new TreeNode<>(3);
//        root1.setLeft(new TreeNode<>(3));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.setRight(new TreeNode<>(1));
//        obj.pseudoPallindromicPathInBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Split linked list in K parts");
//        //https://leetcode.com/problems/split-linked-list-in-parts/
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        obj.splitLinkedListInKParts(head, 5);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(7));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(8));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(9));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(10));
//        obj.splitLinkedListInKParts(head, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove given value from linked list");
//        //https://leetcode.com/problems/remove-linked-list-elements
//        Node<Integer> head = new Node<>(6);
//        head.setNext(new Node<>(1));
//        head.getNext().setNext(new Node<>(2));
//        head.getNext().getNext().setNext(new Node<>(3));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
//        head = new Node<>(6);
//        head.setNext(new Node<>(6));
//        head.getNext().setNext(new Node<>(6));
//        head.getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().setNext(new Node<>(6));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(6));
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
//        head = new Node<>(6);
//        obj.trimLinkedListAndRemoveAllOccurencesOfGivenVal(head, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum difference of sum of two partition of the array DP Problem");
//        //https://practice.geeksforgeeks.org/problems/minimum-sum-partition3317/1#
//        obj.minimumDiffPartition_DP_Memoization(new int[]{1, 6, 11, 5});
//        obj.minimumDiffPartition_DP_Memoization(new int[]{1, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest subarray of consecutive ones after deleting one element in the binary array");
//        //https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{0,0,0});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{1,1,1,1});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{1,1,0,1});
//        obj.longestSubarrayOfConsecutiveOnesAfterDeletingOneElement(new int[]{0,1,1,1,0,1,1,0,1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count subarray with odd sum");
//        //https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum
//        obj.countSubarrayWithOddSum(new int[]{1, 3, 5});
//        obj.countSubarrayWithOddSum(new int[]{2, 4, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge new interval in between");
//        //https://leetcode.com/problems/insert-interval/
//        obj.mergeNewInterval(new int[][]{{1, 3}, {6, 9}}, new int[]{2, 5});
//        obj.mergeNewInterval(new int[][]{{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}}, new int[]{4, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count the number of turns in between two nodes of a tree");
//        //https://www.geeksforgeeks.org/number-turns-reach-one-node-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(4));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(8));
//        root1.getLeft().setRight(new TreeNode<>(5));
//        root1.setRight(new TreeNode<>(3));
//        root1.getRight().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(9));
//        root1.getRight().getLeft().setRight(new TreeNode<>(10));
//        root1.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 9, 10));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 5, 6));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 1, 4));
//        System.out.println("Count turns between two nodes: "
//                +obj.countNumberOfTurnsBetweenTwoNodesOfTree(root1, 5, 10));        
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest zig zag path in the binary tree");
//        //https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setRight(new TreeNode<>(4));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(5));
//        root1.getLeft().getRight().getLeft().setRight(new TreeNode<>(7));
//        root1.getLeft().getRight().setRight(new TreeNode<>(6));
//        root1.setRight(new TreeNode<>(3));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1);
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1);
//        root1.setRight(new TreeNode<>(2));
//        root1.getRight().setLeft(new TreeNode<>(3));
//        root1.getRight().setRight(new TreeNode<>(4));
//        root1.getRight().getRight().setLeft(new TreeNode<>(5));
//        root1.getRight().getRight().getLeft().setRight(new TreeNode<>(7));
//        root1.getRight().getRight().getLeft().getRight().setRight(new TreeNode<>(8));
//        root1.getRight().getRight().setRight(new TreeNode<>(6));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
//        root1 = new TreeNode<>(1); //SKEWED
//        root1.setLeft(new TreeNode<>(2));
//        root1.getLeft().setLeft(new TreeNode<>(3));
//        root1.getLeft().getLeft().setLeft(new TreeNode<>(4));
//        obj.longestZigZagPathInTree(root1);
//        obj.longestZigZagPathInTree2(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Duplicate zero in-place");
//        //https://leetcode.com/problems/duplicate-zeros/
//        obj.duplicateZeroInArray(new int[]{1, 0, 2, 3, 0, 4, 5, 0});
//        obj.duplicateZeroInArray(new int[]{1, 0, 0, 3, 0, 4, 5, 0});
//        obj.duplicateZeroInArray(new int[]{1, 2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Array Nesting");
//        //https://leetcode.com/problems/array-nesting/
//        obj.arrayNesting(new int[]{5, 4, 0, 3, 1, 6, 2});
//        obj.arrayNesting(new int[]{0, 1, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Escaping ghost");
//        //https://leetcode.com/problems/escape-the-ghosts/
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{1, 0}, {0, 3}}, new int[]{0, 1}));
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{1, 0}}, new int[]{2, 0})); //GHOST is in between user and target
//        System.out.println("User escaped all the ghosts to reach target: "
//                + obj.escapingGhost(new int[][]{{2, 0}}, new int[]{1, 0})); //GHOST and user reach target at same time
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove duplicate from sorted array 2 (elements can occur at most twice)");
//        //https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/
//        obj.removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(new int[]{1, 1, 1, 2, 2, 3});
//        obj.removeDuplicateInSortedArray2WhereElementCanHaveAtMostTwiceOccur(new int[]{0, 0, 1, 1, 1, 1, 2, 3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Calculate power(row, n)");
//        //https://leetcode.com/problems/powx-n/
//        obj.nPowerOfX(5.0, 0); //5 ^ 0 = 1
//        obj.nPowerOfX(5.0, 1); //5 ^ 1 = 5
//        obj.nPowerOfX(2.0, 10);
//        obj.nPowerOfX(2.0, -3);
//        obj.nPowerOfX(-2.0, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert postfix exprssion to infix expression");
//        //https://www.geeksforgeeks.org/postfix-to-infix/
//        obj.convertPostfixToInfixExpression("abc++");
//        obj.convertPostfixToInfixExpression("52*5+");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert infix exprssion to postfix expression");
//        //https://www.geeksforgeeks.org/stack-set-2-infix-to-postfix/
//        //https://leetcode.com/problems/basic-calculator/
//        obj.convertInfixToPostfixExpression("a*b+c/d");
//        obj.convertInfixToPostfixExpression("a+b*c/d-e");
//        obj.convertInfixToPostfixExpression("(a*b)+(c/d)-(e^f)");
//        obj.convertInfixToPostfixExpression("a+b*(c^d-e)^(f+g*h)-i");
//        obj.convertInfixToPostfixExpression("(1+(4+5+2)-3)+(6+8)");
        //......................................................................
//        Row: 307
//        System.out.println("Postfix expression evaluation");
//        //https://leetcode.com/problems/evaluate-reverse-polish-notation/
//        //https://leetcode.com/problems/basic-calculator/
//        obj.postfixExpressionEvaluation_SingleDigit("23+");
//        obj.postfixExpressionEvaluation_SingleDigit("231*+9-");
//        obj.postfixExpressionEvaluation_MultipleDigit("10 20 +");
//        obj.postfixExpressionEvaluation_MultipleDigit("100 200 * 10 /");
//        obj.postfixExpressionEvaluation_MultipleDigit("100 200 + 10 / 1000 +");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Course Schedule 2");
//        //https://leetcode.com/problems/course-schedule-ii/
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}}, 2);
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}, {0, 1}}, 2); //CYCLE
//        obj.courseScheduleTwo_Graph(new int[][]{{1, 0}, {2, 0}, {3, 1}, {3, 2}}, 4);
//        obj.courseScheduleTwo_Graph(new int[][]{}, 1);
//        /*
//         //https://leetcode.com/discuss/interview-question/742238/Amazon-or-Student-Order
//         Given a result of a competition among all the students of a class, 
//         write a program to make students stand in a order such that every 
//         student must have lost to the student in his/her immediate left and 
//         won against the student to his/her immediate right.
//        
//         // student[][] = {{0,1},{1,2}} Here 0 lost to 1, 1 lost to 2
//         output of above:  2 1 0
//         0 loses to 1 so 1 is on left of 0
//         1 0
//         1 loses to 2 so 2 is on left of 1
//         2 1 0
//         */
//        obj.courseScheduleTwo_Graph(new int[][]{{0, 1}, {1, 2}}, 3); //3 is total student
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Course Schedule 3");
//        //https://leetcode.com/problems/course-schedule-iii/
//        obj.courseSchedule_3_Greedy(new int[][]{{100, 200}, {200, 1300}, {1000, 1250}, {2000, 3200}});
//        obj.courseSchedule_3_Greedy(new int[][]{{1, 2}});
//        obj.courseSchedule_3_Greedy(new int[][]{{3, 2}, {4, 3}});
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Boats to Save People/ Efficient janitor");
//        //https://leetcode.com/problems/boats-to-save-people/
//        //https://leetcode.com/discuss/interview-question/490066/Efficient-Janitor-Efficient-Vineet-(Hackerrank-OA)
//        //both the approaches works for boats-to-save-people & efficient janitor
//        obj.efficientJanitor_Greedy(new double[]{1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7});
//        obj.efficientJanitor_Greedy(new double[]{1.01, 1.991, 1.32, 1.4});
//        obj.efficientJanitor2_Greedy(new double[]{1.01, 1.01, 3.0, 2.7, 1.99, 2.3, 1.7});
//        obj.efficientJanitor2_Greedy(new double[]{1.01, 1.991, 1.32, 1.4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Flip string to monotone increase");
//        //https://leetcode.com/problems/flip-string-to-monotone-increasing/
//        obj.flipStringToMonotoneIncrease("00110");
//        obj.flipStringToMonotoneIncrease("00110000");
//        obj.flipStringToMonotoneIncrease("00000011"); //ALREADY MONOTONE
//        obj.flipStringToMonotoneIncrease("000000"); //ALREADY MONOTONE
//        obj.flipStringToMonotoneIncrease("11111111"); //ALREADY MONOTONE
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Gas station");
//        //https://leetcode.com/problems/gas-station/
//        obj.gasStationCompleteCircuit(new int[]{1, 2, 3, 4, 5}, new int[]{3, 4, 5, 1, 2});
//        obj.gasStationCompleteCircuit(new int[]{2, 3, 4}, new int[]{3, 4, 3});
//        obj.gasStationCompleteCircuit(new int[]{3, 1, 1}, new int[]{1, 2, 2});
//        obj.gasStationCompleteCircuit2(new int[]{1, 2, 3, 4, 5}, new int[]{3, 4, 5, 1, 2});
//        obj.gasStationCompleteCircuit2(new int[]{2, 3, 4}, new int[]{3, 4, 3});
//        obj.gasStationCompleteCircuit2(new int[]{3, 1, 1}, new int[]{1, 2, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum deletion cost to avoid repeating charracters");
//        //https://leetcode.com/problems/minimum-time-to-make-rope-colorful/
//        //https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/
//        obj.minDeletionCostToAvoidRepeatingChar("abaac", new int[]{1, 2, 3, 4, 5});
//        obj.minDeletionCostToAvoidRepeatingChar("abc", new int[]{1, 2, 3});
//        obj.minDeletionCostToAvoidRepeatingChar("aabaa", new int[]{1, 2, 3, 4, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Alien dictionary (Graph)");
//        //https://www.geeksforgeeks.org/given-sorted-dictionary-find-precedence-characters/
//        obj.alienDictionary_Graph(new String[]{"caa", "aaa", "aab"}, 3);
//        obj.alienDictionary_Graph(new String[]{"baa", "abcd", "abca", "cab", "cad"}, 4);
//        obj.alienDictionary2_Graph(new String[]{"wrt", "wrf", "er", "ett", "rftt"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range update and get queries");
//        //https://www.geeksforgeeks.org/binary-indexed-tree-range-updates-point-queries/
//        obj.rangeUpdateAndPointQueries(new int[]{0, 0, 0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove all adjacent duplicate K chars in the strings and print remaining");
//        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string
//        //https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/
//        obj.removeAdjacentDuplicateKCharInString("pbbcggttciiippooaais", 2);
//        obj.removeAdjacentDuplicateKCharInString("abcd", 2);
//        obj.removeAdjacentDuplicateKCharInString("deeedbbcccbdaa", 3);
//        obj.removeAdjacentDuplicateKCharInString("XABCDFFDCBA", 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Swaps to Make the Binary String Alternating");
//        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("111000")); //101010
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("00")); //Not Possible
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("1110")); //Not Possible
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("010")); //Already alternate
//        System.out.println("Minswaps required to make binary string alternate: "
//                + obj.minSwapRequiredToMakeBinaryStringAlternate("1")); //Already alternate
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rectangle overlapping");
//        //https://leetcode.com/problems/rectangle-overlap/
//        //https://leetcode.com/problems/rectangle-area/
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{0, 0, 2, 2}, new int[]{1, 1, 3, 3})); //overlapping
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{-2, 0, 0, 2}, new int[]{-3, 1, -1, 3})); //Other quadrant
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{0, 0, 1, 1}, new int[]{2, 2, 2, 3})); //No overlapping
//        System.out.println("Rectangle overlapping & area: "
//                + obj.rectangleOverlappingAndArea(new int[]{1, 1, 2, 2}, new int[]{2, 1, 3, 2})); //Only edge touching
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("All common element in 3 sorted arrays");
//        //https://practice.geeksforgeeks.org/problems/common-elements1132/1
//        obj.allCommonElementIn3SortedArray(
//                new int[]{1, 5, 10, 20, 40, 80},
//                new int[]{6, 7, 20, 80, 100},
//                new int[]{3, 4, 15, 20, 30, 70, 80, 120});
//        obj.allCommonElementIn3SortedArray(
//                new int[]{3, 3, 3, 3},
//                new int[]{3, 3, 3, 3},
//                new int[]{3, 3, 3, 3});
//        System.out.println("All common element in k unsorted arrays");
//        //https://leetcode.com/problems/intersection-of-multiple-arrays/
//        //https://www.codingninjas.com/codestudio/problems/common-elements-present-in-all-rows-of-a-matrix_1118111
//        obj.allCommonElementInKUnsortedArray(new int[][]{
//            {1, 4, 5, 6}, {3, 4, 5, 6}, {5, 6, 7, 6}});
//        obj.allCommonElementInKUnsortedArray(new int[][]{
//            {1, 2, 3}, {2, 2, 3}, {2, 3, 1}, {2, 3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Rearrage elements of array randomly but in-place & in O(N)");
//        //https://leetcode.com/problems/shuffle-an-array/
//        obj.randomlyRearrangeElementsOfArray(new int[]{1, 0, 7, 2, 10});
//        obj.randomlyRearrangeElementsOfArray2(new int[]{1, 0, 7, 2, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Time Needed to Inform All Employees");
//        //https://leetcode.com/problems/time-needed-to-inform-all-employees/
//        obj.timeNeededToInformAllEmployee_NAryTree(1, 0, new int[]{-1}, new int[]{0});
//        obj.timeNeededToInformAllEmployee_NAryTree(6, 2, new int[]{2, 2, -1, 2, 2, 2}, new int[]{0, 0, 1, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_NAryTree(15, 0,
//                new int[]{-1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6},
//                new int[]{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_DFS(1, 0, new int[]{-1}, new int[]{0});
//        obj.timeNeededToInformAllEmployee_DFS(6, 2, new int[]{2, 2, -1, 2, 2, 2}, new int[]{0, 0, 1, 0, 0, 0});
//        obj.timeNeededToInformAllEmployee_DFS(15, 0,
//                new int[]{-1, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6},
//                new int[]{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Index Sum of Two Lists");
//        //https://leetcode.com/problems/minimum-index-sum-of-two-lists/
//        obj.minimumIndexSumOfTwoStringArray(new String[]{"Shogun", "Tapioca Express", "Burger King", "KFC"},
//                new String[]{"KFC", "Burger King", "Tapioca Express", "Shogun"});
//        obj.minimumIndexSumOfTwoStringArray(new String[]{"Shogun", "Tapioca Express", "Burger King", "KFC"},
//                new String[]{"Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximal square DP");
//        //https://leetcode.com/problems/maximal-square/
//        //https://practice.geeksforgeeks.org/problems/largest-square-formed-in-a-matrix0806/1
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {1, 0, 1, 0, 0},
//            {1, 0, 1, 1, 1},
//            {1, 1, 1, 1, 1},
//            {1, 0, 0, 1, 0},}); //SQR: mat[1][2] to mat[2][3]
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {0, 0, 0, 0},
//            {0, 0, 1, 0},
//            {0, 0, 0, 0},}); //SQR: mat[1][2]
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {0}}); //SQR: 0
//        obj.maximalSquare_DP_Memoization(new int[][]{
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},
//            {1, 1, 1, 1},}); //SQR: mat[N][N]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count all squares with one in binary matrix/ maximal squares approach");
//        //https://leetcode.com/problems/count-square-submatrices-with-all-ones
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {0, 0, 0, 0},
//            {0, 0, 1, 0},
//            {0, 0, 0, 0},});
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {0, 1, 1, 1},
//            {1, 1, 1, 1},
//            {0, 1, 1, 1},});
//        obj.countAllSquareWithOneInBinaryMatrix_DP_Memoization(new int[][]{
//            {1, 1, 0, 0},
//            {1, 1, 0, 0},
//            {0, 0, 0, 0},});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Teemo attacking ashee");
//        //https://leetcode.com/problems/teemo-attacking
//        //https://leetcode.com/discuss/interview-question/280433/Google-or-Phone-screen-or-Program-scheduling
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 4}, 2));
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 2}, 2));
//        System.out.println("Total time till ashee remained poisined: "
//                + obj.teemoAttackingAshee(new int[]{1, 10}, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min operation to make array equal of size n");
//        //https://leetcode.com/problems/minimum-operations-to-make-array-equal/
//        obj.minOperationToMakeArrayOfSizeNEqual(3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("First Unique Character in a String");
//        //https://leetcode.com/problems/first-unique-character-in-a-string/
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("aabbcc"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("leetcode"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("loveleetcode"));
//        System.out.println("Index of first unique char: " + obj.firstUniqueCharacterInString("aaaa"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Pivot Index");
//        //https://leetcode.com/problems/find-pivot-index/
//        //https://leetcode.com/problems/find-the-middle-index-in-array
//        //https://leetcode.com/problems/number-of-ways-to-split-array
//        //https://leetcode.com/problems/left-and-right-sum-differences/description/
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{1, 7, 3, 6, 5, 6}));
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{1, 2, 3}));
//        System.out.println("Pivot index: " + obj.findPivotIndex(new int[]{2, 1, -1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find the Distinct Difference Array");
//        //https://leetcode.com/problems/find-the-distinct-difference-array/description/
//        obj.findDistinctDiffArray(new int[]{1, 2, 3, 4, 5});
//        obj.findDistinctDiffArray(new int[]{3, 2, 3, 4, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum subarray sum with unique elements/ Maximum Erasure Value");
//        //https://leetcode.com/problems/maximum-erasure-value/
//        obj.maximumSubarraySumWithUniqueElements(new int[]{4, 2, 4, 5, 6}); //sunarr: [2,4,5,6]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{5, 2, 1, 2, 5, 2, 1, 2, 5}); //sunarr: [5,2,1] or [1,2,5]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 1, 1, 1}); //subarr: [1]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 2, 3, 4}); //subarr: [1,2,3,4]
//        obj.maximumSubarraySumWithUniqueElements(new int[]{1, 1, 2, 2, 3, 3, 4, 4}); //subarr: [3,4]
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum path sum in grid(top-left to bottom-right)");
//        //https://leetcode.com/problems/minimum-path-sum/
//        obj.minimumPathSumInGrid(new int[][]{
//            {1, 3, 1}, {1, 5, 1}, {4, 2, 1}
//        });
//        obj.minimumPathSumInGrid(new int[][]{
//            {1, 2, 3}, {4, 5, 6}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array Into Three Parts With Equal Sum");
//        //https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/
//        System.out.println("Pratition possible: "
//                + obj.partitionArrayIntoThreePartsWithEqualSum(new int[]{0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1}));
//        System.out.println("Pratition possible: "
//                + obj.partitionArrayIntoThreePartsWithEqualSum(new int[]{0, 2, 1, -6, 6, 7, 9, -1, 2, 0, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Substring with Concatenation of All Words");
//        //https://leetcode.com/problems/substring-with-concatenation-of-all-words/
//        obj.substringWithConcatenationsOfGivenWords("barfoothefoobarman",
//                new String[]{"foo", "bar"});
//        obj.substringWithConcatenationsOfGivenWords("wordgoodgoodgoodbestword",
//                new String[]{"word", "good", "best", "word"});
//        obj.substringWithConcatenationsOfGivenWords("barfoofoobarthefoobarman",
//                new String[]{"bar", "foo", "the"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove all sequences of consecutive linked list node sum to zero");
//        //https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
//        Node<Integer> head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(-2));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(1);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(-3));
//        head.getNext().getNext().getNext().setNext(new Node<>(1));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
//        head = new Node<>(0);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(3));
//        head.getNext().getNext().setNext(new Node<>(0));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        obj.removeZeroSumConsecutiveNodesFromLinkedList(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Add two nums without usiing + or -");
//        //https://leetcode.com/problems/sum-of-two-integers
//        obj.addTwoNumsWithoutPlusOrMinus(4, 6);
//        obj.addTwoNumsWithoutPlusOrMinus(4, -6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Top k frequent elements in an array");
//        //https://leetcode.com/problems/top-k-frequent-elements/
//        obj.topKFrequentElements(new int[]{1, 1, 1, 2, 2, 3}, 2);
//        obj.topKFrequentElements(new int[]{1}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum words that you can type");
//        //https://leetcode.com/problems/maximum-number-of-words-you-can-type/
//        obj.maximumWordsThatYouCanType("hello world", "ad"); //hello can be typed, world is broken on char d
//        obj.maximumWordsThatYouCanType("world world", "ad"); //no words can be typed, world is broken on char d
//        obj.maximumWordsThatYouCanType("leet code", "lt"); //code can be typed, leet is broken on char l(even one char can make it broken)
//        obj.maximumWordsThatYouCanType("hello world", "xy"); //hello, world both can be typed, no words contains broken chars row & col
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length AP in binary tree");
//        //https://www.geeksforgeeks.org/longest-path-to-the-bottom-of-a-binary-tree-forming-an-arithmetic-progression/
//        //https://www.geeksforgeeks.org/longest-arithmetic-progression-path-in-given-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(6);
//        root1.setRight(new TreeNode<>(9)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().getRight().setRight(new TreeNode<>(15)); //common diff from prev node is 3
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(6);
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(6);
//        root1.setRight(new TreeNode<>(9));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(15);
//        root1.setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(9)); //common diff from prev node is 3
//        root1.getRight().getRight().setRight(new TreeNode<>(6)); //common diff from prev node is 3
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
//        root1 = new TreeNode<>(15);
//        root1.setRight(new TreeNode<>(12)); //common diff from prev node is 3
//        root1.getRight().setRight(new TreeNode<>(11)); //common diff from prev node is NOT 3, hence breaking AP, maxLen - 15 -> 12 = 2
//        root1.getRight().getRight().setRight(new TreeNode<>(9));
//        root1.getRight().setLeft(new TreeNode<>(7));
//        obj.longestPathArithemeticProgressionInBinaryTree(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest string chain");
//        //https://leetcode.com/problems/longest-string-chain/
//        obj.longestStringChain_DP_Memoization(new String[]{"a", "abc", "ab", "abcd"}); //4
//        obj.longestStringChain_DP_Memoization(new String[]{"a", "b", "ba", "bca", "bda", "bdca"});
//        obj.longestStringChain_DP_Memoization(new String[]{"l", "mn", "op", "qrst"}); //any string can be a single lengthed chain = 1
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Sum Circular Subarray");
//        //https://leetcode.com/problems/maximum-sum-circular-subarray
//        obj.maximumSumCircularSubarray(new int[]{5, -1, -2, 5});
//        obj.maximumSumCircularSubarray(new int[]{-1, 5, 5, -2});
//        obj.maximumSumCircularSubarray(new int[]{-4, -3, -2, -1});
//        System.out.println("Maximum Absolute Sum of Any Subarray");
//        //https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
//        obj.maxAbsoluteSumOfAnySubarray(new int[]{1, -3, 2, 3, -4});
//        obj.maxAbsoluteSumOfAnySubarray(new int[]{2, -5, 1, -4, 3, -2});
//        obj.maxAbsoluteSumOfAnySubarray2(new int[]{1, -3, 2, 3, -4});
//        obj.maxAbsoluteSumOfAnySubarray2(new int[]{2, -5, 1, -4, 3, -2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find town judge Graph");
//        //https://leetcode.com/problems/find-the-town-judge/
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(2, new int[][]{{1, 2}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(3, new int[][]{{1, 3}, {2, 3}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(3, new int[][]{{1, 3}, {2, 3}, {3, 1}}));
//        System.out.println("Judge is : " + obj.findTownJudge_Graph(4, new int[][]{{1, 2}, {2, 3}, {3, 4}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check if a Parentheses String Can Be Valid");
//        //https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid("))()))", "010100"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid(")))(((", "001100"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid("()()", "0000"));
//        System.out.println("Valid parenthesis possible: " + obj.checkIfParenthesisStringCanBeValid(")", "0"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest Odd Number in String");
//        //https://leetcode.com/problems/largest-odd-number-in-string/
//        obj.largestOddNumInGivenNumString("52");
//        obj.largestOddNumInGivenNumString("4206");
//        obj.largestOddNumInGivenNumString("864278642");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Non-decreasing Array");
//        //https://leetcode.com/problems/non-decreasing-array/
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2, 3}));
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2}));
//        System.out.println("Non decreasing array with atmost one element change possible: "
//                + obj.nonDecreasingArrayWithAtmostOneChange(new int[]{4, 2, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Surrounded Regions");
//        //https://leetcode.com/problems/surrounded-regions/
//        //https://leetcode.com/problems/number-of-enclaves/
//        obj.surroundedRegions_Graph(new char[][]{
//            {'X', 'X', 'X', 'X'},
//            {'X', 'O', 'O', 'X'},
//            {'X', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'X'}});
//        obj.surroundedRegions_Graph(new char[][]{
//            {'X', 'O', 'X', 'X', 'X'},
//            {'X', 'O', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'O', 'X'},
//            {'X', 'O', 'X', 'X', 'X'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Increasing Path in a Matrix");
//        //https://leetcode.com/problems/longest-increasing-path-in-a-matrix/
//        obj.longestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(new int[][]{
//            {9, 9, 4}, {6, 6, 8}, {2, 1, 1}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Increasing Paths In A Matrix");
//        //https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/
//        obj.numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(new int[][]{{1, 1}, {3, 4}});
//        obj.numberOfLongestIncreasingPathInMatrixFromAnyPoint_Graph_Memoization(new int[][]{{1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Two Sum/ Two Sum II - Input Array Is Sorted/ Four Sum");
//        //https://leetcode.com/problems/two-sum/
//        //https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
//        obj.twoSum_UnsortedArray(new int[]{2, 7, 11, 15}, 9);
//        obj.twoSum_UnsortedArray(new int[]{3, 2, 4}, 6);
//        obj.twoSum2_SortedArray(new int[]{2, 7, 11, 15}, 9);
//        obj.twoSum2_SortedArray(new int[]{-1, 0}, -1);
//        System.out.println("3Sum");
//        //https://leetcode.com/problems/3sum/
//        obj.threeSum(new int[]{-1, 0, 1, 2, -1, -4});
//        obj.threeSum(new int[]{0, 1, 1});
//        obj.threeSum(new int[]{0, 0, 0});
//        obj.threeSum(new int[]{0}); //no trplet sum is possible
//        obj.threeSum(new int[]{});
//        System.out.println("3Sum Closest");
//        //https://leetcode.com/problems/3sum-closest/
//        System.out.println("3Sum closest diff to target: " + obj.threeSumClosest(new int[]{-1, 2, 1, -4}, 1));
//        System.out.println("3Sum closest diff to target: " + obj.threeSumClosest(new int[]{0, 0, 0}, 1));
//        System.out.println("Four Sum");
//        //https://leetcode.com/problems/4sum/
//        obj.fourSum(new int[]{1, 0, -1, 0, -2, 2}, 0);
//        obj.fourSum(new int[]{2, 2, 2, 2, 2}, 8);
//        obj.fourSum_WithThreeSumApproach(new int[]{1, 0, -1, 0, -2, 2}, 0);
//        obj.fourSum_WithThreeSumApproach(new int[]{2, 2, 2, 2, 2}, 8);
//        obj.fourSum_WithThreeSumApproach(new int[]{1000000000, 1000000000, 1000000000, 1000000000}, -294967296);
//        System.out.println("Four Sum II");
//        //https://leetcode.com/problems/4sum-ii/description/
//        obj.fourSumTwo(new int[]{1, 2}, new int[]{-2, -1}, new int[]{-1, 2}, new int[]{0, 2});
//        obj.fourSumTwo(new int[]{0}, new int[]{0}, new int[]{0}, new int[]{0});
//        obj.fourSumTwo(new int[]{-1, -1}, new int[]{-1, 1}, new int[]{-1, 1}, new int[]{1, -1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Smallest String With A Given Numeric Value");
//        //https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/
//        obj.smallestStringWithGivenLengthNAndCharSumValueK(3, 27);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Replace All ?'s to Avoid Consecutive Repeating Characters");
//        //https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("?zs");
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("ubv?w");
//        obj.replaceAllQuestionMarksWithACharAndNoConsecutiveRepeatingChar("?z?a?");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Simplify Path");
//        //https://leetcode.com/problems/simplify-path/
//        //https://leetcode.com/problems/crawler-log-folder/
//        System.out.println("Canonical path: " + obj.simplifyPath("/home/"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/../"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/home///foo/./bar/zoo/./../"));
//        System.out.println("Canonical path: " + obj.simplifyPath("/a//b////c/d//././/.."));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Length of Subarray With Positive Product");
//        //https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{1, -2, -3, 4}); //lenght = 4 as 1 * -2 * -3 * 4 > 0
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{0, 1, -2, -3, -4});
//        obj.maximumLengthOfSubarrayWithPositiveProduct(new int[]{-1, 8, 8, -2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Swim in Rising Water");
//        //https://leetcode.com/problems/swim-in-rising-water/
//        System.out.println("Time taken to swim in rising water to bottom-right corner: "
//                + obj.swimInRisingWater_Graph(new int[][]{
//            {0, 2}, {1, 3}}));
//        System.out.println("Time taken to swim in rising water to bottom-right corner: "
//                + obj.swimInRisingWater_Graph(new int[][]{
//            {0, 1, 2, 3, 4},
//            {24, 23, 22, 21, 5},
//            {12, 13, 14, 15, 16},
//            {11, 17, 18, 19, 20},
//            {10, 9, 8, 7, 6}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Path With Minimum Effort");
//        //https://leetcode.com/problems/path-with-minimum-effort/
//        System.out.println("Path with min efforts: "
//                + obj.pathWithMinEffort_Graph(new int[][]{{1, 2, 2}, {3, 8, 2}, {5, 3, 5}}));
//        System.out.println("Path with min efforts: "
//                + obj.pathWithMinEffort_Graph(new int[][]{
//            {1, 2, 1, 1, 1},
//            {1, 2, 1, 2, 1},
//            {1, 2, 1, 2, 1},
//            {1, 2, 1, 2, 1},
//            {1, 1, 1, 2, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Common Characters");
//        //https://leetcode.com/problems/find-common-characters/
//        //https://leetcode.com/problems/intersection-of-two-arrays-ii/
//        //https://leetcode.com/problems/find-the-difference-of-two-arrays/
//        obj.findCommonCharacters(new String[]{"bella", "label", "roller"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Word Subsets");
//        //https://leetcode.com/problems/word-subsets/
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"e", "o"});
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"e", "l"});
//        obj.wordSubsets(new String[]{"amazon", "apple", "facebook", "google", "leetcode"}, new String[]{"ama", "o"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Interval to Include Each Query");
//        //https://leetcode.com/problems/minimum-interval-to-include-each-query/
//        obj.minimumIntervalToIncludeEachQuery(new int[][]{
//            {1, 4}, {2, 4}, {3, 6}, {4, 4}}, new int[]{2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Three Consecutive Integers That Sum to a Given Number");
//        //https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/
//        obj.threeConsecutiveNumberThatSumsToGivenNumber(33);
//        obj.threeConsecutiveNumberThatSumsToGivenNumber(4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Merge Nodes in Between Zeros");
//        //https://leetcode.com/problems/merge-nodes-in-between-zeros/
//        Node<Integer> head = new Node<>(0);
//        head.setNext(new Node<>(3));
//        head.getNext().setNext(new Node<>(1));
//        head.getNext().getNext().setNext(new Node<>(0));
//        head.getNext().getNext().getNext().setNext(new Node<>(4));
//        head.getNext().getNext().getNext().getNext().setNext(new Node<>(5));
//        head.getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(2));
//        head.getNext().getNext().getNext().getNext().getNext().getNext().setNext(new Node<>(0));
//        obj.mergeNodesInBetweenZeros(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Search Suggestions System");
//        //https://leetcode.com/problems/search-suggestions-system/
//        obj.searchSuggestionSystem(new String[]{"mobile", "mouse", "moneypot", "monitor", "mousepad"}, "mouse");
//        //https://practice.geeksforgeeks.org/problems/phone-directory4628/1
//        obj.searchSuggestionSystem_TrieBased(new String[]{"mobile", "mouse", "moneypot", "monitor", "mousepad"}, "mouse");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum length prefix of one string that occurs as subsequence in another");
//        //https://www.geeksforgeeks.org/maximum-length-prefix-one-string-occurs-subsequence-another/?ref=rp
//        obj.maximumLengthOfSubstringThatExistsAsSubseqInOtherString("biggerdiagram", "digger");
//        obj.maximumLengthOfSubstringThatExistsAsSubseqInOtherString("abcdef", "xyz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Is Subsequence");
//        //https://leetcode.com/problems/is-subsequence/
//        //https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/
//        //https://practice.geeksforgeeks.org/problems/find-patterns0606/1
//        System.out.println("Is string curr exists as any subseq in main: "
//                + obj.isSubsequence("ahbgdc", "abc"));
//        //whole digger string doesn't exists as any subseq in main string
//        System.out.println("Is string curr exists as any subseq in main: "
//                + obj.isSubsequence("biggerdiagram", "digger"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT MY GOOGLE INTERVIEW QUESTION
//        System.out.println("Minimum partitions in curr string where its prefix exists as subseq in main string");
//        obj.partitionsInCurrStringWherePrefixExistsAsSubseqInMainString("aaaabbc", "aacbbabc");
//        obj.partitionsInCurrStringWherePrefixExistsAsSubseqInMainString("aaaabbc", "lmno");
//        obj.partitionsInCurrStringWherePrefixExistsAsSubseqInMainString("aaaabbc", "abcbbabc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Matching Subsequences");
//        //https://leetcode.com/problems/number-of-matching-subsequences/
//        obj.numberOfMatchingSubseq("abcde", new String[]{"a", "bb", "acd", "ace"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Append Characters to String to Make Subsequence");
//        //https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/
//        obj.appendCharsToMakeStringSubseq("coaching", "coding");
//        obj.appendCharsToMakeStringSubseq("abcde", "a");
//        obj.appendCharsToMakeStringSubseq("z", "abcde");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary Tree Cameras");
//        //https://leetcode.com/problems/binary-tree-cameras/
//        TreeNode<Integer> root1 = new TreeNode<>(0);
//        root1.setLeft(new TreeNode<>(0));
//        root1.getLeft().setLeft(new TreeNode<>(0));
//        root1.getLeft().setRight(new TreeNode<>(0));
//        obj.binaryTreeCameras(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Convert Sorted Array to Height Balanced Binary Search Tree");
//        //https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/
//        obj.convertSortedArrayToHeightBalancedBinarySearchTree(new int[]{-10, -3, 0, 5, 9});
//        obj.convertSortedArrayToHeightBalancedBinarySearchTree(new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Arrows to Burst Balloons");
//        //https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {1, 6}, {7, 12}});
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {10, 16}, {2, 8}, {1, 6}, {7, 12}});
//        obj.minimumArrowsToBurstBalloons_Greedy(new int[][]{
//            {1, 2}, {3, 4}, {5, 6}, {7, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Triangle - minimum path sum from top to bottom");
//        //https://leetcode.com/problems/triangle/
//        List<List<Integer>> triangle = new ArrayList<>();
//        triangle.add(Arrays.asList(2));
//        triangle.add(Arrays.asList(3, 4));
//        triangle.add(Arrays.asList(6, 5, 7));
//        triangle.add(Arrays.asList(4, 1, 8, 3));
//        System.out.println("Min path sum top to bottom in triangle 2d matrix: "
//                + obj.triangleMinPathSumTopToBottom(triangle));
//        triangle = new ArrayList<>();
//        triangle.add(Arrays.asList(2));
//        System.out.println("Min path sum top to bottom in triangle 2d matrix: "
//                + obj.triangleMinPathSumTopToBottom(triangle));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Path Sum In The Matrix - From Any Value In First Row To Any Col In Last Row");
//        //https://www.codingninjas.com/codestudio/problems/maximum-path-sum-in-the-matrix_797998?leftPanelTab=0
//        System.out.println("Max path sum in matrix from any col in top row to any col in last row: "
//                + obj.maxPathSumInMatrixFromFirstRowToLastRow(new int[][]{
//            {1, 2, 10, 4},
//            {100, 3, 2, 1},
//            {1, 1, 20, 2},
//            {1, 2, 2, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Candy Distribution");
//        //https://leetcode.com/problems/candy/
//        obj.candyDistributionToNStudent(new int[]{1, 0, 2}); //EASY UNDERSTANDING
//        obj.candyDistributionToNStudent2(new int[]{1, 0, 2}); //SPACE OPTIMISED
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array Such That Maximum Difference Is K");
//        //https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/
//        obj.partitionArrSuchThatMaxDiffIsK_Greedy(new int[]{3, 6, 1, 2, 5}, 2);
//        obj.partitionArrSuchThatMaxDiffIsK_Greedy(new int[]{2, 2, 4, 5}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Triangular Sum of an Array");
//        //https://leetcode.com/problems/find-triangular-sum-of-an-array/
//        //https://leetcode.com/problems/min-max-game/
//        obj.findTriangularSumOfArray(new int[]{1, 2, 3, 4, 5});
//        obj.findTriangularSumOfArray(new int[]{5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fair Distribution of Cookies");
//        //https://leetcode.com/problems/fair-distribution-of-cookies/
//        obj.minimumUnfairDistributionOfCookiesToKStudent_Backtracking(new int[]{8, 15, 10, 20, 8}, 2);
//        obj.minimumUnfairDistributionOfCookiesToKStudent_Backtracking(new int[]{6, 1, 3, 2, 2, 4, 1, 2}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("132 Pattern");
//        //https://leetcode.com/problems/132-pattern/
//        System.out.println("132 Pattern: " + obj.has132Pattern(new int[]{1, 2, 3, 4}));
//        System.out.println("132 Pattern: " + obj.has132Pattern(new int[]{3, 1, 4, 2}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Swaps to Make the String Balanced");
//        //https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
//        obj.minimumSwapsToMakeParenthesisStringBalanced("][][");
//        obj.minimumSwapsToMakeParenthesisStringBalanced("]]][[[");
//        obj.minimumSwapsToMakeParenthesisStringBalanced("[[]][]");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Add to Make Parentheses Valid");
//        //https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/
//        obj.minimumAdditionsToMakeParenthesisStringValid("())");
//        obj.minimumAdditionsToMakeParenthesisStringValid("(())");
//        obj.minimumAdditionsToMakeParenthesisStringValid(")))(((");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Furthest Building You Can Reach");
//        //https://leetcode.com/problems/furthest-building-you-can-reach/
//        System.out.println("Index of the farthest building we can reach: "
//                + obj.farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(new int[]{4, 2, 7, 6, 9, 14, 12}, 5, 1));
//        System.out.println("Index of the farthest building we can reach: "
//                + obj.farthestBuildingWeCanReachUsingBricksAndLadders_Greedy(new int[]{1, 5, 1, 2, 3, 4, 10000}, 4, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Verifying an Alien Dictionary");
//        //https://leetcode.com/problems/verifying-an-alien-dictionary/
//        System.out.println("Alien word dict are sorted acc to alien aplhabet: "
//                + obj.areAlienWordsSorted(new String[]{"hello", "leetcode"}, "hlabcdefgijkmnopqrstuvwxyz"));
//        System.out.println("Alien word dict are sorted acc to alien aplhabet: "
//                + obj.areAlienWordsSorted(new String[]{"apple", "app"}, "abcdefghijklmnopqrstuvwxyz"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Detect Squares");
//        //https://leetcode.com/problems/detect-squares/
//        List<int[]> points = Arrays.asList(
//                new int[]{3, 10},
//                new int[]{11, 2},
//                new int[]{3, 2}
//        );
//        List<int[]> queryPoints = Arrays.asList(
//                new int[]{11, 10},
//                new int[]{14, 8}
//        );
//        obj.detectSquares(points, queryPoints);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Amount To Paint The Area");
//        //https://leetcode.com/problems/amount-of-new-area-painted-each-day/
//        //https://algo.monster/liteproblems/2158
//        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
//        //https://leetcode.com/discuss/interview-question/2072036/Google-or-Onsite-or-banglore-or-May-2022-or-Paint-a-line
//        obj.amountToPaintTheArea(new int[][]{
//            {4, 10}, {7, 13}, {16, 20}, {1, 40}});
//        obj.amountToPaintTheArea2(new int[][]{
//            {4, 10}, {7, 13}, {16, 20}, {1, 40}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Process Tasks Using Servers / Find Servers That Handled Most Number of Requests");
//        //https://leetcode.com/problems/process-tasks-using-servers
//        //https://www.geeksforgeeks.org/google-interview-experience-for-software-engineer-l3-bangalore-6-years-experienced/
//        //https://leetcode.com/discuss/interview-question/2072047/Google-or-Onsite-or-Banglore-or-May-2022-or-Patient-Queue
//        obj.serverAllocationToTasks(new int[]{3, 3, 2}, new int[]{1, 2, 3, 2, 1, 2});
//        //https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3, 4, 5}, new int[]{5, 2, 3, 3, 3});
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3, 4}, new int[]{1, 2, 1, 2});
//        obj.serversThatHandledMostRequests(2, new int[]{1, 2, 3, 4}, new int[]{1, 2, 1, 2});
//        obj.serversThatHandledMostRequests(3, new int[]{1, 2, 3}, new int[]{10, 12, 11});
//        System.out.println("Meeting Room Three / Find Max Patient Treated In Any Given N Rooms");
//        //https://leetcode.com/problems/meeting-rooms-iii/
//        obj.meetingRoomsThree(2, new int[][]{{0, 10}, {1, 5}, {2, 7}, {3, 4}});
//        obj.meetingRoomsThree(3, new int[][]{{1, 20}, {2, 10}, {3, 5}, {4, 9}, {6, 8}});
//        // room 2 as (1,2) will be alloted first and will go first then (6,4) will be alloted
//        obj.maxPatientTreatedInGivenInAnyNRoom(new int[][]{
//            {1, 8}, {1, 2}, {6, 4}}, 2);
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("DI String Match/ Construct Smallest Number From DI String");
//        //https://leetcode.com/problems/di-string-match/
//        obj.generateNumberFollowingPattern("D");
//        obj.generateNumberFollowingPattern("IIDDD");
//        obj.generateNumberFollowingPattern("IDID");
//        obj.generateNumberFollowingPattern("III");
//        obj.generateNumberFollowingPattern("DDI");
//        //https://leetcode.com/problems/construct-smallest-number-from-di-string/
//        obj.generateSmallestNumberFromDIString("D");
//        obj.generateSmallestNumberFromDIString("IIIDIDDD");
//        obj.generateSmallestNumberFromDIString("DDD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Pacific Atlantic Water Flow");
//        //https://leetcode.com/problems/pacific-atlantic-water-flow/
//        obj.pacificAtlanticWaterFlow(new int[][]{
//            {1, 2, 2, 3, 5},
//            {3, 2, 3, 4, 4},
//            {2, 4, 5, 3, 1},
//            {6, 7, 1, 4, 5},
//            {5, 1, 1, 2, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Mth Element After K Array Rotation");
//        //https://www.geeksforgeeks.org/cpp-program-to-find-the-mth-element-of-the-array-after-k-left-rotations/
//        obj.mThElementAfterKArrayRotation(new int[]{1, 2, 3, 4, 5}, 2, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("The Skyline Problem");
//        //https://leetcode.com/problems/the-skyline-problem/
//        obj.skylineProblem(new int[][]{
//            {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
//        });
//        //OPTIMIZED with tree map
//        obj.skylineProblem_TreeMap(new int[][]{
//            {2, 9, 10}, {3, 7, 15}, {5, 12, 12}, {15, 20, 10}, {19, 24, 8}
//        });
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Angle Between Hands of a Clock");
//        //https://leetcode.com/problems/angle-between-hands-of-a-clock/
//        obj.minAngleBetweeHourAndMinuteHands(12, 30);
//        obj.minAngleBetweeHourAndMinuteHands(2, 60); // 3:00
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Inserts/ Deletes To Make String Pallindrome");
//        //https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
//        //https://www.geeksforgeeks.org/java-program-to-find-minimum-insertions-to-form-a-palindrome-dp-28/
//        obj.minInsertsToMakeStringPallindrome_DP_Memoization("abcda"); //insert d,b like this abdcdba
//        obj.minInsertsToMakeStringPallindrome_DP_Memoization("aba");
//        obj.minDeletesToMakeStringPallindrome_DP_Memoization("abcda"); //deletes d,b like this aca
//        obj.minDeletesToMakeStringPallindrome_DP_Memoization("aba");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize sum of given array after removing valleys");
//        //https://www.geeksforgeeks.org/maximize-sum-of-given-array-after-removing-valleys/
//        obj.maximizeSumAfterRemovingValleys(new int[]{5, 1, 8}); //valley removed [1,1,8] = 10
//        obj.maximizeSumAfterRemovingValleys(new int[]{8, 1, 10, 1, 8}); // valley removed [1,1,10,1,1] = 14
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Moves to Make Palindrome");
//        //https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/
//        // a_swap(a,b)_b ==> abab ==> swap(a,b)_ab ==> baab == pallindrome in 2 swaps
//        obj.minMovesToMakeStringPallindrome("aabb");
//        obj.minMovesToMakeStringPallindrome("zzazz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Largest 3-Same-Digit Number in String");
//        //https://leetcode.com/problems/largest-3-same-digit-number-in-string/
//        obj.largestThreeSameDigitNumInString("6777133339");
//        obj.largestThreeSameDigitNumInString("2300019");
//        obj.largestThreeSameDigitNumInString("42352338");
//        obj.largestThreeSameDigitNumInString("00042352338");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Visible People in a Queue");
//        //https://leetcode.com/problems/number-of-visible-people-in-a-queue/
//        obj.numberOfVisiblePeopleInQueue(new int[]{10, 6, 8, 5, 11, 9});
//        obj.numberOfVisiblePeopleInQueue(new int[]{5, 1, 2, 3, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Min Cost to Connect All Points/ Prim's Algo Based");
//        //https://leetcode.com/problems/min-cost-to-connect-all-points/
//        obj.minCostToConnectAllPoints_Graph(new int[][]{
//            {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}});
//        obj.minCostToConnectAllPoints_Graph(new int[][]{
//            {3, 12}, {-2, 5}, {-4, 1}});
//        obj.minCostToConnectAllPoints_Graph_UnionFind(new int[][]{
//            {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0}});
//        obj.minCostToConnectAllPoints_Graph_UnionFind(new int[][]{
//            {3, 12}, {-2, 5}, {-4, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Split Array Largest Sum");
//        //https://leetcode.com/problems/split-array-largest-sum/
//        obj.splitArrayInLargestSum(new int[]{7, 2, 5, 10, 8}, 2);
//        obj.splitArrayInLargestSum(new int[]{1, 2, 3, 4, 5}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Capacity To Ship Packages Within D Days");
//        //https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
//        //https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store
//        obj.shipWeightsWithinGivenDays(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 1);
//        obj.shipWeightsWithinGivenDays(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5);
//        obj.shipWeightsWithinGivenDays(new int[]{3, 2, 2, 4, 1, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize Page Allocations To Students");
//        //https://www.interviewbit.com/problems/allocate-books/
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 2);
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 1);
//        obj.minimizePageAllocationsToStudents(new int[]{12, 34, 67, 90}, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Koko Eating Bananas");
//        //https://leetcode.com/problems/koko-eating-bananas/
//        obj.kokoEatingBananas(new int[]{3, 6, 7, 11}, 8);
//        obj.kokoEatingBananas(new int[]{30, 11, 23, 4, 20}, 5);
//        obj.kokoEatingBananas(new int[]{30, 11, 23, 4, 20}, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Cake Distribution Problem");
//        //https://practice.geeksforgeeks.org/problems/0a7c7f1089932257071f9fa076f25d353f91e0fd/1
//        obj.cakeDistributionMaxSweetnessAmongKFriends(new int[]{6, 3, 2, 8, 7, 5}, 2);
//        obj.cakeDistributionMaxSweetnessAmongKFriends(new int[]{1, 2, 4, 7, 3, 6, 9}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Subsequence of Length K With the Largest Sum");
//        //https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/
//        obj.subseqOfLengthKWithLargestSum(new int[]{2, 1, 3, 3}, 2);
//        obj.subseqOfLengthKWithLargestSum(new int[]{-1, -2, 3, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Flips to Make the Binary String Alternating");
//        //https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
//        obj.minFlipsToMakeBinaryStringAlternating("111000");
//        obj.minFlipsToMakeBinaryStringAlternating("010");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("12 Color Card Possible");
//        //https://leetcode.com/discuss/interview-experience/2279548/Google-or-Phone-Screen-or-Question-or-India
//        obj.cardOf12();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Paint Fence");
//        //https://www.geeksforgeeks.org/painting-fence-algorithm/
//        obj.paintFence_DP_Memoization(1, 2);
//        obj.paintFence_DP_Memoization(2, 2);
//        obj.paintFence_DP_Memoization(3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range Addition II");
//        //https://leetcode.com/problems/range-addition-ii/
//        obj.rangeAdditionTwo(3, 3, new int[][]{});
//        obj.rangeAdditionTwo(3, 3, new int[][]{{2,2},{3,3}});
//        System.out.println("Smallest Rectangle Enclosing Black Pixels");
//        //https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/
//        obj.smallestRectangleEnclosingBlackPixels(new int[][]{
//            {0, 0, 1, 0}, {0, 1, 1, 0}, {0, 1, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Jump game(s)");
//        //https://leetcode.com/problems/jump-game/
//        obj.jumpGame(new int[]{2, 3, 1, 1, 4});
//        obj.jumpGame(new int[]{3, 2, 1, 0, 4});
//        obj.jumpGame(new int[]{1});
//        obj.jumpGame(new int[]{0});
//        //https://leetcode.com/problems/jump-game-ii/description/
//        obj.jumpGameTwo(new int[]{2, 3, 1, 1, 4});
//        obj.jumpGameTwo(new int[]{2, 3, 0, 1, 4});
//        //https://leetcode.com/problems/jump-game-iii/
//        obj.jumpGameThree(new int[]{4, 2, 3, 0, 3, 1, 2}, 5);
//        obj.jumpGameThree(new int[]{3, 0, 2, 1, 2}, 2);
//        //https://leetcode.com/problems/jump-game-iv/
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{100, -23, -23, 404, 100, 23, 23, 23, 3, 404}));
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{7}));
//        System.out.println("Steps to reach end: "
//                + obj.jumpGameFour(new int[]{7, 6, 9, 6, 9, 6, 9, 7}));
//        //https://leetcode.com/problems/jump-game-vii/
//        System.out.println("Can we reach end of str: " + obj.jumpGameSeven("011010", 2, 3));
//        System.out.println("Can we reach end of str: " + obj.jumpGameSeven("01101110", 2, 3));
//        //https://leetcode.com/problems/frog-jump/
//        System.out.println("Frog can reach the end of river: " + obj.frogJump(new int[]{0, 1, 3, 5, 6, 8, 12, 17}));
//        System.out.println("Frog can reach the end of river: " + obj.frogJump(new int[]{0, 1, 2, 3, 4, 8, 9, 11}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Djikstra Algorithm Graph");
//        obj.djikstraAlgorithm_Graph();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Network Delay Time");
//        //https://leetcode.com/problems/network-delay-time/
//        obj.networkTimeDelay_Graph(new int[][]{{2, 1, 1}, {2, 3, 1}, {3, 4, 1}}, 4, 2);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}}, 2, 1);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}}, 2, 2);
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 1}, {2, 1, 1}}, 2, 1);
//        //max network delay is 100 because max time it will take from 1 to 2 
//        //and other nodes will take 1 unit time each 
//        obj.networkTimeDelay_Graph(new int[][]{{1, 2, 100}, {1, 3, 1}, {3, 4, 1}, {4, 5, 1}, {5, 6, 1}}, 6, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Task Schedular");
//        //https://leetcode.com/problems/task-scheduler/
//        obj.taskSchedular_Greedy(new char[]{'A', 'A', 'A', 'B', 'B', 'B'}, 2);
//        obj.taskSchedular_Greedy(new char[]{'A', 'A', 'A', 'B', 'B', 'B'}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If A Move Is Legal");
//        //https://leetcode.com/problems/check-if-move-is-legal/
//        obj.checkIfMoveIsLegal(
//                new String[][]{
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."},
//                    {"W", "B", "B", ".", "W", "W", "W", "B"},
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "B", ".", ".", ".", "."},
//                    {".", ".", ".", "W", ".", ".", ".", "."}
//                }, 4, 3, "B"
//        );
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Island Perimeter");
//        //https://leetcode.com/problems/island-perimeter/
//        obj.islandPerimeter(new int[][]{{0, 1, 0}, {0, 1, 0}});
//        obj.islandPerimeter(new int[][]{{1, 1, 0}});
//        obj.islandPerimeter(new int[][]{
//            {0, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 0, 0}, {1, 1, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Decode String");
//        //https://leetcode.com/problems/decode-string/
//        obj.decodedString("3[a]2[bc]");
//        obj.decodedString("3[a2[c]]");
//        obj.decodedString("2[abc]3[cd]ef");
//        obj.decodedString("20[abc]3[cd]ef");
//        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Substrings Between Each Pair of Parentheses");
//        //https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
//        obj.reverseSubstringsBetweenParenthesis("(abcd)");
//        obj.reverseSubstringsBetweenParenthesis("(u(love)i)");
//        obj.reverseSubstringsBetweenParenthesis("(ed(et(oc))el)");
//        obj.reverseSubstringsBetweenParenthesis("a(bcdefghijkl(mno)p)q");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Valid Palindrome II");
//        //https://leetcode.com/problems/valid-palindrome-ii/
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("abc"));
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("aba"));
//        System.out.println("Valid pallindrome two: " + obj.validPallindromeTwo("abca"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Decode Ways DP Problem");
//        //https://leetcode.com/problems/decode-ways/
//        obj.decodeWays_Recursive_Memoization("12");
//        obj.decodeWays_Recursive_Memoization("226");
//        obj.decodeWays_Recursive_Memoization("06");
//        obj.decodeWays_Recursive_Memoization("11106");
//        obj.decodeWays_DP_Memoization("12");
//        obj.decodeWays_DP_Memoization("226");
//        obj.decodeWays_DP_Memoization("06");
//        obj.decodeWays_DP_Memoization("11106");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Two City Scheduling");
//        //https://leetcode.com/problems/two-city-scheduling/
//        obj.twoCityScheduling_Greedy(new int[][]{
//            {10, 20}, {30, 200}, {400, 50}, {30, 20}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT MY GOOGLE ONSITE INTERVIEW
//        System.out.println("Filling Bookcase Shelves");
//        //https://leetcode.com/problems/filling-bookcase-shelves/
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 1}, {3, 1}}, 4);
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 1}, {2, 3}, {2, 3}, {1, 1}, {1, 1}, {1, 1}, {1, 2}}, 4);
//        obj.fillingBooksInShelves_DP_Recusrive_Memoization(new int[][]{
//            {1, 3}, {2, 4}, {3, 2}}, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Perfect Squares");
//        //https://leetcode.com/problems/perfect-squares
//        //possible perfect sqrs that sum upto 12
//        //1. sqr(3) + sqr(1) + sqr(1) + sqr(1) ==> 9 + 1 + 1 + 1 == 12
//        //2. sqr(2) + sqr(2) + sqr(2) ==> 4 + 4 + 4 == 12 also this is MIN hence our result
//        obj.perfectSquares_DP_Recursive_Memoization(12);
//        obj.perfectSquares_DP_Recursive_Memoization(13);
//        obj.perfectSquares_DP_Recursive_Memoization(1);
//        //TLE on leetcode
//        obj.perfectSquares_DP_Memoization(12);
//        obj.perfectSquares_DP_Memoization(13);
//        obj.perfectSquares_DP_Memoization(1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Out of Boundary Paths");
//        //https://leetcode.com/problems/out-of-boundary-paths/
//        obj.outOfBoundaryPaths_DP_Recursive_Memoization(2, 2, 2, 0, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Range Sum Query (1D/ 2D) - Immutable");
//        //https://leetcode.com/problems/range-sum-query-immutable/
//        //https://leetcode.com/problems/range-sum-query-2d-immutable/
//        obj.rangeSumQueries_BruteForce(
//                new int[]{-2, 0, 3, -5, 2, -1},
//                new int[][]{{0, 2}, {2, 5}, {0, 5}});
//        obj.rangeSumQueries(
//                new int[]{-2, 0, 3, -5, 2, -1},
//                new int[][]{{0, 2}, {2, 5}, {0, 5}});
//        obj.rangeSumQuery2D(
//                new int[][]{
//                    {3, 0, 1, 4, 2},
//                    {5, 6, 3, 2, 1},
//                    {1, 2, 0, 1, 5},
//                    {4, 1, 0, 1, 7},
//                    {1, 0, 3, 0, 5}},
//                new int[][]{
//                    {0, 0, 4, 4},
//                    {2, 1, 4, 3},
//                    {1, 1, 2, 2},
//                    {1, 2, 2, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Binary Search Tree Iterator");
//        //https://leetcode.com/problems/binary-search-tree-iterator
//        TreeNode<Integer> root1 = new TreeNode<>(2);
//        root1.setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(3));
//        obj.binarySearchTreeIterator(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition to K Equal Sum Subsets");
//        //https://leetcode.com/problems/partition-to-k-equal-sum-subsets/
//        System.out.println("Partition to K equal subset sum possible: "
//                + obj.partitionToKEqualSumSubset_Backtracking(new int[]{4, 3, 2, 3, 5, 2, 1}, 4));
//        System.out.println("Partition to K equal subset sum possible: "
//                + obj.partitionToKEqualSumSubset_Backtracking(new int[]{1, 2, 3, 4}, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Implement Increamental Stack");
//        obj.implementIncreamentalStack();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("N-Queens");
//        //https://leetcode.com/problems/n-queens/
//        //https://leetcode.com/problems/n-queens-ii/
//        obj.nQueens_Backtracking(1);
//        obj.nQueens_Backtracking(4);
//        obj.nQueens_Backtracking(9);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sudoku Solver");
//        //https://leetcode.com/problems/sudoku-solver
//        obj.sudokuSolver_Backtracking(new char[][]{
//            {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
//            {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
//            {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
//            {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
//            {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
//            {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
//            {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
//            {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
//            {'.', '.', '.', '.', '8', '.', '.', '7', '9'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Linked List in Binary Tree");
//        //https://leetcode.com/problems/linked-list-in-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().getLeft().getRight().setRight(new TreeNode<>(3));
//        Node<Integer> head = new Node<>(4);
//        head.setNext(new Node<>(2));
//        head.getNext().setNext(new Node<>(8));
//        obj.linkedListInBinaryTree(head, root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Text Justification");
//        //https://leetcode.com/problems/text-justification/
//        obj.textJustification(new String[]{"This", "is", "an", "example", "of", "text", "justification."}, 16);
//        obj.textJustification(new String[]{"What", "must", "be", "acknowledgment", "shall", "be"}, 16);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Positions of Large Groups");
//        //https://leetcode.com/problems/positions-of-large-groups/
//        obj.positionsOfLargeGroups("abbxxxxzzy");
//        obj.positionsOfLargeGroups("aaa");
//        obj.positionsOfLargeGroups("abc");
//        obj.positionsOfLargeGroups("nnnhaaannnm");
//        obj.positionsOfLargeGroups_Optimized("abbxxxxzzy");
//        obj.positionsOfLargeGroups_Optimized("aaa");
//        obj.positionsOfLargeGroups_Optimized("abc");
//        obj.positionsOfLargeGroups_Optimized("nnnhaaannnm");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Frog Jump DP Problem");
//        //https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0
//        obj.frogJump_Recursive_And_Memoization(new int[]{10, 20, 30, 10});
//        obj.frogJump_DP_Memoization(new int[]{10, 20, 30, 10});
//        obj.frogJump_DP_Memoization_SpaceOptimization(new int[]{10, 20, 30, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Ninja’s Training");
//        //https://www.codingninjas.com/codestudio/problems/ninja-s-training_3621003?leftPanelTab=0
//        obj.ninjaTraining_Recursive_And_Memoization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_Recursive_And_Memoization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
//        obj.ninjaTraining_DP_Memoization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_DP_Memoization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
//        obj.ninjaTraining_DP_Memoization_SpaceOptimization(new int[][]{
//            {1, 2, 5}, {3, 1, 1}, {3, 3, 3}});
//        obj.ninjaTraining_DP_Memoization_SpaceOptimization(new int[][]{
//            {10, 40, 70}, {20, 50, 80}, {30, 60, 90}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Partition Array According to Given Pivot");
//        //https://leetcode.com/problems/partition-array-according-to-given-pivot/
//        //https://leetcode.com/problems/rearrange-array-elements-by-sign
//        obj.partitionArrayOnGivenPivot(new int[]{9, 12, 5, 10, 14, 3, 10}, 10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print Binary Tree In String Array Format");
//        //https://leetcode.com/problems/print-binary-tree/
//        TreeNode<Integer> root1 = new TreeNode<>(1);
//        root1.setLeft(new TreeNode<>(4));
//        root1.getLeft().setRight(new TreeNode<>(2));
//        root1.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.setRight(new TreeNode<>(4));
//        root1.getRight().setLeft(new TreeNode<>(2));
//        root1.getRight().getLeft().setLeft(new TreeNode<>(6));
//        root1.getRight().getLeft().setRight(new TreeNode<>(8));
//        root1.getRight().getLeft().getRight().setLeft(new TreeNode<>(1));
//        root1.getRight().getLeft().getRight().setRight(new TreeNode<>(3));
//        obj.printBinaryTreeInStringMatrixFormat(root1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Eventual Safe States Graph Problem");
//        //https://leetcode.com/problems/find-eventual-safe-states/
//        obj.findEventualSafeNodes_Graph(new int[][]{{1, 2}, {2, 3}, {5}, {0}, {5}, {}, {}});
//        obj.findEventualSafeNodes_Graph(new int[][]{{1, 2, 3, 4}, {1, 2}, {3, 4}, {0, 4}, {}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Provinces");
//        //https://leetcode.com/problems/number-of-provinces/
//        obj.numberOfProvince_Graph(new int[][]{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph(new int[][]{{1, 0, 1}, {0, 1, 0}, {1, 0, 1}});
//        obj.numberOfProvince_Graph(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 0, 1}, {0, 1, 0}, {1, 0, 1}});
//        obj.numberOfProvince_Graph_UnionFind(new int[][]{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Most Stones Removed with Same Row or Column");
//        //https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}, {0, 1}, {1, 0}, {1, 2}, {2, 1}, {2, 2}});
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}, {0, 2}, {1, 1}, {2, 0}, {2, 2}});
//        obj.mostStonesRemovedInSameRowCol_Graph(new int[][]{{0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distant Barcodes");
//        //https://leetcode.com/problems/distant-barcodes/
//        obj.distinctBarcodes(new int[]{1, 1, 1, 2, 2, 2});
//        obj.distinctBarcodes(new int[]{1, 1, 1, 1, 2, 2, 3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Super Washing Machines (Greedy Problem)");
//        //https://leetcode.com/problems/super-washing-machines/
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{1, 0, 5}));
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{0, 3, 0}));
//        System.out.println("Balancing clothes in machines: " + obj.superWashingMachines_Greedy(new int[]{0, 2, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K Radius Subarray Averages");
//        //https://leetcode.com/problems/k-radius-subarray-averages/
//        //https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-effort/
//        obj.kRadiusSubarrayAverages(new int[]{7, 4, 3, 9, 1, 8, 5, 2, 6}, 3);
//        obj.kRadiusSubarrayAverages(new int[]{100000}, 0);
//        obj.kRadiusSubarrayAverages(new int[]{8}, 100000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Time to Type Word Using Special Typewriter");
//        //https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/
//        obj.minTimeToType("abc");
//        obj.minTimeToType("bza");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reorder Routes to Make All Paths Lead to the City Zero");
//        //https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(6, new int[][]{{0, 1}, {1, 3}, {2, 3}, {4, 0}, {4, 5}});
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(5, new int[][]{{1, 0}, {1, 2}, {3, 2}, {3, 4}});
//        obj.reorderPathsToMakeAllCitiesReachToCityZero_Graph(3, new int[][]{{1, 0}, {2, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Next warmer day in the given weather recordings (Next greater element to right)");
//        //https://youtu.be/0mcAy91rPzE
//        //https://leetcode.com/problems/daily-temperatures/
//        obj.nextWarmerDayInTheGivenWeatherRecordings(new int[]{60, 90, 76, 80, 100, 62, 90});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Steps to Make Array Non-decreasing");
//        //https://leetcode.com/problems/steps-to-make-array-non-decreasing/
//        obj.stepsToMakeArrayNonDecreasing(new int[]{5, 3, 4, 4, 7, 3, 6, 11, 8, 5, 11});
//        obj.stepsToMakeArrayNonDecreasing(new int[]{4, 5, 7, 7, 13});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Online Stock Span");
//        //https://leetcode.com/problems/online-stock-span/
//        obj.onlineStockSpan(new int[]{100, 80, 60, 70, 60, 75, 85});
//        obj.onlineStockSpan(new int[]{4, 2, 3, 3, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Obstacle Removal to Reach Corner");
//        //https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/
//        obj.minObstaclesRemovalToReachBottomRightCorner_Graph(new int[][]{
//            {0, 1, 1}, {1, 1, 0}, {1, 1, 0}});
//        obj.minObstaclesRemovalToReachBottomRightCorner_Graph(new int[][]{
//            {0, 1, 0, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 0, 1, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Path in a Grid with Obstacles Elimination");
//        //https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
//        obj.shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
//                new int[][]{{0, 0, 0}, {1, 1, 0}, {0, 0, 0}, {0, 1, 1}, {0, 0, 0}}, 1);
//        obj.shortestPathFromTopLeftToBottomRightWithAtMostKObstacleRemoval_Graph(
//                new int[][]{{0, 1, 1}, {1, 1, 1}, {1, 0, 0}}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Height Trees");
//        //https://leetcode.com/problems/minimum-height-trees/
//        obj.minHeightTrees_Graph_BruteForce(4, new int[][]{{1, 0}, {1, 2}, {1, 3}});
//        obj.minHeightTrees_Graph_BruteForce(6, new int[][]{{3, 0}, {3, 1}, {3, 2}, {3, 4}, {5, 4}});
//        obj.minHeightTrees_Graph(4, new int[][]{{1, 0}, {1, 2}, {1, 3}});
//        obj.minHeightTrees_Graph(6, new int[][]{{3, 0}, {3, 1}, {3, 2}, {3, 4}, {5, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Vowels in a Substring of Given Length");
//        //https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
//        obj.maxVowelCountInSubstringOfKLength("abciiidef", 3);
//        //any subtring of size k == 2 will contain 2 vowels since the str is only vowels
//        obj.maxVowelCountInSubstringOfKLength("aeiou", 2);
//        //for k == 3, substring: "lee" contains vowels 2 (e, e) same for substring: "ode" 2(o ,e)
//        obj.maxVowelCountInSubstringOfKLength("leetcode", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Points You Can Obtain from Cards");
//        //https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/
//        obj.maxPointsObtainFromCards(new int[]{1, 2, 3, 4, 5, 6, 1}, 3);
//        obj.maxPointsObtainFromCards(new int[]{2, 2, 2}, 2);
//        obj.maxPointsObtainFromCards(new int[]{9, 7, 7, 9, 7, 7, 9}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Removing Minimum and Maximum From Array");
//        //https://leetcode.com/problems/removing-minimum-and-maximum-from-array/
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{2, 10, 7, 5, 4, 1, 8, 6});
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{0, -4, 19, 1, 8, -2, -3, 5});
//        obj.minStepsToRemoveMaxAndMinValueFromFrontOrBack(new int[]{101});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Consecutive Floors Without Special Floors");
//        //https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
//        obj.maxConsecutiveFloorsWithoutIncludingSpecialFloors(2, 9, new int[]{4, 6});
//        obj.maxConsecutiveFloorsWithoutIncludingSpecialFloors(6, 8, new int[]{7, 6, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Amount of Time to Collect Garbage");
//        //https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/
//        obj.minAmountOfTimeToCollectGarbage(new String[]{"G", "P", "GP", "GG"}, new int[]{2, 4, 3});
//        obj.minAmountOfTimeToCollectGarbage(new String[]{"MMM", "PGM", "GP"}, new int[]{3, 10});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Cost Homecoming of a Robot in a Grid");
//        //https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/
//        obj.minPathCostRobotMovingStartToHomePos(new int[]{1, 0}, new int[]{2, 3},
//                new int[]{5, 4, 3}, new int[]{8, 2, 6, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Good Days to Rob the Bank");
//        //https://leetcode.com/problems/find-good-days-to-rob-the-bank/
//        obj.findGoodDayToRobBank(new int[]{5, 3, 3, 3, 5, 6, 2}, 2);
//        obj.findGoodDayToRobBank(new int[]{1, 1, 1, 1, 1}, 0);
//        obj.findGoodDayToRobBank(new int[]{1, 2, 3, 4, 5, 6}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Mountain in Array");
//        //https://leetcode.com/problems/longest-mountain-in-array/
//        obj.longestMountainInArray(new int[]{2, 1, 4, 7, 3, 2, 5});
//        obj.longestMountainInArray(new int[]{2, 2, 2, 2});
//        obj.longestMountainInArray(new int[]{1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Number of Removals to Make Mountain Array");
//        //https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{1, 3, 1});
//        //one possible mountain after 3 elements removal [1,5,6,3,1]
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{2, 1, 1, 5, 6, 2, 3, 1});
//        obj.minRemovalToMakeArrayMountain_DP_Memoization(new int[]{4, 3, 2, 1, 1, 2, 3, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Smallest Element in a Sorted Matrix");
//        //https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/
//        System.out.println("K th smallest in sorted matrix: " + obj.kThSmallestElementInSortedMatrix(new int[][]{
//            {1, 5, 9}, {10, 11, 13}, {12, 13, 15}}, 8));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Smallest Number in Multiplication Table");
//        //https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/
//        obj.kThSmallestNumberInMultiplicationTable(2, 3, 6);
//        obj.kThSmallestNumberInMultiplicationTable(3, 3, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Increasing Triplet Subsequence");
//        //https://leetcode.com/problems/increasing-triplet-subsequence/
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{1, 2, 3, 4, 5}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{5, 4, 3, 2, 1}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{2, 1, 5, 0, 4, 6}));
//        System.out.println("Increasing triplet subseq: " + obj.increasingTripletSubseq(new int[]{7, -9, 8, -10, 9, -11}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Suffix Flips");
//        //https://leetcode.com/problems/minimum-suffix-flips/
//        obj.minSuffixFlipInBinaryString("10111");
//        obj.minSuffixFlipInBinaryString("101");
//        obj.minSuffixFlipInBinaryString("0000000");
//        obj.minSuffixFlipInBinaryString("1111111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reveal Cards In Increasing Order");
//        //https://leetcode.com/problems/reveal-cards-in-increasing-order/
//        obj.deckRevealedIncreasing(new int[]{17, 13, 11, 2, 3, 5, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Insufficient Nodes in Root to Leaf Paths");
//        //https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(11));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(7));
//        root.getLeft().getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(17));
//        root.getRight().setRight(new TreeNode<>(4));
//        root.getRight().getRight().setLeft(new TreeNode<>(5));
//        root.getRight().getRight().setRight(new TreeNode<>(3));
//        obj.insufficientNodesInRootToLeafPath(root, 22);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Subarray Minimums");
//        //https://leetcode.com/problems/sum-of-subarray-minimums/
//        obj.sumOfSubarrayMins(new int[]{3, 1, 2, 4});
//        obj.sumOfSubarrayMins(new int[]{11, 81, 94, 43, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts");
//        //https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
//        obj.maxAreaOfPieceOfCake(5, 4, new int[]{1, 2, 4}, new int[]{3, 1});
//        obj.maxAreaOfPieceOfCake(5, 4, new int[]{3}, new int[]{3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Frequency of the Most Frequent Element");
//        //https://leetcode.com/problems/frequency-of-the-most-frequent-element/
//        obj.freqOfMostFrequentElement(new int[]{1, 2, 4}, 5);
//        obj.freqOfMostFrequentElement(new int[]{1, 4, 8, 13}, 5);
//        obj.freqOfMostFrequentElement(new int[]{3, 9, 6}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find All Lonely Numbers in the Array");
//        //https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
//        obj.findAllLonelyNumberInArray(new int[]{10, 6, 5, 8});
//        obj.findAllLonelyNumberInArray(new int[]{1, 3, 5, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Word in Dictionary");
//        //https://leetcode.com/problems/longest-word-in-dictionary/
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary(new String[]{"w", "wo", "wor", "worl", "world"}));
//        System.out.println("Longest word in dictionary: "
//                + obj.longestWordInDictionary(new String[]{"a", "banana", "app", "appl", "ap", "apply", "apple"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("The Number of Weak Characters in the Game");
//        //https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{5, 5}, {6, 3}, {3, 6}});
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{2, 2}, {3, 3}});
//        obj.numberOfWeakCharactersInGame_Greedy(new int[][]{{1, 5}, {10, 4}, {4, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Unique Paths I/ II/ III");
//        //https://leetcode.com/problems/unique-paths/
//        //https://leetcode.com/problems/unique-paths-ii/
//        obj.uniquePaths_Graph_Memoization(3, 7);
//        //https://leetcode.com/problems/unique-paths-iii/description/
//        obj.uniquePathsThree_Graph(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,2,-1}});
//        obj.uniquePathsThree_Graph(new int[][]{{1,0,0,0},{0,0,0,0},{0,0,0,2}});
//        obj.uniquePathsThree_Graph(new int[][]{{0,1},{2,0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Insertions to Balance a Parentheses String");
//        //https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
//        obj.minInsertionsToBalanceAParenthesisString("(()))");
//        obj.minInsertionsToBalanceAParenthesisString("())");
//        obj.minInsertionsToBalanceAParenthesisString("))())(");
//        obj.minInsertionsToBalanceAParenthesisString("(()))(()))()())))");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Performance of a Team");
//        //https://leetcode.com/problems/maximum-performance-of-a-team/
//        obj.maxPerformanceOfTeam_Greedy(6, 2, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
//        obj.maxPerformanceOfTeam_Greedy(6, 3, new int[]{5, 4, 3, 9, 7, 2}, new int[]{2, 10, 3, 1, 5, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Zero-Filled Subarrays");
//        //https://leetcode.com/problems/number-of-zero-filled-subarrays/
//        obj.numberOfSubarraysFilledWithZeros(new int[]{1, 3, 0, 0, 2, 0, 0, 4});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{0, 0, 0, 2, 0, 0});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{-1, 1});
//        obj.numberOfSubarraysFilledWithZeros(new int[]{-1, 0, -2, 0, -3, 0, -4, 0, 1, 0, 2, 0, 3, 0, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Bag of Tokens");
//        //https://leetcode.com/problems/bag-of-tokens/
//        obj.bagOfTokens_Greedy(new int[]{100}, 5);
//        obj.bagOfTokens_Greedy(new int[]{100, 200}, 150);
//        obj.bagOfTokens_Greedy(new int[]{100, 200, 300, 400}, 200);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Parallel Courses III");
//        //https://leetcode.com/problems/parallel-courses-iii/
//        obj.parallelCourseThree_Graph(3, new int[][]{{1, 3}, {2, 3}}, new int[]{3, 2, 5});
//        obj.parallelCourseThree_Graph(5, new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}},
//                new int[]{1, 2, 3, 4, 5});
//        obj.parallelCourseThree_Graph_TopologicalSort(3, new int[][]{{1, 3}, {2, 3}}, new int[]{3, 2, 5});
//        obj.parallelCourseThree_Graph_TopologicalSort(5, new int[][]{{1, 5}, {2, 5}, {3, 5}, {3, 4}, {4, 5}},
//                new int[]{1, 2, 3, 4, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Product of the Last K Numbers");
//        //https://leetcode.com/problems/product-of-the-last-k-numbers/
//        obj.productOfTheLastKNumbers();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Groups Entering a Competition");
//        //https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
//        System.out.println("Max Number of groups formed : "
//                + obj.maxNumberOfGroupsEnteringCompetition_Greedy(new int[]{10, 6, 12, 7, 3, 5}));
//        System.out.println("Max Number of groups formed : "
//                + obj.maxNumberOfGroupsEnteringCompetition_Greedy(new int[]{8, 8}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Last Stone Weight II");
//        //https://leetcode.com/problems/last-stone-weight-ii/
//        obj.lastStoneWeightTwo_DP_Memoization(new int[]{2, 7, 4, 1, 8, 1});
//        obj.lastStoneWeightTwo_DP_Memoization(new int[]{31, 26, 33, 21, 40});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Original Array From Doubled Array");
//        //https://leetcode.com/problems/find-original-array-from-doubled-array/
//        //https://leetcode.com/problems/array-of-doubled-pairs/
//        obj.findOriginalArrayFromDoubledArray(new int[]{0, 0, 0, 0});
//        obj.findOriginalArrayFromDoubledArray(new int[]{1, 3, 4, 2, 6, 8});
//        obj.findOriginalArrayFromDoubledArray(new int[]{6, 3, 0, 1});
//        obj.findOriginalArrayFromDoubledArray(new int[]{1});
//        obj.findOriginalArrayFromDoubledArray(new int[]{0, 3, 2, 4, 6, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shifting Letters II");
//        //https://leetcode.com/problems/shifting-letters-ii/
//        obj.shiftingLetterTwo_BruteForce("abc", new int[][]{{0, 1, 0}, {1, 2, 1}, {0, 2, 1}});
//        obj.shiftingLetterTwo_BruteForce("dztz", new int[][]{{0, 0, 0}, {1, 1, 1}});
//        obj.shiftingLetterTwo("abc", new int[][]{{0, 1, 0}, {1, 2, 1}, {0, 2, 1}});
//        obj.shiftingLetterTwo("dztz", new int[][]{{0, 0, 0}, {1, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("K-Concatenation Maximum Sum");
//        //https://leetcode.com/problems/k-concatenation-maximum-sum/
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{1, 2}, 3));
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{1, -2, 1}, 5));
//        System.out.println("K concatenation array max subarray sum: "
//                + obj.kConcatenationMaxSubarraySum(new int[]{-1, -2}, 7));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Remove Stones to Minimize the Total");
//        //https://leetcode.com/problems/remove-stones-to-minimize-the-total/
//        obj.removeStonesToMinimizeTotal_Greedy(new int[]{5, 4, 9}, 2);
//        obj.removeStonesToMinimizeTotal_Greedy(new int[]{4, 3, 6, 7}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Operations to Halve Array Sum");
//        //https://leetcode.com/problems/minimum-operations-to-halve-array-sum/
//        obj.minOperationToHalveTheArraySum_Greedy(new int[]{5, 19, 8, 1});
//        obj.minOperationToHalveTheArraySum_Greedy(new int[]{3, 8, 20});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reduce Array Size to The Half");
//        //https://leetcode.com/problems/reduce-array-size-to-the-half/
//        obj.reduceArraySizeTohalf_Greedy(new int[]{3, 3, 3, 3, 5, 5, 5, 2, 2, 7});
//        obj.reduceArraySizeTohalf_Greedy(new int[]{7, 7, 7, 7, 7, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Palindrome Pairs");
//        //https://leetcode.com/problems/palindrome-pairs/
//        obj.pallindromePairs(new String[]{"abcd", "dcba", "lls", "s", "sssll"});
//        obj.pallindromePairs(new String[]{"bat", "tab", "cat"});
//        obj.pallindromePairs(new String[]{"a", ""});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Palindrome by Concatenating Two Letter Words");
//        //https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"lc", "cl", "gg"});
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"ab", "ty", "yt", "lc", "cl", "ab"});
//        obj.longestPallindromeByConcatenatingTwoLetterWords(new String[]{"cc", "ll", "xx"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find And Replace in String");
//        //https://leetcode.com/problems/find-and-replace-in-string/
//        obj.findAndReplaceInString("abcd", new int[]{0, 2}, new String[]{"a", "cd"}, new String[]{"eee", "ffff"});
//        obj.findAndReplaceInString("abcd", new int[]{0, 2}, new String[]{"ab", "ec"}, new String[]{"eee", "ffff"});
//        obj.findAndReplaceInString("abcde", new int[]{2, 2}, new String[]{"cdef", "bc"}, new String[]{"f", "fe"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Removing Stars From a String");
//        //https://leetcode.com/problems/removing-stars-from-a-string/
//        //https://leetcode.com/problems/delete-characters-to-make-fancy-string/
//        obj.removeStarsFromString("leet**cod*e");
//        obj.removeStarsFromString("erase*****");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Distinct Echo Substrings");
//        //https://leetcode.com/problems/distinct-echo-substrings/
//        obj.distinctEchoSubstrings("abcabcabc");
//        obj.distinctEchoSubstrings("leetcodeleetcode");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Duplicate File in System");
//        //https://leetcode.com/problems/find-duplicate-file-in-system/
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)", "root 4.txt(efgh)"});
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)"});
//        obj.findDuplicateFilesInSystem(new String[]{
//            "root/a 1.txt(abcd) 2.txt(efsfgh)", "root/c 3.txt(abdfcd)", "root/c/d 4.txt(efggdfh)"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Lines to Represent a Line Chart");
//        //https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/
//        //https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/
//        System.out.println("Max lines covering points: "
//                + obj.maxLineToRepresentLineChart(new int[][]{{1, 7}, {2, 6}, {3, 5},
//        {4, 4}, {5, 4}, {6, 3}, {7, 2}, {8, 1}}));
//        System.out.println("Max lines covering points: "
//                + obj.maxLineToRepresentLineChart(new int[][]{{3, 4}, {1, 2}, {7, 8}, {2, 3}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Max Points on a Line");
//        //https://leetcode.com/problems/max-points-on-a-line/description/
//        obj.maxPointsOnLine(new int[][]{{1, 1}, {2, 2}, {3, 3}});
//        obj.maxPointsOnLine(new int[][]{{1, 1}, {3, 2}, {5, 3}, {4, 1}, {2, 3}, {1, 4}});
//        obj.maxPointsOnLine(new int[][]{{1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Even Numbers After Queries");
//        //https://leetcode.com/problems/sum-of-even-numbers-after-queries/
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{1, 2, 3, 4}, new int[][]{{1, 0}, {-3, 1}, {-4, 0}, {2, 3}});
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{-1, -2, -3, -4},
//                new int[][]{{1, 0}, {-3, 1}, {-4, 0}, {2, 3}});
//        obj.sumOfEvenNumbersAfterGivenQueries(new int[]{1}, new int[][]{{4, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize Maximum Pair Sum in Array");
//        //https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/
//        obj.minimizeMaxPairSumInArray_Greedy(new int[]{3, 5, 2, 3});
//        obj.minimizeMaxPairSumInArray_Greedy(new int[]{3, 5, 4, 2, 4, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Equal Row and Column Pairs");
//        //https://leetcode.com/problems/equal-row-and-column-pairs/
//        obj.equalRowAndColPairs(new int[][]{{3, 2, 1}, {1, 7, 6}, {2, 7, 7}});
//        obj.equalRowAndColPairs(new int[][]{{3, 1, 2, 2}, {1, 4, 4, 5}, {2, 4, 2, 2}, {2, 4, 2, 2}});
//        obj.equalRowAndColPairs(new int[][]{{11, 1}, {1, 11}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Fruit Into Baskets");
//        //https://leetcode.com/problems/fruit-into-baskets/
//        obj.fruitsIntoBasket(new int[]{1, 2, 1});
//        obj.fruitsIntoBasket(new int[]{0, 1, 2, 2});
//        obj.fruitsIntoBasket(new int[]{1, 2, 3, 2, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Length of the Longest Alphabetical Continuous Substring");
//        //https://leetcode.com/problems/length-of-the-longest-alphabetical-continuous-substring/
//        obj.longestLengthSubstringOfContigousLetters("abacaba");
//        obj.longestLengthSubstringOfContigousLetters("abcde");
//        obj.longestLengthSubstringOfContigousLetters("aaaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Alert Using Same Key-Card Three or More Times in a One Hour");
//        //https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/
//        obj.workersGettingAlertsMoreThanTriceInAnHour(
//                new String[]{"daniel", "daniel", "daniel", "luis", "luis", "luis", "luis"},
//                new String[]{"10:00", "10:40", "11:00", "09:00", "11:00", "13:00", "15:00"});
//        obj.workersGettingAlertsMoreThanTriceInAnHour(
//                new String[]{"leslie", "leslie", "leslie", "clare", "clare", "clare", "clare"},
//                new String[]{"13:00", "13:20", "14:00", "18:00", "18:51", "19:30", "19:49"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Step-By-Step Directions From a Binary Tree Node to Another");
//        //https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(1));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.stepByStepDirectionsBetweenTwoNodesInBinaryTree(root, 3, 6);
//        root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(1));
//        obj.stepByStepDirectionsBetweenTwoNodesInBinaryTree(root, 2, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Path in Binary Matrix");
//        //https://leetcode.com/problems/shortest-path-in-binary-matrix/
//        //https://practice.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{0, 1}, {1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{0, 0, 0}, {1, 1, 0}, {1, 1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{{1, 0, 0}, {1, 1, 0}, {1, 1, 0}}));
//        System.out.println("Shortest path in binary matrix: "
//                + obj.shortestPathInBinaryMatrix_Graph(new int[][]{
//            {0, 1, 1, 0, 0, 0},
//            {0, 1, 0, 1, 1, 0},
//            {0, 1, 1, 0, 1, 0},
//            {0, 0, 0, 1, 1, 0},
//            {1, 1, 1, 1, 1, 0},
//            {1, 1, 1, 1, 1, 0}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Satisfiability of Equality Equations");
//        //https://leetcode.com/problems/satisfiability-of-equality-equations/
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"a==b", "b!=a"}));
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"b==a", "a==b"}));
//        System.out.println("All equations satisfied: "
//                + obj.satisfiabilityOfEqualityEquation_Graph(new String[]{"a==b", "b!=c", "c==a"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Subsequence in Non-Increasing Order");
//        //https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
//        obj.minSubseqOfNonIncreasingOrder_Greedy_HeapBased(new int[]{4, 3, 10, 9, 8});
//        obj.minSubseqOfNonIncreasingOrder_Greedy(new int[]{4, 3, 10, 9, 8});
//        obj.minSubseqOfNonIncreasingOrder_Greedy_HeapBased(new int[]{4, 4, 7, 6, 7});
//        obj.minSubseqOfNonIncreasingOrder_Greedy(new int[]{4, 4, 7, 6, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Push Dominoes");
//        //https://leetcode.com/problems/push-dominoes/
//        obj.pushDominoes("RR.L");
//        obj.pushDominoes(".L.R...LR..L..");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Longest Uncommon Subsequence II");
//        //https://leetcode.com/problems/longest-uncommon-subsequence-ii/
//        obj.longestUncommonSubseqTwo(new String[]{"aba", "cdc", "eae"});
//        obj.longestUncommonSubseqTwo(new String[]{"aaa", "aaa", "aa"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Widest Vertical Area Between Two Points Containing No Points");
//        //https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/
//        obj.maxWidthBetweenGivenPoints(new int[][]{{8, 7}, {9, 9}, {7, 4}, {9, 7}});
//        obj.maxWidthBetweenGivenPoints(new int[][]{{3, 1}, {9, 0}, {1, 0}, {1, 4}, {5, 3}, {8, 8}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find K-th Smallest Pair Distance");
//        //https://leetcode.com/problems/find-k-th-smallest-pair-distance/
//        obj.kThSmallestPairDistance(new int[]{1, 3, 1}, 1);
//        obj.kThSmallestPairDistance(new int[]{1, 1, 1}, 2);
//        obj.kThSmallestPairDistance(new int[]{1, 6, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find K Pairs with Smallest Sums");
//        //https://leetcode.com/problems/find-k-pairs-with-smallest-sums/
//        obj.kThSmallestPairSum(new int[]{1, 7, 11}, new int[]{2, 4, 6}, 3);
//        obj.kThSmallestPairSum(new int[]{1, 1, 2}, new int[]{1, 2, 3}, 2);
//        obj.kThSmallestPairSum(new int[]{1, 2}, new int[]{3}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Atoms");
//        //https://leetcode.com/problems/number-of-atoms/
//        obj.numberOfAtoms("H2O");
//        obj.numberOfAtoms("Mg(OH)2");
//        obj.numberOfAtoms("K4(ON(SO3)2)2");
//        obj.numberOfAtoms("K(K(K(K)))");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Rounds to Complete All Tasks");
//        //https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/
//        System.out.println("Min rounds to complete tasks: "
//                + obj.minRoundsToCompleteAllTasks_Greedy(new int[]{2, 2, 3, 3, 2, 4, 4, 4, 4, 4}));
//        System.out.println("Min rounds to complete tasks: "
//                + obj.minRoundsToCompleteAllTasks_Greedy(new int[]{2, 3, 3}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sentence Similarity III");
//        //https://leetcode.com/problems/sentence-similarity-iii/
//        obj.sentenceSimilarityThree("My name is Haley", "My Haley");
//        obj.sentenceSimilarityThree("of", "A lot of words");
//        obj.sentenceSimilarityThree("Eating right now", "Eating");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Primes");
//        //https://leetcode.com/problems/count-primes/
//        obj.countPrimes(10);
//        obj.countPrimes(50);
//        obj.countPrimes(100);
//        //obj.countPrimes(5000000); //working but output too long
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Game Of Life");
//        //https://leetcode.com/problems/game-of-life/
//        obj.gameOfLife(new int[][]{{0, 1, 0}, {0, 0, 1}, {1, 1, 1}, {0, 0, 0}});
//        obj.gameOfLife(new int[][]{{1, 1}, {1, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Dice Rolls With Target Sum");
//        //https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(1, 6, 3);
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(2, 6, 7);
//        obj.numberOfDiceRollWithTargetSum_Recursive_Memoization(30, 30, 500);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reachable Nodes With Restrictions");
//        //https://leetcode.com/problems/reachable-nodes-with-restrictions/
//        obj.countReachableNodesWithRestrictions_Graph(
//                new int[][]{{0, 1}, {1, 2}, {3, 1}, {4, 0}, {0, 5}, {5, 6}},
//                new int[]{4, 5});
//        obj.countReachableNodesWithRestrictions_Graph(
//                new int[][]{{0, 1}, {0, 2}, {0, 5}, {0, 4}, {3, 2}, {6, 5}},
//                new int[]{4, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Prefix Scores of Strings");
//        //https://leetcode.com/problems/sum-of-prefix-scores-of-strings/
//        //https://practice.geeksforgeeks.org/problems/geek-and-strings3030/1
//        obj.sumOfPrefixScoresOfString(new String[]{"abc", "ab", "bc", "b"});
//        obj.sumOfPrefixScoresOfString(new String[]{"abcd"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Design Add and Search Words Data Structure");
//        //https://leetcode.com/problems/design-add-and-search-words-data-structure/
//        obj.trieAddAndSearchWords();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If a Word Occurs As a Prefix of Any Word in a Sentence");
//        //https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
//        //https://leetcode.com/problems/counting-words-with-a-given-prefix/
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("i love eating burger", "burg");
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("this problem is an easy problem", "pro");
//        obj.checkIfSearchWordExistAsPrefixInAnyWordOfSentence("i am tired", "you");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Add One Row to Tree");
//        //https://leetcode.com/problems/add-one-row-to-tree/
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 1);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 2);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 3);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth(root, 1, 4);
//        //BFS Iterative approach
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 1);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 2);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 3);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(6));
//        root.getRight().setLeft(new TreeNode<>(5));
//        obj.addExtraRowWithGivenValueAtGivenDepth_BFSIterative(root, 1, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("My Calendar I");
//        //https://leetcode.com/problems/my-calendar-i/
//        obj.myCalendarOne();
//        //https://leetcode.com/problems/my-calendar-iii/
//        obj.myCalendarThree();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Break a Palindrome");
//        //https://leetcode.com/problems/break-a-palindrome/
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("abccba"));
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("a"));
//        System.out.println("Break a pallindromic string into lexicographically smaller non pallindromic string: "
//                + obj.breakAPallindrome("aba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Count Number of Homogenous Substrings/ Number of Subtrings With Ony 1s");
//        //https://leetcode.com/problems/count-number-of-homogenous-substrings/
//        //https://leetcode.com/problems/consecutive-characters/
//        //https://leetcode.com/problems/number-of-substrings-with-only-1s/
//        obj.countNumberOfHomogenousSubstring("abbcccaa");
//        obj.countNumberOfHomogenousSubstring("xy");
//        obj.countNumberOfHomogenousSubstring("zzzzz");
//        obj.numberOfSubstringWithOnlyOnes("0110111");
//        obj.numberOfSubstringWithOnlyOnes("101");
//        obj.numberOfSubstringWithOnlyOnes("111111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Increasing Decreasing String");
//        //https://leetcode.com/problems/increasing-decreasing-string/
//        obj.increasingDecreasingString("aaaabbbbcccc");
//        obj.increasingDecreasingString("rat");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Deletions to Make Array Divisible");
//        //https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/
//        System.out.println("Min deletes to find the smallest value in num array"
//                + "that divides all the numbers fronm numsToDivide array: "
//                + obj.minDeletionsToMakeArrayDivisble(new int[]{2, 3, 2, 4, 3},
//                new int[]{9, 6, 9, 3, 15}));
//        System.out.println("Min deletes to find the smallest value in num array"
//                + "that divides all the numbers fronm numsToDivide array: "
//                + obj.minDeletionsToMakeArrayDivisble(new int[]{4, 3, 6},
//                new int[]{8, 2, 6, 10}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Check If Array Pairs Are Divisible by k");
//        //https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 10, 6, 7, 8, 9}, 5));
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 6}, 7));
//        System.out.println("Check if array pairs are divisible by k: "
//                + obj.checkIfArrayPairsAreDivisibleByK(new int[]{1, 2, 3, 4, 5, 6}, 10));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Shortest Subarray to be Removed to Make Array Sorted");
//        //https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3, 10, 4, 2, 3, 5}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{5, 4, 3, 2, 1}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3}));
//        System.out.println("Shortest subarray to remove to make array sorted: "
//                + obj.shortestSubarrayRemovedToMakeArrayNonDecreasing(new int[]{1, 2, 3, 2, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Number of Points with Cost");
//        //https://leetcode.com/problems/maximum-number-of-points-with-cost/
//        obj.maxNumberOfPointsWithCost_Recursive(new int[][]{{1, 2, 3}, {1, 5, 1}, {3, 1, 1}});
//        obj.maxNumberOfPointsWithCost_Recursive(new int[][]{{1, 5}, {2, 3}, {4, 2}});
//        obj.maxNumberOfPointsWithCost_DP_Memoization(new int[][]{{1, 2, 3}, {1, 5, 1}, {3, 1, 1}});
//        obj.maxNumberOfPointsWithCost_DP_Memoization(new int[][]{{1, 5}, {2, 3}, {4, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimize the Difference Between Target and Chosen Elements");
//        //https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
//        obj.minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(
//                new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, 13);
//        obj.minimizeDiffBetweenTargetAndChoosenElement_Recursive_Memoization(
//                new int[][]{{1}, {2}, {3}}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Minimum Difficulty of a Job Schedule");
//        //https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{6, 5, 4, 3, 2, 1}, 2);
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{9, 9, 9}, 4);
//        obj.minDifficultyOfAJobSchedule_Recursive_Memoization(new int[]{1, 1, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Optimal Partition of String");
//        //https://leetcode.com/problems/optimal-partition-of-string/
//        obj.optimalStringPartitions("abacaba");
//        obj.optimalStringPartitions("ssssss");
//        obj.optimalStringPartitions("abcdef");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Partition Array into Disjoint Intervals");
        //https://leetcode.com/problems/partition-array-into-disjoint-intervals/
        obj.partitionsArrayIntoDisjointIntervals(new int[]{5, 0, 3, 8, 6});
        obj.partitionsArrayIntoDisjointIntervals(new int[]{1, 1, 1, 0, 6, 12});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("As Far from Land as Possible");
        //https://leetcode.com/problems/as-far-from-land-as-possible/
        obj.asFarFromLandAsPossible_Graph(new int[][]{
            {1, 0, 1}, {0, 0, 0}, {1, 0, 1}});
        obj.asFarFromLandAsPossible_Graph(new int[][]{
            {1, 0, 0}, {0, 0, 0}, {0, 0, 0}});
        obj.asFarFromLandAsPossible_Graph(new int[][]{
            {0, 0, 0}, {0, 0, 0}, {0, 0, 0}});
        obj.asFarFromLandAsPossible_Graph(new int[][]{
            {1, 1, 1}, {1, 1, 1}, {1, 1, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Arithmetic Subsequence of Given Difference");
        //https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/
        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 2, 3, 4}, 1);
        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 3, 5, 7}, 1);
        obj.longestArithmeticSubseqOfGivenDiff_DP_Memoization(new int[]{1, 5, 7, 8, 5, 3, 4, 2, 1}, -2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest Merge Of Two Strings");
        //https://leetcode.com/problems/largest-merge-of-two-strings/
        obj.largestMergeOfTwoStrings("cabaa", "bcaaa");
        obj.largestMergeOfTwoStrings("abcabc", "abdcaba");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Matching of Players With Trainers");
        //https://leetcode.com/problems/maximum-matching-of-players-with-trainers/
        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{4, 7, 9}, new int[]{8, 5, 2, 8});
        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{1, 1, 1}, new int[]{10});
        obj.maxMatchingOfPlayersWithTrainers_Greedy(new int[]{10, 11, 12}, new int[]{2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Contains Duplicate III");
        //https://leetcode.com/problems/contains-duplicate-iii/
        System.out.println("Contains duplicate three: "
                + obj.containsDuplicateThree(new int[]{1, 2, 3, 1}, 3, 0));
        System.out.println("Contains duplicate three: "
                + obj.containsDuplicateThree(new int[]{1, 5, 9, 1, 5, 9}, 2, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Genetic Mutation / Word Ladder");
        //https://leetcode.com/problems/minimum-genetic-mutation/
        System.out.println("Min genetic mutation from start to end: "
                + obj.minGeneticMutation_Graph("AACCGGTT", "AACCGGTA", Arrays.asList("AACCGGTA")));
        System.out.println("Min genetic mutation from start to end: "
                + obj.minGeneticMutation_Graph("AACCGGTT", "AAACGGTA", Arrays.asList("AACCGGTA", "AACCGCTA", "AAACGGTA")));
        System.out.println("Min genetic mutation from start to end: "
                + obj.minGeneticMutation_Graph("AAAAACCC", "AACCCCCC", Arrays.asList("AAAACCCC", "AAACCCCC", "AACCCCCC")));
        //https://leetcode.com/problems/word-ladder/
        System.out.println("Word ladder from startWord to endWord: "
                + obj.wordLadder_Graph("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log", "cog")));
        System.out.println("Word ladder from startWord to endWord: "
                + obj.wordLadder_Graph("hit", "cog", Arrays.asList("hot", "dot", "dog", "lot", "log")));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Number of Operations to Make Array Continuous");
        //https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/
        obj.minOperationsToMakeArrayContinous(new int[]{4, 2, 5, 3});
        obj.minOperationsToMakeArrayContinous(new int[]{1, 2, 3, 5, 6});
        obj.minOperationsToMakeArrayContinous(new int[]{1, 10, 100, 1000});
        obj.minOperationsToMakeArrayContinous(new int[]{8, 5, 9, 9, 8, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Image Overlap");
        //https://leetcode.com/problems/image-overlap/
        obj.largestImageOverlap(
                new int[][]{{1, 1, 0}, {0, 1, 0}, {0, 1, 0}}, new int[][]{{0, 0, 0}, {0, 1, 1}, {0, 0, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Eliminate Maximum Number of Monsters");
        //https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
        obj.eliminateMaxNumberOfMosnter_Greedy(new int[]{1, 3, 4}, new int[]{1, 1, 1});
        obj.eliminateMaxNumberOfMosnter_Greedy(new int[]{1, 1, 2, 3}, new int[]{1, 1, 1, 1});
        obj.eliminateMaxNumberOfMosnter_Greedy(new int[]{3, 2, 4}, new int[]{5, 3, 2});
        obj.eliminateMaxNumberOfMosnter_Greedy(new int[]{4, 2, 3}, new int[]{2, 1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Eliminate Maximum Number of Monsters");
        obj.groupPeopleInTheirGroupSizes(new int[]{3, 3, 3, 3, 3, 1, 3});
        obj.groupPeopleInTheirGroupSizes(new int[]{2, 1, 3, 3, 3, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Number of K-Sum Pairs");
        //https://leetcode.com/problems/max-number-of-k-sum-pairs/
        obj.maxNumberOfKSumPairs(new int[]{1, 2, 3, 4}, 5);
        obj.maxNumberOfKSumPairs(new int[]{3, 1, 3, 4, 3}, 6);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Repeated DNA Sequences");
        //https://leetcode.com/problems/repeated-dna-sequences/
        obj.repeatedDNASequences("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT");
        obj.repeatedDNASequences("AAAAAAAAAAAAA");
        obj.repeatedDNASequences("AAAAAAAA");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Laser Beams in a Bank");
        //https://leetcode.com/problems/number-of-laser-beams-in-a-bank/
        obj.numberOfLaserBeamsInBank(new String[]{"011001", "000000", "010100", "001000"});
        obj.numberOfLaserBeamsInBank(new String[]{"000", "111", "000"});
        obj.numberOfLaserBeamsInBank(new String[]{"111"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Where Will the Ball Fall");
        //https://leetcode.com/problems/where-will-the-ball-fall/
        obj.whereWillTheBallsFall_Graph(new int[][]{
            {1, 1, 1, -1, -1},
            {1, 1, 1, -1, -1},
            {-1, -1, -1, 1, 1},
            {1, 1, 1, 1, -1},
            {-1, -1, -1, -1, -1}});
        obj.whereWillTheBallsFall_Graph(new int[][]{
            {-1}});
        obj.whereWillTheBallsFall_Graph(new int[][]{
            {1, 1, 1, 1, 1, 1},
            {-1, -1, -1, -1, -1, -1},
            {1, 1, 1, 1, 1, 1},
            {-1, -1, -1, -1, -1, -1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Array With Elements Not Equal to Average of Neighbors");
        //https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
        obj.arrayWithElementsNotEqualToAverageOfNeighbours(new int[]{1, 2, 3, 4, 5});
        obj.arrayWithElementsNotEqualToAverageOfNeighbours(new int[]{6, 2, 0, 9, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Consecutive Cards to Pick Up");
        //https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
        obj.minConsecutiveCardsToPickUpBetweenSameCards(new int[]{3, 4, 2, 3, 4, 7});
        obj.minConsecutiveCardsToPickUpBetweenSameCards(new int[]{1, 0, 5, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest Area In Matrix Between K Blocked Row & Cols");
        //https://practice.geeksforgeeks.org/problems/enemy/1
        System.out.println("Largest area between blocked rows and cols: "
                + obj.largestAreaInMatrixBetweenKBlockedRowCols(2, 2, new int[][]{{2, 2}}));
        System.out.println("Largest area between blocked rows and cols: "
                + obj.largestAreaInMatrixBetweenKBlockedRowCols(3, 3, new int[][]{{3, 3}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Distinct Subsequences");
        //https://leetcode.com/problems/distinct-subsequences/
        obj.distinctSubsequences_Recursive_Memoization("rabbbit", "rabbit");
        obj.distinctSubsequences_Recursive_Memoization("babgbag", "bag");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Array Removals");
        //https://practice.geeksforgeeks.org/problems/array-removals/1
        obj.arrayRemovals_Recursive_Memoization(new int[]{1, 3, 4, 9, 10, 11, 12, 17, 20}, 4);
        obj.arrayRemovals_Recursive_Memoization(new int[]{1, 5, 6, 2, 8}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Frequency Stack");
        //https://leetcode.com/problems/maximum-frequency-stack/
        obj.implementMaxFreqStack();
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Construct K Palindrome Strings");
        //https://leetcode.com/problems/construct-k-palindrome-strings/
        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
                + obj.isPossibleToConstructKPallindromeString("annabelle", 2));
        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
                + obj.isPossibleToConstructKPallindromeString("leetcode", 3));
        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
                + obj.isPossibleToConstructKPallindromeString("true", 4));
        System.out.println("Is it possible to construct k pallindrome strings from all chars of given string: "
                + obj.isPossibleToConstructKPallindromeString("aafaaeaagaahaak", 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Destroy Sequential Targets");
        //https://leetcode.com/problems/destroy-sequential-targets/
        obj.destroySequentialTarget(new int[]{3, 7, 8, 1, 1, 5}, 2);
        obj.destroySequentialTarget(new int[]{1, 3, 5, 2, 4, 6}, 2);
        obj.destroySequentialTarget(new int[]{6, 2, 5}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Delete and Earn");
        //https://leetcode.com/problems/delete-and-earn/
        obj.deleteAndEarn_Recursive_Memoization(new int[]{3, 4, 2});
        obj.deleteAndEarn_Recursive_Memoization(new int[]{2, 2, 3, 3, 3, 4});
        obj.deleteAndEarn_DP_Memoization(new int[]{3, 4, 2});
        obj.deleteAndEarn_DP_Memoization(new int[]{2, 2, 3, 3, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Word Search II");
        //https://leetcode.com/problems/word-search-ii/
        obj.wordSearchTwo_Graph(
                new char[][]{
                    {'o', 'a', 'a', 'n'},
                    {'e', 't', 'a', 'e'},
                    {'i', 'h', 'k', 'r'},
                    {'i', 'f', 'l', 'v'}},
                new String[]{"oath", "pea", "eat", "rain"});
        obj.wordSearchTwo_Graph(
                new char[][]{
                    {'a', 'b'},
                    {'c', 'd'}},
                new String[]{"abcd"});
        obj.wordSearchTwo_Graph_TrieBased(
                new char[][]{
                    {'o', 'a', 'a', 'n'},
                    {'e', 't', 'a', 'e'},
                    {'i', 'h', 'k', 'r'},
                    {'i', 'f', 'l', 'v'}},
                new String[]{"oath", "pea", "eat", "rain"});
        obj.wordSearchTwo_Graph_TrieBased(
                new char[][]{
                    {'a', 'b'},
                    {'c', 'd'}},
                new String[]{"abcd"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Orderly Queue");
        //https://leetcode.com/problems/orderly-queue/
        obj.orderlyQueue("cba", 1);
        obj.orderlyQueue("acba", 1);
        obj.orderlyQueue("baaca", 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Bags With Full Capacity of Rocks");
        //https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/
        obj.maxBagsCompletelyFilledWithRocks_Greedy(new int[]{2, 3, 4, 5}, new int[]{1, 2, 4, 4}, 2);
        obj.maxBagsCompletelyFilledWithRocks_Greedy(new int[]{10, 2, 2}, new int[]{2, 2, 0}, 100);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Moves to Reach Target Score");
        //https://leetcode.com/problems/minimum-moves-to-reach-target-score/
        //https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
        //https://leetcode.com/problems/count-operations-to-obtain-zero/
        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(4, 0));
        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(19, 2));
        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(10, 4));
        System.out.println("Min moves from src = 1 to target: " + obj.minMovesToReachTarget_Greedy(1000000000, 100));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Make The String Great");
        //https://leetcode.com/problems/make-the-string-great/
        obj.makeTheStringGreat("leEeetcode");
        obj.makeTheStringGreat("abBAcC");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Find Elements in a Contaminated Binary Tree");
//        //https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(-1);
//        root.setRight(new TreeNode<>(6));
//        obj.findElementsInContaminatedBinaryTree(root, Arrays.asList(1, 2));
//        root = new TreeNode<>(-1);
//        root.setLeft(new TreeNode<>(-1));
//        root.getLeft().setLeft(new TreeNode<>(-1));
//        root.getLeft().setRight(new TreeNode<>(-1));
//        root.setRight(new TreeNode<>(-1));
//        obj.findElementsInContaminatedBinaryTree(root, Arrays.asList(1, 3, 5));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Single Element in a Sorted Array");
        //https://leetcode.com/problems/single-element-in-a-sorted-array/
        obj.singleElementInSortedArray(new int[]{1, 1, 2, 3, 3, 4, 4, 8, 8});
        obj.singleElementInSortedArray(new int[]{3, 3, 7, 7, 10, 11, 11});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Increasing Subsequences");
        //https://leetcode.com/problems/increasing-subsequences/
        obj.increasingSubsequences_Backtracking(new int[]{4, 6, 7, 7});
        obj.increasingSubsequences_Backtracking(new int[]{4, 4, 3, 2, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximize the Topmost Element After K Moves");
        //https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/
        System.out.println("Maximize topmost elements after k moves: "
                + obj.maximizeTopmostElementAfterKMoves_Greedy(new int[]{5, 2, 2, 4, 0, 6}, 4));
        System.out.println("Maximize topmost elements after k moves: "
                + obj.maximizeTopmostElementAfterKMoves_Greedy(new int[]{2}, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Unguarded Cells in the Grid");
        //https://leetcode.com/problems/count-unguarded-cells-in-the-grid/
        obj.countUnguardedCellsInGrid(4, 6,
                new int[][]{{0, 0}, {1, 1}, {2, 3}}, new int[][]{{0, 1}, {2, 2}, {1, 4}});
        obj.countUnguardedCellsInGrid(3, 3,
                new int[][]{{1, 1}}, new int[][]{{0, 1}, {1, 0}, {2, 1}, {1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Sum of Distinct Subarrays With Length K");
        //https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/
        obj.maxSumOfDistinctSubarrayOfLengthK(new int[]{1, 5, 4, 2, 9, 9, 9}, 3);
        obj.maxSumOfDistinctSubarrayOfLengthK(new int[]{4, 4, 4}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit"
                + "/ Longest Perfect Piece");
        //https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{8, 2, 4, 7}, 4);
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{10, 1, 2, 4, 7, 2}, 5);
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{4, 2, 2, 2, 4, 4, 2, 2}, 0);
        //https://practice.geeksforgeeks.org/problems/close-to-perfection1525/1
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{8, 8, 8, 8}, 1);
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{5, 4, 5, 5, 6, 7, 8, 8, 8, 7, 6}, 1);
        obj.longestSubarrayWithDiffInMinAndMaxIsAtmostToLimit(new int[]{1, 2, 3, 4, 5}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Subarrays With Fixed Bounds");
        //https://leetcode.com/problems/count-subarrays-with-fixed-bounds/
        obj.countSubarraysWithFixedBounds(new int[]{1, 3, 5, 2, 7, 5}, 1, 5);
        obj.countSubarraysWithFixedBounds(new int[]{1, 1, 1, 1}, 1, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sum of Beauty of All Substrings");
        //https://leetcode.com/problems/sum-of-beauty-of-all-substrings/
        obj.sumOfBeautyOfAllSubstring("aaab");
        obj.sumOfBeautyOfAllSubstring("aabcb");
        obj.sumOfBeautyOfAllSubstring("aabcbaa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Difference Between Largest and Smallest Value in Three Moves");
        //https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/
        System.out.println("Min Diff between min and max value: "
                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{5, 3, 2, 4}));
        System.out.println("Min Diff between min and max value: "
                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{1, 5, 0, 10, 14}));
        System.out.println("Min Diff between min and max value: "
                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{3, 100, 20}));
        System.out.println("Min Diff between min and max value: "
                + obj.minDiffBetweenMaxAndMinValueAfterThreeMoves_Greedy(new int[]{-1, -2, -3, -4, -5}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Unique partitions");
        //https://practice.geeksforgeeks.org/problems/unique-partitions1041/1
        obj.uniquePartitions_Recursive(3);
        obj.uniquePartitions_Recursive(4);
        obj.uniquePartitions_Recursive(10);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Nearest Exit from Entrance in Maze");
        //https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/
        System.out.println("Nearest exit from maze dist: "
                + obj.nearestExitFromMaze_Graph(new char[][]{
            {'+', '+', '.', '+'},
            {'.', '.', '.', '.'},
            {'.', '+', '+', '.'}}, new int[]{1, 2}));
        System.out.println("Nearest exit from maze dist: "
                + obj.nearestExitFromMaze_Graph(new char[][]{
            {'+', '+', '+'},
            {'.', '.', '.'},
            {'+', '+', '+'}}, new int[]{1, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Circular Array Loop");
        //https://leetcode.com/problems/circular-array-loop/
        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{2, -1, 1, 2, 2}));
        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{-1, -2, -3, -4, -5, 6}));
        System.out.println("Is circular array loop: " + obj.circularArrayLoop(new int[]{1, -1, 5, 1, 4}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Players With Zero or One Losses");
        //https://leetcode.com/problems/find-players-with-zero-or-one-losses/
        obj.findPlayerWithZeroOrOneLosses(new int[][]{{1, 3}, {2, 3}, {3, 6},
        {5, 6}, {5, 7}, {4, 5}, {4, 8}, {4, 9}, {10, 4}, {10, 9}});
        obj.findPlayerWithZeroOrOneLosses(new int[][]{{2, 3}, {1, 3}, {5, 4}, {6, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Short Encoding of Words");
        //https://leetcode.com/problems/short-encoding-of-words/
        obj.shortEncodingOfWords(new String[]{"t"});
        obj.shortEncodingOfWords(new String[]{"time", "me", "bell"});
        obj.shortEncodingOfWords(new String[]{"time", "me", "bell", "chime"});
        obj.shortEncodingOfWords(new String[]{"time", "me", "bell", "chimeno"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Covered Intervals");
        //https://leetcode.com/problems/remove-covered-intervals/
        obj.removeCoveredIntervals(new int[][]{{1, 4}, {3, 6}, {2, 8}});
        obj.removeCoveredIntervals(new int[][]{{1, 4}, {2, 3}});
        obj.removeCoveredIntervals(new int[][]{{2, 4}, {1, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest 1-Bordered Square");
        //https://leetcode.com/problems/largest-1-bordered-square/
        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}});
        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{1, 1, 0, 0}});
        obj.largestOneBorderedSquare_DP_Memoization(new int[][]{{0, 0, 0}, {0, 1, 0}, {0, 0, 0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Making File Names Unique");
        //https://leetcode.com/problems/making-file-names-unique/
        obj.makingFileNamesUnique(new String[]{"pes", "fifa", "gta", "pes(2019)"});
        obj.makingFileNamesUnique(new String[]{"gta", "gta(1)", "gta", "avalon"});
        obj.makingFileNamesUnique(new String[]{"onepiece", "onepiece(1)", "onepiece(2)", "onepiece(3)", "onepiece"});
        obj.makingFileNamesUnique(new String[]{"onepiece", "onepiece(1)", "onepiece(2)",
            "onepiece(3)", "onepiece", "onepiece(4)"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Number of Occurrences of a Substring");
        //https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/
        obj.maxOccurenceSubstringFollowingCondition("aababcaab", 2, 3, 4);
        obj.maxOccurenceSubstringFollowingCondition("aaaa", 1, 3, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Task Scheduler II");
        //https://leetcode.com/problems/task-scheduler-ii/
        obj.taskSchedulerTwo(new int[]{1, 2, 1, 2, 3, 1}, 3);
        obj.taskSchedulerTwo(new int[]{5, 8, 8, 5}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Prefix and Suffix Search");
        //https://leetcode.com/problems/prefix-and-suffix-search/
        obj.prefixAndSuffixSearch(new String[]{"apple"}, new String[][]{{"a", "e"}, {"a", "a"}});
        obj.prefixAndSuffixSearch(new String[]{"time", "me", "chime", "moonchime"},
                new String[][]{{"t", "me"}, {"m", "e"}, {"mo", "chime"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Implement Magic Dictionary");
        //https://leetcode.com/problems/implement-magic-dictionary/
        obj.magicDictionary(new String[]{"hello", "leetcode"},
                new String[]{"hello", "hhllo", "hell", "leetcoded"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Lexicographical Numbers");
        //https://leetcode.com/problems/lexicographical-numbers/
        obj.lexicographicalNumbers_Recursion(13);
        obj.lexicographicalNumbers_Recursion(2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Node With Highest Edge Score");
        //https://leetcode.com/problems/node-with-highest-edge-score/
        obj.nodesWithHighestEdgeScore_Graph(new int[]{1, 0, 0, 0, 0, 7, 7, 5});
        obj.nodesWithHighestEdgeScore_Graph(new int[]{2, 0, 0, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Average Difference");
        //https://leetcode.com/problems/minimum-average-difference/
        obj.minAverageDiff(new int[]{2, 5, 3, 9, 5, 3});
        obj.minAverageDiff(new int[]{0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Falling Path Sum/ Minimum Falling Path Sum II");
        //https://leetcode.com/problems/minimum-falling-path-sum/description/
        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{2, 1, 3}, {6, 5, 4}, {7, 8, 9}});
        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{-19, 57}, {-40, -5}});
        obj.minFallingPathSum_Recursive_Memoization(new int[][]{{17, 82}, {1, -44}});
        //https://leetcode.com/problems/minimum-falling-path-sum-ii/
        obj.minFallingPathSumTwo_Recursive_Memoization(new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
        obj.minFallingPathSumTwo_Recursive_Memoization(new int[][]{{7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Cherry Pickup II");
        //https://leetcode.com/problems/cherry-pickup-ii/
        obj.cherryPickupTwo_Recursive_Memoization(new int[][]{{3, 1, 1}, {2, 5, 1}, {1, 5, 5}, {2, 1, 1}});
        obj.cherryPickupTwo_Recursive_Memoization(new int[][]{{1, 0, 0, 0, 0, 0, 1},
        {2, 0, 0, 0, 0, 3, 0}, {2, 0, 9, 0, 0, 0, 0}, {0, 3, 0, 5, 4, 0, 0}, {1, 0, 2, 3, 0, 0, 6}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Reverse Odd Levels of Binary Tree");
//        //https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/
//        TreeNode<Integer> root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(8));
//        root.getLeft().setRight(new TreeNode<>(13));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setLeft(new TreeNode<>(21));
//        root.getRight().setRight(new TreeNode<>(34));
//        obj.reverseOddLevelsOfPerfectBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Closest Nodes Queries in a Binary Search Tree");
//        //https://leetcode.com/problems/closest-nodes-queries-in-a-binary-search-tree/
//        TreeNode<Integer> root = new TreeNode<>(6);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(13));
//        root.getRight().setLeft(new TreeNode<>(9));
//        root.getRight().setRight(new TreeNode<>(15));
//        root.getRight().getRight().setLeft(new TreeNode<>(14));
//        obj.closestNodesQueriesInBinarySearchTree(root, Arrays.asList(2, 5, 16));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Delete Leaves With a Given Value");
//        //https://leetcode.com/problems/delete-leaves-with-a-given-value/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(4));
//        obj.deleteLeavesWithGiveValue(root, 2);
//        root = new TreeNode<>(2);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(2));
//        obj.deleteLeavesWithGiveValue(root, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Difference Between Node and Ancestor");
//        //https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/
//        TreeNode<Integer> root = new TreeNode<>(8);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(6));
//        root.getLeft().getRight().setLeft(new TreeNode<>(4));
//        root.getLeft().getRight().setRight(new TreeNode<>(7));
//        root.setRight(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(14));
//        root.getRight().getRight().setLeft(new TreeNode<>(13));
//        obj.maxDiffBetweenNodesAndAncestor(root);
//        root = new TreeNode<>(1);
//        root.setRight(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(0));
//        root.getRight().getRight().setLeft(new TreeNode<>(3));
//        obj.maxDiffBetweenNodesAndAncestor(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Amount of Time for Binary Tree to Be Infected");
//        //https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().getLeft().setRight(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(6));
//        obj.timeRequiredToInfectBinaryTree(root, 3);
//        root = new TreeNode<>(1);
//        obj.timeRequiredToInfectBinaryTree(root, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Binary Tree");
//        //https://leetcode.com/problems/maximum-binary-tree/
//        obj.maxBinaryTree(new int[]{3, 2, 1, 6, 0, 5});
//        obj.maxBinaryTree(new int[]{3, 2, 1});
//        System.out.println("Maximum Binary Tree II");
//        //https://leetcode.com/problems/maximum-binary-tree-ii/description/
//        TreeNode<Integer> root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(2));
//        obj.maxBinaryTreeTwo(root, 5);
//        root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(4));
//        obj.maxBinaryTreeTwo(root, 3);
//        root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.setRight(new TreeNode<>(3));
//        obj.maxBinaryTreeTwo(root, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("People Whose List of Favorite Companies Is Not a Subset of Another List");
        //https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
        List<List<String>> favouriteCompanies = new ArrayList<>();
        favouriteCompanies.add(Arrays.asList("leetcode", "google", "facebook"));
        favouriteCompanies.add(Arrays.asList("google", "microsoft"));
        favouriteCompanies.add(Arrays.asList("google", "facebook"));
        favouriteCompanies.add(Arrays.asList("google"));
        favouriteCompanies.add(Arrays.asList("amazon"));
        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
        favouriteCompanies = new ArrayList<>();
        favouriteCompanies.add(Arrays.asList("leetcode", "google", "facebook"));
        favouriteCompanies.add(Arrays.asList("leetcode", "amazon"));
        favouriteCompanies.add(Arrays.asList("google", "facebook"));
        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
        favouriteCompanies = new ArrayList<>();
        favouriteCompanies.add(Arrays.asList("leetcode"));
        favouriteCompanies.add(Arrays.asList("amazon"));
        favouriteCompanies.add(Arrays.asList("google"));
        favouriteCompanies.add(Arrays.asList("facebook"));
        obj.peopleWhoseFavoriteCompaniesNotSubsetOfAnotherList(favouriteCompanies);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Print Words Vertically");
        //https://leetcode.com/problems/print-words-vertically/description/
        obj.printWordsVertically("HOW ARE YOU");
        obj.printWordsVertically("TO BE OR NOT TO BE");
        obj.printWordsVertically("CONTEST IS COMING");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Bulls and Cows");
        //https://leetcode.com/problems/bulls-and-cows/description/
        obj.bullsAndCows("1807", "7810");
        obj.bullsAndCows("1122", "2211");
        obj.bullsAndCows("1122", "1222");
        obj.bullsAndCows("1123", "0111");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Sum of a Pair With Equal Sum of Digits");
        //https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/
        obj.maxPairSumWithEqualDigitSum(new int[]{18, 43, 36, 13, 7});
        obj.maxPairSumWithEqualDigitSum(new int[]{10, 12, 19, 14});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Unreachable Pairs of Nodes in an Undirected Graph");
        //https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/
        obj.countUnreachablePairOfNodes_Graph(3, new int[][]{{0, 1}, {0, 2}, {1, 2}});
        obj.countUnreachablePairOfNodes_Graph(7, new int[][]{{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Bridge");
        //https://leetcode.com/problems/shortest-bridge/description/
        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
            {0, 1}, {1, 0}}));
        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
            {0, 1, 0},
            {0, 0, 0},
            {0, 0, 1}}));
        System.out.println("Shortest bridge: " + obj.shortestBridge_Graph(new int[][]{
            {1, 1, 1, 1, 1},
            {1, 0, 0, 0, 1},
            {1, 0, 1, 0, 1},
            {1, 0, 0, 0, 1},
            {1, 1, 1, 1, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Detonate the Maximum Bombs");
        //https://leetcode.com/problems/detonate-the-maximum-bombs/description/
        obj.detonateMaxBombs_Graph(new int[][]{{2, 1, 3}, {6, 1, 4}});
        obj.detonateMaxBombs_Graph(new int[][]{{1, 1, 5}, {10, 10, 5}});
        obj.detonateMaxBombs_Graph(new int[][]{{1, 2, 3}, {2, 3, 1}, {3, 4, 2}, {4, 5, 3}, {5, 6, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Dungeon Game");
        //https://leetcode.com/problems/dungeon-game/description/
        obj.dungeonGame_Recursive_Memoization(new int[][]{{-2, -3, 3}, {-5, -10, 1}, {10, 30, -5}});
        obj.dungeonGame_Recursive_Memoization(new int[][]{{0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Previous Permutation With One Swap");
        //https://leetcode.com/problems/previous-permutation-with-one-swap/description/
        obj.previousPermutationWithOneSwap_Greedy(new int[]{3, 2, 1});
        obj.previousPermutationWithOneSwap_Greedy(new int[]{1, 1, 5});
        obj.previousPermutationWithOneSwap_Greedy(new int[]{1, 9, 4, 6, 7});
        obj.previousPermutationWithOneSwap_Greedy(new int[]{3, 1, 1, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Expressive Words");
        //https://leetcode.com/problems/expressive-words/description/
        obj.expressiveWords("heeellooo", new String[]{"hello", "hi", "helo"});
        obj.expressiveWords("zzzzzyyyyy", new String[]{"zzyy", "zy", "zyy"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find All Groups of Farmland");
        //https://leetcode.com/problems/find-all-groups-of-farmland/description/
        obj.findAllGroupOfFarmland_Graph(new int[][]{
            {1, 0, 0},
            {0, 1, 1},
            {0, 1, 1}});
        obj.findAllGroupOfFarmland_Graph(new int[][]{
            {1, 1},
            {1, 1}});
        obj.findAllGroupOfFarmland_Graph(new int[][]{{0}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sum of Distances in Tree");
        //https://leetcode.com/problems/sum-of-distances-in-tree/description/
        obj.sumOfDistancesInTree_Graph(2, new int[][]{{0, 1}});
        obj.sumOfDistancesInTree_Graph(6, new int[][]{{0, 1}, {0, 2}, {2, 3}, {2, 4}, {2, 5}});
        obj.sumOfDistancesInTree_Graph(1, new int[][]{});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Domino and Tromino Tiling");
        //https://leetcode.com/problems/domino-and-tromino-tiling/description/
        obj.dominoTrominoTiling_DP_Memoization(1);
        obj.dominoTrominoTiling_DP_Memoization(2);
        obj.dominoTrominoTiling_DP_Memoization(3);
        obj.dominoTrominoTiling_DP_Memoization(4);
        obj.dominoTrominoTiling_DP_Memoization(5);
        obj.dominoTrominoTiling_DP_Memoization(1000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Custom Sort String");
        //https://leetcode.com/problems/custom-sort-string/description/
        obj.customSortString("cba", "abcd");
        obj.customSortString("cbafg", "abcd");
        obj.customSortString("cba", "zxagabcdiz");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Single valued subtree");
//        //https://leetcode.com/problems/univalued-binary-tree/description/
//        //https://practice.geeksforgeeks.org/problems/single-valued-subtree/1
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(5));
//        root.getRight().setRight(new TreeNode<>(5));
//        obj.univaluedBinaryTree(root);
//        obj.countSingleValuedSubtreeInATree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Sum of Nodes with Even-Valued Grandparent");
//        //https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/description/
//        TreeNode<Integer> root = new TreeNode<>(6);
//        root.setLeft(new TreeNode<>(7));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().setRight(new TreeNode<>(7));
//        root.getLeft().getRight().setLeft(new TreeNode<>(1));
//        root.getLeft().getRight().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(8));
//        root.getRight().setLeft(new TreeNode<>(1));
//        root.getRight().setRight(new TreeNode<>(3));
//        root.getRight().getRight().setRight(new TreeNode<>(5));
//        obj.sumOfNodesWithEvenValuedGrandparent(root);
//        root = new TreeNode<>(1);
//        obj.sumOfNodesWithEvenValuedGrandparent(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Print Ancestor of given Target Node in a Binary Tree");
//        //https://youtu.be/2VZHLtHM_6w
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(5));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(9));
//        root.getLeft().getLeft().setRight(new TreeNode<>(2));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(10));
//        root.getRight().setRight(new TreeNode<>(6));
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 1);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 5);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 6);
//        obj.printAllAncestorOfTagetNodeInBinaryTree(root, 9);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("All Ancestors of a Node in a Directed Acyclic Graph");
        //https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/
        obj.allAncestorsOfAllNodesInDAG_Graph(8, new int[][]{{0, 3}, {0, 4}, {1, 3},
        {2, 4}, {2, 7}, {3, 5}, {3, 6}, {3, 7}, {4, 6}});
        obj.allAncestorsOfAllNodesInDAG_Graph(5, new int[][]{{0, 1}, {0, 2}, {0, 3},
        {0, 4}, {1, 2}, {1, 3}, {1, 4}, {2, 3}, {2, 4}, {3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Kth Ancestor of a Tree Node");
        //https://leetcode.com/problems/kth-ancestor-of-a-tree-node/description/
        obj.kThAncestorOfTreeNode_Graph(7, new int[]{-1, 0, 0, 1, 1, 2, 2}, new int[][]{{3, 1}, {5, 2}, {6, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Buddy Strings");
        //https://leetcode.com/problems/buddy-strings/description/
        System.out.println("Buddy strings: " + obj.buddyStrings("ab", "ab"));
        System.out.println("Buddy strings: " + obj.buddyStrings("aa", "aa"));
        System.out.println("Buddy strings: " + obj.buddyStrings("ab", "ba"));
        System.out.println("Buddy strings: " + obj.buddyStrings("abcaa", "abcbb"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Number of Balloons");
        //https://leetcode.com/problems/maximum-number-of-balloons/description/
        obj.maxNumberOfBalloonsFromText("balloon");
        obj.maxNumberOfBalloonsFromText("nlaebolko");
        obj.maxNumberOfBalloonsFromText("loonbalxballpoon");
        obj.maxNumberOfBalloonsFromText("leetcode");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Palindrome Partitioning");
        //https://leetcode.com/problems/palindrome-partitioning/description/
        obj.pallindromePartitioning_Backtracking("aab");
        obj.pallindromePartitioning_Backtracking("a");
        obj.pallindromePartitioning_Backtracking("aabbaa");
        System.out.println("Palindrome Partitioning II");
        //https://leetcode.com/problems/palindrome-partitioning-ii/description/
        obj.pallindromePartitioningTwo_Recursive_Memoization("a");
        obj.pallindromePartitioningTwo_Recursive_Memoization("aa");
        obj.pallindromePartitioningTwo_Recursive_Memoization("ab");
        obj.pallindromePartitioningTwo_Recursive_Memoization("aba");
        obj.pallindromePartitioningTwo_Recursive_Memoization("aab");
        obj.pallindromePartitioningTwo_DP_Memoization("a");
        obj.pallindromePartitioningTwo_DP_Memoization("aa");
        obj.pallindromePartitioningTwo_DP_Memoization("ab");
        obj.pallindromePartitioningTwo_DP_Memoization("aba");
        obj.pallindromePartitioningTwo_DP_Memoization("aab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Nodes From Linked List");
        //https://leetcode.com/problems/remove-nodes-from-linked-list/description/
        Node<Integer> head = new Node<>(5);
        head.setNext(new Node<>(2));
        head.getNext().setNext(new Node<>(13));
        head.getNext().getNext().setNext(new Node<>(3));
        head.getNext().getNext().getNext().setNext(new Node<>(8));
        obj.removeEveryNodeWhichHasStrictlyGreaterNodeToRight(head);
        head = new Node<>(1);
        head.setNext(new Node<>(1));
        head.getNext().setNext(new Node<>(1));
        head.getNext().getNext().setNext(new Node<>(1));
        obj.removeEveryNodeWhichHasStrictlyGreaterNodeToRight(head);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Wildcard Matching");
        //https://leetcode.com/problems/wildcard-matching/description/
        obj.wildCardMatching_Recursive_Memoization("aa", "a");
        obj.wildCardMatching_Recursive_Memoization("aa", "*");
        obj.wildCardMatching_Recursive_Memoization("cb", "?a");
        obj.wildCardMatching_Recursive_Memoization("abxyzef", "ab*ef");
        obj.wildCardMatching_Recursive_Memoization("abef", "ab*ef");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Chunks To Make Sorted I/ II");
        //https://leetcode.com/problems/max-chunks-to-make-sorted/description/
        obj.maxChunkToMakeSorted(new int[]{4, 3, 2, 1, 0});
        obj.maxChunkToMakeSorted(new int[]{1, 0, 2, 3, 4});
        obj.maxChunkToMakeSorted(new int[]{0, 1, 2, 3, 4});
        //https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/
        obj.maxChunkToMakeSortedTwo(new int[]{5, 4, 3, 2, 1});
        obj.maxChunkToMakeSortedTwo(new int[]{2, 1, 3, 4, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Increment to Make Array Unique");
        //https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/
        obj.minIncreamentToMakeArrayUnique(new int[]{1, 2, 2});
        obj.minIncreamentToMakeArrayUnique(new int[]{3, 2, 1, 2, 1, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Validate Stack Sequences");
        //https://leetcode.com/problems/validate-stack-sequences/description/
        obj.validateStackSequences(new int[]{1, 2, 3, 4, 5}, new int[]{4, 5, 3, 2, 1});
        obj.validateStackSequences(new int[]{1, 2, 3, 4, 5}, new int[]{4, 3, 5, 1, 2});
        obj.validateStackSequences2(new int[]{1, 2, 3, 4, 5}, new int[]{4, 5, 3, 2, 1});
        obj.validateStackSequences2(new int[]{1, 2, 3, 4, 5}, new int[]{4, 3, 5, 1, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Profit By Choosing A Subset Of Intervals");
        //https://practice.geeksforgeeks.org/problems/649205908e04ac00f303626fa845261318adfa8f/1
        obj.maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization(new int[][]{
            {1, 2, 4}, {1, 5, 7}, {2, 4, 4}});
        obj.maxProfitByChoosingSubsetOfIntervals_Recursive_Memoization(new int[][]{
            {1, 4, 4}, {2, 3, 7}, {2, 3, 4}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the longest string from the string array");
        //https://practice.geeksforgeeks.org/problems/8d157f11af5416087251513cfc38ffc4d23be308/1
        obj.findLongestString(new String[]{"ab", "a", "abc", "abd"});
        obj.findLongestString(new String[]{"ab", "a", "aa", "abd", "abc", "abda", "abdd", "abde", "abdab"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Moves to Equal Array Elements");
        //https://leetcode.com/problems/minimum-moves-to-equal-array-elements/description/
        obj.minMovesToEqualArrayElements(new int[]{1, 2, 3});
        obj.minMovesToEqualArrayElements(new int[]{1, 1, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Ice Cream Bars");
        //https://leetcode.com/problems/maximum-ice-cream-bars/description/
        obj.maxIcecreamBars_Greedy(new int[]{1, 3, 2, 4, 1}, 7);
        obj.maxIcecreamBars_Greedy(new int[]{10, 6, 8, 7, 7, 8}, 5);
        obj.maxIcecreamBars_Greedy(new int[]{1, 6, 3, 1, 2, 5}, 20);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Coloring A Border");
        //https://leetcode.com/problems/coloring-a-border/description/
        obj.coloringBorders_Graph(new int[][]{{1, 1}, {1, 2}}, 0, 0, 3);
        obj.coloringBorders_Graph(new int[][]{{1, 2, 2}, {2, 3, 2}}, 0, 1, 3);
        obj.coloringBorders_Graph(new int[][]{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, 1, 1, 3);
        obj.coloringBorders_Graph(new int[][]{{1, 1, 1, 1, 1}, {1, 2, 2, 2, 1},
        {1, 2, 2, 2, 1}, {1, 2, 2, 2, 1}, {1, 1, 1, 1, 1}}, 2, 2, 3);
        obj.coloringBorders_Graph(new int[][]{{1, 2, 1, 2, 1, 2}, {2, 2, 2, 2, 1, 2},
        {1, 2, 2, 2, 1, 2}}, 1, 3, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Interval List Intersections");
        //https://leetcode.com/problems/interval-list-intersections/description/
        obj.intervalsListIntersection(new int[][]{{0, 2}, {5, 10}, {13, 23}, {24, 25}},
                new int[][]{{1, 5}, {8, 12}, {15, 24}, {25, 26}});
        obj.intervalsListIntersection(new int[][]{{1, 3}, {5, 9}},
                new int[][]{});
        obj.intervalsListIntersection(new int[][]{{0, 5}, {12, 15}, {21, 25}},
                new int[][]{{6, 11}, {16, 20}, {26, 30}});
        obj.intervalsListIntersection(new int[][]{{0, 2}, {5, 10}},
                new int[][]{{1, 5}, {8, 12}, {15, 24}, {25, 26}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Absolute difference divisible by K");
        //https://practice.geeksforgeeks.org/problems/e0059183c88ab680b2f73f7d809fb8056fe9dc43/1
        obj.countPairsWithAbsoluteDiffDivisibleByK(new int[]{3, 7, 11}, 4);
        obj.countPairsWithAbsoluteDiffDivisibleByK(new int[]{1, 2, 3, 4}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Value of K Coins From Piles");
        //https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/
        obj.maxValueFromKCoinsFromPiles_Recursive_Memoization(new int[][]{{1, 100, 3}, {7, 8, 9}}, 2);
        obj.maxValueFromKCoinsFromPiles_Recursive_Memoization(
                new int[][]{{100}, {100}, {100}, {100}, {100}, {100}, {1, 1, 1, 1, 1, 1, 700}}, 7);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Time to Collect All Apples in a Tree");
        //https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/
        obj.minTimeToCollectAllApplesInATree_Graph(7,
                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}},
                new boolean[]{false, false, true, false, true, true, false});
        obj.minTimeToCollectAllApplesInATree_Graph(7,
                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}},
                new boolean[]{false, false, true, false, false, true, false});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Nodes in the Sub-Tree With the Same Label");
        //https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description/
        obj.numberOfNodesInSubtreeWithSameLabel_Graph(7,
                new int[][]{{0, 1}, {0, 2}, {1, 4}, {1, 5}, {2, 3}, {2, 6}}, "abaedcd");
        obj.numberOfNodesInSubtreeWithSameLabel_Graph(4,
                new int[][]{{0, 1}, {1, 2}, {0, 3}}, "bbbb");
        obj.numberOfNodesInSubtreeWithSameLabel_Graph(5,
                new int[][]{{0, 1}, {0, 2}, {1, 3}, {0, 4}}, "aabab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Path With Different Adjacent Characters");
        //https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 0, 1, 1, 2}, "abacbe");
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 0, 0}, "aabc");
        obj.longestPathWithDiffAdjacentCharsInTree_Graph(new int[]{-1, 0, 1}, "aab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Lexicographically Smallest Equivalent String");
        //https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/
        obj.lexicographicallySmallestEquivalentString_Graph("parker", "morris", "parser");
        obj.lexicographicallySmallestEquivalentString_Graph("hello", "world", "hold");
        obj.lexicographicallySmallestEquivalentString_Graph("leetcode", "programs", "sourcecode");
        obj.lexicographicallySmallestEquivalentString_Graph(
                "opecenadojbodihfgmpijpfocomhcncicefpohkibjckijghii",
                "ndlbhpaeppgekfhnjnmmplmdoifdhbglmedpjgleofgnahglbe",
                "ttusuhhrabgsswpaapxoxdanchyccmpjitwwmfioedtbiggfru");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Accounts Merge");
        //https://leetcode.com/problems/accounts-merge/description/
        obj.accountsMerge_Graph(new String[][]{
            {"John", "johnsmith@mail.com", "john_newyork@mail.com"},
            {"John", "johnsmith@mail.com", "john00@mail.com"},
            {"Mary", "mary@mail.com"},
            {"John", "johnnybravo@mail.com"}});
        obj.accountsMerge_Graph(new String[][]{
            {"Gabe", "Gabe0@m.co", "Gabe3@m.co", "Gabe1@m.co"},
            {"Kevin", "Kevin3@m.co", "Kevin5@m.co", "Kevin0@m.co"},
            {"Ethan", "Ethan5@m.co", "Ethan4@m.co", "Ethan0@m.co"},
            {"Hanzo", "Hanzo3@m.co", "Hanzo1@m.co", "Hanzo0@m.co"},
            {"Fern", "Fern5@m.co", "Fern1@m.co", "Fern0@m.co"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Apply Discount to Prices");
        //https://leetcode.com/problems/apply-discount-to-prices/description/
        obj.applyDiscountToPrices("there are $1 $2 and 5$ candies in the shop", 50);
        obj.applyDiscountToPrices("1 2 $3 4 $5 $6 7 8$ $9 $10$", 100);
        //round off required case
        obj.applyDiscountToPrices("duew$11mengf $8 $1", 7);
        //amount of long type required
        obj.applyDiscountToPrices("706hzu76jjh7yufr5x9ot60v149k5 $7651913186 pw2o $6", 28);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove All Occurrences of a Substring");
        //https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/
        obj.removeAllOccurencesOfSubstring("daabcbaabcbc", "abc");
        obj.removeAllOccurencesOfSubstring("axxxxyyyyb", "xy");
        obj.removeAllOccurencesOfSubstring("abcabcabcabcabc", "abc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove One Element to Make the Array Strictly Increasing");
        //https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/description/
        System.out.println("Is array strictly increasing: "
                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{1, 2, 10, 5, 7}));
        System.out.println("Is array strictly increasing: "
                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{2, 3, 1, 2}));
        System.out.println("Is array strictly increasing: "
                + obj.removeOneElementMakeArrayStrictlyIncr(new int[]{1, 1, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Chunked Palindrome Decomposition");
        //https://leetcode.com/problems/longest-chunked-palindrome-decomposition/description/
        obj.longestChunkedPallindromeDecomposition_Greedy("ghiabcdefhelloadamhelloabcdefghi");
        obj.longestChunkedPallindromeDecomposition_Greedy("merchant");
        obj.longestChunkedPallindromeDecomposition_Greedy("antaprezatepzapreanta");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Decoded String at Index");
        //https://leetcode.com/problems/decoded-string-at-index/description/
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("leet2code3", 10));
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("ha22", 5));
        System.out.println("Decode string at index: " + obj.decodeStringAtIndex("a2345678999999999999999", 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Restore IP Addresses");
        //https://leetcode.com/problems/restore-ip-addresses/description/
        obj.restoreIPAddresses_Backtracking("25525511135");
        obj.restoreIPAddresses_Backtracking("0000");
        obj.restoreIPAddresses_Backtracking("101023");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Snakes and Ladders");
        //https://leetcode.com/problems/snakes-and-ladders/description/
        obj.snakesAndLadder_Graph(new int[][]{
            {-1, -1, -1, -1, -1, -1},
            {-1, -1, -1, -1, -1, -1},
            {-1, -1, -1, -1, -1, -1},
            {-1, 35, -1, -1, 13, -1},
            {-1, -1, -1, -1, -1, -1},
            {-1, 15, -1, -1, -1, -1}});
        obj.snakesAndLadder_Graph(new int[][]{
            {-1, -1}, {-1, 3}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Closest Node to Given Two Nodes");
        //https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/
        obj.findClosestNodeToGivenTwoNodes_Graph(new int[]{2, 2, 3, -1}, 0, 1);
        obj.findClosestNodeToGivenTwoNodes_Graph(new int[]{1, 2, -1}, 0, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Data Stream as Disjoint Intervals");
        //https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/
        obj.dataStreamAsDisjointIntervals(
                Arrays.asList("addNum", "getIntervals", "addNum", "getIntervals",
                        "addNum", "getIntervals", "addNum", "getIntervals",
                        "addNum", "getIntervals"),
                Arrays.asList(1, -1, 3, -1, 7, -1, 2, -1, 6, -1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Best Team With No Conflicts");
        //https://leetcode.com/problems/best-team-with-no-conflicts/description/
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{1, 3, 5, 10, 15}, new int[]{1, 2, 3, 4, 5});
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{4, 5, 6, 5}, new int[]{2, 1, 2, 1});
        obj.bestTeamWithNoConflict_DP_Memoization(new int[]{1, 2, 3, 5}, new int[]{8, 9, 10, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Naming a Company");
        //https://leetcode.com/problems/naming-a-company/description/
        obj.namingACompany(new String[]{"coffee", "donuts", "time", "toffee"});
        obj.namingACompany(new String[]{"lack", "back"});
        obj.namingACompany(new String[]{"phhrrjjcm", "zjfkpps", "pm", "fnpduelfe", "mxtvjnq"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Greatest Common Divisor of Strings");
        //https://leetcode.com/problems/greatest-common-divisor-of-strings/description/
        System.out.println("Greatest common divisor of strings : "
                + obj.greatestCommonDivisorOfStrings("ABCABC", "ABC"));
        System.out.println("Greatest common divisor of strings : "
                + obj.greatestCommonDivisorOfStrings("ABABAB", "ABAB"));
        System.out.println("Greatest common divisor of strings : "
                + obj.greatestCommonDivisorOfStrings("LEET", "CODE"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path with Alternating Colors");
        https://leetcode.com/problems/shortest-path-with-alternating-colors/description/
        obj.shortestPathWithAlternatingColors_Graph(3, new int[][]{{0, 1}, {1, 2}}, new int[][]{});
        obj.shortestPathWithAlternatingColors_Graph(3, new int[][]{{0, 1}}, new int[][]{{2, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Divide Players Into Teams of Equal Skill");
        //https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/description/
        System.out.println("Player chemistry : "
                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 2, 5, 1, 3, 4}));
        System.out.println("Player chemistry : "
                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 4}));
        System.out.println("Player chemistry : "
                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{1, 1, 2, 3}));
        System.out.println("Player chemistry : "
                + obj.dividePlayersIntoTeamsOfEqualSkill(new int[]{3, 2, 5, 1, 3, 6}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Fuel Cost to Report to the Capital");
        //https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/
        obj.minFuelToReachCapitalCity_Graph(new int[][]{{0, 1}, {0, 2}, {0, 3}}, 5);
        obj.minFuelToReachCapitalCity_Graph(new int[][]{{3, 1}, {3, 2}, {1, 0}, {0, 4}, {0, 5}, {4, 6}}, 2);
        obj.minFuelToReachCapitalCity_Graph(new int[][]{}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Odd Numbers in an Interval Range");
        //https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/
        obj.countOddNumbersInIntervalRange(3, 7);
        obj.countOddNumbersInIntervalRange(8, 10);
        obj.countOddNumbersInIntervalRange(278382788, 569302584);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Good Ways to Split a String");
        //https://leetcode.com/problems/number-of-good-ways-to-split-a-string/description/
        obj.numberOfGoodWaysToSplitString("aacaba");
        obj.numberOfGoodWaysToSplitString("abcd");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Cheapest Flights Within K Stops");
        //https://leetcode.com/problems/cheapest-flights-within-k-stops/description/
        obj.cheapestFlightsWithinKStops_Graph(4,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {2, 0, 100}, {1, 3, 600}, {2, 3, 200}}, 0, 3, 1);
        obj.cheapestFlightsWithinKStops_Graph(3,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {0, 2, 500}}, 0, 2, 1);
        obj.cheapestFlightsWithinKStops_Graph(3,
                new int[][]{{0, 1, 100}, {1, 2, 100}, {0, 2, 500}}, 0, 2, 0);
        obj.cheapestFlightsWithinKStops_Graph(4,
                new int[][]{{0, 1, 1}, {0, 2, 5}, {1, 2, 1}, {2, 3, 1}}, 0, 3, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Letter Case Permutation");
        //https://leetcode.com/problems/letter-case-permutation/description/
        obj.letterCasePermutation_Backtracking("a1b2");
        obj.letterCasePermutation_Backtracking("3z4");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Repeated String Match");
        //https://leetcode.com/problems/repeated-string-match/description/
        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("abcd", "cdabcdab"));
        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("a", "aa"));
        System.out.println("Repeated string match count: " + obj.repeatedStringMatch("aaaaaaaaaaaaaaab", "ba"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Append K Integers With Minimal Sum");
        //https://leetcode.com/problems/append-k-integers-with-minimal-sum/description/
        obj.appendKIntegerWithMinSum_Greedy(new int[]{1, 4, 25, 10, 25}, 2);
        obj.appendKIntegerWithMinSum_Greedy(new int[]{5, 6}, 6);
        obj.appendKIntegerWithMinSum_Greedy(new int[]{1}, 100000000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Create Binary Tree From Descriptions");
        //https://leetcode.com/problems/create-binary-tree-from-descriptions/description/
        obj.createBinaryTreeFromDescription_Graph(new int[][]{{20, 15, 1}, {20, 17, 0},
        {50, 20, 1}, {50, 80, 0}, {80, 19, 1}});
        obj.createBinaryTreeFromDescription_Graph(new int[][]{{1, 2, 1}, {2, 3, 0}, {3, 4, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Time to Complete Trips");
        //https://leetcode.com/problems/minimum-time-to-complete-trips/description/
        obj.minTimeToCompleteTrips(new int[]{1, 2, 3}, 5);
        obj.minTimeToCompleteTrips(new int[]{2}, 1);
        obj.minTimeToCompleteTrips(new int[]{100}, 10000000);
        obj.minTimeToCompleteTrips(new int[]{1000}, 10000000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Kth Largest Sum in a Binary Tree");
//        //https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description/
//        TreeNode<Integer> root = new TreeNode<>(5);
//        root.setLeft(new TreeNode<>(8));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(1));
//        root.getLeft().getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().getLeft().setRight(new TreeNode<>(6));
//        root.setRight(new TreeNode<>(9));
//        root.getRight().setLeft(new TreeNode<>(3));
//        root.getRight().setRight(new TreeNode<>(7));
//        obj.kthLargestLevelSumInBinaryTree(root, 2);
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(3));
//        obj.kthLargestLevelSumInBinaryTree(root, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Number of Good Leaf Nodes Pairs");
//        //https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(3));
//        System.out.println("Pairs of good leaf nodes in binary tree: "
//                + obj.numberOfGoodLeafNodesPairsOFBinaryTree(root, 3));
//        root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(2));
//        root.getLeft().setLeft(new TreeNode<>(4));
//        root.getLeft().setRight(new TreeNode<>(5));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(6));
//        root.getRight().setRight(new TreeNode<>(7));
//        System.out.println("Pairs of good leaf nodes in binary tree: "
//                + obj.numberOfGoodLeafNodesPairsOFBinaryTree(root, 3));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Operations to Convert Number");
        //https://leetcode.com/problems/minimum-operations-to-convert-number/description/
        System.out.println("Minimum operations to convert number: "
                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{2, 4, 12}, 2, 12));
        System.out.println("Minimum operations to convert number: "
                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{3, 5, 7}, 0, -4));
        System.out.println("Minimum operations to convert number: "
                + obj.minNumberOfOperationsToConvertNumber_Graph(new int[]{2, 8, 16}, 0, 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Reward Top K Students");
        //https://leetcode.com/problems/reward-top-k-students/description/
        obj.rewardTopKStudents(
                new String[]{"smart", "brilliant", "studious"},
                new String[]{"not"},
                new String[]{"this student is studious", "the student is smart"},
                new int[]{1, 2},
                2);
        obj.rewardTopKStudents(
                new String[]{"smart", "brilliant", "studious"},
                new String[]{"not"},
                new String[]{"this student is not studious", "the student is smart"},
                new int[]{1, 2},
                2);
        obj.rewardTopKStudents(
                new String[]{"fkeofjpc", "qq", "iio"},
                new String[]{"jdh", "khj", "eget", "rjstbhe", "yzyoatfyx", "wlinrrgcm"},
                new String[]{"rjstbhe eget kctxcoub urrmkhlmi yniqafy fkeofjpc iio yzyoatfyx khj iio",
                    "gpnhgabl qq qq fkeofjpc dflidshdb qq iio khj qq yzyoatfyx",
                    "tizpzhlbyb eget z rjstbhe iio jdh jdh iptxh qq rjstbhe",
                    "jtlghe wlinrrgcm jnkdbd k iio et rjstbhe iio qq jdh",
                    "yp fkeofjpc lkhypcebox rjstbhe ewwykishv egzhne jdh y qq qq",
                    "fu ql iio fkeofjpc jdh luspuy yzyoatfyx li qq v",
                    "wlinrrgcm iio qq omnc sgkt tzgev iio iio qq qq",
                    "d vhg qlj khj wlinrrgcm qq f jp zsmhkjokmb rjstbhe"},
                new int[]{96537918, 589204657, 765963609, 613766496, 43871615, 189209587, 239084671, 908938263},
                3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Can Place Flowers");
        //https://leetcode.com/problems/can-place-flowers/description/
        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 1}, 1));
        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 1}, 2));
        System.out.println("Can place flower: " + obj.canPlaceFlowers_Greedy(new int[]{1, 0, 0, 0, 0, 1}, 2));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Score For String rp Or pr");
        //https://leetcode.com/problems/maximum-score-from-removing-substrings/description/
        //https://practice.geeksforgeeks.org/problems/d25f415de2ff3e02134de03e17ad019d723ab2e9/1
        obj.maxScoreForString_Greedy("cdbcbbaaabab", 4, 5);
        obj.maxScoreForString_Greedy("aabbaaxybbaabb", 5, 4);
        obj.maxScoreForString_Greedy("lbbfbbabgabaaaaamubb", 10, 20);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Greatest Sum Divisible by Three");
        //https://leetcode.com/problems/greatest-sum-divisible-by-three/description/
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{3, 6, 5, 1, 8});
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{4});
        obj.greatestSumDivisibleByThree_DP_Memoization(new int[]{1, 2, 3, 4, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Score of a Path Between Two Cities");
        //https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/
        obj.minScoreOfPathBetweenTwoCities_Graph(4, new int[][]{{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}});
        obj.minScoreOfPathBetweenTwoCities_Graph(4, new int[][]{{1, 2, 2}, {1, 3, 4}, {3, 4, 7}});
        obj.minScoreOfPathBetweenTwoCities_Graph_UnionFind(4, new int[][]{{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}});
        obj.minScoreOfPathBetweenTwoCities_Graph_UnionFind(4, new int[][]{{1, 2, 2}, {1, 3, 4}, {3, 4, 7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Operations to Make Network Connected");
        //https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(4,
                        new int[][]{{0, 1}, {0, 2}, {1, 2}}));
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(6,
                        new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}}));
        System.out.println("Number of operations to make network connected: "
                + obj.numberOfOperationToMakeNetworkConnected_Graph(6,
                        new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(4,
                        new int[][]{{0, 1}, {0, 2}, {1, 2}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(6,
                        new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}}));
        System.out.println("Number of operations to make network connected (Union-Find): "
                + obj.numberOfOperationToMakeNetworkConnected_Graph_UnionFind(6,
                        new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 2}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Check if There is a Valid Path in a Grid");
        //https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/description/
        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{2, 4, 3}, {6, 5, 2}});
        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{1, 2, 1}, {1, 2, 1}});
        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{1, 1, 2}});
        obj.checkIfValidPathInStreetGrid_Graph(new int[][]{{2, 6, 3}, {6, 5, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Cycle in a Graph");
        //https://leetcode.com/problems/longest-cycle-in-a-graph/description/
        obj.longestCycleInGraph_Graph(new int[]{3, 3, 4, 2, 3});
        obj.longestCycleInGraph_Graph(new int[]{2, -1, 3, 1});
        obj.longestCycleInGraph_Graph(new int[]{3, 3, 0, 0, 7, 0, 7, 5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Alphabet Board Path");
        //https://leetcode.com/problems/alphabet-board-path/description/
        obj.alphabetBoardPath("leet");
        obj.alphabetBoardPath("code");
        obj.alphabetBoardPath("zdz");
        obj.alphabetBoardPath("lezet");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Cost For Tickets");
        //https://leetcode.com/problems/minimum-cost-for-tickets/description/
        obj.minCostForTickets_Recursive_Memoization(new int[]{1, 4, 6, 7, 8, 20},
                new int[]{2, 7, 15});
        obj.minCostForTickets_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 31},
                new int[]{2, 7, 15});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Reducing Dishes");
        //https://leetcode.com/problems/reducing-dishes/description/
        obj.reducingDishes_Recursive_Memoization(new int[]{-1, -8, 0, 5, -9});
        obj.reducingDishes_Recursive_Memoization(new int[]{4, 3, 2});
        obj.reducingDishes_Recursive_Memoization(new int[]{-1, -4, -5});
        //greedy solution
        obj.reducingDishes_Greedy(new int[]{-1, -8, 0, 5, -9});
        obj.reducingDishes_Greedy(new int[]{4, 3, 2});
        obj.reducingDishes_Greedy(new int[]{-1, -4, -5});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Subarray Sum with One Deletion");
        //https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/description/
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{1, -2, 0, 3});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{1, -2, -2, 3});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{-1, -1, -1, -1});
        obj.maxSubarraySumWithAtmostOneDeletion(new int[]{100, 30, 1, 987, 400, 200, 9});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Scramble String");
        //https://leetcode.com/problems/scramble-string/description/
        obj.scrambledStrings_Recursive_Memoization("great", "rgeat");
        obj.scrambledStrings_Recursive_Memoization("abcde", "caebd");
        obj.scrambledStrings_Recursive_Memoization("a", "a");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways of Cutting a Pizza");
        //https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description/
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "AAA", "..."}, 3);
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "AA.", "..."}, 3);
        obj.numberOfWaysOfCuttingPizza_Recursive_Memoization(new String[]{"A..", "A..", "..."}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Take K of Each Character From Left and Right");
        //https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/
        System.out.println("Min k char pick up from left & right: "
                + obj.takeKOfEachCharFromLeftRight("aabaaaacaabc", 2));
        System.out.println("Min k char pick up from left & right: "
                + obj.takeKOfEachCharFromLeftRight("a", 1));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Swap Adjacent in LR String");
        //https://leetcode.com/problems/swap-adjacent-in-lr-string/description/
        System.out.println("Swap adjacent LR string possible: " + obj.swapAdjacentLRString("RXXLRXRXL", "XRLXXRRLX"));
        System.out.println("Swap adjacent LR string possible: " + obj.swapAdjacentLRString("X", "L"));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Successful Pairs of Spells and Potions");
        //https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/
        obj.successfulPairsOfSpellsAndPotions(new int[]{5, 1, 3}, new int[]{1, 2, 3, 4, 5}, 7);
        obj.successfulPairsOfSpellsAndPotions(new int[]{3, 1, 2}, new int[]{8, 5, 8}, 16);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Steps Required To Make String Empty");
        //https://practice.geeksforgeeks.org/problems/6a1b365b520f10c8a29b533eb72951b4b4237b57/1
        obj.minStepsReqToMakeStringEmpty_Greedy("bbaaabb");
        obj.minStepsReqToMakeStringEmpty_Greedy("aababaa");
        obj.minStepsReqToMakeStringEmpty_Greedy("bababa");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimize Maximum of Array");
        //https://leetcode.com/problems/minimize-maximum-of-array/description/
        obj.minimizeMaxArray_Greedy(new int[]{3, 7, 1, 6});
        obj.minimizeMaxArray_Greedy(new int[]{10, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Without AAA or BBB");
        //https://leetcode.com/problems/string-without-aaa-or-bbb/description/
        obj.stringWithoutAAAOrBBB_Greedy(1, 2);
        obj.stringWithoutAAAOrBBB_Greedy(4, 1);
        obj.stringWithoutAAAOrBBB_Greedy(4, 8);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Outermost Parentheses");
        //https://leetcode.com/problems/remove-outermost-parentheses/description/
        obj.removeOutermostParenthesis("(()())(())");
        obj.removeOutermostParenthesis("(()())(())(()(()))");
        obj.removeOutermostParenthesis("()()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Largest Color Value in a Directed Graph");
        //https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/
        System.out.println("Largest color value in directed graph : "
                + obj.largestColorValueInDirectedGraph_Graph("abaca", new int[][]{{0, 1}, {0, 2}, {2, 3}, {3, 4}}));
        System.out.println("Largest color value in directed graph : "
                + obj.largestColorValueInDirectedGraph_Graph("a", new int[][]{{0, 0}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Target Sum");
        //https://leetcode.com/problems/target-sum/description/
        obj.targetSum_Recursive_Memoization(new int[]{1, 1, 1, 1, 1}, 3);
        obj.targetSum_Recursive_Memoization(new int[]{1}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Form a Target String Given a Dictionary");
        //https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/
        obj.waysToFormStringFromDict_Recursive_Memoization(new String[]{"acca", "bbbb", "caca"}, "aba");
        obj.waysToFormStringFromDict_Recursive_Memoization(new String[]{"abba", "baab"}, "bab");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Maximum Number of Marked Indices");
        //https://leetcode.com/problems/find-the-maximum-number-of-marked-indices/description/
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{3, 5, 2, 4});
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{9, 2, 5, 4});
        obj.maxNumberOfMarkedIndices_Greedy(new int[]{7, 6, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Additions to Make Valid String");
        //https://leetcode.com/problems/minimum-additions-to-make-valid-string/description/
        obj.minAdditionToMakeValidString("b");
        obj.minAdditionToMakeValidString("aaa");
        obj.minAdditionToMakeValidString("abc");
        obj.minAdditionToMakeValidString("aaaabbbc");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximum Sum BST in Binary Tree");
//        //https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/description/
//        TreeNode<Integer> root = new TreeNode<>(1);
//        root.setLeft(new TreeNode<>(4));
//        root.getLeft().setLeft(new TreeNode<>(2));
//        root.getLeft().setRight(new TreeNode<>(4));
//        root.setRight(new TreeNode<>(3));
//        root.getRight().setLeft(new TreeNode<>(2));
//        root.getRight().setRight(new TreeNode<>(5));
//        root.getRight().getRight().setLeft(new TreeNode<>(4));
//        root.getRight().getRight().setRight(new TreeNode<>(6));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(4);
//        root.setLeft(new TreeNode<>(3));
//        root.getLeft().setLeft(new TreeNode<>(1));
//        root.getLeft().setRight(new TreeNode<>(2));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(-4);
//        root.setLeft(new TreeNode<>(-2));
//        root.setRight(new TreeNode<>(-5));
//        obj.maxSumBSTInBinaryTree(root);
//        root = new TreeNode<>(-2);
//        root.setLeft(new TreeNode<>(-6));
//        root.getLeft().setLeft(new TreeNode<>(-7));
//        root.getLeft().setRight(new TreeNode<>(-4));
//        root.setRight(new TreeNode<>(-1));
//        obj.maxSumBSTInBinaryTree(root);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Differ By One Char");
        //https://leetcode.com/problems/strings-differ-by-one-character/
        //https://leetcode.ca/2020-03-02-1554-Strings-Differ-by-One-Character/
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar(new String[]{"abcd", "acbd", "aacd"}));
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar(new String[]{"ab", "cd", "yz"}));
        System.out.println("Strings differ by one char : "
                + obj.stringsDifferByOneChar(new String[]{"abcd", "cccc", "abyd", "abab"}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Profitable Schemes");
        //https://leetcode.com/problems/profitable-schemes/description/
        obj.profitableScheme_Recursive_Memoization(5, 3, new int[]{2, 2}, new int[]{2, 3});
        obj.profitableScheme_Recursive_Memoization(10, 5, new int[]{2, 3, 5}, new int[]{6, 7, 8});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Similar String Groups");
        //https://leetcode.com/problems/similar-string-groups/description/
        obj.similarStringGroups_Graph(new String[]{"tars", "rats", "arts", "star"});
        obj.similarStringGroups_Graph(new String[]{"omv", "ovm"});
        obj.similarStringGroups_Graph_UnionFind(new String[]{"tars", "rats", "arts", "star"});
        obj.similarStringGroups_Graph_UnionFind(new String[]{"omv", "ovm"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sum Of Integer Smaller Than Each Value of Array");
        //https://practice.geeksforgeeks.org/problems/5877fde1c8e1029658845cd4bc94066ac1d4b09b/1
        obj.smallerSumThanEachValueInArray(new int[]{1, 2, 3});
        obj.smallerSumThanEachValueInArray(new int[]{4, 4});
        obj.smallerSumThanEachValueInArray(
                new int[]{0, 7, 7, 9, 0, 0, 5, 1, 0, 6, 6, 5, 8, 9, 9, 9, 1, 2, 4, 3});
        obj.smallerSumThanEachValueInArray_HashMapBased(new int[]{1, 2, 3});
        obj.smallerSumThanEachValueInArray_HashMapBased(new int[]{4, 4});
        obj.smallerSumThanEachValueInArray_HashMapBased(
                new int[]{0, 7, 7, 9, 0, 0, 5, 1, 0, 6, 6, 5, 8, 9, 9, 9, 1, 2, 4, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Restore The Array");
        //https://leetcode.com/problems/restore-the-array/description/
        obj.restoreArray_Recursive_Memoization("1000", 10000);
        obj.restoreArray_Recursive_Memoization("1000", 10);
        obj.restoreArray_Recursive_Memoization("1317", 2000);
        obj.restoreArray_Recursive_Memoization("48486250454844645287030712560644579294181", 989);
        obj.restoreArray_DP_Memoization("1000", 10000);
        obj.restoreArray_DP_Memoization("1000", 10);
        obj.restoreArray_DP_Memoization("1317", 2000);
        obj.restoreArray_DP_Memoization("48486250454844645287030712560644579294181", 989);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Ways To Make K Partiton String Of Length M");
        //https://leetcode.com/discuss/interview-question/2257966/Google-OA
        obj.waysToMakeKPartitionStringOfMLength_Recursive_Memoization("232387421", 3, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Graph As Tree Diameter");
        //https://leetcode.com/problems/tree-diameter/
        //https://leetcode.ca/all/1245.html
        obj.graphAsTreeDiameter_Graph(new int[][]{{0, 1}, {0, 2}});
        obj.graphAsTreeDiameter_Graph(new int[][]{{0, 1}, {1, 2}, {2, 3}, {1, 4}, {4, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Nearest smaller tower");
        //https://practice.geeksforgeeks.org/problems/a520c08a8ea9b617be25c38b0fc2fe057e889253/1
        obj.nearestSmallerTower(new int[]{1, 3, 2});
        obj.nearestSmallerTower(new int[]{4, 8, 3, 5, 3});
        obj.nearestSmallerTower(new int[]{1, 2, 3, 2, 1, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Next Greater Element IV");
        //https://leetcode.com/problems/next-greater-element-iv/description/
        obj.nearestGreaterElementFour(new int[]{2, 4, 0, 9, 6});
        obj.nearestGreaterElementFour(new int[]{3, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Operations to Reduce X to Zero");
        //https://leetcode.com/problems/minimum-operations-to-reduce-row-to-zero/description/
        obj.minOperationToReduceXToZero(new int[]{1, 1, 4, 2, 3}, 5);
        obj.minOperationToReduceXToZero(new int[]{5, 6, 7, 8, 9}, 4);
        obj.minOperationToReduceXToZero(new int[]{3, 2, 20, 1, 1, 3}, 10);
        obj.minOperationToReduceXToZero(new int[]{1, 1}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Shortest Path in Weighted undirected graph");
        //https://leetcode.com/problems/design-graph-with-shortest-path-calculator/description/
        //https://practice.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
        obj.shorestPathInWeightedUndirectedGraph_Graph(5,
                new int[][]{{1, 2, 2}, {2, 5, 5}, {2, 3, 4}, {1, 4, 1}, {4, 3, 3}, {3, 5, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Checking Existence of Edge Length Limited Paths");
        //https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/
        //TLE for normal DFS based approach for larger inputs
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph(3,
                new int[][]{{0, 1, 2}, {1, 2, 4}, {2, 0, 8}, {1, 0, 16}},
                new int[][]{{0, 1, 2}, {0, 2, 5}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph(5,
                new int[][]{{0, 1, 10}, {1, 2, 5}, {2, 3, 9}, {3, 4, 13}},
                new int[][]{{0, 4, 14}, {1, 4, 13}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(3,
                new int[][]{{0, 1, 2}, {1, 2, 4}, {2, 0, 8}, {1, 0, 16}},
                new int[][]{{0, 1, 2}, {0, 2, 5}});
        obj.checkExistenceOfEdgeLengthLimitedPaths_Graph_UnionFindApproach(5,
                new int[][]{{0, 1, 10}, {1, 2, 5}, {2, 3, 9}, {3, 4, 13}},
                new int[][]{{0, 4, 14}, {1, 4, 13}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Redundant Connection");
        //https://leetcode.com/problems/redundant-connection/description/
        obj.redundantConnections_Graph(new int[][]{{1, 2}, {1, 3}, {2, 3}});
        obj.redundantConnections_Graph(new int[][]{{1, 2}, {2, 3}, {3, 4}, {1, 4}, {1, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Remove Max Number of Edges to Keep Graph Fully Traversable");
        //https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 1, 2}, {3, 2, 3}, {1, 1, 3}, {1, 2, 4}, {1, 1, 2}, {2, 3, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 1, 2}, {3, 2, 3}, {1, 1, 4}, {2, 1, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(4,
                new int[][]{{3, 2, 3}, {1, 1, 2}, {2, 3, 4}});
        obj.removeMaxEdgesToKeepGraphFullyTraversable_Graph(2,
                new int[][]{{1, 1, 2}, {2, 1, 2}, {3, 1, 2}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Combination Sum IV (4)");
        //https://leetcode.com/problems/combination-sum-iv/description/
        obj.combinationSumFour_Recursive_Memoization(new int[]{1, 2, 3}, 4);
        obj.combinationSumFour_Recursive_Memoization(new int[]{9}, 3);
        obj.combinationSumFour_Recursive_Memoization(new int[]{1, 2, 3}, 32);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Prefix Common Array of Two Arrays");
        //https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/
        obj.prefixCommonArrayOfTwoArrays(new int[]{1, 3, 2, 4}, new int[]{3, 1, 2, 4});
        obj.prefixCommonArrayOfTwoArrays(new int[]{2, 3, 1}, new int[]{3, 1, 2});
        obj.prefixCommonArrayOfTwoArrays(new int[]{1, 2, 3, 4}, new int[]{1, 2, 3, 4});
        obj.prefixCommonArrayOfTwoArrays(new int[]{4, 3, 2, 1}, new int[]{1, 2, 3, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Dota2 Senate");
        //https://leetcode.com/problems/dota2-senate/description/
        obj.dota2Senate_Greedy("RD");
        obj.dota2Senate_Greedy("RDD");
        obj.dota2Senate_Greedy("RRDRD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Detect Cycles in 2D Grid");
        //https://leetcode.com/problems/detect-cycles-in-2d-grid/description/
        obj.detectCycleIn2DGrid_Graph(new char[][]{
            {'a', 'a', 'a', 'a'},
            {'a', 'b', 'b', 'a'},
            {'a', 'b', 'b', 'a'},
            {'a', 'a', 'a', 'a'}});
        obj.detectCycleIn2DGrid_Graph(new char[][]{
            {'c', 'c', 'c', 'a'},
            {'c', 'd', 'c', 'c'},
            {'c', 'c', 'e', 'c'},
            {'f', 'c', 'c', 'c'}});
        obj.detectCycleIn2DGrid_Graph(new char[][]{
            {'a', 'b', 'b'},
            {'b', 'z', 'b'},
            {'b', 'b', 'a'}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Subsequences That Satisfy the Given Sum Condition");
        //https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/
        obj.subseqSatisfyGivenSumCond_1(new int[]{3, 5, 6, 7}, 9);
        obj.subseqSatisfyGivenSumCond_1(new int[]{3, 3, 6, 8}, 10);
        obj.subseqSatisfyGivenSumCond_1(new int[]{2, 3, 3, 4, 6, 7}, 12);
        obj.subseqSatisfyGivenSumCond_2(new int[]{3, 5, 6, 7}, 9);
        obj.subseqSatisfyGivenSumCond_2(new int[]{3, 3, 6, 8}, 10);
        obj.subseqSatisfyGivenSumCond_2(new int[]{2, 3, 3, 4, 6, 7}, 12);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Check if Array Is Sorted and Rotated");
        //https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{3, 4, 5, 1, 2}));
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{2, 1, 3, 4}));
        System.out.println("Check if array is sorrted and rotated : "
                + obj.checkIfArrayIsSortedAndRotated(new int[]{1, 2, 3}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Longest Valid Obstacle Course at Each Position");
        //https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description/
        obj.longestValidObstacleCourseAtEachPosition(new int[]{1, 2, 3, 2});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{2, 2, 1});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{3, 1, 5, 6, 4, 2});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{5, 1, 5, 5, 1, 3, 4, 5, 1, 4});
        obj.longestValidObstacleCourseAtEachPosition(new int[]{5, 2, 5, 4, 1, 1, 1, 5, 3, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Reach a Position After Exactly k Steps");
        //https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(1, 2, 3);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(2, 5, 10);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(989, 1000, 99);
        obj.waysToReachAPositionAfterKSteps_Recursive_Memoization(1, 1000, 1000);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("String Mirror");
        //https://practice.geeksforgeeks.org/problems/d385b9d635b7b10eef6bf365b84922aaeec9eb98/1
        obj.stringMirror("bvdfndkn");
        obj.stringMirror("casd");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Making A Large Island");
        //https://leetcode.com/problems/making-a-large-island/description/
        System.out.println("Making a large island : " + obj.makingALargeIsland_Graph(new int[][]{{1}}));
        System.out.println("Making a large island : " + obj.makingALargeIsland_Graph(new int[][]{{0}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
            {1, 0},
            {0, 1}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
            {1, 1},
            {1, 0}}));
        System.out.println("Making a large island : "
                + obj.makingALargeIsland_Graph(new int[][]{
            {1, 1},
            {1, 1}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Amount of Time to Fill Cups");
        //https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/description/
        obj.minTimeToFillCups_Greedy(new int[]{1, 4, 2});
        obj.minTimeToFillCups_Greedy(new int[]{5, 4, 4});
        obj.minTimeToFillCups_Greedy(new int[]{5, 0, 0});
        obj.minTimeToFillCups_Greedy(new int[]{0, 0, 0});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Validate Binary Tree Nodes");
        //https://leetcode.com/problems/validate-binary-tree-nodes/description/
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(4, new int[]{1, -1, 3, -1}, new int[]{2, -1, -1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(4, new int[]{1, -1, 3, -1}, new int[]{2, 3, -1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(2, new int[]{1, 0}, new int[]{-1, -1}));
        System.out.println("validate binary tree nodes : "
                + obj.validateBinaryTreeNodes_Graph(3, new int[]{1, -1, -1}, new int[]{-1, -1, 1}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Elements to Add to Form a Given Sum");
        //https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/description/
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{1, -1, 1}, 3, -4);
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{1, -10, 9, 1}, 100, 0);
        obj.minElementsToAddToFormGivenSum_Greedy(new int[]{-10, 10}, 20, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Parsing A Boolean Expression");
        //https://leetcode.com/problems/parsing-a-boolean-expression/description/
        obj.parsingBooleanExpression("&(|(f))");
        obj.parsingBooleanExpression("|(f,f,f,t)");
        obj.parsingBooleanExpression("!(&(f,t))");
        obj.parsingBooleanExpression("!(t)");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Solving Questions With Brainpower");
        //https://leetcode.com/problems/solving-questions-with-brainpower/description/
        obj.solvingQuestionsWithBrainPower_Recursive_Memoization(
                new int[][]{{3, 2}, {4, 3}, {4, 4}, {2, 5}});
        obj.solvingQuestionsWithBrainPower_Recursive_Memoization(
                new int[][]{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}});
        obj.solvingQuestionsWithBrainPower_DP_Memoization(
                new int[][]{{3, 2}, {4, 3}, {4, 4}, {2, 5}});
        obj.solvingQuestionsWithBrainPower_DP_Memoization(
                new int[][]{{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Binary Subarrays With Sum");
        //https://leetcode.com/problems/binary-subarrays-with-sum/description/
        obj.binarySubarraySumEqualToGoal(new int[]{1, 0, 1, 0, 1}, 2);
        obj.binarySubarraySumEqualToGoal(new int[]{0, 0, 0, 0, 0}, 0);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Ways To Build Good Strings");
        //https://leetcode.com/problems/count-ways-to-build-good-strings/description/
        obj.countWaysToBuildGoodStrings_Recursive_Memoization(3, 3, 1, 1);
        obj.countWaysToBuildGoodStrings_Recursive_Memoization(2, 3, 1, 2);
        obj.countWaysToBuildGoodStrings_DP_Memoization(3, 3, 1, 1);
        obj.countWaysToBuildGoodStrings_DP_Memoization(2, 3, 1, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sort Integers by The Power Value");
        //https://leetcode.com/problems/sort-integers-by-the-power-value/description/
        obj.sortIntegersByPowerValue_Recursive_Memoization(12, 15, 2);
        obj.sortIntegersByPowerValue_Recursive_Memoization(7, 11, 4);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Score of an Array After Marking All Elements");
        //https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/
        obj.scoreForArrayAfterMarkingAllElements_Greedy(new int[]{2, 1, 3, 4, 5, 2});
        obj.scoreForArrayAfterMarkingAllElements_Greedy(new int[]{2, 3, 5, 1, 3, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
//        System.out.println("Maximize Score After N Operations");
//        //https://leetcode.com/problems/maximize-score-after-n-operations/description/
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{1, 2});
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{3, 4, 6, 8});
//        obj.maxScoreOfNOperations_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Add Minimum Number of Rungs");
        //https://leetcode.com/problems/add-minimum-number-of-rungs/description/
        obj.addMinNumberOfRungs_Greedy(new int[]{1, 3, 5, 10}, 2);
        obj.addMinNumberOfRungs_Greedy(new int[]{3, 6, 8, 10}, 3);
        obj.addMinNumberOfRungs_Greedy(new int[]{3, 4, 6, 7}, 2);
        obj.addMinNumberOfRungs_Greedy(new int[]{2, 1000000000}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Nesting Depth of the Parentheses");
        //https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/
        obj.maxNestedDepthOfParenthesis("(1+(2*3)+((8)/4))+1");
        obj.maxNestedDepthOfParenthesis("(1)+((2))+(((3)))");
        obj.maxNestedDepthOfParenthesis("(((())))");
        obj.maxNestedDepthOfParenthesis("()()()()");
        System.out.println("Maximum Nesting Depth of Two Valid Parentheses Strings");
        //https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/description/
        obj.maxNestedDepthOfTwoValidParenthesisString("(()())");
        obj.maxNestedDepthOfTwoValidParenthesisString("()(())()");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Execution of All Suffix Instructions Staying in a Grid");
        //https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/description/
        obj.executionOfAllInstructionsStayingInGrid(3, new int[]{0, 1}, "RRDDLU");
        obj.executionOfAllInstructionsStayingInGrid(2, new int[]{1, 1}, "LURD");
        obj.executionOfAllInstructionsStayingInGrid(1, new int[]{0, 0}, "LRUD");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximal Network Rank");
        //https://leetcode.com/problems/maximal-network-rank/description/
        obj.maximalNetworkRank_Graph(4, new int[][]{{0, 1}, {0, 3}, {1, 2}, {1, 3}});
        obj.maximalNetworkRank_Graph(5, new int[][]{{0, 1}, {0, 3}, {1, 2}, {1, 3}, {2, 3}, {2, 4}});
        obj.maximalNetworkRank_Graph(8, new int[][]{{0, 1}, {1, 2}, {2, 3}, {2, 4}, {5, 6}, {5, 7}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Evaluate Division");
        //https://leetcode.com/problems/evaluate-division/description/
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}, {"b", "c"}},
                new double[]{2.0, 3.0},
                new String[][]{{"a", "c"}, {"b", "a"}, {"a", "e"}, {"a", "a"}, {"x", "x"}});
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}, {"b", "c"}, {"bc", "cd"}},
                new double[]{1.5, 2.5, 5.0},
                new String[][]{{"a", "c"}, {"c", "b"}, {"bc", "cd"}, {"cd", "bc"}});
        obj.evaluateDivision_Graph(
                new String[][]{{"a", "b"}},
                new double[]{0.5},
                new String[][]{{"a", "b"}, {"b", "a"}, {"a", "c"}, {"x", "y"}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Paths in Matrix Whose Sum Is Divisible by K");
        //https://leetcode.com/problems/paths-in-matrix-whose-sum-is-divisible-by-k/description/
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{5, 2, 4}, {3, 0, 5}, {0, 7, 2}}, 3);
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{0, 0}}, 5);
        obj.numberOfPathsInGridWhoseSumDivisibleByK_Recursive_Memoization(
                new int[][]{{7, 3, 4, 9}, {2, 3, 6, 2}, {2, 3, 7, 0}}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Number of Ways to Earn Points");
        //https://leetcode.com/problems/number-of-ways-to-earn-points/description/
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{6, 1}, {3, 2}, {2, 3}}, 6);
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{50, 1}, {50, 2}, {50, 5}}, 5);
        obj.numberOfWaysToEarnPoints_Recursive_Memoization(new int[][]{{6, 1}, {3, 2}, {2, 3}}, 18);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the City With the Smallest Number of Neighbors at a Threshold Distance");
        //https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/
        obj.cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(
                4, new int[][]{{0, 1, 3}, {1, 2, 1}, {1, 3, 4}, {2, 3, 1}}, 4);
        obj.cityWithSmallestNeighboursConnectedWithinGivenThreshold_Graph(
                5, new int[][]{{0, 1, 2}, {0, 4, 8}, {1, 2, 3}, {1, 4, 2}, {2, 3, 1}, {3, 4, 1}}, 2);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Subsequence Score");
        //https://leetcode.com/problems/maximum-subsequence-score/description/
        obj.maxSubsequenceScore_Greedy(new int[]{1, 3, 3, 2}, new int[]{2, 1, 3, 4}, 3);
        obj.maxSubsequenceScore_Greedy(new int[]{4, 2, 3, 1, 1}, new int[]{7, 5, 10, 9, 6}, 1);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Longest Turbulent Subarray");
        //https://leetcode.com/problems/longest-turbulent-subarray/description/
        obj.longestTurbulentSubarray(new int[]{9, 4, 2, 10, 7, 8, 8, 1, 9});
        obj.longestTurbulentSubarray(new int[]{4, 8, 12, 16});
        obj.longestTurbulentSubarray(new int[]{100});
        obj.longestTurbulentSubarray(new int[]{9, 9});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Most Profit Assigning Work");
        //https://leetcode.com/problems/most-profit-assigning-work/description/
        obj.mostProfitAssigningWork(
                new int[]{2, 4, 6, 8, 10}, new int[]{10, 20, 30, 40, 50}, new int[]{4, 5, 6, 7});
        obj.mostProfitAssigningWork(
                new int[]{85, 47, 57}, new int[]{24, 66, 99}, new int[]{40, 25, 25});
        obj.mostProfitAssigningWork(
                new int[]{68, 35, 52, 47, 86}, new int[]{67, 17, 1, 81, 3}, new int[]{92, 10, 85, 84, 82});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Stone Game II");
        //https://leetcode.com/problems/stone-game-ii/description/
        obj.stoneGameTwo_Recursive_Memoization(new int[]{2, 7, 9, 4, 4});
        obj.stoneGameTwo_Recursive_Memoization(new int[]{1, 2, 3, 4, 5, 100});
        System.out.println("Stone Game III");
        //https://leetcode.com/problems/stone-game-iii/description/
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, 7});
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, -9});
        obj.stoneGameThree_Recursive_Memoization(new int[]{1, 2, 3, 6});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, 7});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, -9});
        obj.stoneGameThree_DP_Memoization(new int[]{1, 2, 3, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find Subarrays With Equal Sum");
        //https://leetcode.com/problems/find-subarrays-with-equal-sum/description/
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{4, 2, 4}));
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{1, 2, 3, 4, 5}));
        System.out.println("Subarrays having equal sum : " + obj.subarraysHavingEqualSum(new int[]{0, 0, 0}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Cost to Cut a Stick");
        //https://leetcode.com/problems/minimum-cost-to-cut-a-stick/description/
        obj.minCostToCutStick_Recursive_Memoization(7, new int[]{1, 3, 4, 5});
        obj.minCostToCutStick_Recursive_Memoization(9, new int[]{5, 6, 1, 4, 2});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Replace Words");
        //https://leetcode.com/problems/replace-words/description/
        obj.replaceWords(Arrays.asList("cat", "bat", "rat"), "the cattle was rattled by the battery");
        obj.replaceWords(Arrays.asList("a", "b", "c"), "aadsfasf absbs bbab cadsfafs");
        obj.replaceWords(Arrays.asList("catt", "cat", "bat", "rat"), "the cattle was rattled by the battery");
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Sentence Screen Fitting");
        //https://leetcode.com/problems/sentence-screen-fitting/
        obj.sentenceScreenFitting(new String[]{"hello", "world"}, 2, 8);
        obj.sentenceScreenFitting(new String[]{"a", "bcd", "e"}, 3, 6);
        obj.sentenceScreenFitting(new String[]{"i", "had", "apple", "pie"}, 4, 5);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Count Good Meals");
        //https://leetcode.com/problems/count-good-meals/description/
        obj.countGoodMeals(new int[]{1, 3, 5, 7, 9});
        obj.countGoodMeals(new int[]{1, 1, 1, 3, 3, 3, 7});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Maximum Split of Positive Even Integers");
        //https://leetcode.com/problems/maximum-split-of-positive-even-integers/description/
        obj.maxSplitOfPositiveEvenIntegers_Greedy(12);
        obj.maxSplitOfPositiveEvenIntegers_Greedy(7);
        obj.maxSplitOfPositiveEvenIntegers_Greedy(28);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Odd Even Jump");
        //https://leetcode.com/problems/odd-even-jump/description/
        obj.oddEvenJumps(new int[]{10, 13, 12, 14, 15});
        obj.oddEvenJumps(new int[]{2, 3, 1, 1, 4});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Area Rectangle");
        //https://leetcode.com/problems/minimum-area-rectangle/description/
        obj.minAreaRectangle(new int[][]{{1, 1}, {1, 3}, {3, 1}, {3, 3}, {2, 2}});
        obj.minAreaRectangle(new int[][]{{1, 1}, {1, 3}, {3, 1}, {3, 3}, {4, 1}, {4, 3}});
        obj.minAreaRectangle(new int[][]{{1, 1}, {3, 1}});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Max Value of Equation");
        //https://leetcode.com/problems/max-value-of-equation/description/
        obj.maxValueOfEquation(new int[][]{{1, 3}, {2, 0}, {5, 10}, {6, -10}}, 1);
        obj.maxValueOfEquation(new int[][]{{0, 0}, {3, 0}, {9, 2}}, 3);
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Adding Spaces to a String");
        //https://leetcode.com/problems/adding-spaces-to-a-string/description/
        obj.addingSpacesToString("LeetcodeHelpsMeLearn", new int[]{8, 13, 15});
        obj.addingSpacesToString("icodeinpython", new int[]{1, 5, 7, 9});
        obj.addingSpacesToString("spacing", new int[]{0, 1, 2, 3, 4, 5, 6});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Distribute Repeating Integers");
        //https://leetcode.com/problems/distribute-repeating-integers/description/
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 2, 3, 4}, new int[]{2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 2, 3, 3}, new int[]{2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 1, 2, 2}, new int[]{2, 2});
        obj.distributeRepeatingIntegers_Backtracking(new int[]{1, 1, 1, 1, 1}, new int[]{2, 3});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Minimum Operations to Make a Subsequence");
        //https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/description/
        obj.minOperationsToMakeASubseq(new int[]{5, 1, 3}, new int[]{9, 4, 2, 3, 4});
        obj.minOperationsToMakeASubseq(new int[]{6, 4, 8, 1, 3, 2}, new int[]{4, 7, 6, 2, 3, 8, 6, 1});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Words Within Two Edits of Dictionary");
        //https://leetcode.com/problems/words-within-two-edits-of-dictionary/description/
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"word", "note", "ants", "wood"},
                new String[]{"wood", "joke", "moat"});
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"yes"},
                new String[]{"not"});
        obj.wordsWithinTwoEditsOfDictionary(
                new String[]{"tsl", "sri", "yyy", "rbc", "dda", "qus", "hyb", "ilu", "ahd"},
                new String[]{"uyj", "bug", "dba", "xbe", "blu", "wuo", "tsf", "tga"});
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("First Completely Painted Row or Column");
        //https://leetcode.com/problems/first-completely-painted-row-or-column/description/
        System.out.println("First index where row or col completely painted : "
                + obj.firstCompletelyPaintedRowOrCol(
                        new int[]{1, 3, 4, 2}, new int[][]{{1, 4}, {2, 3}}));
        System.out.println("First index where row or col completely painted : "
                + obj.firstCompletelyPaintedRowOrCol(
                        new int[]{2, 8, 7, 4, 1, 3, 5, 6, 9}, new int[][]{{3, 2, 5}, {1, 4, 6}, {8, 7, 9}}));
        //......................................................................
//        Row: SEPARATE QUESTION IMPORTANT
        System.out.println("Find the Divisibility Array of a String");
        //https://leetcode.com/problems/find-the-divisibility-array-of-a-string/description/
        obj.findDivisibiltyArrayOfString("998244353", 3);
        obj.findDivisibiltyArrayOfString("1010", 10);
    }

}
